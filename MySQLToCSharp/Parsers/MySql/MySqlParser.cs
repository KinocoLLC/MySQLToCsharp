//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from /app/MySqlParser.g4 by ANTLR 4.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace MySQLToCSharp.Parsers.MySql {
using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6")]
[System.CLSCompliant(false)]
public partial class MySqlParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		SPACE=1, SPEC_MYSQL_COMMENT=2, COMMENT_INPUT=3, LINE_COMMENT=4, ADD=5, 
		ALL=6, ALTER=7, ALWAYS=8, ANALYZE=9, AND=10, AS=11, ASC=12, BEFORE=13, 
		BETWEEN=14, BOTH=15, BY=16, CALL=17, CASCADE=18, CASE=19, CAST=20, CHANGE=21, 
		CHARACTER=22, CHECK=23, COLLATE=24, COLUMN=25, CONDITION=26, CONSTRAINT=27, 
		CONTINUE=28, CONVERT=29, CREATE=30, CROSS=31, CURRENT_USER=32, CURSOR=33, 
		DATABASE=34, DATABASES=35, DECLARE=36, DEFAULT=37, DELAYED=38, DELETE=39, 
		DESC=40, DESCRIBE=41, DETERMINISTIC=42, DISTINCT=43, DISTINCTROW=44, DROP=45, 
		EACH=46, ELSE=47, ELSEIF=48, ENCLOSED=49, ESCAPED=50, EXISTS=51, EXIT=52, 
		EXPLAIN=53, FALSE=54, FETCH=55, FOR=56, FORCE=57, FOREIGN=58, FROM=59, 
		FULLTEXT=60, GENERATED=61, GRANT=62, GROUP=63, HAVING=64, HIGH_PRIORITY=65, 
		IF=66, IGNORE=67, IN=68, INDEX=69, INFILE=70, INNER=71, INOUT=72, INSERT=73, 
		INTERVAL=74, INTO=75, IS=76, ITERATE=77, JOIN=78, KEY=79, KEYS=80, KILL=81, 
		LEADING=82, LEAVE=83, LEFT=84, LIKE=85, LIMIT=86, LINEAR=87, LINES=88, 
		LOAD=89, LOCK=90, LOOP=91, LOW_PRIORITY=92, MASTER_BIND=93, MASTER_SSL_VERIFY_SERVER_CERT=94, 
		MATCH=95, MAXVALUE=96, MODIFIES=97, NATURAL=98, NOT=99, NO_WRITE_TO_BINLOG=100, 
		NULL_LITERAL=101, ON=102, OPTIMIZE=103, OPTION=104, OPTIONALLY=105, OR=106, 
		ORDER=107, OUT=108, OUTER=109, OUTFILE=110, PARTITION=111, PRIMARY=112, 
		PROCEDURE=113, PURGE=114, RANGE=115, READ=116, READS=117, REFERENCES=118, 
		REGEXP=119, RELEASE=120, RENAME=121, REPEAT=122, REPLACE=123, REQUIRE=124, 
		RESTRICT=125, RETURN=126, REVOKE=127, RIGHT=128, RLIKE=129, SCHEMA=130, 
		SCHEMAS=131, SELECT=132, SET=133, SEPARATOR=134, SHOW=135, SPATIAL=136, 
		SQL=137, SQLEXCEPTION=138, SQLSTATE=139, SQLWARNING=140, SQL_BIG_RESULT=141, 
		SQL_CALC_FOUND_ROWS=142, SQL_SMALL_RESULT=143, SSL=144, STARTING=145, 
		STRAIGHT_JOIN=146, TABLE=147, TERMINATED=148, THEN=149, TO=150, TRAILING=151, 
		TRIGGER=152, TRUE=153, UNDO=154, UNION=155, UNIQUE=156, UNLOCK=157, UNSIGNED=158, 
		UPDATE=159, USAGE=160, USE=161, USING=162, VALUES=163, WHEN=164, WHERE=165, 
		WHILE=166, WITH=167, WRITE=168, XOR=169, ZEROFILL=170, TINYINT=171, SMALLINT=172, 
		MEDIUMINT=173, INT=174, INTEGER=175, BIGINT=176, REAL=177, DOUBLE=178, 
		PRECISION=179, FLOAT=180, DECIMAL=181, DEC=182, NUMERIC=183, DATE=184, 
		TIME=185, TIMESTAMP=186, DATETIME=187, YEAR=188, CHAR=189, VARCHAR=190, 
		NVARCHAR=191, NATIONAL=192, BINARY=193, VARBINARY=194, TINYBLOB=195, BLOB=196, 
		MEDIUMBLOB=197, LONGBLOB=198, TINYTEXT=199, TEXT=200, MEDIUMTEXT=201, 
		LONGTEXT=202, ENUM=203, VARYING=204, SERIAL=205, YEAR_MONTH=206, DAY_HOUR=207, 
		DAY_MINUTE=208, DAY_SECOND=209, HOUR_MINUTE=210, HOUR_SECOND=211, MINUTE_SECOND=212, 
		SECOND_MICROSECOND=213, MINUTE_MICROSECOND=214, HOUR_MICROSECOND=215, 
		DAY_MICROSECOND=216, AVG=217, BIT_AND=218, BIT_OR=219, BIT_XOR=220, COUNT=221, 
		GROUP_CONCAT=222, MAX=223, MIN=224, STD=225, STDDEV=226, STDDEV_POP=227, 
		STDDEV_SAMP=228, SUM=229, VAR_POP=230, VAR_SAMP=231, VARIANCE=232, CURRENT_DATE=233, 
		CURRENT_TIME=234, CURRENT_TIMESTAMP=235, LOCALTIME=236, CURDATE=237, CURTIME=238, 
		DATE_ADD=239, DATE_SUB=240, EXTRACT=241, LOCALTIMESTAMP=242, NOW=243, 
		POSITION=244, SUBSTR=245, SUBSTRING=246, SYSDATE=247, TRIM=248, UTC_DATE=249, 
		UTC_TIME=250, UTC_TIMESTAMP=251, ACCOUNT=252, ACTION=253, AFTER=254, AGGREGATE=255, 
		ALGORITHM=256, ANY=257, AT=258, AUTHORS=259, AUTOCOMMIT=260, AUTOEXTEND_SIZE=261, 
		AUTO_INCREMENT=262, AVG_ROW_LENGTH=263, BEGIN=264, BINLOG=265, BIT=266, 
		BLOCK=267, BOOL=268, BOOLEAN=269, BTREE=270, CACHE=271, CASCADED=272, 
		CHAIN=273, CHANGED=274, CHANNEL=275, CHECKSUM=276, PAGE_CHECKSUM=277, 
		CIPHER=278, CLIENT=279, CLOSE=280, COALESCE=281, CODE=282, COLUMNS=283, 
		COLUMN_FORMAT=284, COMMENT=285, COMMIT=286, COMPACT=287, COMPLETION=288, 
		COMPRESSED=289, COMPRESSION=290, CONCURRENT=291, CONNECTION=292, CONSISTENT=293, 
		CONTAINS=294, CONTEXT=295, CONTRIBUTORS=296, COPY=297, CPU=298, DATA=299, 
		DATAFILE=300, DEALLOCATE=301, DEFAULT_AUTH=302, DEFINER=303, DELAY_KEY_WRITE=304, 
		DES_KEY_FILE=305, DIRECTORY=306, DISABLE=307, DISCARD=308, DISK=309, DO=310, 
		DUMPFILE=311, DUPLICATE=312, DYNAMIC=313, ENABLE=314, ENCRYPTION=315, 
		END=316, ENDS=317, ENGINE=318, ENGINES=319, ERROR=320, ERRORS=321, ESCAPE=322, 
		EVEN=323, EVENT=324, EVENTS=325, EVERY=326, EXCHANGE=327, EXCLUSIVE=328, 
		EXPIRE=329, EXPORT=330, EXTENDED=331, EXTENT_SIZE=332, FAST=333, FAULTS=334, 
		FIELDS=335, FILE_BLOCK_SIZE=336, FILTER=337, FIRST=338, FIXED=339, FLUSH=340, 
		FOLLOWS=341, FOUND=342, FULL=343, FUNCTION=344, GENERAL=345, GLOBAL=346, 
		GRANTS=347, GROUP_REPLICATION=348, HANDLER=349, HASH=350, HELP=351, HOST=352, 
		HOSTS=353, IDENTIFIED=354, IGNORE_SERVER_IDS=355, IMPORT=356, INDEXES=357, 
		INITIAL_SIZE=358, INPLACE=359, INSERT_METHOD=360, INSTALL=361, INSTANCE=362, 
		INVOKER=363, IO=364, IO_THREAD=365, IPC=366, ISOLATION=367, ISSUER=368, 
		JSON=369, KEY_BLOCK_SIZE=370, LANGUAGE=371, LAST=372, LEAVES=373, LESS=374, 
		LEVEL=375, LIST=376, LOCAL=377, LOGFILE=378, LOGS=379, MASTER=380, MASTER_AUTO_POSITION=381, 
		MASTER_CONNECT_RETRY=382, MASTER_DELAY=383, MASTER_HEARTBEAT_PERIOD=384, 
		MASTER_HOST=385, MASTER_LOG_FILE=386, MASTER_LOG_POS=387, MASTER_PASSWORD=388, 
		MASTER_PORT=389, MASTER_RETRY_COUNT=390, MASTER_SSL=391, MASTER_SSL_CA=392, 
		MASTER_SSL_CAPATH=393, MASTER_SSL_CERT=394, MASTER_SSL_CIPHER=395, MASTER_SSL_CRL=396, 
		MASTER_SSL_CRLPATH=397, MASTER_SSL_KEY=398, MASTER_TLS_VERSION=399, MASTER_USER=400, 
		MAX_CONNECTIONS_PER_HOUR=401, MAX_QUERIES_PER_HOUR=402, MAX_ROWS=403, 
		MAX_SIZE=404, MAX_UPDATES_PER_HOUR=405, MAX_USER_CONNECTIONS=406, MEDIUM=407, 
		MERGE=408, MID=409, MIGRATE=410, MIN_ROWS=411, MODE=412, MODIFY=413, MUTEX=414, 
		MYSQL=415, NAME=416, NAMES=417, NCHAR=418, NEVER=419, NEXT=420, NO=421, 
		NODEGROUP=422, NONE=423, OFFLINE=424, OFFSET=425, OJ=426, OLD_PASSWORD=427, 
		ONE=428, ONLINE=429, ONLY=430, OPEN=431, OPTIMIZER_COSTS=432, OPTIONS=433, 
		OWNER=434, PACK_KEYS=435, PAGE=436, PARSER=437, PARTIAL=438, PARTITIONING=439, 
		PARTITIONS=440, PASSWORD=441, PHASE=442, PLUGIN=443, PLUGIN_DIR=444, PLUGINS=445, 
		PORT=446, PRECEDES=447, PREPARE=448, PRESERVE=449, PREV=450, PROCESSLIST=451, 
		PROFILE=452, PROFILES=453, PROXY=454, QUERY=455, QUICK=456, REBUILD=457, 
		RECOVER=458, REDO_BUFFER_SIZE=459, REDUNDANT=460, RELAY=461, RELAY_LOG_FILE=462, 
		RELAY_LOG_POS=463, RELAYLOG=464, REMOVE=465, REORGANIZE=466, REPAIR=467, 
		REPLICATE_DO_DB=468, REPLICATE_DO_TABLE=469, REPLICATE_IGNORE_DB=470, 
		REPLICATE_IGNORE_TABLE=471, REPLICATE_REWRITE_DB=472, REPLICATE_WILD_DO_TABLE=473, 
		REPLICATE_WILD_IGNORE_TABLE=474, REPLICATION=475, RESET=476, RESUME=477, 
		RETURNS=478, ROLLBACK=479, ROLLUP=480, ROTATE=481, ROW=482, ROWS=483, 
		ROW_FORMAT=484, SAVEPOINT=485, SCHEDULE=486, SECURITY=487, SERVER=488, 
		SESSION=489, SHARE=490, SHARED=491, SIGNED=492, SIMPLE=493, SLAVE=494, 
		SLOW=495, SNAPSHOT=496, SOCKET=497, SOME=498, SONAME=499, SOUNDS=500, 
		SOURCE=501, SQL_AFTER_GTIDS=502, SQL_AFTER_MTS_GAPS=503, SQL_BEFORE_GTIDS=504, 
		SQL_BUFFER_RESULT=505, SQL_CACHE=506, SQL_NO_CACHE=507, SQL_THREAD=508, 
		START=509, STARTS=510, STATS_AUTO_RECALC=511, STATS_PERSISTENT=512, STATS_SAMPLE_PAGES=513, 
		STATUS=514, STOP=515, STORAGE=516, STORED=517, STRING=518, SUBJECT=519, 
		SUBPARTITION=520, SUBPARTITIONS=521, SUSPEND=522, SWAPS=523, SWITCHES=524, 
		TABLESPACE=525, TEMPORARY=526, TEMPTABLE=527, THAN=528, TRADITIONAL=529, 
		TRANSACTION=530, TRIGGERS=531, TRUNCATE=532, UNDEFINED=533, UNDOFILE=534, 
		UNDO_BUFFER_SIZE=535, UNINSTALL=536, UNKNOWN=537, UNTIL=538, UPGRADE=539, 
		USER=540, USE_FRM=541, USER_RESOURCES=542, VALIDATION=543, VALUE=544, 
		VARIABLES=545, VIEW=546, VIRTUAL=547, WAIT=548, WARNINGS=549, WITHOUT=550, 
		WORK=551, WRAPPER=552, X509=553, XA=554, XML=555, EUR=556, USA=557, JIS=558, 
		ISO=559, INTERNAL=560, QUARTER=561, MONTH=562, DAY=563, HOUR=564, MINUTE=565, 
		WEEK=566, SECOND=567, MICROSECOND=568, TABLES=569, ROUTINE=570, EXECUTE=571, 
		FILE=572, PROCESS=573, RELOAD=574, SHUTDOWN=575, SUPER=576, PRIVILEGES=577, 
		ARMSCII8=578, ASCII=579, BIG5=580, CP1250=581, CP1251=582, CP1256=583, 
		CP1257=584, CP850=585, CP852=586, CP866=587, CP932=588, DEC8=589, EUCJPMS=590, 
		EUCKR=591, GB2312=592, GBK=593, GEOSTD8=594, GREEK=595, HEBREW=596, HP8=597, 
		KEYBCS2=598, KOI8R=599, KOI8U=600, LATIN1=601, LATIN2=602, LATIN5=603, 
		LATIN7=604, MACCE=605, MACROMAN=606, SJIS=607, SWE7=608, TIS620=609, UCS2=610, 
		UJIS=611, UTF16=612, UTF16LE=613, UTF32=614, UTF8=615, UTF8MB3=616, UTF8MB4=617, 
		ARCHIVE=618, BLACKHOLE=619, CSV=620, FEDERATED=621, INNODB=622, MEMORY=623, 
		MRG_MYISAM=624, MYISAM=625, NDB=626, NDBCLUSTER=627, PERFORMANCE_SCHEMA=628, 
		TOKUDB=629, REPEATABLE=630, COMMITTED=631, UNCOMMITTED=632, SERIALIZABLE=633, 
		GEOMETRYCOLLECTION=634, GEOMCOLLECTION=635, GEOMETRY=636, LINESTRING=637, 
		MULTILINESTRING=638, MULTIPOINT=639, MULTIPOLYGON=640, POINT=641, POLYGON=642, 
		ABS=643, ACOS=644, ADDDATE=645, ADDTIME=646, AES_DECRYPT=647, AES_ENCRYPT=648, 
		AREA=649, ASBINARY=650, ASIN=651, ASTEXT=652, ASWKB=653, ASWKT=654, ASYMMETRIC_DECRYPT=655, 
		ASYMMETRIC_DERIVE=656, ASYMMETRIC_ENCRYPT=657, ASYMMETRIC_SIGN=658, ASYMMETRIC_VERIFY=659, 
		ATAN=660, ATAN2=661, BENCHMARK=662, BIN=663, BIT_COUNT=664, BIT_LENGTH=665, 
		BUFFER=666, CEIL=667, CEILING=668, CENTROID=669, CHARACTER_LENGTH=670, 
		CHARSET=671, CHAR_LENGTH=672, COERCIBILITY=673, COLLATION=674, COMPRESS=675, 
		CONCAT=676, CONCAT_WS=677, CONNECTION_ID=678, CONV=679, CONVERT_TZ=680, 
		COS=681, COT=682, CRC32=683, CREATE_ASYMMETRIC_PRIV_KEY=684, CREATE_ASYMMETRIC_PUB_KEY=685, 
		CREATE_DH_PARAMETERS=686, CREATE_DIGEST=687, CROSSES=688, DATEDIFF=689, 
		DATE_FORMAT=690, DAYNAME=691, DAYOFMONTH=692, DAYOFWEEK=693, DAYOFYEAR=694, 
		DECODE=695, DEGREES=696, DES_DECRYPT=697, DES_ENCRYPT=698, DIMENSION=699, 
		DISJOINT=700, ELT=701, ENCODE=702, ENCRYPT=703, ENDPOINT=704, ENVELOPE=705, 
		EQUALS=706, EXP=707, EXPORT_SET=708, EXTERIORRING=709, EXTRACTVALUE=710, 
		FIELD=711, FIND_IN_SET=712, FLOOR=713, FORMAT=714, FOUND_ROWS=715, FROM_BASE64=716, 
		FROM_DAYS=717, FROM_UNIXTIME=718, GEOMCOLLFROMTEXT=719, GEOMCOLLFROMWKB=720, 
		GEOMETRYCOLLECTIONFROMTEXT=721, GEOMETRYCOLLECTIONFROMWKB=722, GEOMETRYFROMTEXT=723, 
		GEOMETRYFROMWKB=724, GEOMETRYN=725, GEOMETRYTYPE=726, GEOMFROMTEXT=727, 
		GEOMFROMWKB=728, GET_FORMAT=729, GET_LOCK=730, GLENGTH=731, GREATEST=732, 
		GTID_SUBSET=733, GTID_SUBTRACT=734, HEX=735, IFNULL=736, INET6_ATON=737, 
		INET6_NTOA=738, INET_ATON=739, INET_NTOA=740, INSTR=741, INTERIORRINGN=742, 
		INTERSECTS=743, ISCLOSED=744, ISEMPTY=745, ISNULL=746, ISSIMPLE=747, IS_FREE_LOCK=748, 
		IS_IPV4=749, IS_IPV4_COMPAT=750, IS_IPV4_MAPPED=751, IS_IPV6=752, IS_USED_LOCK=753, 
		LAST_INSERT_ID=754, LCASE=755, LEAST=756, LENGTH=757, LINEFROMTEXT=758, 
		LINEFROMWKB=759, LINESTRINGFROMTEXT=760, LINESTRINGFROMWKB=761, LN=762, 
		LOAD_FILE=763, LOCATE=764, LOG=765, LOG10=766, LOG2=767, LOWER=768, LPAD=769, 
		LTRIM=770, MAKEDATE=771, MAKETIME=772, MAKE_SET=773, MASTER_POS_WAIT=774, 
		MBRCONTAINS=775, MBRDISJOINT=776, MBREQUAL=777, MBRINTERSECTS=778, MBROVERLAPS=779, 
		MBRTOUCHES=780, MBRWITHIN=781, MD5=782, MLINEFROMTEXT=783, MLINEFROMWKB=784, 
		MONTHNAME=785, MPOINTFROMTEXT=786, MPOINTFROMWKB=787, MPOLYFROMTEXT=788, 
		MPOLYFROMWKB=789, MULTILINESTRINGFROMTEXT=790, MULTILINESTRINGFROMWKB=791, 
		MULTIPOINTFROMTEXT=792, MULTIPOINTFROMWKB=793, MULTIPOLYGONFROMTEXT=794, 
		MULTIPOLYGONFROMWKB=795, NAME_CONST=796, NULLIF=797, NUMGEOMETRIES=798, 
		NUMINTERIORRINGS=799, NUMPOINTS=800, OCT=801, OCTET_LENGTH=802, ORD=803, 
		OVERLAPS=804, PERIOD_ADD=805, PERIOD_DIFF=806, PI=807, POINTFROMTEXT=808, 
		POINTFROMWKB=809, POINTN=810, POLYFROMTEXT=811, POLYFROMWKB=812, POLYGONFROMTEXT=813, 
		POLYGONFROMWKB=814, POW=815, POWER=816, QUOTE=817, RADIANS=818, RAND=819, 
		RANDOM_BYTES=820, RELEASE_LOCK=821, REVERSE=822, ROUND=823, ROW_COUNT=824, 
		RPAD=825, RTRIM=826, SEC_TO_TIME=827, SESSION_USER=828, SHA=829, SHA1=830, 
		SHA2=831, SIGN=832, SIN=833, SLEEP=834, SOUNDEX=835, SQL_THREAD_WAIT_AFTER_GTIDS=836, 
		SQRT=837, SRID=838, STARTPOINT=839, STRCMP=840, STR_TO_DATE=841, ST_AREA=842, 
		ST_ASBINARY=843, ST_ASTEXT=844, ST_ASWKB=845, ST_ASWKT=846, ST_BUFFER=847, 
		ST_CENTROID=848, ST_CONTAINS=849, ST_CROSSES=850, ST_DIFFERENCE=851, ST_DIMENSION=852, 
		ST_DISJOINT=853, ST_DISTANCE=854, ST_ENDPOINT=855, ST_ENVELOPE=856, ST_EQUALS=857, 
		ST_EXTERIORRING=858, ST_GEOMCOLLFROMTEXT=859, ST_GEOMCOLLFROMTXT=860, 
		ST_GEOMCOLLFROMWKB=861, ST_GEOMETRYCOLLECTIONFROMTEXT=862, ST_GEOMETRYCOLLECTIONFROMWKB=863, 
		ST_GEOMETRYFROMTEXT=864, ST_GEOMETRYFROMWKB=865, ST_GEOMETRYN=866, ST_GEOMETRYTYPE=867, 
		ST_GEOMFROMTEXT=868, ST_GEOMFROMWKB=869, ST_INTERIORRINGN=870, ST_INTERSECTION=871, 
		ST_INTERSECTS=872, ST_ISCLOSED=873, ST_ISEMPTY=874, ST_ISSIMPLE=875, ST_LINEFROMTEXT=876, 
		ST_LINEFROMWKB=877, ST_LINESTRINGFROMTEXT=878, ST_LINESTRINGFROMWKB=879, 
		ST_NUMGEOMETRIES=880, ST_NUMINTERIORRING=881, ST_NUMINTERIORRINGS=882, 
		ST_NUMPOINTS=883, ST_OVERLAPS=884, ST_POINTFROMTEXT=885, ST_POINTFROMWKB=886, 
		ST_POINTN=887, ST_POLYFROMTEXT=888, ST_POLYFROMWKB=889, ST_POLYGONFROMTEXT=890, 
		ST_POLYGONFROMWKB=891, ST_SRID=892, ST_STARTPOINT=893, ST_SYMDIFFERENCE=894, 
		ST_TOUCHES=895, ST_UNION=896, ST_WITHIN=897, ST_X=898, ST_Y=899, SUBDATE=900, 
		SUBSTRING_INDEX=901, SUBTIME=902, SYSTEM_USER=903, TAN=904, TIMEDIFF=905, 
		TIMESTAMPADD=906, TIMESTAMPDIFF=907, TIME_FORMAT=908, TIME_TO_SEC=909, 
		TOUCHES=910, TO_BASE64=911, TO_DAYS=912, TO_SECONDS=913, UCASE=914, UNCOMPRESS=915, 
		UNCOMPRESSED_LENGTH=916, UNHEX=917, UNIX_TIMESTAMP=918, UPDATEXML=919, 
		UPPER=920, UUID=921, UUID_SHORT=922, VALIDATE_PASSWORD_STRENGTH=923, VERSION=924, 
		WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS=925, WEEKDAY=926, WEEKOFYEAR=927, WEIGHT_STRING=928, 
		WITHIN=929, YEARWEEK=930, Y_FUNCTION=931, X_FUNCTION=932, VAR_ASSIGN=933, 
		PLUS_ASSIGN=934, MINUS_ASSIGN=935, MULT_ASSIGN=936, DIV_ASSIGN=937, MOD_ASSIGN=938, 
		AND_ASSIGN=939, XOR_ASSIGN=940, OR_ASSIGN=941, STAR=942, DIVIDE=943, MODULE=944, 
		PLUS=945, MINUSMINUS=946, MINUS=947, DIV=948, MOD=949, EQUAL_SYMBOL=950, 
		GREATER_SYMBOL=951, LESS_SYMBOL=952, EXCLAMATION_SYMBOL=953, BIT_NOT_OP=954, 
		BIT_OR_OP=955, BIT_AND_OP=956, BIT_XOR_OP=957, DOT=958, LR_BRACKET=959, 
		RR_BRACKET=960, COMMA=961, SEMI=962, AT_SIGN=963, ZERO_DECIMAL=964, ONE_DECIMAL=965, 
		TWO_DECIMAL=966, SINGLE_QUOTE_SYMB=967, DOUBLE_QUOTE_SYMB=968, REVERSE_QUOTE_SYMB=969, 
		COLON_SYMB=970, CHARSET_REVERSE_QOUTE_STRING=971, FILESIZE_LITERAL=972, 
		START_NATIONAL_STRING_LITERAL=973, STRING_LITERAL=974, DECIMAL_LITERAL=975, 
		HEXADECIMAL_LITERAL=976, REAL_LITERAL=977, NULL_SPEC_LITERAL=978, BIT_STRING=979, 
		STRING_CHARSET_NAME=980, DOT_ID=981, ID=982, REVERSE_QUOTE_ID=983, STRING_USER_NAME=984, 
		LOCAL_ID=985, GLOBAL_ID=986, ERROR_RECONGNIGION=987;
	public const int
		RULE_root = 0, RULE_sqlStatements = 1, RULE_sqlStatement = 2, RULE_emptyStatement = 3, 
		RULE_ddlStatement = 4, RULE_dmlStatement = 5, RULE_transactionStatement = 6, 
		RULE_replicationStatement = 7, RULE_preparedStatement = 8, RULE_compoundStatement = 9, 
		RULE_administrationStatement = 10, RULE_utilityStatement = 11, RULE_createDatabase = 12, 
		RULE_createEvent = 13, RULE_createIndex = 14, RULE_createLogfileGroup = 15, 
		RULE_createProcedure = 16, RULE_createFunction = 17, RULE_createServer = 18, 
		RULE_createTable = 19, RULE_createTablespaceInnodb = 20, RULE_createTablespaceNdb = 21, 
		RULE_createTrigger = 22, RULE_createView = 23, RULE_createDatabaseOption = 24, 
		RULE_ownerStatement = 25, RULE_scheduleExpression = 26, RULE_timestampValue = 27, 
		RULE_intervalExpr = 28, RULE_intervalType = 29, RULE_enableType = 30, 
		RULE_indexType = 31, RULE_indexOption = 32, RULE_procedureParameter = 33, 
		RULE_functionParameter = 34, RULE_routineOption = 35, RULE_serverOption = 36, 
		RULE_createDefinitions = 37, RULE_createDefinition = 38, RULE_columnDefinition = 39, 
		RULE_columnConstraint = 40, RULE_tableConstraint = 41, RULE_referenceDefinition = 42, 
		RULE_referenceAction = 43, RULE_referenceControlType = 44, RULE_indexColumnDefinition = 45, 
		RULE_tableOption = 46, RULE_tablespaceStorage = 47, RULE_partitionDefinitions = 48, 
		RULE_partitionFunctionDefinition = 49, RULE_subpartitionFunctionDefinition = 50, 
		RULE_partitionDefinition = 51, RULE_partitionDefinerAtom = 52, RULE_partitionDefinerVector = 53, 
		RULE_subpartitionDefinition = 54, RULE_partitionOption = 55, RULE_alterDatabase = 56, 
		RULE_alterEvent = 57, RULE_alterFunction = 58, RULE_alterInstance = 59, 
		RULE_alterLogfileGroup = 60, RULE_alterProcedure = 61, RULE_alterServer = 62, 
		RULE_alterTable = 63, RULE_alterTablespace = 64, RULE_alterView = 65, 
		RULE_alterSpecification = 66, RULE_dropDatabase = 67, RULE_dropEvent = 68, 
		RULE_dropIndex = 69, RULE_dropLogfileGroup = 70, RULE_dropProcedure = 71, 
		RULE_dropFunction = 72, RULE_dropServer = 73, RULE_dropTable = 74, RULE_dropTablespace = 75, 
		RULE_dropTrigger = 76, RULE_dropView = 77, RULE_renameTable = 78, RULE_renameTableClause = 79, 
		RULE_truncateTable = 80, RULE_callStatement = 81, RULE_deleteStatement = 82, 
		RULE_doStatement = 83, RULE_handlerStatement = 84, RULE_insertStatement = 85, 
		RULE_loadDataStatement = 86, RULE_loadXmlStatement = 87, RULE_replaceStatement = 88, 
		RULE_selectStatement = 89, RULE_updateStatement = 90, RULE_insertStatementValue = 91, 
		RULE_updatedElement = 92, RULE_assignmentField = 93, RULE_lockClause = 94, 
		RULE_singleDeleteStatement = 95, RULE_multipleDeleteStatement = 96, RULE_handlerOpenStatement = 97, 
		RULE_handlerReadIndexStatement = 98, RULE_handlerReadStatement = 99, RULE_handlerCloseStatement = 100, 
		RULE_singleUpdateStatement = 101, RULE_multipleUpdateStatement = 102, 
		RULE_orderByClause = 103, RULE_orderByExpression = 104, RULE_tableSources = 105, 
		RULE_tableSource = 106, RULE_tableSourceItem = 107, RULE_indexHint = 108, 
		RULE_indexHintType = 109, RULE_joinPart = 110, RULE_queryExpression = 111, 
		RULE_queryExpressionNointo = 112, RULE_querySpecification = 113, RULE_querySpecificationNointo = 114, 
		RULE_unionParenthesis = 115, RULE_unionStatement = 116, RULE_selectSpec = 117, 
		RULE_selectElements = 118, RULE_selectElement = 119, RULE_selectIntoExpression = 120, 
		RULE_selectFieldsInto = 121, RULE_selectLinesInto = 122, RULE_fromClause = 123, 
		RULE_groupByItem = 124, RULE_limitClause = 125, RULE_limitClauseAtom = 126, 
		RULE_startTransaction = 127, RULE_beginWork = 128, RULE_commitWork = 129, 
		RULE_rollbackWork = 130, RULE_savepointStatement = 131, RULE_rollbackStatement = 132, 
		RULE_releaseStatement = 133, RULE_lockTables = 134, RULE_unlockTables = 135, 
		RULE_setAutocommitStatement = 136, RULE_setTransactionStatement = 137, 
		RULE_transactionMode = 138, RULE_lockTableElement = 139, RULE_lockAction = 140, 
		RULE_transactionOption = 141, RULE_transactionLevel = 142, RULE_changeMaster = 143, 
		RULE_changeReplicationFilter = 144, RULE_purgeBinaryLogs = 145, RULE_resetMaster = 146, 
		RULE_resetSlave = 147, RULE_startSlave = 148, RULE_stopSlave = 149, RULE_startGroupReplication = 150, 
		RULE_stopGroupReplication = 151, RULE_masterOption = 152, RULE_stringMasterOption = 153, 
		RULE_decimalMasterOption = 154, RULE_boolMasterOption = 155, RULE_channelOption = 156, 
		RULE_replicationFilter = 157, RULE_tablePair = 158, RULE_threadType = 159, 
		RULE_untilOption = 160, RULE_connectionOption = 161, RULE_gtuidSet = 162, 
		RULE_xaStartTransaction = 163, RULE_xaEndTransaction = 164, RULE_xaPrepareStatement = 165, 
		RULE_xaCommitWork = 166, RULE_xaRollbackWork = 167, RULE_xaRecoverWork = 168, 
		RULE_prepareStatement = 169, RULE_executeStatement = 170, RULE_deallocatePrepare = 171, 
		RULE_routineBody = 172, RULE_blockStatement = 173, RULE_caseStatement = 174, 
		RULE_ifStatement = 175, RULE_iterateStatement = 176, RULE_leaveStatement = 177, 
		RULE_loopStatement = 178, RULE_repeatStatement = 179, RULE_returnStatement = 180, 
		RULE_whileStatement = 181, RULE_cursorStatement = 182, RULE_declareVariable = 183, 
		RULE_declareCondition = 184, RULE_declareCursor = 185, RULE_declareHandler = 186, 
		RULE_handlerConditionValue = 187, RULE_procedureSqlStatement = 188, RULE_caseAlternative = 189, 
		RULE_elifAlternative = 190, RULE_alterUser = 191, RULE_createUser = 192, 
		RULE_dropUser = 193, RULE_grantStatement = 194, RULE_grantProxy = 195, 
		RULE_renameUser = 196, RULE_revokeStatement = 197, RULE_revokeProxy = 198, 
		RULE_setPasswordStatement = 199, RULE_userSpecification = 200, RULE_userAuthOption = 201, 
		RULE_tlsOption = 202, RULE_userResourceOption = 203, RULE_userPasswordOption = 204, 
		RULE_userLockOption = 205, RULE_privelegeClause = 206, RULE_privilege = 207, 
		RULE_privilegeLevel = 208, RULE_renameUserClause = 209, RULE_analyzeTable = 210, 
		RULE_checkTable = 211, RULE_checksumTable = 212, RULE_optimizeTable = 213, 
		RULE_repairTable = 214, RULE_checkTableOption = 215, RULE_createUdfunction = 216, 
		RULE_installPlugin = 217, RULE_uninstallPlugin = 218, RULE_setStatement = 219, 
		RULE_showStatement = 220, RULE_variableClause = 221, RULE_showCommonEntity = 222, 
		RULE_showFilter = 223, RULE_showGlobalInfoClause = 224, RULE_showSchemaEntity = 225, 
		RULE_showProfileType = 226, RULE_binlogStatement = 227, RULE_cacheIndexStatement = 228, 
		RULE_flushStatement = 229, RULE_killStatement = 230, RULE_loadIndexIntoCache = 231, 
		RULE_resetStatement = 232, RULE_shutdownStatement = 233, RULE_tableIndexes = 234, 
		RULE_flushOption = 235, RULE_flushTableOption = 236, RULE_loadedTableIndexes = 237, 
		RULE_simpleDescribeStatement = 238, RULE_fullDescribeStatement = 239, 
		RULE_helpStatement = 240, RULE_useStatement = 241, RULE_describeObjectClause = 242, 
		RULE_fullId = 243, RULE_tableName = 244, RULE_fullColumnName = 245, RULE_indexColumnName = 246, 
		RULE_userName = 247, RULE_mysqlVariable = 248, RULE_charsetName = 249, 
		RULE_collationName = 250, RULE_engineName = 251, RULE_uuidSet = 252, RULE_xid = 253, 
		RULE_xuidStringId = 254, RULE_authPlugin = 255, RULE_uid = 256, RULE_simpleId = 257, 
		RULE_dottedId = 258, RULE_decimalLiteral = 259, RULE_fileSizeLiteral = 260, 
		RULE_stringLiteral = 261, RULE_booleanLiteral = 262, RULE_hexadecimalLiteral = 263, 
		RULE_nullNotnull = 264, RULE_constant = 265, RULE_dataType = 266, RULE_collectionOptions = 267, 
		RULE_convertedDataType = 268, RULE_lengthOneDimension = 269, RULE_lengthTwoDimension = 270, 
		RULE_lengthTwoOptionalDimension = 271, RULE_uidList = 272, RULE_tables = 273, 
		RULE_indexColumnNames = 274, RULE_expressions = 275, RULE_expressionsWithDefaults = 276, 
		RULE_constants = 277, RULE_simpleStrings = 278, RULE_userVariables = 279, 
		RULE_defaultValue = 280, RULE_currentTimestamp = 281, RULE_expressionOrDefault = 282, 
		RULE_ifExists = 283, RULE_ifNotExists = 284, RULE_functionCall = 285, 
		RULE_specificFunction = 286, RULE_caseFuncAlternative = 287, RULE_levelsInWeightString = 288, 
		RULE_levelInWeightListElement = 289, RULE_aggregateWindowedFunction = 290, 
		RULE_scalarFunctionName = 291, RULE_passwordFunctionClause = 292, RULE_functionArgs = 293, 
		RULE_functionArg = 294, RULE_expression = 295, RULE_predicate = 296, RULE_expressionAtom = 297, 
		RULE_unaryOperator = 298, RULE_comparisonOperator = 299, RULE_logicalOperator = 300, 
		RULE_bitOperator = 301, RULE_mathOperator = 302, RULE_charsetNameBase = 303, 
		RULE_transactionLevelBase = 304, RULE_privilegesBase = 305, RULE_intervalTypeBase = 306, 
		RULE_dataTypeBase = 307, RULE_keywordsCanBeId = 308, RULE_functionNameBase = 309;
	public static readonly string[] ruleNames = {
		"root", "sqlStatements", "sqlStatement", "emptyStatement", "ddlStatement", 
		"dmlStatement", "transactionStatement", "replicationStatement", "preparedStatement", 
		"compoundStatement", "administrationStatement", "utilityStatement", "createDatabase", 
		"createEvent", "createIndex", "createLogfileGroup", "createProcedure", 
		"createFunction", "createServer", "createTable", "createTablespaceInnodb", 
		"createTablespaceNdb", "createTrigger", "createView", "createDatabaseOption", 
		"ownerStatement", "scheduleExpression", "timestampValue", "intervalExpr", 
		"intervalType", "enableType", "indexType", "indexOption", "procedureParameter", 
		"functionParameter", "routineOption", "serverOption", "createDefinitions", 
		"createDefinition", "columnDefinition", "columnConstraint", "tableConstraint", 
		"referenceDefinition", "referenceAction", "referenceControlType", "indexColumnDefinition", 
		"tableOption", "tablespaceStorage", "partitionDefinitions", "partitionFunctionDefinition", 
		"subpartitionFunctionDefinition", "partitionDefinition", "partitionDefinerAtom", 
		"partitionDefinerVector", "subpartitionDefinition", "partitionOption", 
		"alterDatabase", "alterEvent", "alterFunction", "alterInstance", "alterLogfileGroup", 
		"alterProcedure", "alterServer", "alterTable", "alterTablespace", "alterView", 
		"alterSpecification", "dropDatabase", "dropEvent", "dropIndex", "dropLogfileGroup", 
		"dropProcedure", "dropFunction", "dropServer", "dropTable", "dropTablespace", 
		"dropTrigger", "dropView", "renameTable", "renameTableClause", "truncateTable", 
		"callStatement", "deleteStatement", "doStatement", "handlerStatement", 
		"insertStatement", "loadDataStatement", "loadXmlStatement", "replaceStatement", 
		"selectStatement", "updateStatement", "insertStatementValue", "updatedElement", 
		"assignmentField", "lockClause", "singleDeleteStatement", "multipleDeleteStatement", 
		"handlerOpenStatement", "handlerReadIndexStatement", "handlerReadStatement", 
		"handlerCloseStatement", "singleUpdateStatement", "multipleUpdateStatement", 
		"orderByClause", "orderByExpression", "tableSources", "tableSource", "tableSourceItem", 
		"indexHint", "indexHintType", "joinPart", "queryExpression", "queryExpressionNointo", 
		"querySpecification", "querySpecificationNointo", "unionParenthesis", 
		"unionStatement", "selectSpec", "selectElements", "selectElement", "selectIntoExpression", 
		"selectFieldsInto", "selectLinesInto", "fromClause", "groupByItem", "limitClause", 
		"limitClauseAtom", "startTransaction", "beginWork", "commitWork", "rollbackWork", 
		"savepointStatement", "rollbackStatement", "releaseStatement", "lockTables", 
		"unlockTables", "setAutocommitStatement", "setTransactionStatement", "transactionMode", 
		"lockTableElement", "lockAction", "transactionOption", "transactionLevel", 
		"changeMaster", "changeReplicationFilter", "purgeBinaryLogs", "resetMaster", 
		"resetSlave", "startSlave", "stopSlave", "startGroupReplication", "stopGroupReplication", 
		"masterOption", "stringMasterOption", "decimalMasterOption", "boolMasterOption", 
		"channelOption", "replicationFilter", "tablePair", "threadType", "untilOption", 
		"connectionOption", "gtuidSet", "xaStartTransaction", "xaEndTransaction", 
		"xaPrepareStatement", "xaCommitWork", "xaRollbackWork", "xaRecoverWork", 
		"prepareStatement", "executeStatement", "deallocatePrepare", "routineBody", 
		"blockStatement", "caseStatement", "ifStatement", "iterateStatement", 
		"leaveStatement", "loopStatement", "repeatStatement", "returnStatement", 
		"whileStatement", "cursorStatement", "declareVariable", "declareCondition", 
		"declareCursor", "declareHandler", "handlerConditionValue", "procedureSqlStatement", 
		"caseAlternative", "elifAlternative", "alterUser", "createUser", "dropUser", 
		"grantStatement", "grantProxy", "renameUser", "revokeStatement", "revokeProxy", 
		"setPasswordStatement", "userSpecification", "userAuthOption", "tlsOption", 
		"userResourceOption", "userPasswordOption", "userLockOption", "privelegeClause", 
		"privilege", "privilegeLevel", "renameUserClause", "analyzeTable", "checkTable", 
		"checksumTable", "optimizeTable", "repairTable", "checkTableOption", "createUdfunction", 
		"installPlugin", "uninstallPlugin", "setStatement", "showStatement", "variableClause", 
		"showCommonEntity", "showFilter", "showGlobalInfoClause", "showSchemaEntity", 
		"showProfileType", "binlogStatement", "cacheIndexStatement", "flushStatement", 
		"killStatement", "loadIndexIntoCache", "resetStatement", "shutdownStatement", 
		"tableIndexes", "flushOption", "flushTableOption", "loadedTableIndexes", 
		"simpleDescribeStatement", "fullDescribeStatement", "helpStatement", "useStatement", 
		"describeObjectClause", "fullId", "tableName", "fullColumnName", "indexColumnName", 
		"userName", "mysqlVariable", "charsetName", "collationName", "engineName", 
		"uuidSet", "xid", "xuidStringId", "authPlugin", "uid", "simpleId", "dottedId", 
		"decimalLiteral", "fileSizeLiteral", "stringLiteral", "booleanLiteral", 
		"hexadecimalLiteral", "nullNotnull", "constant", "dataType", "collectionOptions", 
		"convertedDataType", "lengthOneDimension", "lengthTwoDimension", "lengthTwoOptionalDimension", 
		"uidList", "tables", "indexColumnNames", "expressions", "expressionsWithDefaults", 
		"constants", "simpleStrings", "userVariables", "defaultValue", "currentTimestamp", 
		"expressionOrDefault", "ifExists", "ifNotExists", "functionCall", "specificFunction", 
		"caseFuncAlternative", "levelsInWeightString", "levelInWeightListElement", 
		"aggregateWindowedFunction", "scalarFunctionName", "passwordFunctionClause", 
		"functionArgs", "functionArg", "expression", "predicate", "expressionAtom", 
		"unaryOperator", "comparisonOperator", "logicalOperator", "bitOperator", 
		"mathOperator", "charsetNameBase", "transactionLevelBase", "privilegesBase", 
		"intervalTypeBase", "dataTypeBase", "keywordsCanBeId", "functionNameBase"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, null, "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", 
		"'ANALYZE'", "'AND'", "'AS'", "'ASC'", "'BEFORE'", "'BETWEEN'", "'BOTH'", 
		"'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'", "'CHANGE'", "'CHARACTER'", 
		"'CHECK'", "'COLLATE'", "'COLUMN'", "'CONDITION'", "'CONSTRAINT'", "'CONTINUE'", 
		"'CONVERT'", "'CREATE'", "'CROSS'", "'CURRENT_USER'", "'CURSOR'", "'DATABASE'", 
		"'DATABASES'", "'DECLARE'", "'DEFAULT'", "'DELAYED'", "'DELETE'", "'DESC'", 
		"'DESCRIBE'", "'DETERMINISTIC'", "'DISTINCT'", "'DISTINCTROW'", "'DROP'", 
		"'EACH'", "'ELSE'", "'ELSEIF'", "'ENCLOSED'", "'ESCAPED'", "'EXISTS'", 
		"'EXIT'", "'EXPLAIN'", "'FALSE'", "'FETCH'", "'FOR'", "'FORCE'", "'FOREIGN'", 
		"'FROM'", "'FULLTEXT'", "'GENERATED'", "'GRANT'", "'GROUP'", "'HAVING'", 
		"'HIGH_PRIORITY'", "'IF'", "'IGNORE'", "'IN'", "'INDEX'", "'INFILE'", 
		"'INNER'", "'INOUT'", "'INSERT'", "'INTERVAL'", "'INTO'", "'IS'", "'ITERATE'", 
		"'JOIN'", "'KEY'", "'KEYS'", "'KILL'", "'LEADING'", "'LEAVE'", "'LEFT'", 
		"'LIKE'", "'LIMIT'", "'LINEAR'", "'LINES'", "'LOAD'", "'LOCK'", "'LOOP'", 
		"'LOW_PRIORITY'", "'MASTER_BIND'", "'MASTER_SSL_VERIFY_SERVER_CERT'", 
		"'MATCH'", "'MAXVALUE'", "'MODIFIES'", "'NATURAL'", "'NOT'", "'NO_WRITE_TO_BINLOG'", 
		"'NULL'", "'ON'", "'OPTIMIZE'", "'OPTION'", "'OPTIONALLY'", "'OR'", "'ORDER'", 
		"'OUT'", "'OUTER'", "'OUTFILE'", "'PARTITION'", "'PRIMARY'", "'PROCEDURE'", 
		"'PURGE'", "'RANGE'", "'READ'", "'READS'", "'REFERENCES'", "'REGEXP'", 
		"'RELEASE'", "'RENAME'", "'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESTRICT'", 
		"'RETURN'", "'REVOKE'", "'RIGHT'", "'RLIKE'", "'SCHEMA'", "'SCHEMAS'", 
		"'SELECT'", "'SET'", "'SEPARATOR'", "'SHOW'", "'SPATIAL'", "'SQL'", "'SQLEXCEPTION'", 
		"'SQLSTATE'", "'SQLWARNING'", "'SQL_BIG_RESULT'", "'SQL_CALC_FOUND_ROWS'", 
		"'SQL_SMALL_RESULT'", "'SSL'", "'STARTING'", "'STRAIGHT_JOIN'", "'TABLE'", 
		"'TERMINATED'", "'THEN'", "'TO'", "'TRAILING'", "'TRIGGER'", "'TRUE'", 
		"'UNDO'", "'UNION'", "'UNIQUE'", "'UNLOCK'", "'UNSIGNED'", "'UPDATE'", 
		"'USAGE'", "'USE'", "'USING'", "'VALUES'", "'WHEN'", "'WHERE'", "'WHILE'", 
		"'WITH'", "'WRITE'", "'XOR'", "'ZEROFILL'", "'TINYINT'", "'SMALLINT'", 
		"'MEDIUMINT'", "'INT'", "'INTEGER'", "'BIGINT'", "'REAL'", "'DOUBLE'", 
		"'PRECISION'", "'FLOAT'", "'DECIMAL'", "'DEC'", "'NUMERIC'", "'DATE'", 
		"'TIME'", "'TIMESTAMP'", "'DATETIME'", "'YEAR'", "'CHAR'", "'VARCHAR'", 
		"'NVARCHAR'", "'NATIONAL'", "'BINARY'", "'VARBINARY'", "'TINYBLOB'", "'BLOB'", 
		"'MEDIUMBLOB'", "'LONGBLOB'", "'TINYTEXT'", "'TEXT'", "'MEDIUMTEXT'", 
		"'LONGTEXT'", "'ENUM'", "'VARYING'", "'SERIAL'", "'YEAR_MONTH'", "'DAY_HOUR'", 
		"'DAY_MINUTE'", "'DAY_SECOND'", "'HOUR_MINUTE'", "'HOUR_SECOND'", "'MINUTE_SECOND'", 
		"'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'", "'HOUR_MICROSECOND'", 
		"'DAY_MICROSECOND'", "'AVG'", "'BIT_AND'", "'BIT_OR'", "'BIT_XOR'", "'COUNT'", 
		"'GROUP_CONCAT'", "'MAX'", "'MIN'", "'STD'", "'STDDEV'", "'STDDEV_POP'", 
		"'STDDEV_SAMP'", "'SUM'", "'VAR_POP'", "'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'", 
		"'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'LOCALTIME'", "'CURDATE'", "'CURTIME'", 
		"'DATE_ADD'", "'DATE_SUB'", "'EXTRACT'", "'LOCALTIMESTAMP'", "'NOW'", 
		"'POSITION'", "'SUBSTR'", "'SUBSTRING'", "'SYSDATE'", "'TRIM'", "'UTC_DATE'", 
		"'UTC_TIME'", "'UTC_TIMESTAMP'", "'ACCOUNT'", "'ACTION'", "'AFTER'", "'AGGREGATE'", 
		"'ALGORITHM'", "'ANY'", "'AT'", "'AUTHORS'", "'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", 
		"'AUTO_INCREMENT'", "'AVG_ROW_LENGTH'", "'BEGIN'", "'BINLOG'", "'BIT'", 
		"'BLOCK'", "'BOOL'", "'BOOLEAN'", "'BTREE'", "'CACHE'", "'CASCADED'", 
		"'CHAIN'", "'CHANGED'", "'CHANNEL'", "'CHECKSUM'", "'PAGE_CHECKSUM'", 
		"'CIPHER'", "'CLIENT'", "'CLOSE'", "'COALESCE'", "'CODE'", "'COLUMNS'", 
		"'COLUMN_FORMAT'", "'COMMENT'", "'COMMIT'", "'COMPACT'", "'COMPLETION'", 
		"'COMPRESSED'", "'COMPRESSION'", "'CONCURRENT'", "'CONNECTION'", "'CONSISTENT'", 
		"'CONTAINS'", "'CONTEXT'", "'CONTRIBUTORS'", "'COPY'", "'CPU'", "'DATA'", 
		"'DATAFILE'", "'DEALLOCATE'", "'DEFAULT_AUTH'", "'DEFINER'", "'DELAY_KEY_WRITE'", 
		"'DES_KEY_FILE'", "'DIRECTORY'", "'DISABLE'", "'DISCARD'", "'DISK'", "'DO'", 
		"'DUMPFILE'", "'DUPLICATE'", "'DYNAMIC'", "'ENABLE'", "'ENCRYPTION'", 
		"'END'", "'ENDS'", "'ENGINE'", "'ENGINES'", "'ERROR'", "'ERRORS'", "'ESCAPE'", 
		"'EVEN'", "'EVENT'", "'EVENTS'", "'EVERY'", "'EXCHANGE'", "'EXCLUSIVE'", 
		"'EXPIRE'", "'EXPORT'", "'EXTENDED'", "'EXTENT_SIZE'", "'FAST'", "'FAULTS'", 
		"'FIELDS'", "'FILE_BLOCK_SIZE'", "'FILTER'", "'FIRST'", "'FIXED'", "'FLUSH'", 
		"'FOLLOWS'", "'FOUND'", "'FULL'", "'FUNCTION'", "'GENERAL'", "'GLOBAL'", 
		"'GRANTS'", "'GROUP_REPLICATION'", "'HANDLER'", "'HASH'", "'HELP'", "'HOST'", 
		"'HOSTS'", "'IDENTIFIED'", "'IGNORE_SERVER_IDS'", "'IMPORT'", "'INDEXES'", 
		"'INITIAL_SIZE'", "'INPLACE'", "'INSERT_METHOD'", "'INSTALL'", "'INSTANCE'", 
		"'INVOKER'", "'IO'", "'IO_THREAD'", "'IPC'", "'ISOLATION'", "'ISSUER'", 
		"'JSON'", "'KEY_BLOCK_SIZE'", "'LANGUAGE'", "'LAST'", "'LEAVES'", "'LESS'", 
		"'LEVEL'", "'LIST'", "'LOCAL'", "'LOGFILE'", "'LOGS'", "'MASTER'", "'MASTER_AUTO_POSITION'", 
		"'MASTER_CONNECT_RETRY'", "'MASTER_DELAY'", "'MASTER_HEARTBEAT_PERIOD'", 
		"'MASTER_HOST'", "'MASTER_LOG_FILE'", "'MASTER_LOG_POS'", "'MASTER_PASSWORD'", 
		"'MASTER_PORT'", "'MASTER_RETRY_COUNT'", "'MASTER_SSL'", "'MASTER_SSL_CA'", 
		"'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'", "'MASTER_SSL_CIPHER'", "'MASTER_SSL_CRL'", 
		"'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'", "'MASTER_TLS_VERSION'", "'MASTER_USER'", 
		"'MAX_CONNECTIONS_PER_HOUR'", "'MAX_QUERIES_PER_HOUR'", "'MAX_ROWS'", 
		"'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'", "'MAX_USER_CONNECTIONS'", "'MEDIUM'", 
		"'MERGE'", "'MID'", "'MIGRATE'", "'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'", 
		"'MYSQL'", "'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'", "'NEXT'", "'NO'", 
		"'NODEGROUP'", "'NONE'", "'OFFLINE'", "'OFFSET'", "'OJ'", "'OLD_PASSWORD'", 
		"'ONE'", "'ONLINE'", "'ONLY'", "'OPEN'", "'OPTIMIZER_COSTS'", "'OPTIONS'", 
		"'OWNER'", "'PACK_KEYS'", "'PAGE'", "'PARSER'", "'PARTIAL'", "'PARTITIONING'", 
		"'PARTITIONS'", "'PASSWORD'", "'PHASE'", "'PLUGIN'", "'PLUGIN_DIR'", "'PLUGINS'", 
		"'PORT'", "'PRECEDES'", "'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'", 
		"'PROFILE'", "'PROFILES'", "'PROXY'", "'QUERY'", "'QUICK'", "'REBUILD'", 
		"'RECOVER'", "'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'", "'RELAY_LOG_FILE'", 
		"'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'", "'REPAIR'", 
		"'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'", 
		"'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'", 
		"'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'", "'RESET'", "'RESUME'", 
		"'RETURNS'", "'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", 
		"'ROW_FORMAT'", "'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", "'SERVER'", 
		"'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", "'SIMPLE'", "'SLAVE'", 
		"'SLOW'", "'SNAPSHOT'", "'SOCKET'", "'SOME'", "'SONAME'", "'SOUNDS'", 
		"'SOURCE'", "'SQL_AFTER_GTIDS'", "'SQL_AFTER_MTS_GAPS'", "'SQL_BEFORE_GTIDS'", 
		"'SQL_BUFFER_RESULT'", "'SQL_CACHE'", "'SQL_NO_CACHE'", "'SQL_THREAD'", 
		"'START'", "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'", "'STATS_SAMPLE_PAGES'", 
		"'STATUS'", "'STOP'", "'STORAGE'", "'STORED'", "'STRING'", "'SUBJECT'", 
		"'SUBPARTITION'", "'SUBPARTITIONS'", "'SUSPEND'", "'SWAPS'", "'SWITCHES'", 
		"'TABLESPACE'", "'TEMPORARY'", "'TEMPTABLE'", "'THAN'", "'TRADITIONAL'", 
		"'TRANSACTION'", "'TRIGGERS'", "'TRUNCATE'", "'UNDEFINED'", "'UNDOFILE'", 
		"'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'", "'UNTIL'", "'UPGRADE'", 
		"'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'", "'VALUE'", 
		"'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'WAIT'", "'WARNINGS'", "'WITHOUT'", 
		"'WORK'", "'WRAPPER'", "'X509'", "'XA'", "'XML'", "'EUR'", "'USA'", "'JIS'", 
		"'ISO'", "'INTERNAL'", "'QUARTER'", "'MONTH'", "'DAY'", "'HOUR'", "'MINUTE'", 
		"'WEEK'", "'SECOND'", "'MICROSECOND'", "'TABLES'", "'ROUTINE'", "'EXECUTE'", 
		"'FILE'", "'PROCESS'", "'RELOAD'", "'SHUTDOWN'", "'SUPER'", "'PRIVILEGES'", 
		"'ARMSCII8'", "'ASCII'", "'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", 
		"'CP1257'", "'CP850'", "'CP852'", "'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'", 
		"'EUCKR'", "'GB2312'", "'GBK'", "'GEOSTD8'", "'GREEK'", "'HEBREW'", "'HP8'", 
		"'KEYBCS2'", "'KOI8R'", "'KOI8U'", "'LATIN1'", "'LATIN2'", "'LATIN5'", 
		"'LATIN7'", "'MACCE'", "'MACROMAN'", "'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", 
		"'UJIS'", "'UTF16'", "'UTF16LE'", "'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'", 
		"'ARCHIVE'", "'BLACKHOLE'", "'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'", 
		"'MRG_MYISAM'", "'MYISAM'", "'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'", 
		"'TOKUDB'", "'REPEATABLE'", "'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'", 
		"'GEOMETRYCOLLECTION'", "'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'", 
		"'MULTILINESTRING'", "'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'", 
		"'ABS'", "'ACOS'", "'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'", 
		"'AREA'", "'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'", "'ASYMMETRIC_DECRYPT'", 
		"'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'", "'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", 
		"'ATAN'", "'ATAN2'", "'BENCHMARK'", "'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", 
		"'BUFFER'", "'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", 
		"'CHARSET'", "'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", 
		"'CONCAT'", "'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", 
		"'COS'", "'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'", 
		"'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'", 
		"'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'", 
		"'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'", 
		"'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENVELOPE'", 
		"'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'", "'EXTRACTVALUE'", 
		"'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'", "'FOUND_ROWS'", "'FROM_BASE64'", 
		"'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'", "'GEOMCOLLFROMWKB'", 
		"'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'", "'GEOMETRYFROMTEXT'", 
		"'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'", "'GEOMFROMTEXT'", 
		"'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'", "'GREATEST'", 
		"'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'", "'INET6_ATON'", 
		"'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'", "'INTERIORRINGN'", 
		"'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'", "'ISSIMPLE'", "'IS_FREE_LOCK'", 
		"'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'", "'IS_IPV6'", "'IS_USED_LOCK'", 
		"'LAST_INSERT_ID'", "'LCASE'", "'LEAST'", "'LENGTH'", "'LINEFROMTEXT'", 
		"'LINEFROMWKB'", "'LINESTRINGFROMTEXT'", "'LINESTRINGFROMWKB'", "'LN'", 
		"'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'", "'LOG2'", "'LOWER'", "'LPAD'", 
		"'LTRIM'", "'MAKEDATE'", "'MAKETIME'", "'MAKE_SET'", "'MASTER_POS_WAIT'", 
		"'MBRCONTAINS'", "'MBRDISJOINT'", "'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", 
		"'MBRTOUCHES'", "'MBRWITHIN'", "'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'", 
		"'MONTHNAME'", "'MPOINTFROMTEXT'", "'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", 
		"'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'", "'MULTILINESTRINGFROMWKB'", 
		"'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'", "'MULTIPOLYGONFROMTEXT'", 
		"'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'", "'NUMGEOMETRIES'", 
		"'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'", "'ORD'", 
		"'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'", 
		"'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'", 
		"'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'", 
		"'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'", "'ROW_COUNT'", 
		"'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SESSION_USER'", "'SHA'", "'SHA1'", 
		"'SHA2'", "'SIGN'", "'SIN'", "'SLEEP'", "'SOUNDEX'", "'SQL_THREAD_WAIT_AFTER_GTIDS'", 
		"'SQRT'", "'SRID'", "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'", 
		"'ST_ASBINARY'", "'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'", 
		"'ST_CENTROID'", "'ST_CONTAINS'", "'ST_CROSSES'", "'ST_DIFFERENCE'", "'ST_DIMENSION'", 
		"'ST_DISJOINT'", "'ST_DISTANCE'", "'ST_ENDPOINT'", "'ST_ENVELOPE'", "'ST_EQUALS'", 
		"'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'", "'ST_GEOMCOLLFROMTXT'", 
		"'ST_GEOMCOLLFROMWKB'", "'ST_GEOMETRYCOLLECTIONFROMTEXT'", "'ST_GEOMETRYCOLLECTIONFROMWKB'", 
		"'ST_GEOMETRYFROMTEXT'", "'ST_GEOMETRYFROMWKB'", "'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", 
		"'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'", "'ST_INTERIORRINGN'", "'ST_INTERSECTION'", 
		"'ST_INTERSECTS'", "'ST_ISCLOSED'", "'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", 
		"'ST_LINEFROMWKB'", "'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", 
		"'ST_NUMGEOMETRIES'", "'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", 
		"'ST_NUMPOINTS'", "'ST_OVERLAPS'", "'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'", 
		"'ST_POINTN'", "'ST_POLYFROMTEXT'", "'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", 
		"'ST_POLYGONFROMWKB'", "'ST_SRID'", "'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", 
		"'ST_TOUCHES'", "'ST_UNION'", "'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'", 
		"'SUBSTRING_INDEX'", "'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", 
		"'TIMESTAMPADD'", "'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", 
		"'TOUCHES'", "'TO_BASE64'", "'TO_DAYS'", "'TO_SECONDS'", "'UCASE'", "'UNCOMPRESS'", 
		"'UNCOMPRESSED_LENGTH'", "'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'", 
		"'UPPER'", "'UUID'", "'UUID_SHORT'", "'VALIDATE_PASSWORD_STRENGTH'", "'VERSION'", 
		"'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'", "'WEEKDAY'", "'WEEKOFYEAR'", "'WEIGHT_STRING'", 
		"'WITHIN'", "'YEARWEEK'", "'Y'", "'X'", "':='", "'+='", "'-='", "'*='", 
		"'/='", "'%='", "'&='", "'^='", "'|='", "'*'", "'/'", "'%'", "'+'", "'--'", 
		"'-'", "'DIV'", "'MOD'", "'='", "'>'", "'<'", "'!'", "'~'", "'|'", "'&'", 
		"'^'", "'.'", "'('", "')'", "','", "';'", "'@'", "'0'", "'1'", "'2'", 
		"'''", "'\"'", "'`'", "':'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT", 
		"ADD", "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "AS", "ASC", "BEFORE", 
		"BETWEEN", "BOTH", "BY", "CALL", "CASCADE", "CASE", "CAST", "CHANGE", 
		"CHARACTER", "CHECK", "COLLATE", "COLUMN", "CONDITION", "CONSTRAINT", 
		"CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT_USER", "CURSOR", "DATABASE", 
		"DATABASES", "DECLARE", "DEFAULT", "DELAYED", "DELETE", "DESC", "DESCRIBE", 
		"DETERMINISTIC", "DISTINCT", "DISTINCTROW", "DROP", "EACH", "ELSE", "ELSEIF", 
		"ENCLOSED", "ESCAPED", "EXISTS", "EXIT", "EXPLAIN", "FALSE", "FETCH", 
		"FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", "GENERATED", "GRANT", "GROUP", 
		"HAVING", "HIGH_PRIORITY", "IF", "IGNORE", "IN", "INDEX", "INFILE", "INNER", 
		"INOUT", "INSERT", "INTERVAL", "INTO", "IS", "ITERATE", "JOIN", "KEY", 
		"KEYS", "KILL", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR", 
		"LINES", "LOAD", "LOCK", "LOOP", "LOW_PRIORITY", "MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT", 
		"MATCH", "MAXVALUE", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG", 
		"NULL_LITERAL", "ON", "OPTIMIZE", "OPTION", "OPTIONALLY", "OR", "ORDER", 
		"OUT", "OUTER", "OUTFILE", "PARTITION", "PRIMARY", "PROCEDURE", "PURGE", 
		"RANGE", "READ", "READS", "REFERENCES", "REGEXP", "RELEASE", "RENAME", 
		"REPEAT", "REPLACE", "REQUIRE", "RESTRICT", "RETURN", "REVOKE", "RIGHT", 
		"RLIKE", "SCHEMA", "SCHEMAS", "SELECT", "SET", "SEPARATOR", "SHOW", "SPATIAL", 
		"SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS", 
		"SQL_SMALL_RESULT", "SSL", "STARTING", "STRAIGHT_JOIN", "TABLE", "TERMINATED", 
		"THEN", "TO", "TRAILING", "TRIGGER", "TRUE", "UNDO", "UNION", "UNIQUE", 
		"UNLOCK", "UNSIGNED", "UPDATE", "USAGE", "USE", "USING", "VALUES", "WHEN", 
		"WHERE", "WHILE", "WITH", "WRITE", "XOR", "ZEROFILL", "TINYINT", "SMALLINT", 
		"MEDIUMINT", "INT", "INTEGER", "BIGINT", "REAL", "DOUBLE", "PRECISION", 
		"FLOAT", "DECIMAL", "DEC", "NUMERIC", "DATE", "TIME", "TIMESTAMP", "DATETIME", 
		"YEAR", "CHAR", "VARCHAR", "NVARCHAR", "NATIONAL", "BINARY", "VARBINARY", 
		"TINYBLOB", "BLOB", "MEDIUMBLOB", "LONGBLOB", "TINYTEXT", "TEXT", "MEDIUMTEXT", 
		"LONGTEXT", "ENUM", "VARYING", "SERIAL", "YEAR_MONTH", "DAY_HOUR", "DAY_MINUTE", 
		"DAY_SECOND", "HOUR_MINUTE", "HOUR_SECOND", "MINUTE_SECOND", "SECOND_MICROSECOND", 
		"MINUTE_MICROSECOND", "HOUR_MICROSECOND", "DAY_MICROSECOND", "AVG", "BIT_AND", 
		"BIT_OR", "BIT_XOR", "COUNT", "GROUP_CONCAT", "MAX", "MIN", "STD", "STDDEV", 
		"STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE", 
		"CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "LOCALTIME", "CURDATE", 
		"CURTIME", "DATE_ADD", "DATE_SUB", "EXTRACT", "LOCALTIMESTAMP", "NOW", 
		"POSITION", "SUBSTR", "SUBSTRING", "SYSDATE", "TRIM", "UTC_DATE", "UTC_TIME", 
		"UTC_TIMESTAMP", "ACCOUNT", "ACTION", "AFTER", "AGGREGATE", "ALGORITHM", 
		"ANY", "AT", "AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE", "AUTO_INCREMENT", 
		"AVG_ROW_LENGTH", "BEGIN", "BINLOG", "BIT", "BLOCK", "BOOL", "BOOLEAN", 
		"BTREE", "CACHE", "CASCADED", "CHAIN", "CHANGED", "CHANNEL", "CHECKSUM", 
		"PAGE_CHECKSUM", "CIPHER", "CLIENT", "CLOSE", "COALESCE", "CODE", "COLUMNS", 
		"COLUMN_FORMAT", "COMMENT", "COMMIT", "COMPACT", "COMPLETION", "COMPRESSED", 
		"COMPRESSION", "CONCURRENT", "CONNECTION", "CONSISTENT", "CONTAINS", "CONTEXT", 
		"CONTRIBUTORS", "COPY", "CPU", "DATA", "DATAFILE", "DEALLOCATE", "DEFAULT_AUTH", 
		"DEFINER", "DELAY_KEY_WRITE", "DES_KEY_FILE", "DIRECTORY", "DISABLE", 
		"DISCARD", "DISK", "DO", "DUMPFILE", "DUPLICATE", "DYNAMIC", "ENABLE", 
		"ENCRYPTION", "END", "ENDS", "ENGINE", "ENGINES", "ERROR", "ERRORS", "ESCAPE", 
		"EVEN", "EVENT", "EVENTS", "EVERY", "EXCHANGE", "EXCLUSIVE", "EXPIRE", 
		"EXPORT", "EXTENDED", "EXTENT_SIZE", "FAST", "FAULTS", "FIELDS", "FILE_BLOCK_SIZE", 
		"FILTER", "FIRST", "FIXED", "FLUSH", "FOLLOWS", "FOUND", "FULL", "FUNCTION", 
		"GENERAL", "GLOBAL", "GRANTS", "GROUP_REPLICATION", "HANDLER", "HASH", 
		"HELP", "HOST", "HOSTS", "IDENTIFIED", "IGNORE_SERVER_IDS", "IMPORT", 
		"INDEXES", "INITIAL_SIZE", "INPLACE", "INSERT_METHOD", "INSTALL", "INSTANCE", 
		"INVOKER", "IO", "IO_THREAD", "IPC", "ISOLATION", "ISSUER", "JSON", "KEY_BLOCK_SIZE", 
		"LANGUAGE", "LAST", "LEAVES", "LESS", "LEVEL", "LIST", "LOCAL", "LOGFILE", 
		"LOGS", "MASTER", "MASTER_AUTO_POSITION", "MASTER_CONNECT_RETRY", "MASTER_DELAY", 
		"MASTER_HEARTBEAT_PERIOD", "MASTER_HOST", "MASTER_LOG_FILE", "MASTER_LOG_POS", 
		"MASTER_PASSWORD", "MASTER_PORT", "MASTER_RETRY_COUNT", "MASTER_SSL", 
		"MASTER_SSL_CA", "MASTER_SSL_CAPATH", "MASTER_SSL_CERT", "MASTER_SSL_CIPHER", 
		"MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", "MASTER_SSL_KEY", "MASTER_TLS_VERSION", 
		"MASTER_USER", "MAX_CONNECTIONS_PER_HOUR", "MAX_QUERIES_PER_HOUR", "MAX_ROWS", 
		"MAX_SIZE", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS", "MEDIUM", 
		"MERGE", "MID", "MIGRATE", "MIN_ROWS", "MODE", "MODIFY", "MUTEX", "MYSQL", 
		"NAME", "NAMES", "NCHAR", "NEVER", "NEXT", "NO", "NODEGROUP", "NONE", 
		"OFFLINE", "OFFSET", "OJ", "OLD_PASSWORD", "ONE", "ONLINE", "ONLY", "OPEN", 
		"OPTIMIZER_COSTS", "OPTIONS", "OWNER", "PACK_KEYS", "PAGE", "PARSER", 
		"PARTIAL", "PARTITIONING", "PARTITIONS", "PASSWORD", "PHASE", "PLUGIN", 
		"PLUGIN_DIR", "PLUGINS", "PORT", "PRECEDES", "PREPARE", "PRESERVE", "PREV", 
		"PROCESSLIST", "PROFILE", "PROFILES", "PROXY", "QUERY", "QUICK", "REBUILD", 
		"RECOVER", "REDO_BUFFER_SIZE", "REDUNDANT", "RELAY", "RELAY_LOG_FILE", 
		"RELAY_LOG_POS", "RELAYLOG", "REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB", 
		"REPLICATE_DO_TABLE", "REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE", 
		"REPLICATE_REWRITE_DB", "REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE", 
		"REPLICATION", "RESET", "RESUME", "RETURNS", "ROLLBACK", "ROLLUP", "ROTATE", 
		"ROW", "ROWS", "ROW_FORMAT", "SAVEPOINT", "SCHEDULE", "SECURITY", "SERVER", 
		"SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE", "SLAVE", "SLOW", "SNAPSHOT", 
		"SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE", "SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS", 
		"SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_NO_CACHE", 
		"SQL_THREAD", "START", "STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT", 
		"STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", "STORED", "STRING", 
		"SUBJECT", "SUBPARTITION", "SUBPARTITIONS", "SUSPEND", "SWAPS", "SWITCHES", 
		"TABLESPACE", "TEMPORARY", "TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", 
		"TRIGGERS", "TRUNCATE", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE", "UNINSTALL", 
		"UNKNOWN", "UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES", "VALIDATION", 
		"VALUE", "VARIABLES", "VIEW", "VIRTUAL", "WAIT", "WARNINGS", "WITHOUT", 
		"WORK", "WRAPPER", "X509", "XA", "XML", "EUR", "USA", "JIS", "ISO", "INTERNAL", 
		"QUARTER", "MONTH", "DAY", "HOUR", "MINUTE", "WEEK", "SECOND", "MICROSECOND", 
		"TABLES", "ROUTINE", "EXECUTE", "FILE", "PROCESS", "RELOAD", "SHUTDOWN", 
		"SUPER", "PRIVILEGES", "ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", 
		"CP1256", "CP1257", "CP850", "CP852", "CP866", "CP932", "DEC8", "EUCJPMS", 
		"EUCKR", "GB2312", "GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", 
		"KOI8R", "KOI8U", "LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN", 
		"SJIS", "SWE7", "TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32", 
		"UTF8", "UTF8MB3", "UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED", 
		"INNODB", "MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA", 
		"TOKUDB", "REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE", "GEOMETRYCOLLECTION", 
		"GEOMCOLLECTION", "GEOMETRY", "LINESTRING", "MULTILINESTRING", "MULTIPOINT", 
		"MULTIPOLYGON", "POINT", "POLYGON", "ABS", "ACOS", "ADDDATE", "ADDTIME", 
		"AES_DECRYPT", "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN", "ASTEXT", "ASWKB", 
		"ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE", "ASYMMETRIC_ENCRYPT", 
		"ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", "ATAN", "ATAN2", "BENCHMARK", 
		"BIN", "BIT_COUNT", "BIT_LENGTH", "BUFFER", "CEIL", "CEILING", "CENTROID", 
		"CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH", "COERCIBILITY", "COLLATION", 
		"COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID", "CONV", "CONVERT_TZ", 
		"COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY", "CREATE_ASYMMETRIC_PUB_KEY", 
		"CREATE_DH_PARAMETERS", "CREATE_DIGEST", "CROSSES", "DATEDIFF", "DATE_FORMAT", 
		"DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "DECODE", "DEGREES", 
		"DES_DECRYPT", "DES_ENCRYPT", "DIMENSION", "DISJOINT", "ELT", "ENCODE", 
		"ENCRYPT", "ENDPOINT", "ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", "EXTERIORRING", 
		"EXTRACTVALUE", "FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", 
		"FROM_BASE64", "FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB", 
		"GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT", 
		"GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB", 
		"GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT", 
		"HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA", 
		"INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL", 
		"ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED", 
		"IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH", 
		"LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB", 
		"LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", 
		"LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS", 
		"MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES", 
		"MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT", 
		"MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT", 
		"MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB", "MULTIPOLYGONFROMTEXT", 
		"MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF", "NUMGEOMETRIES", "NUMINTERIORRINGS", 
		"NUMPOINTS", "OCT", "OCTET_LENGTH", "ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", 
		"PI", "POINTFROMTEXT", "POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", 
		"POLYGONFROMTEXT", "POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", 
		"RAND", "RANDOM_BYTES", "RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT", 
		"RPAD", "RTRIM", "SEC_TO_TIME", "SESSION_USER", "SHA", "SHA1", "SHA2", 
		"SIGN", "SIN", "SLEEP", "SOUNDEX", "SQL_THREAD_WAIT_AFTER_GTIDS", "SQRT", 
		"SRID", "STARTPOINT", "STRCMP", "STR_TO_DATE", "ST_AREA", "ST_ASBINARY", 
		"ST_ASTEXT", "ST_ASWKB", "ST_ASWKT", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS", 
		"ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", 
		"ST_ENDPOINT", "ST_ENVELOPE", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT", 
		"ST_GEOMCOLLFROMTXT", "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT", 
		"ST_GEOMETRYCOLLECTIONFROMWKB", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB", 
		"ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB", 
		"ST_INTERIORRINGN", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED", 
		"ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", "ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT", 
		"ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS", 
		"ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINTFROMTEXT", "ST_POINTFROMWKB", 
		"ST_POINTN", "ST_POLYFROMTEXT", "ST_POLYFROMWKB", "ST_POLYGONFROMTEXT", 
		"ST_POLYGONFROMWKB", "ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_TOUCHES", 
		"ST_UNION", "ST_WITHIN", "ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX", 
		"SUBTIME", "SYSTEM_USER", "TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF", 
		"TIME_FORMAT", "TIME_TO_SEC", "TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS", 
		"UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP", 
		"UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH", 
		"VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR", 
		"WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", "X_FUNCTION", "VAR_ASSIGN", 
		"PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", 
		"AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE", "MODULE", "PLUS", 
		"MINUSMINUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", 
		"LESS_SYMBOL", "EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", 
		"BIT_XOR_OP", "DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "AT_SIGN", 
		"ZERO_DECIMAL", "ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB", 
		"REVERSE_QUOTE_SYMB", "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING", "FILESIZE_LITERAL", 
		"START_NATIONAL_STRING_LITERAL", "STRING_LITERAL", "DECIMAL_LITERAL", 
		"HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL", "BIT_STRING", 
		"STRING_CHARSET_NAME", "DOT_ID", "ID", "REVERSE_QUOTE_ID", "STRING_USER_NAME", 
		"LOCAL_ID", "GLOBAL_ID", "ERROR_RECONGNIGION"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "MySqlParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	static MySqlParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

	public MySqlParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}
	public partial class RootContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(MySqlParser.Eof, 0); }
		public SqlStatementsContext sqlStatements() {
			return GetRuleContext<SqlStatementsContext>(0);
		}
		public ITerminalNode MINUSMINUS() { return GetToken(MySqlParser.MINUSMINUS, 0); }
		public RootContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_root; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoot(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoot(this);
		}
	}

	[RuleVersion(0)]
	public RootContext root() {
		RootContext _localctx = new RootContext(Context, State);
		EnterRule(_localctx, 0, RULE_root);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 621;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ALTER) | (1L << ANALYZE) | (1L << CALL) | (1L << CHANGE) | (1L << CHECK) | (1L << CREATE) | (1L << DELETE) | (1L << DESC) | (1L << DESCRIBE) | (1L << DROP) | (1L << EXPLAIN) | (1L << GRANT))) != 0) || ((((_la - 73)) & ~0x3f) == 0 && ((1L << (_la - 73)) & ((1L << (INSERT - 73)) | (1L << (KILL - 73)) | (1L << (LOAD - 73)) | (1L << (LOCK - 73)) | (1L << (OPTIMIZE - 73)) | (1L << (PURGE - 73)) | (1L << (RELEASE - 73)) | (1L << (RENAME - 73)) | (1L << (REPLACE - 73)) | (1L << (REVOKE - 73)) | (1L << (SELECT - 73)) | (1L << (SET - 73)) | (1L << (SHOW - 73)))) != 0) || ((((_la - 157)) & ~0x3f) == 0 && ((1L << (_la - 157)) & ((1L << (UNLOCK - 157)) | (1L << (UPDATE - 157)) | (1L << (USE - 157)))) != 0) || ((((_la - 264)) & ~0x3f) == 0 && ((1L << (_la - 264)) & ((1L << (BEGIN - 264)) | (1L << (BINLOG - 264)) | (1L << (CACHE - 264)) | (1L << (CHECKSUM - 264)) | (1L << (COMMIT - 264)) | (1L << (DEALLOCATE - 264)) | (1L << (DO - 264)))) != 0) || ((((_la - 340)) & ~0x3f) == 0 && ((1L << (_la - 340)) & ((1L << (FLUSH - 340)) | (1L << (HANDLER - 340)) | (1L << (HELP - 340)) | (1L << (INSTALL - 340)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (PREPARE - 448)) | (1L << (REPAIR - 448)) | (1L << (RESET - 448)) | (1L << (ROLLBACK - 448)) | (1L << (SAVEPOINT - 448)) | (1L << (START - 448)))) != 0) || ((((_la - 515)) & ~0x3f) == 0 && ((1L << (_la - 515)) & ((1L << (STOP - 515)) | (1L << (TRUNCATE - 515)) | (1L << (UNINSTALL - 515)) | (1L << (XA - 515)) | (1L << (EXECUTE - 515)) | (1L << (SHUTDOWN - 515)))) != 0) || _la==LR_BRACKET || _la==SEMI) {
				{
				State = 620; sqlStatements();
				}
			}

			State = 624;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MINUSMINUS) {
				{
				State = 623; Match(MINUSMINUS);
				}
			}

			State = 626; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SqlStatementsContext : ParserRuleContext {
		public SqlStatementContext[] sqlStatement() {
			return GetRuleContexts<SqlStatementContext>();
		}
		public SqlStatementContext sqlStatement(int i) {
			return GetRuleContext<SqlStatementContext>(i);
		}
		public EmptyStatementContext[] emptyStatement() {
			return GetRuleContexts<EmptyStatementContext>();
		}
		public EmptyStatementContext emptyStatement(int i) {
			return GetRuleContext<EmptyStatementContext>(i);
		}
		public ITerminalNode[] SEMI() { return GetTokens(MySqlParser.SEMI); }
		public ITerminalNode SEMI(int i) {
			return GetToken(MySqlParser.SEMI, i);
		}
		public ITerminalNode[] MINUSMINUS() { return GetTokens(MySqlParser.MINUSMINUS); }
		public ITerminalNode MINUSMINUS(int i) {
			return GetToken(MySqlParser.MINUSMINUS, i);
		}
		public SqlStatementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlStatements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSqlStatements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSqlStatements(this);
		}
	}

	[RuleVersion(0)]
	public SqlStatementsContext sqlStatements() {
		SqlStatementsContext _localctx = new SqlStatementsContext(Context, State);
		EnterRule(_localctx, 2, RULE_sqlStatements);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 638;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 636;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ALTER:
					case ANALYZE:
					case CALL:
					case CHANGE:
					case CHECK:
					case CREATE:
					case DELETE:
					case DESC:
					case DESCRIBE:
					case DROP:
					case EXPLAIN:
					case GRANT:
					case INSERT:
					case KILL:
					case LOAD:
					case LOCK:
					case OPTIMIZE:
					case PURGE:
					case RELEASE:
					case RENAME:
					case REPLACE:
					case REVOKE:
					case SELECT:
					case SET:
					case SHOW:
					case UNLOCK:
					case UPDATE:
					case USE:
					case BEGIN:
					case BINLOG:
					case CACHE:
					case CHECKSUM:
					case COMMIT:
					case DEALLOCATE:
					case DO:
					case FLUSH:
					case HANDLER:
					case HELP:
					case INSTALL:
					case PREPARE:
					case REPAIR:
					case RESET:
					case ROLLBACK:
					case SAVEPOINT:
					case START:
					case STOP:
					case TRUNCATE:
					case UNINSTALL:
					case XA:
					case EXECUTE:
					case SHUTDOWN:
					case LR_BRACKET:
						{
						State = 628; sqlStatement();
						State = 630;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==MINUSMINUS) {
							{
							State = 629; Match(MINUSMINUS);
							}
						}

						State = 633;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
						case 1:
							{
							State = 632; Match(SEMI);
							}
							break;
						}
						}
						break;
					case SEMI:
						{
						State = 635; emptyStatement();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 640;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			}
			State = 649;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALTER:
			case ANALYZE:
			case CALL:
			case CHANGE:
			case CHECK:
			case CREATE:
			case DELETE:
			case DESC:
			case DESCRIBE:
			case DROP:
			case EXPLAIN:
			case GRANT:
			case INSERT:
			case KILL:
			case LOAD:
			case LOCK:
			case OPTIMIZE:
			case PURGE:
			case RELEASE:
			case RENAME:
			case REPLACE:
			case REVOKE:
			case SELECT:
			case SET:
			case SHOW:
			case UNLOCK:
			case UPDATE:
			case USE:
			case BEGIN:
			case BINLOG:
			case CACHE:
			case CHECKSUM:
			case COMMIT:
			case DEALLOCATE:
			case DO:
			case FLUSH:
			case HANDLER:
			case HELP:
			case INSTALL:
			case PREPARE:
			case REPAIR:
			case RESET:
			case ROLLBACK:
			case SAVEPOINT:
			case START:
			case STOP:
			case TRUNCATE:
			case UNINSTALL:
			case XA:
			case EXECUTE:
			case SHUTDOWN:
			case LR_BRACKET:
				{
				State = 641; sqlStatement();
				State = 646;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,7,Context) ) {
				case 1:
					{
					State = 643;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==MINUSMINUS) {
						{
						State = 642; Match(MINUSMINUS);
						}
					}

					State = 645; Match(SEMI);
					}
					break;
				}
				}
				break;
			case SEMI:
				{
				State = 648; emptyStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SqlStatementContext : ParserRuleContext {
		public DdlStatementContext ddlStatement() {
			return GetRuleContext<DdlStatementContext>(0);
		}
		public DmlStatementContext dmlStatement() {
			return GetRuleContext<DmlStatementContext>(0);
		}
		public TransactionStatementContext transactionStatement() {
			return GetRuleContext<TransactionStatementContext>(0);
		}
		public ReplicationStatementContext replicationStatement() {
			return GetRuleContext<ReplicationStatementContext>(0);
		}
		public PreparedStatementContext preparedStatement() {
			return GetRuleContext<PreparedStatementContext>(0);
		}
		public AdministrationStatementContext administrationStatement() {
			return GetRuleContext<AdministrationStatementContext>(0);
		}
		public UtilityStatementContext utilityStatement() {
			return GetRuleContext<UtilityStatementContext>(0);
		}
		public SqlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSqlStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSqlStatement(this);
		}
	}

	[RuleVersion(0)]
	public SqlStatementContext sqlStatement() {
		SqlStatementContext _localctx = new SqlStatementContext(Context, State);
		EnterRule(_localctx, 4, RULE_sqlStatement);
		try {
			State = 658;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,9,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 651; ddlStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 652; dmlStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 653; transactionStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 654; replicationStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 655; preparedStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 656; administrationStatement();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 657; utilityStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EmptyStatementContext : ParserRuleContext {
		public ITerminalNode SEMI() { return GetToken(MySqlParser.SEMI, 0); }
		public EmptyStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_emptyStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterEmptyStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitEmptyStatement(this);
		}
	}

	[RuleVersion(0)]
	public EmptyStatementContext emptyStatement() {
		EmptyStatementContext _localctx = new EmptyStatementContext(Context, State);
		EnterRule(_localctx, 6, RULE_emptyStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 660; Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DdlStatementContext : ParserRuleContext {
		public CreateDatabaseContext createDatabase() {
			return GetRuleContext<CreateDatabaseContext>(0);
		}
		public CreateEventContext createEvent() {
			return GetRuleContext<CreateEventContext>(0);
		}
		public CreateIndexContext createIndex() {
			return GetRuleContext<CreateIndexContext>(0);
		}
		public CreateLogfileGroupContext createLogfileGroup() {
			return GetRuleContext<CreateLogfileGroupContext>(0);
		}
		public CreateProcedureContext createProcedure() {
			return GetRuleContext<CreateProcedureContext>(0);
		}
		public CreateFunctionContext createFunction() {
			return GetRuleContext<CreateFunctionContext>(0);
		}
		public CreateServerContext createServer() {
			return GetRuleContext<CreateServerContext>(0);
		}
		public CreateTableContext createTable() {
			return GetRuleContext<CreateTableContext>(0);
		}
		public CreateTablespaceInnodbContext createTablespaceInnodb() {
			return GetRuleContext<CreateTablespaceInnodbContext>(0);
		}
		public CreateTablespaceNdbContext createTablespaceNdb() {
			return GetRuleContext<CreateTablespaceNdbContext>(0);
		}
		public CreateTriggerContext createTrigger() {
			return GetRuleContext<CreateTriggerContext>(0);
		}
		public CreateViewContext createView() {
			return GetRuleContext<CreateViewContext>(0);
		}
		public AlterDatabaseContext alterDatabase() {
			return GetRuleContext<AlterDatabaseContext>(0);
		}
		public AlterEventContext alterEvent() {
			return GetRuleContext<AlterEventContext>(0);
		}
		public AlterFunctionContext alterFunction() {
			return GetRuleContext<AlterFunctionContext>(0);
		}
		public AlterInstanceContext alterInstance() {
			return GetRuleContext<AlterInstanceContext>(0);
		}
		public AlterLogfileGroupContext alterLogfileGroup() {
			return GetRuleContext<AlterLogfileGroupContext>(0);
		}
		public AlterProcedureContext alterProcedure() {
			return GetRuleContext<AlterProcedureContext>(0);
		}
		public AlterServerContext alterServer() {
			return GetRuleContext<AlterServerContext>(0);
		}
		public AlterTableContext alterTable() {
			return GetRuleContext<AlterTableContext>(0);
		}
		public AlterTablespaceContext alterTablespace() {
			return GetRuleContext<AlterTablespaceContext>(0);
		}
		public AlterViewContext alterView() {
			return GetRuleContext<AlterViewContext>(0);
		}
		public DropDatabaseContext dropDatabase() {
			return GetRuleContext<DropDatabaseContext>(0);
		}
		public DropEventContext dropEvent() {
			return GetRuleContext<DropEventContext>(0);
		}
		public DropIndexContext dropIndex() {
			return GetRuleContext<DropIndexContext>(0);
		}
		public DropLogfileGroupContext dropLogfileGroup() {
			return GetRuleContext<DropLogfileGroupContext>(0);
		}
		public DropProcedureContext dropProcedure() {
			return GetRuleContext<DropProcedureContext>(0);
		}
		public DropFunctionContext dropFunction() {
			return GetRuleContext<DropFunctionContext>(0);
		}
		public DropServerContext dropServer() {
			return GetRuleContext<DropServerContext>(0);
		}
		public DropTableContext dropTable() {
			return GetRuleContext<DropTableContext>(0);
		}
		public DropTablespaceContext dropTablespace() {
			return GetRuleContext<DropTablespaceContext>(0);
		}
		public DropTriggerContext dropTrigger() {
			return GetRuleContext<DropTriggerContext>(0);
		}
		public DropViewContext dropView() {
			return GetRuleContext<DropViewContext>(0);
		}
		public RenameTableContext renameTable() {
			return GetRuleContext<RenameTableContext>(0);
		}
		public TruncateTableContext truncateTable() {
			return GetRuleContext<TruncateTableContext>(0);
		}
		public DdlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ddlStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDdlStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDdlStatement(this);
		}
	}

	[RuleVersion(0)]
	public DdlStatementContext ddlStatement() {
		DdlStatementContext _localctx = new DdlStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_ddlStatement);
		try {
			State = 697;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 662; createDatabase();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 663; createEvent();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 664; createIndex();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 665; createLogfileGroup();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 666; createProcedure();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 667; createFunction();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 668; createServer();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 669; createTable();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 670; createTablespaceInnodb();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 671; createTablespaceNdb();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 672; createTrigger();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 673; createView();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 674; alterDatabase();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 675; alterEvent();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 676; alterFunction();
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 677; alterInstance();
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 678; alterLogfileGroup();
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 679; alterProcedure();
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 680; alterServer();
				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 681; alterTable();
				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 682; alterTablespace();
				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 683; alterView();
				}
				break;
			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 684; dropDatabase();
				}
				break;
			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 685; dropEvent();
				}
				break;
			case 25:
				EnterOuterAlt(_localctx, 25);
				{
				State = 686; dropIndex();
				}
				break;
			case 26:
				EnterOuterAlt(_localctx, 26);
				{
				State = 687; dropLogfileGroup();
				}
				break;
			case 27:
				EnterOuterAlt(_localctx, 27);
				{
				State = 688; dropProcedure();
				}
				break;
			case 28:
				EnterOuterAlt(_localctx, 28);
				{
				State = 689; dropFunction();
				}
				break;
			case 29:
				EnterOuterAlt(_localctx, 29);
				{
				State = 690; dropServer();
				}
				break;
			case 30:
				EnterOuterAlt(_localctx, 30);
				{
				State = 691; dropTable();
				}
				break;
			case 31:
				EnterOuterAlt(_localctx, 31);
				{
				State = 692; dropTablespace();
				}
				break;
			case 32:
				EnterOuterAlt(_localctx, 32);
				{
				State = 693; dropTrigger();
				}
				break;
			case 33:
				EnterOuterAlt(_localctx, 33);
				{
				State = 694; dropView();
				}
				break;
			case 34:
				EnterOuterAlt(_localctx, 34);
				{
				State = 695; renameTable();
				}
				break;
			case 35:
				EnterOuterAlt(_localctx, 35);
				{
				State = 696; truncateTable();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DmlStatementContext : ParserRuleContext {
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public InsertStatementContext insertStatement() {
			return GetRuleContext<InsertStatementContext>(0);
		}
		public UpdateStatementContext updateStatement() {
			return GetRuleContext<UpdateStatementContext>(0);
		}
		public DeleteStatementContext deleteStatement() {
			return GetRuleContext<DeleteStatementContext>(0);
		}
		public ReplaceStatementContext replaceStatement() {
			return GetRuleContext<ReplaceStatementContext>(0);
		}
		public CallStatementContext callStatement() {
			return GetRuleContext<CallStatementContext>(0);
		}
		public LoadDataStatementContext loadDataStatement() {
			return GetRuleContext<LoadDataStatementContext>(0);
		}
		public LoadXmlStatementContext loadXmlStatement() {
			return GetRuleContext<LoadXmlStatementContext>(0);
		}
		public DoStatementContext doStatement() {
			return GetRuleContext<DoStatementContext>(0);
		}
		public HandlerStatementContext handlerStatement() {
			return GetRuleContext<HandlerStatementContext>(0);
		}
		public DmlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dmlStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDmlStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDmlStatement(this);
		}
	}

	[RuleVersion(0)]
	public DmlStatementContext dmlStatement() {
		DmlStatementContext _localctx = new DmlStatementContext(Context, State);
		EnterRule(_localctx, 10, RULE_dmlStatement);
		try {
			State = 709;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 699; selectStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 700; insertStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 701; updateStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 702; deleteStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 703; replaceStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 704; callStatement();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 705; loadDataStatement();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 706; loadXmlStatement();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 707; doStatement();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 708; handlerStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TransactionStatementContext : ParserRuleContext {
		public StartTransactionContext startTransaction() {
			return GetRuleContext<StartTransactionContext>(0);
		}
		public BeginWorkContext beginWork() {
			return GetRuleContext<BeginWorkContext>(0);
		}
		public CommitWorkContext commitWork() {
			return GetRuleContext<CommitWorkContext>(0);
		}
		public RollbackWorkContext rollbackWork() {
			return GetRuleContext<RollbackWorkContext>(0);
		}
		public SavepointStatementContext savepointStatement() {
			return GetRuleContext<SavepointStatementContext>(0);
		}
		public RollbackStatementContext rollbackStatement() {
			return GetRuleContext<RollbackStatementContext>(0);
		}
		public ReleaseStatementContext releaseStatement() {
			return GetRuleContext<ReleaseStatementContext>(0);
		}
		public LockTablesContext lockTables() {
			return GetRuleContext<LockTablesContext>(0);
		}
		public UnlockTablesContext unlockTables() {
			return GetRuleContext<UnlockTablesContext>(0);
		}
		public TransactionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transactionStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTransactionStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTransactionStatement(this);
		}
	}

	[RuleVersion(0)]
	public TransactionStatementContext transactionStatement() {
		TransactionStatementContext _localctx = new TransactionStatementContext(Context, State);
		EnterRule(_localctx, 12, RULE_transactionStatement);
		try {
			State = 720;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 711; startTransaction();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 712; beginWork();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 713; commitWork();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 714; rollbackWork();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 715; savepointStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 716; rollbackStatement();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 717; releaseStatement();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 718; lockTables();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 719; unlockTables();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReplicationStatementContext : ParserRuleContext {
		public ChangeMasterContext changeMaster() {
			return GetRuleContext<ChangeMasterContext>(0);
		}
		public ChangeReplicationFilterContext changeReplicationFilter() {
			return GetRuleContext<ChangeReplicationFilterContext>(0);
		}
		public PurgeBinaryLogsContext purgeBinaryLogs() {
			return GetRuleContext<PurgeBinaryLogsContext>(0);
		}
		public ResetMasterContext resetMaster() {
			return GetRuleContext<ResetMasterContext>(0);
		}
		public ResetSlaveContext resetSlave() {
			return GetRuleContext<ResetSlaveContext>(0);
		}
		public StartSlaveContext startSlave() {
			return GetRuleContext<StartSlaveContext>(0);
		}
		public StopSlaveContext stopSlave() {
			return GetRuleContext<StopSlaveContext>(0);
		}
		public StartGroupReplicationContext startGroupReplication() {
			return GetRuleContext<StartGroupReplicationContext>(0);
		}
		public StopGroupReplicationContext stopGroupReplication() {
			return GetRuleContext<StopGroupReplicationContext>(0);
		}
		public XaStartTransactionContext xaStartTransaction() {
			return GetRuleContext<XaStartTransactionContext>(0);
		}
		public XaEndTransactionContext xaEndTransaction() {
			return GetRuleContext<XaEndTransactionContext>(0);
		}
		public XaPrepareStatementContext xaPrepareStatement() {
			return GetRuleContext<XaPrepareStatementContext>(0);
		}
		public XaCommitWorkContext xaCommitWork() {
			return GetRuleContext<XaCommitWorkContext>(0);
		}
		public XaRollbackWorkContext xaRollbackWork() {
			return GetRuleContext<XaRollbackWorkContext>(0);
		}
		public XaRecoverWorkContext xaRecoverWork() {
			return GetRuleContext<XaRecoverWorkContext>(0);
		}
		public ReplicationStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_replicationStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReplicationStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReplicationStatement(this);
		}
	}

	[RuleVersion(0)]
	public ReplicationStatementContext replicationStatement() {
		ReplicationStatementContext _localctx = new ReplicationStatementContext(Context, State);
		EnterRule(_localctx, 14, RULE_replicationStatement);
		try {
			State = 737;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,13,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 722; changeMaster();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 723; changeReplicationFilter();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 724; purgeBinaryLogs();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 725; resetMaster();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 726; resetSlave();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 727; startSlave();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 728; stopSlave();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 729; startGroupReplication();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 730; stopGroupReplication();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 731; xaStartTransaction();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 732; xaEndTransaction();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 733; xaPrepareStatement();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 734; xaCommitWork();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 735; xaRollbackWork();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 736; xaRecoverWork();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PreparedStatementContext : ParserRuleContext {
		public PrepareStatementContext prepareStatement() {
			return GetRuleContext<PrepareStatementContext>(0);
		}
		public ExecuteStatementContext executeStatement() {
			return GetRuleContext<ExecuteStatementContext>(0);
		}
		public DeallocatePrepareContext deallocatePrepare() {
			return GetRuleContext<DeallocatePrepareContext>(0);
		}
		public PreparedStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_preparedStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPreparedStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPreparedStatement(this);
		}
	}

	[RuleVersion(0)]
	public PreparedStatementContext preparedStatement() {
		PreparedStatementContext _localctx = new PreparedStatementContext(Context, State);
		EnterRule(_localctx, 16, RULE_preparedStatement);
		try {
			State = 742;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PREPARE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 739; prepareStatement();
				}
				break;
			case EXECUTE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 740; executeStatement();
				}
				break;
			case DROP:
			case DEALLOCATE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 741; deallocatePrepare();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompoundStatementContext : ParserRuleContext {
		public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		public CaseStatementContext caseStatement() {
			return GetRuleContext<CaseStatementContext>(0);
		}
		public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		public LeaveStatementContext leaveStatement() {
			return GetRuleContext<LeaveStatementContext>(0);
		}
		public LoopStatementContext loopStatement() {
			return GetRuleContext<LoopStatementContext>(0);
		}
		public RepeatStatementContext repeatStatement() {
			return GetRuleContext<RepeatStatementContext>(0);
		}
		public WhileStatementContext whileStatement() {
			return GetRuleContext<WhileStatementContext>(0);
		}
		public IterateStatementContext iterateStatement() {
			return GetRuleContext<IterateStatementContext>(0);
		}
		public ReturnStatementContext returnStatement() {
			return GetRuleContext<ReturnStatementContext>(0);
		}
		public CursorStatementContext cursorStatement() {
			return GetRuleContext<CursorStatementContext>(0);
		}
		public CompoundStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compoundStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCompoundStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCompoundStatement(this);
		}
	}

	[RuleVersion(0)]
	public CompoundStatementContext compoundStatement() {
		CompoundStatementContext _localctx = new CompoundStatementContext(Context, State);
		EnterRule(_localctx, 18, RULE_compoundStatement);
		try {
			State = 754;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 744; blockStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 745; caseStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 746; ifStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 747; leaveStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 748; loopStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 749; repeatStatement();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 750; whileStatement();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 751; iterateStatement();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 752; returnStatement();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 753; cursorStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AdministrationStatementContext : ParserRuleContext {
		public AlterUserContext alterUser() {
			return GetRuleContext<AlterUserContext>(0);
		}
		public CreateUserContext createUser() {
			return GetRuleContext<CreateUserContext>(0);
		}
		public DropUserContext dropUser() {
			return GetRuleContext<DropUserContext>(0);
		}
		public GrantStatementContext grantStatement() {
			return GetRuleContext<GrantStatementContext>(0);
		}
		public GrantProxyContext grantProxy() {
			return GetRuleContext<GrantProxyContext>(0);
		}
		public RenameUserContext renameUser() {
			return GetRuleContext<RenameUserContext>(0);
		}
		public RevokeStatementContext revokeStatement() {
			return GetRuleContext<RevokeStatementContext>(0);
		}
		public RevokeProxyContext revokeProxy() {
			return GetRuleContext<RevokeProxyContext>(0);
		}
		public AnalyzeTableContext analyzeTable() {
			return GetRuleContext<AnalyzeTableContext>(0);
		}
		public CheckTableContext checkTable() {
			return GetRuleContext<CheckTableContext>(0);
		}
		public ChecksumTableContext checksumTable() {
			return GetRuleContext<ChecksumTableContext>(0);
		}
		public OptimizeTableContext optimizeTable() {
			return GetRuleContext<OptimizeTableContext>(0);
		}
		public RepairTableContext repairTable() {
			return GetRuleContext<RepairTableContext>(0);
		}
		public CreateUdfunctionContext createUdfunction() {
			return GetRuleContext<CreateUdfunctionContext>(0);
		}
		public InstallPluginContext installPlugin() {
			return GetRuleContext<InstallPluginContext>(0);
		}
		public UninstallPluginContext uninstallPlugin() {
			return GetRuleContext<UninstallPluginContext>(0);
		}
		public SetStatementContext setStatement() {
			return GetRuleContext<SetStatementContext>(0);
		}
		public ShowStatementContext showStatement() {
			return GetRuleContext<ShowStatementContext>(0);
		}
		public BinlogStatementContext binlogStatement() {
			return GetRuleContext<BinlogStatementContext>(0);
		}
		public CacheIndexStatementContext cacheIndexStatement() {
			return GetRuleContext<CacheIndexStatementContext>(0);
		}
		public FlushStatementContext flushStatement() {
			return GetRuleContext<FlushStatementContext>(0);
		}
		public KillStatementContext killStatement() {
			return GetRuleContext<KillStatementContext>(0);
		}
		public LoadIndexIntoCacheContext loadIndexIntoCache() {
			return GetRuleContext<LoadIndexIntoCacheContext>(0);
		}
		public ResetStatementContext resetStatement() {
			return GetRuleContext<ResetStatementContext>(0);
		}
		public ShutdownStatementContext shutdownStatement() {
			return GetRuleContext<ShutdownStatementContext>(0);
		}
		public AdministrationStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_administrationStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAdministrationStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAdministrationStatement(this);
		}
	}

	[RuleVersion(0)]
	public AdministrationStatementContext administrationStatement() {
		AdministrationStatementContext _localctx = new AdministrationStatementContext(Context, State);
		EnterRule(_localctx, 20, RULE_administrationStatement);
		try {
			State = 781;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 756; alterUser();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 757; createUser();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 758; dropUser();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 759; grantStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 760; grantProxy();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 761; renameUser();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 762; revokeStatement();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 763; revokeProxy();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 764; analyzeTable();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 765; checkTable();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 766; checksumTable();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 767; optimizeTable();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 768; repairTable();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 769; createUdfunction();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 770; installPlugin();
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 771; uninstallPlugin();
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 772; setStatement();
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 773; showStatement();
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 774; binlogStatement();
				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 775; cacheIndexStatement();
				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 776; flushStatement();
				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 777; killStatement();
				}
				break;
			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 778; loadIndexIntoCache();
				}
				break;
			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 779; resetStatement();
				}
				break;
			case 25:
				EnterOuterAlt(_localctx, 25);
				{
				State = 780; shutdownStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UtilityStatementContext : ParserRuleContext {
		public SimpleDescribeStatementContext simpleDescribeStatement() {
			return GetRuleContext<SimpleDescribeStatementContext>(0);
		}
		public FullDescribeStatementContext fullDescribeStatement() {
			return GetRuleContext<FullDescribeStatementContext>(0);
		}
		public HelpStatementContext helpStatement() {
			return GetRuleContext<HelpStatementContext>(0);
		}
		public UseStatementContext useStatement() {
			return GetRuleContext<UseStatementContext>(0);
		}
		public UtilityStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_utilityStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUtilityStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUtilityStatement(this);
		}
	}

	[RuleVersion(0)]
	public UtilityStatementContext utilityStatement() {
		UtilityStatementContext _localctx = new UtilityStatementContext(Context, State);
		EnterRule(_localctx, 22, RULE_utilityStatement);
		try {
			State = 787;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 783; simpleDescribeStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 784; fullDescribeStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 785; helpStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 786; useStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateDatabaseContext : ParserRuleContext {
		public IToken dbFormat;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(MySqlParser.SCHEMA, 0); }
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public CreateDatabaseOptionContext[] createDatabaseOption() {
			return GetRuleContexts<CreateDatabaseOptionContext>();
		}
		public CreateDatabaseOptionContext createDatabaseOption(int i) {
			return GetRuleContext<CreateDatabaseOptionContext>(i);
		}
		public CreateDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createDatabase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateDatabase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateDatabase(this);
		}
	}

	[RuleVersion(0)]
	public CreateDatabaseContext createDatabase() {
		CreateDatabaseContext _localctx = new CreateDatabaseContext(Context, State);
		EnterRule(_localctx, 24, RULE_createDatabase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 789; Match(CREATE);
			State = 790;
			_localctx.dbFormat = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DATABASE || _la==SCHEMA) ) {
				_localctx.dbFormat = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 792;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 791; ifNotExists();
				}
			}

			State = 794; uid();
			State = 798;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << CHARACTER) | (1L << COLLATE) | (1L << DEFAULT))) != 0) || _la==CHARSET) {
				{
				{
				State = 795; createDatabaseOption();
				}
				}
				State = 800;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateEventContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode EVENT() { return GetToken(MySqlParser.EVENT, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode[] ON() { return GetTokens(MySqlParser.ON); }
		public ITerminalNode ON(int i) {
			return GetToken(MySqlParser.ON, i);
		}
		public ITerminalNode SCHEDULE() { return GetToken(MySqlParser.SCHEDULE, 0); }
		public ScheduleExpressionContext scheduleExpression() {
			return GetRuleContext<ScheduleExpressionContext>(0);
		}
		public ITerminalNode DO() { return GetToken(MySqlParser.DO, 0); }
		public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public ITerminalNode COMPLETION() { return GetToken(MySqlParser.COMPLETION, 0); }
		public ITerminalNode PRESERVE() { return GetToken(MySqlParser.PRESERVE, 0); }
		public EnableTypeContext enableType() {
			return GetRuleContext<EnableTypeContext>(0);
		}
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public CreateEventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createEvent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateEvent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateEvent(this);
		}
	}

	[RuleVersion(0)]
	public CreateEventContext createEvent() {
		CreateEventContext _localctx = new CreateEventContext(Context, State);
		EnterRule(_localctx, 26, RULE_createEvent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 801; Match(CREATE);
			State = 803;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 802; ownerStatement();
				}
			}

			State = 805; Match(EVENT);
			State = 807;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 806; ifNotExists();
				}
			}

			State = 809; fullId();
			State = 810; Match(ON);
			State = 811; Match(SCHEDULE);
			State = 812; scheduleExpression();
			State = 819;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 813; Match(ON);
				State = 814; Match(COMPLETION);
				State = 816;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 815; Match(NOT);
					}
				}

				State = 818; Match(PRESERVE);
				}
			}

			State = 822;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DISABLE || _la==ENABLE) {
				{
				State = 821; enableType();
				}
			}

			State = 826;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMENT) {
				{
				State = 824; Match(COMMENT);
				State = 825; Match(STRING_LITERAL);
				}
			}

			State = 828; Match(DO);
			State = 829; routineBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateIndexContext : ParserRuleContext {
		public IToken intimeAction;
		public IToken indexCategory;
		public IToken algType;
		public IToken lockType;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public ITerminalNode[] ALGORITHM() { return GetTokens(MySqlParser.ALGORITHM); }
		public ITerminalNode ALGORITHM(int i) {
			return GetToken(MySqlParser.ALGORITHM, i);
		}
		public ITerminalNode[] LOCK() { return GetTokens(MySqlParser.LOCK); }
		public ITerminalNode LOCK(int i) {
			return GetToken(MySqlParser.LOCK, i);
		}
		public ITerminalNode ONLINE() { return GetToken(MySqlParser.ONLINE, 0); }
		public ITerminalNode OFFLINE() { return GetToken(MySqlParser.OFFLINE, 0); }
		public ITerminalNode UNIQUE() { return GetToken(MySqlParser.UNIQUE, 0); }
		public ITerminalNode FULLTEXT() { return GetToken(MySqlParser.FULLTEXT, 0); }
		public ITerminalNode SPATIAL() { return GetToken(MySqlParser.SPATIAL, 0); }
		public ITerminalNode[] DEFAULT() { return GetTokens(MySqlParser.DEFAULT); }
		public ITerminalNode DEFAULT(int i) {
			return GetToken(MySqlParser.DEFAULT, i);
		}
		public ITerminalNode[] INPLACE() { return GetTokens(MySqlParser.INPLACE); }
		public ITerminalNode INPLACE(int i) {
			return GetToken(MySqlParser.INPLACE, i);
		}
		public ITerminalNode[] COPY() { return GetTokens(MySqlParser.COPY); }
		public ITerminalNode COPY(int i) {
			return GetToken(MySqlParser.COPY, i);
		}
		public ITerminalNode[] NONE() { return GetTokens(MySqlParser.NONE); }
		public ITerminalNode NONE(int i) {
			return GetToken(MySqlParser.NONE, i);
		}
		public ITerminalNode[] SHARED() { return GetTokens(MySqlParser.SHARED); }
		public ITerminalNode SHARED(int i) {
			return GetToken(MySqlParser.SHARED, i);
		}
		public ITerminalNode[] EXCLUSIVE() { return GetTokens(MySqlParser.EXCLUSIVE); }
		public ITerminalNode EXCLUSIVE(int i) {
			return GetToken(MySqlParser.EXCLUSIVE, i);
		}
		public CreateIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createIndex; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateIndex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateIndex(this);
		}
	}

	[RuleVersion(0)]
	public CreateIndexContext createIndex() {
		CreateIndexContext _localctx = new CreateIndexContext(Context, State);
		EnterRule(_localctx, 28, RULE_createIndex);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 831; Match(CREATE);
			State = 833;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OFFLINE || _la==ONLINE) {
				{
				State = 832;
				_localctx.intimeAction = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==OFFLINE || _la==ONLINE) ) {
					_localctx.intimeAction = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 836;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FULLTEXT || _la==SPATIAL || _la==UNIQUE) {
				{
				State = 835;
				_localctx.indexCategory = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FULLTEXT || _la==SPATIAL || _la==UNIQUE) ) {
					_localctx.indexCategory = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 838; Match(INDEX);
			State = 839; uid();
			State = 841;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 840; indexType();
				}
			}

			State = 843; Match(ON);
			State = 844; tableName();
			State = 845; indexColumnNames();
			State = 849;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==USING || _la==WITH || _la==COMMENT || _la==KEY_BLOCK_SIZE) {
				{
				{
				State = 846; indexOption();
				}
				}
				State = 851;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 864;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 862;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ALGORITHM:
						{
						State = 852; Match(ALGORITHM);
						State = 854;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==EQUAL_SYMBOL) {
							{
							State = 853; Match(EQUAL_SYMBOL);
							}
						}

						State = 856;
						_localctx.algType = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==DEFAULT || _la==COPY || _la==INPLACE) ) {
							_localctx.algType = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					case LOCK:
						{
						State = 857; Match(LOCK);
						State = 859;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==EQUAL_SYMBOL) {
							{
							State = 858; Match(EQUAL_SYMBOL);
							}
						}

						State = 861;
						_localctx.lockType = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==DEFAULT || _la==EXCLUSIVE || _la==NONE || _la==SHARED) ) {
							_localctx.lockType = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 866;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateLogfileGroupContext : ParserRuleContext {
		public IToken undoFile;
		public FileSizeLiteralContext initSize;
		public FileSizeLiteralContext undoSize;
		public FileSizeLiteralContext redoSize;
		public IToken comment;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode LOGFILE() { return GetToken(MySqlParser.LOGFILE, 0); }
		public ITerminalNode GROUP() { return GetToken(MySqlParser.GROUP, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode UNDOFILE() { return GetToken(MySqlParser.UNDOFILE, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(MySqlParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(MySqlParser.STRING_LITERAL, i);
		}
		public ITerminalNode INITIAL_SIZE() { return GetToken(MySqlParser.INITIAL_SIZE, 0); }
		public ITerminalNode UNDO_BUFFER_SIZE() { return GetToken(MySqlParser.UNDO_BUFFER_SIZE, 0); }
		public ITerminalNode REDO_BUFFER_SIZE() { return GetToken(MySqlParser.REDO_BUFFER_SIZE, 0); }
		public ITerminalNode NODEGROUP() { return GetToken(MySqlParser.NODEGROUP, 0); }
		public ITerminalNode WAIT() { return GetToken(MySqlParser.WAIT, 0); }
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public FileSizeLiteralContext[] fileSizeLiteral() {
			return GetRuleContexts<FileSizeLiteralContext>();
		}
		public FileSizeLiteralContext fileSizeLiteral(int i) {
			return GetRuleContext<FileSizeLiteralContext>(i);
		}
		public CreateLogfileGroupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createLogfileGroup; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateLogfileGroup(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateLogfileGroup(this);
		}
	}

	[RuleVersion(0)]
	public CreateLogfileGroupContext createLogfileGroup() {
		CreateLogfileGroupContext _localctx = new CreateLogfileGroupContext(Context, State);
		EnterRule(_localctx, 30, RULE_createLogfileGroup);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 867; Match(CREATE);
			State = 868; Match(LOGFILE);
			State = 869; Match(GROUP);
			State = 870; uid();
			State = 871; Match(ADD);
			State = 872; Match(UNDOFILE);
			State = 873; _localctx.undoFile = Match(STRING_LITERAL);
			State = 879;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INITIAL_SIZE) {
				{
				State = 874; Match(INITIAL_SIZE);
				State = 876;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 875; Match(EQUAL_SYMBOL);
					}
				}

				State = 878; _localctx.initSize = fileSizeLiteral();
				}
			}

			State = 886;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNDO_BUFFER_SIZE) {
				{
				State = 881; Match(UNDO_BUFFER_SIZE);
				State = 883;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 882; Match(EQUAL_SYMBOL);
					}
				}

				State = 885; _localctx.undoSize = fileSizeLiteral();
				}
			}

			State = 893;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REDO_BUFFER_SIZE) {
				{
				State = 888; Match(REDO_BUFFER_SIZE);
				State = 890;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 889; Match(EQUAL_SYMBOL);
					}
				}

				State = 892; _localctx.redoSize = fileSizeLiteral();
				}
			}

			State = 900;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NODEGROUP) {
				{
				State = 895; Match(NODEGROUP);
				State = 897;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 896; Match(EQUAL_SYMBOL);
					}
				}

				State = 899; uid();
				}
			}

			State = 903;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WAIT) {
				{
				State = 902; Match(WAIT);
				}
			}

			State = 910;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMENT) {
				{
				State = 905; Match(COMMENT);
				State = 907;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 906; Match(EQUAL_SYMBOL);
					}
				}

				State = 909; _localctx.comment = Match(STRING_LITERAL);
				}
			}

			State = 912; Match(ENGINE);
			State = 914;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQUAL_SYMBOL) {
				{
				State = 913; Match(EQUAL_SYMBOL);
				}
			}

			State = 916; engineName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateProcedureContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public ProcedureParameterContext[] procedureParameter() {
			return GetRuleContexts<ProcedureParameterContext>();
		}
		public ProcedureParameterContext procedureParameter(int i) {
			return GetRuleContext<ProcedureParameterContext>(i);
		}
		public RoutineOptionContext[] routineOption() {
			return GetRuleContexts<RoutineOptionContext>();
		}
		public RoutineOptionContext routineOption(int i) {
			return GetRuleContext<RoutineOptionContext>(i);
		}
		public CreateProcedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createProcedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateProcedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateProcedure(this);
		}
	}

	[RuleVersion(0)]
	public CreateProcedureContext createProcedure() {
		CreateProcedureContext _localctx = new CreateProcedureContext(Context, State);
		EnterRule(_localctx, 32, RULE_createProcedure);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 918; Match(CREATE);
			State = 920;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 919; ownerStatement();
				}
			}

			State = 922; Match(PROCEDURE);
			State = 923; fullId();
			State = 924; Match(LR_BRACKET);
			State = 926;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || ((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (IN - 68)) | (1L << (INOUT - 68)) | (1L << (LEFT - 68)) | (1L << (OUT - 68)) | (1L << (RIGHT - 68)))) != 0) || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
				{
				State = 925; procedureParameter();
				}
			}

			State = 932;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 928; Match(COMMA);
				State = 929; procedureParameter();
				}
				}
				State = 934;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 935; Match(RR_BRACKET);
			State = 939;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 936; routineOption();
					}
					} 
				}
				State = 941;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			}
			State = 942; routineBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateFunctionContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode RETURNS() { return GetToken(MySqlParser.RETURNS, 0); }
		public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public FunctionParameterContext[] functionParameter() {
			return GetRuleContexts<FunctionParameterContext>();
		}
		public FunctionParameterContext functionParameter(int i) {
			return GetRuleContext<FunctionParameterContext>(i);
		}
		public RoutineOptionContext[] routineOption() {
			return GetRuleContexts<RoutineOptionContext>();
		}
		public RoutineOptionContext routineOption(int i) {
			return GetRuleContext<RoutineOptionContext>(i);
		}
		public CreateFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateFunction(this);
		}
	}

	[RuleVersion(0)]
	public CreateFunctionContext createFunction() {
		CreateFunctionContext _localctx = new CreateFunctionContext(Context, State);
		EnterRule(_localctx, 34, RULE_createFunction);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 944; Match(CREATE);
			State = 946;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 945; ownerStatement();
				}
			}

			State = 948; Match(FUNCTION);
			State = 949; fullId();
			State = 950; Match(LR_BRACKET);
			State = 952;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
				{
				State = 951; functionParameter();
				}
			}

			State = 958;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 954; Match(COMMA);
				State = 955; functionParameter();
				}
				}
				State = 960;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 961; Match(RR_BRACKET);
			State = 962; Match(RETURNS);
			State = 963; dataType();
			State = 967;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,53,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 964; routineOption();
					}
					} 
				}
				State = 969;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,53,Context);
			}
			State = 970; routineBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateServerContext : ParserRuleContext {
		public IToken wrapperName;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode SERVER() { return GetToken(MySqlParser.SERVER, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode FOREIGN() { return GetToken(MySqlParser.FOREIGN, 0); }
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode WRAPPER() { return GetToken(MySqlParser.WRAPPER, 0); }
		public ITerminalNode OPTIONS() { return GetToken(MySqlParser.OPTIONS, 0); }
		public ServerOptionContext[] serverOption() {
			return GetRuleContexts<ServerOptionContext>();
		}
		public ServerOptionContext serverOption(int i) {
			return GetRuleContext<ServerOptionContext>(i);
		}
		public ITerminalNode MYSQL() { return GetToken(MySqlParser.MYSQL, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public CreateServerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createServer; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateServer(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateServer(this);
		}
	}

	[RuleVersion(0)]
	public CreateServerContext createServer() {
		CreateServerContext _localctx = new CreateServerContext(Context, State);
		EnterRule(_localctx, 36, RULE_createServer);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 972; Match(CREATE);
			State = 973; Match(SERVER);
			State = 974; uid();
			State = 975; Match(FOREIGN);
			State = 976; Match(DATA);
			State = 977; Match(WRAPPER);
			State = 978;
			_localctx.wrapperName = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==MYSQL || _la==STRING_LITERAL) ) {
				_localctx.wrapperName = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 979; Match(OPTIONS);
			State = 980; Match(LR_BRACKET);
			State = 981; serverOption();
			State = 986;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 982; Match(COMMA);
				State = 983; serverOption();
				}
				}
				State = 988;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 989; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTableContext : ParserRuleContext {
		public CreateTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTable; } }
	 
		public CreateTableContext() { }
		public virtual void CopyFrom(CreateTableContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CopyCreateTableContext : CreateTableContext {
		public TableNameContext parenthesisTable;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext[] tableName() {
			return GetRuleContexts<TableNameContext>();
		}
		public TableNameContext tableName(int i) {
			return GetRuleContext<TableNameContext>(i);
		}
		public ITerminalNode LIKE() { return GetToken(MySqlParser.LIKE, 0); }
		public ITerminalNode TEMPORARY() { return GetToken(MySqlParser.TEMPORARY, 0); }
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public CopyCreateTableContext(CreateTableContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCopyCreateTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCopyCreateTable(this);
		}
	}
	public partial class ColumnCreateTableContext : CreateTableContext {
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public CreateDefinitionsContext createDefinitions() {
			return GetRuleContext<CreateDefinitionsContext>(0);
		}
		public ITerminalNode TEMPORARY() { return GetToken(MySqlParser.TEMPORARY, 0); }
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public TableOptionContext[] tableOption() {
			return GetRuleContexts<TableOptionContext>();
		}
		public TableOptionContext tableOption(int i) {
			return GetRuleContext<TableOptionContext>(i);
		}
		public PartitionDefinitionsContext partitionDefinitions() {
			return GetRuleContext<PartitionDefinitionsContext>(0);
		}
		public ColumnCreateTableContext(CreateTableContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterColumnCreateTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitColumnCreateTable(this);
		}
	}
	public partial class QueryCreateTableContext : CreateTableContext {
		public IToken keyViolate;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ITerminalNode TEMPORARY() { return GetToken(MySqlParser.TEMPORARY, 0); }
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public CreateDefinitionsContext createDefinitions() {
			return GetRuleContext<CreateDefinitionsContext>(0);
		}
		public TableOptionContext[] tableOption() {
			return GetRuleContexts<TableOptionContext>();
		}
		public TableOptionContext tableOption(int i) {
			return GetRuleContext<TableOptionContext>(i);
		}
		public PartitionDefinitionsContext partitionDefinitions() {
			return GetRuleContext<PartitionDefinitionsContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode REPLACE() { return GetToken(MySqlParser.REPLACE, 0); }
		public QueryCreateTableContext(CreateTableContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterQueryCreateTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitQueryCreateTable(this);
		}
	}

	[RuleVersion(0)]
	public CreateTableContext createTable() {
		CreateTableContext _localctx = new CreateTableContext(Context, State);
		EnterRule(_localctx, 38, RULE_createTable);
		int _la;
		try {
			int _alt;
			State = 1069;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,73,Context) ) {
			case 1:
				_localctx = new CopyCreateTableContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 991; Match(CREATE);
				State = 993;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==TEMPORARY) {
					{
					State = 992; Match(TEMPORARY);
					}
				}

				State = 995; Match(TABLE);
				State = 997;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IF) {
					{
					State = 996; ifNotExists();
					}
				}

				State = 999; tableName();
				State = 1007;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case LIKE:
					{
					State = 1000; Match(LIKE);
					State = 1001; tableName();
					}
					break;
				case LR_BRACKET:
					{
					State = 1002; Match(LR_BRACKET);
					State = 1003; Match(LIKE);
					State = 1004; ((CopyCreateTableContext)_localctx).parenthesisTable = tableName();
					State = 1005; Match(RR_BRACKET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				_localctx = new QueryCreateTableContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1009; Match(CREATE);
				State = 1011;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==TEMPORARY) {
					{
					State = 1010; Match(TEMPORARY);
					}
				}

				State = 1013; Match(TABLE);
				State = 1015;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IF) {
					{
					State = 1014; ifNotExists();
					}
				}

				State = 1017; tableName();
				State = 1019;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,60,Context) ) {
				case 1:
					{
					State = 1018; createDefinitions();
					}
					break;
				}
				State = 1031;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 22)) & ~0x3f) == 0 && ((1L << (_la - 22)) & ((1L << (CHARACTER - 22)) | (1L << (COLLATE - 22)) | (1L << (DEFAULT - 22)) | (1L << (INDEX - 22)))) != 0) || _la==UNION || ((((_la - 262)) & ~0x3f) == 0 && ((1L << (_la - 262)) & ((1L << (AUTO_INCREMENT - 262)) | (1L << (AVG_ROW_LENGTH - 262)) | (1L << (CHECKSUM - 262)) | (1L << (PAGE_CHECKSUM - 262)) | (1L << (COMMENT - 262)) | (1L << (COMPRESSION - 262)) | (1L << (CONNECTION - 262)) | (1L << (DATA - 262)) | (1L << (DELAY_KEY_WRITE - 262)) | (1L << (ENCRYPTION - 262)) | (1L << (ENGINE - 262)))) != 0) || ((((_la - 360)) & ~0x3f) == 0 && ((1L << (_la - 360)) & ((1L << (INSERT_METHOD - 360)) | (1L << (KEY_BLOCK_SIZE - 360)) | (1L << (MAX_ROWS - 360)) | (1L << (MIN_ROWS - 360)))) != 0) || ((((_la - 435)) & ~0x3f) == 0 && ((1L << (_la - 435)) & ((1L << (PACK_KEYS - 435)) | (1L << (PASSWORD - 435)) | (1L << (ROW_FORMAT - 435)))) != 0) || ((((_la - 511)) & ~0x3f) == 0 && ((1L << (_la - 511)) & ((1L << (STATS_AUTO_RECALC - 511)) | (1L << (STATS_PERSISTENT - 511)) | (1L << (STATS_SAMPLE_PAGES - 511)) | (1L << (STORAGE - 511)) | (1L << (TABLESPACE - 511)))) != 0) || _la==CHARSET) {
					{
					State = 1021; tableOption();
					State = 1028;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (((((_la - 22)) & ~0x3f) == 0 && ((1L << (_la - 22)) & ((1L << (CHARACTER - 22)) | (1L << (COLLATE - 22)) | (1L << (DEFAULT - 22)) | (1L << (INDEX - 22)))) != 0) || _la==UNION || ((((_la - 262)) & ~0x3f) == 0 && ((1L << (_la - 262)) & ((1L << (AUTO_INCREMENT - 262)) | (1L << (AVG_ROW_LENGTH - 262)) | (1L << (CHECKSUM - 262)) | (1L << (PAGE_CHECKSUM - 262)) | (1L << (COMMENT - 262)) | (1L << (COMPRESSION - 262)) | (1L << (CONNECTION - 262)) | (1L << (DATA - 262)) | (1L << (DELAY_KEY_WRITE - 262)) | (1L << (ENCRYPTION - 262)) | (1L << (ENGINE - 262)))) != 0) || ((((_la - 360)) & ~0x3f) == 0 && ((1L << (_la - 360)) & ((1L << (INSERT_METHOD - 360)) | (1L << (KEY_BLOCK_SIZE - 360)) | (1L << (MAX_ROWS - 360)) | (1L << (MIN_ROWS - 360)))) != 0) || ((((_la - 435)) & ~0x3f) == 0 && ((1L << (_la - 435)) & ((1L << (PACK_KEYS - 435)) | (1L << (PASSWORD - 435)) | (1L << (ROW_FORMAT - 435)))) != 0) || ((((_la - 511)) & ~0x3f) == 0 && ((1L << (_la - 511)) & ((1L << (STATS_AUTO_RECALC - 511)) | (1L << (STATS_PERSISTENT - 511)) | (1L << (STATS_SAMPLE_PAGES - 511)) | (1L << (STORAGE - 511)) | (1L << (TABLESPACE - 511)))) != 0) || _la==CHARSET || _la==COMMA) {
						{
						{
						State = 1023;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 1022; Match(COMMA);
							}
						}

						State = 1025; tableOption();
						}
						}
						State = 1030;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 1034;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PARTITION) {
					{
					State = 1033; partitionDefinitions();
					}
				}

				State = 1037;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IGNORE || _la==REPLACE) {
					{
					State = 1036;
					((QueryCreateTableContext)_localctx).keyViolate = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==IGNORE || _la==REPLACE) ) {
						((QueryCreateTableContext)_localctx).keyViolate = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1040;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 1039; Match(AS);
					}
				}

				State = 1042; selectStatement();
				}
				break;
			case 3:
				_localctx = new ColumnCreateTableContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1044; Match(CREATE);
				State = 1046;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==TEMPORARY) {
					{
					State = 1045; Match(TEMPORARY);
					}
				}

				State = 1048; Match(TABLE);
				State = 1050;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IF) {
					{
					State = 1049; ifNotExists();
					}
				}

				State = 1052; tableName();
				State = 1053; createDefinitions();
				State = 1064;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,71,Context) ) {
				case 1:
					{
					State = 1054; tableOption();
					State = 1061;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,70,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 1056;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (_la==COMMA) {
								{
								State = 1055; Match(COMMA);
								}
							}

							State = 1058; tableOption();
							}
							} 
						}
						State = 1063;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,70,Context);
					}
					}
					break;
				}
				State = 1067;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PARTITION) {
					{
					State = 1066; partitionDefinitions();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTablespaceInnodbContext : ParserRuleContext {
		public IToken datafile;
		public FileSizeLiteralContext fileBlockSize;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode DATAFILE() { return GetToken(MySqlParser.DATAFILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode FILE_BLOCK_SIZE() { return GetToken(MySqlParser.FILE_BLOCK_SIZE, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public FileSizeLiteralContext fileSizeLiteral() {
			return GetRuleContext<FileSizeLiteralContext>(0);
		}
		public CreateTablespaceInnodbContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTablespaceInnodb; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateTablespaceInnodb(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateTablespaceInnodb(this);
		}
	}

	[RuleVersion(0)]
	public CreateTablespaceInnodbContext createTablespaceInnodb() {
		CreateTablespaceInnodbContext _localctx = new CreateTablespaceInnodbContext(Context, State);
		EnterRule(_localctx, 40, RULE_createTablespaceInnodb);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1071; Match(CREATE);
			State = 1072; Match(TABLESPACE);
			State = 1073; uid();
			State = 1074; Match(ADD);
			State = 1075; Match(DATAFILE);
			State = 1076; _localctx.datafile = Match(STRING_LITERAL);
			State = 1080;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FILE_BLOCK_SIZE) {
				{
				State = 1077; Match(FILE_BLOCK_SIZE);
				State = 1078; Match(EQUAL_SYMBOL);
				State = 1079; _localctx.fileBlockSize = fileSizeLiteral();
				}
			}

			State = 1087;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ENGINE) {
				{
				State = 1082; Match(ENGINE);
				State = 1084;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1083; Match(EQUAL_SYMBOL);
					}
				}

				State = 1086; engineName();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTablespaceNdbContext : ParserRuleContext {
		public IToken datafile;
		public FileSizeLiteralContext extentSize;
		public FileSizeLiteralContext initialSize;
		public FileSizeLiteralContext autoextendSize;
		public FileSizeLiteralContext maxSize;
		public IToken comment;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode DATAFILE() { return GetToken(MySqlParser.DATAFILE, 0); }
		public ITerminalNode USE() { return GetToken(MySqlParser.USE, 0); }
		public ITerminalNode LOGFILE() { return GetToken(MySqlParser.LOGFILE, 0); }
		public ITerminalNode GROUP() { return GetToken(MySqlParser.GROUP, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(MySqlParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(MySqlParser.STRING_LITERAL, i);
		}
		public ITerminalNode EXTENT_SIZE() { return GetToken(MySqlParser.EXTENT_SIZE, 0); }
		public ITerminalNode INITIAL_SIZE() { return GetToken(MySqlParser.INITIAL_SIZE, 0); }
		public ITerminalNode AUTOEXTEND_SIZE() { return GetToken(MySqlParser.AUTOEXTEND_SIZE, 0); }
		public ITerminalNode MAX_SIZE() { return GetToken(MySqlParser.MAX_SIZE, 0); }
		public ITerminalNode NODEGROUP() { return GetToken(MySqlParser.NODEGROUP, 0); }
		public ITerminalNode WAIT() { return GetToken(MySqlParser.WAIT, 0); }
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public FileSizeLiteralContext[] fileSizeLiteral() {
			return GetRuleContexts<FileSizeLiteralContext>();
		}
		public FileSizeLiteralContext fileSizeLiteral(int i) {
			return GetRuleContext<FileSizeLiteralContext>(i);
		}
		public CreateTablespaceNdbContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTablespaceNdb; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateTablespaceNdb(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateTablespaceNdb(this);
		}
	}

	[RuleVersion(0)]
	public CreateTablespaceNdbContext createTablespaceNdb() {
		CreateTablespaceNdbContext _localctx = new CreateTablespaceNdbContext(Context, State);
		EnterRule(_localctx, 42, RULE_createTablespaceNdb);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1089; Match(CREATE);
			State = 1090; Match(TABLESPACE);
			State = 1091; uid();
			State = 1092; Match(ADD);
			State = 1093; Match(DATAFILE);
			State = 1094; _localctx.datafile = Match(STRING_LITERAL);
			State = 1095; Match(USE);
			State = 1096; Match(LOGFILE);
			State = 1097; Match(GROUP);
			State = 1098; uid();
			State = 1104;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXTENT_SIZE) {
				{
				State = 1099; Match(EXTENT_SIZE);
				State = 1101;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1100; Match(EQUAL_SYMBOL);
					}
				}

				State = 1103; _localctx.extentSize = fileSizeLiteral();
				}
			}

			State = 1111;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INITIAL_SIZE) {
				{
				State = 1106; Match(INITIAL_SIZE);
				State = 1108;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1107; Match(EQUAL_SYMBOL);
					}
				}

				State = 1110; _localctx.initialSize = fileSizeLiteral();
				}
			}

			State = 1118;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AUTOEXTEND_SIZE) {
				{
				State = 1113; Match(AUTOEXTEND_SIZE);
				State = 1115;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1114; Match(EQUAL_SYMBOL);
					}
				}

				State = 1117; _localctx.autoextendSize = fileSizeLiteral();
				}
			}

			State = 1125;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MAX_SIZE) {
				{
				State = 1120; Match(MAX_SIZE);
				State = 1122;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1121; Match(EQUAL_SYMBOL);
					}
				}

				State = 1124; _localctx.maxSize = fileSizeLiteral();
				}
			}

			State = 1132;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NODEGROUP) {
				{
				State = 1127; Match(NODEGROUP);
				State = 1129;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1128; Match(EQUAL_SYMBOL);
					}
				}

				State = 1131; uid();
				}
			}

			State = 1135;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WAIT) {
				{
				State = 1134; Match(WAIT);
				}
			}

			State = 1142;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMENT) {
				{
				State = 1137; Match(COMMENT);
				State = 1139;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1138; Match(EQUAL_SYMBOL);
					}
				}

				State = 1141; _localctx.comment = Match(STRING_LITERAL);
				}
			}

			State = 1144; Match(ENGINE);
			State = 1146;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQUAL_SYMBOL) {
				{
				State = 1145; Match(EQUAL_SYMBOL);
				}
			}

			State = 1148; engineName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTriggerContext : ParserRuleContext {
		public FullIdContext thisTrigger;
		public IToken triggerTime;
		public IToken triggerEvent;
		public IToken triggerPlace;
		public FullIdContext otherTrigger;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TRIGGER() { return GetToken(MySqlParser.TRIGGER, 0); }
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode EACH() { return GetToken(MySqlParser.EACH, 0); }
		public ITerminalNode ROW() { return GetToken(MySqlParser.ROW, 0); }
		public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		public FullIdContext[] fullId() {
			return GetRuleContexts<FullIdContext>();
		}
		public FullIdContext fullId(int i) {
			return GetRuleContext<FullIdContext>(i);
		}
		public ITerminalNode BEFORE() { return GetToken(MySqlParser.BEFORE, 0); }
		public ITerminalNode AFTER() { return GetToken(MySqlParser.AFTER, 0); }
		public ITerminalNode INSERT() { return GetToken(MySqlParser.INSERT, 0); }
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public ITerminalNode DELETE() { return GetToken(MySqlParser.DELETE, 0); }
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public ITerminalNode FOLLOWS() { return GetToken(MySqlParser.FOLLOWS, 0); }
		public ITerminalNode PRECEDES() { return GetToken(MySqlParser.PRECEDES, 0); }
		public CreateTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTrigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateTrigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateTrigger(this);
		}
	}

	[RuleVersion(0)]
	public CreateTriggerContext createTrigger() {
		CreateTriggerContext _localctx = new CreateTriggerContext(Context, State);
		EnterRule(_localctx, 44, RULE_createTrigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1150; Match(CREATE);
			State = 1152;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 1151; ownerStatement();
				}
			}

			State = 1154; Match(TRIGGER);
			State = 1155; _localctx.thisTrigger = fullId();
			State = 1156;
			_localctx.triggerTime = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==BEFORE || _la==AFTER) ) {
				_localctx.triggerTime = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1157;
			_localctx.triggerEvent = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DELETE || _la==INSERT || _la==UPDATE) ) {
				_localctx.triggerEvent = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1158; Match(ON);
			State = 1159; tableName();
			State = 1160; Match(FOR);
			State = 1161; Match(EACH);
			State = 1162; Match(ROW);
			State = 1165;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,92,Context) ) {
			case 1:
				{
				State = 1163;
				_localctx.triggerPlace = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FOLLOWS || _la==PRECEDES) ) {
					_localctx.triggerPlace = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1164; _localctx.otherTrigger = fullId();
				}
				break;
			}
			State = 1167; routineBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateViewContext : ParserRuleContext {
		public IToken algType;
		public IToken secContext;
		public IToken checkOption;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode VIEW() { return GetToken(MySqlParser.VIEW, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ITerminalNode OR() { return GetToken(MySqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(MySqlParser.REPLACE, 0); }
		public ITerminalNode ALGORITHM() { return GetToken(MySqlParser.ALGORITHM, 0); }
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public ITerminalNode SQL() { return GetToken(MySqlParser.SQL, 0); }
		public ITerminalNode SECURITY() { return GetToken(MySqlParser.SECURITY, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode CHECK() { return GetToken(MySqlParser.CHECK, 0); }
		public ITerminalNode OPTION() { return GetToken(MySqlParser.OPTION, 0); }
		public ITerminalNode UNDEFINED() { return GetToken(MySqlParser.UNDEFINED, 0); }
		public ITerminalNode MERGE() { return GetToken(MySqlParser.MERGE, 0); }
		public ITerminalNode TEMPTABLE() { return GetToken(MySqlParser.TEMPTABLE, 0); }
		public ITerminalNode DEFINER() { return GetToken(MySqlParser.DEFINER, 0); }
		public ITerminalNode INVOKER() { return GetToken(MySqlParser.INVOKER, 0); }
		public ITerminalNode CASCADED() { return GetToken(MySqlParser.CASCADED, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public CreateViewContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createView; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateView(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateView(this);
		}
	}

	[RuleVersion(0)]
	public CreateViewContext createView() {
		CreateViewContext _localctx = new CreateViewContext(Context, State);
		EnterRule(_localctx, 46, RULE_createView);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1169; Match(CREATE);
			State = 1172;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 1170; Match(OR);
				State = 1171; Match(REPLACE);
				}
			}

			State = 1177;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALGORITHM) {
				{
				State = 1174; Match(ALGORITHM);
				State = 1175; Match(EQUAL_SYMBOL);
				State = 1176;
				_localctx.algType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==MERGE || _la==TEMPTABLE || _la==UNDEFINED) ) {
					_localctx.algType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 1180;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 1179; ownerStatement();
				}
			}

			State = 1185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SQL) {
				{
				State = 1182; Match(SQL);
				State = 1183; Match(SECURITY);
				State = 1184;
				_localctx.secContext = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFINER || _la==INVOKER) ) {
					_localctx.secContext = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 1187; Match(VIEW);
			State = 1188; fullId();
			State = 1193;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LR_BRACKET) {
				{
				State = 1189; Match(LR_BRACKET);
				State = 1190; uidList();
				State = 1191; Match(RR_BRACKET);
				}
			}

			State = 1195; Match(AS);
			State = 1196; selectStatement();
			State = 1203;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 1197; Match(WITH);
				State = 1199;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CASCADED || _la==LOCAL) {
					{
					State = 1198;
					_localctx.checkOption = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==CASCADED || _la==LOCAL) ) {
						_localctx.checkOption = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1201; Match(CHECK);
				State = 1202; Match(OPTION);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateDatabaseOptionContext : ParserRuleContext {
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public CreateDatabaseOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createDatabaseOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateDatabaseOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateDatabaseOption(this);
		}
	}

	[RuleVersion(0)]
	public CreateDatabaseOptionContext createDatabaseOption() {
		CreateDatabaseOptionContext _localctx = new CreateDatabaseOptionContext(Context, State);
		EnterRule(_localctx, 48, RULE_createDatabaseOption);
		int _la;
		try {
			State = 1225;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,105,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1206;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 1205; Match(DEFAULT);
					}
				}

				State = 1211;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case CHARACTER:
					{
					State = 1208; Match(CHARACTER);
					State = 1209; Match(SET);
					}
					break;
				case CHARSET:
					{
					State = 1210; Match(CHARSET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1214;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1213; Match(EQUAL_SYMBOL);
					}
				}

				State = 1216; charsetName();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1218;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 1217; Match(DEFAULT);
					}
				}

				State = 1220; Match(COLLATE);
				State = 1222;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1221; Match(EQUAL_SYMBOL);
					}
				}

				State = 1224; collationName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OwnerStatementContext : ParserRuleContext {
		public ITerminalNode DEFINER() { return GetToken(MySqlParser.DEFINER, 0); }
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public ITerminalNode CURRENT_USER() { return GetToken(MySqlParser.CURRENT_USER, 0); }
		public OwnerStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ownerStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterOwnerStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitOwnerStatement(this);
		}
	}

	[RuleVersion(0)]
	public OwnerStatementContext ownerStatement() {
		OwnerStatementContext _localctx = new OwnerStatementContext(Context, State);
		EnterRule(_localctx, 50, RULE_ownerStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1227; Match(DEFINER);
			State = 1228; Match(EQUAL_SYMBOL);
			State = 1235;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STRING_LITERAL:
			case ID:
			case STRING_USER_NAME:
				{
				State = 1229; userName();
				}
				break;
			case CURRENT_USER:
				{
				State = 1230; Match(CURRENT_USER);
				State = 1233;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LR_BRACKET) {
					{
					State = 1231; Match(LR_BRACKET);
					State = 1232; Match(RR_BRACKET);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScheduleExpressionContext : ParserRuleContext {
		public ScheduleExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scheduleExpression; } }
	 
		public ScheduleExpressionContext() { }
		public virtual void CopyFrom(ScheduleExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PreciseScheduleContext : ScheduleExpressionContext {
		public ITerminalNode AT() { return GetToken(MySqlParser.AT, 0); }
		public TimestampValueContext timestampValue() {
			return GetRuleContext<TimestampValueContext>(0);
		}
		public IntervalExprContext[] intervalExpr() {
			return GetRuleContexts<IntervalExprContext>();
		}
		public IntervalExprContext intervalExpr(int i) {
			return GetRuleContext<IntervalExprContext>(i);
		}
		public PreciseScheduleContext(ScheduleExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPreciseSchedule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPreciseSchedule(this);
		}
	}
	public partial class IntervalScheduleContext : ScheduleExpressionContext {
		public TimestampValueContext start;
		public IntervalExprContext _intervalExpr;
		public IList<IntervalExprContext> _startIntervals = new List<IntervalExprContext>();
		public TimestampValueContext end;
		public IList<IntervalExprContext> _endIntervals = new List<IntervalExprContext>();
		public ITerminalNode EVERY() { return GetToken(MySqlParser.EVERY, 0); }
		public IntervalTypeContext intervalType() {
			return GetRuleContext<IntervalTypeContext>(0);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode STARTS() { return GetToken(MySqlParser.STARTS, 0); }
		public ITerminalNode ENDS() { return GetToken(MySqlParser.ENDS, 0); }
		public TimestampValueContext[] timestampValue() {
			return GetRuleContexts<TimestampValueContext>();
		}
		public TimestampValueContext timestampValue(int i) {
			return GetRuleContext<TimestampValueContext>(i);
		}
		public IntervalExprContext[] intervalExpr() {
			return GetRuleContexts<IntervalExprContext>();
		}
		public IntervalExprContext intervalExpr(int i) {
			return GetRuleContext<IntervalExprContext>(i);
		}
		public IntervalScheduleContext(ScheduleExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIntervalSchedule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIntervalSchedule(this);
		}
	}

	[RuleVersion(0)]
	public ScheduleExpressionContext scheduleExpression() {
		ScheduleExpressionContext _localctx = new ScheduleExpressionContext(Context, State);
		EnterRule(_localctx, 52, RULE_scheduleExpression);
		int _la;
		try {
			State = 1271;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AT:
				_localctx = new PreciseScheduleContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1237; Match(AT);
				State = 1238; timestampValue();
				State = 1242;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==PLUS) {
					{
					{
					State = 1239; intervalExpr();
					}
					}
					State = 1244;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case EVERY:
				_localctx = new IntervalScheduleContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1245; Match(EVERY);
				State = 1248;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,109,Context) ) {
				case 1:
					{
					State = 1246; decimalLiteral();
					}
					break;
				case 2:
					{
					State = 1247; expression(0);
					}
					break;
				}
				State = 1250; intervalType();
				State = 1259;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==STARTS) {
					{
					State = 1251; Match(STARTS);
					State = 1252; ((IntervalScheduleContext)_localctx).start = timestampValue();
					State = 1256;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==PLUS) {
						{
						{
						State = 1253; ((IntervalScheduleContext)_localctx)._intervalExpr = intervalExpr();
						((IntervalScheduleContext)_localctx)._startIntervals.Add(((IntervalScheduleContext)_localctx)._intervalExpr);
						}
						}
						State = 1258;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 1269;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ENDS) {
					{
					State = 1261; Match(ENDS);
					State = 1262; ((IntervalScheduleContext)_localctx).end = timestampValue();
					State = 1266;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==PLUS) {
						{
						{
						State = 1263; ((IntervalScheduleContext)_localctx)._intervalExpr = intervalExpr();
						((IntervalScheduleContext)_localctx)._endIntervals.Add(((IntervalScheduleContext)_localctx)._intervalExpr);
						}
						}
						State = 1268;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimestampValueContext : ParserRuleContext {
		public ITerminalNode CURRENT_TIMESTAMP() { return GetToken(MySqlParser.CURRENT_TIMESTAMP, 0); }
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public TimestampValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timestampValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTimestampValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTimestampValue(this);
		}
	}

	[RuleVersion(0)]
	public TimestampValueContext timestampValue() {
		TimestampValueContext _localctx = new TimestampValueContext(Context, State);
		EnterRule(_localctx, 54, RULE_timestampValue);
		try {
			State = 1277;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,115,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1273; Match(CURRENT_TIMESTAMP);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1274; stringLiteral();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1275; decimalLiteral();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1276; expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalExprContext : ParserRuleContext {
		public ITerminalNode INTERVAL() { return GetToken(MySqlParser.INTERVAL, 0); }
		public IntervalTypeContext intervalType() {
			return GetRuleContext<IntervalTypeContext>(0);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public IntervalExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIntervalExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIntervalExpr(this);
		}
	}

	[RuleVersion(0)]
	public IntervalExprContext intervalExpr() {
		IntervalExprContext _localctx = new IntervalExprContext(Context, State);
		EnterRule(_localctx, 56, RULE_intervalExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1279; Match(PLUS);
			State = 1280; Match(INTERVAL);
			State = 1283;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,116,Context) ) {
			case 1:
				{
				State = 1281; decimalLiteral();
				}
				break;
			case 2:
				{
				State = 1282; expression(0);
				}
				break;
			}
			State = 1285; intervalType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalTypeContext : ParserRuleContext {
		public IntervalTypeBaseContext intervalTypeBase() {
			return GetRuleContext<IntervalTypeBaseContext>(0);
		}
		public ITerminalNode YEAR() { return GetToken(MySqlParser.YEAR, 0); }
		public ITerminalNode YEAR_MONTH() { return GetToken(MySqlParser.YEAR_MONTH, 0); }
		public ITerminalNode DAY_HOUR() { return GetToken(MySqlParser.DAY_HOUR, 0); }
		public ITerminalNode DAY_MINUTE() { return GetToken(MySqlParser.DAY_MINUTE, 0); }
		public ITerminalNode DAY_SECOND() { return GetToken(MySqlParser.DAY_SECOND, 0); }
		public ITerminalNode HOUR_MINUTE() { return GetToken(MySqlParser.HOUR_MINUTE, 0); }
		public ITerminalNode HOUR_SECOND() { return GetToken(MySqlParser.HOUR_SECOND, 0); }
		public ITerminalNode MINUTE_SECOND() { return GetToken(MySqlParser.MINUTE_SECOND, 0); }
		public ITerminalNode SECOND_MICROSECOND() { return GetToken(MySqlParser.SECOND_MICROSECOND, 0); }
		public ITerminalNode MINUTE_MICROSECOND() { return GetToken(MySqlParser.MINUTE_MICROSECOND, 0); }
		public ITerminalNode HOUR_MICROSECOND() { return GetToken(MySqlParser.HOUR_MICROSECOND, 0); }
		public ITerminalNode DAY_MICROSECOND() { return GetToken(MySqlParser.DAY_MICROSECOND, 0); }
		public IntervalTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIntervalType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIntervalType(this);
		}
	}

	[RuleVersion(0)]
	public IntervalTypeContext intervalType() {
		IntervalTypeContext _localctx = new IntervalTypeContext(Context, State);
		EnterRule(_localctx, 58, RULE_intervalType);
		try {
			State = 1300;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1287; intervalTypeBase();
				}
				break;
			case YEAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1288; Match(YEAR);
				}
				break;
			case YEAR_MONTH:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1289; Match(YEAR_MONTH);
				}
				break;
			case DAY_HOUR:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1290; Match(DAY_HOUR);
				}
				break;
			case DAY_MINUTE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1291; Match(DAY_MINUTE);
				}
				break;
			case DAY_SECOND:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1292; Match(DAY_SECOND);
				}
				break;
			case HOUR_MINUTE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1293; Match(HOUR_MINUTE);
				}
				break;
			case HOUR_SECOND:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1294; Match(HOUR_SECOND);
				}
				break;
			case MINUTE_SECOND:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1295; Match(MINUTE_SECOND);
				}
				break;
			case SECOND_MICROSECOND:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1296; Match(SECOND_MICROSECOND);
				}
				break;
			case MINUTE_MICROSECOND:
				EnterOuterAlt(_localctx, 11);
				{
				State = 1297; Match(MINUTE_MICROSECOND);
				}
				break;
			case HOUR_MICROSECOND:
				EnterOuterAlt(_localctx, 12);
				{
				State = 1298; Match(HOUR_MICROSECOND);
				}
				break;
			case DAY_MICROSECOND:
				EnterOuterAlt(_localctx, 13);
				{
				State = 1299; Match(DAY_MICROSECOND);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnableTypeContext : ParserRuleContext {
		public ITerminalNode ENABLE() { return GetToken(MySqlParser.ENABLE, 0); }
		public ITerminalNode DISABLE() { return GetToken(MySqlParser.DISABLE, 0); }
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public EnableTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enableType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterEnableType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitEnableType(this);
		}
	}

	[RuleVersion(0)]
	public EnableTypeContext enableType() {
		EnableTypeContext _localctx = new EnableTypeContext(Context, State);
		EnterRule(_localctx, 60, RULE_enableType);
		try {
			State = 1307;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,118,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1302; Match(ENABLE);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1303; Match(DISABLE);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1304; Match(DISABLE);
				State = 1305; Match(ON);
				State = 1306; Match(SLAVE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexTypeContext : ParserRuleContext {
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public ITerminalNode BTREE() { return GetToken(MySqlParser.BTREE, 0); }
		public ITerminalNode HASH() { return GetToken(MySqlParser.HASH, 0); }
		public IndexTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexType(this);
		}
	}

	[RuleVersion(0)]
	public IndexTypeContext indexType() {
		IndexTypeContext _localctx = new IndexTypeContext(Context, State);
		EnterRule(_localctx, 62, RULE_indexType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1309; Match(USING);
			State = 1310;
			_la = TokenStream.LA(1);
			if ( !(_la==BTREE || _la==HASH) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOptionContext : ParserRuleContext {
		public ITerminalNode KEY_BLOCK_SIZE() { return GetToken(MySqlParser.KEY_BLOCK_SIZE, 0); }
		public FileSizeLiteralContext fileSizeLiteral() {
			return GetRuleContext<FileSizeLiteralContext>(0);
		}
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode PARSER() { return GetToken(MySqlParser.PARSER, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public IndexOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexOption(this);
		}
	}

	[RuleVersion(0)]
	public IndexOptionContext indexOption() {
		IndexOptionContext _localctx = new IndexOptionContext(Context, State);
		EnterRule(_localctx, 64, RULE_indexOption);
		int _la;
		try {
			State = 1323;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KEY_BLOCK_SIZE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1312; Match(KEY_BLOCK_SIZE);
				State = 1314;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1313; Match(EQUAL_SYMBOL);
					}
				}

				State = 1316; fileSizeLiteral();
				}
				break;
			case USING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1317; indexType();
				}
				break;
			case WITH:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1318; Match(WITH);
				State = 1319; Match(PARSER);
				State = 1320; uid();
				}
				break;
			case COMMENT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1321; Match(COMMENT);
				State = 1322; Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureParameterContext : ParserRuleContext {
		public IToken direction;
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public ITerminalNode OUT() { return GetToken(MySqlParser.OUT, 0); }
		public ITerminalNode INOUT() { return GetToken(MySqlParser.INOUT, 0); }
		public ProcedureParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureParameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterProcedureParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitProcedureParameter(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureParameterContext procedureParameter() {
		ProcedureParameterContext _localctx = new ProcedureParameterContext(Context, State);
		EnterRule(_localctx, 66, RULE_procedureParameter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1326;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (IN - 68)) | (1L << (INOUT - 68)) | (1L << (OUT - 68)))) != 0)) {
				{
				State = 1325;
				_localctx.direction = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (IN - 68)) | (1L << (INOUT - 68)) | (1L << (OUT - 68)))) != 0)) ) {
					_localctx.direction = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 1328; uid();
			State = 1329; dataType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionParameterContext : ParserRuleContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		public FunctionParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionParameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFunctionParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFunctionParameter(this);
		}
	}

	[RuleVersion(0)]
	public FunctionParameterContext functionParameter() {
		FunctionParameterContext _localctx = new FunctionParameterContext(Context, State);
		EnterRule(_localctx, 68, RULE_functionParameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1331; uid();
			State = 1332; dataType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RoutineOptionContext : ParserRuleContext {
		public RoutineOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routineOption; } }
	 
		public RoutineOptionContext() { }
		public virtual void CopyFrom(RoutineOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class RoutineBehaviorContext : RoutineOptionContext {
		public ITerminalNode DETERMINISTIC() { return GetToken(MySqlParser.DETERMINISTIC, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public RoutineBehaviorContext(RoutineOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoutineBehavior(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoutineBehavior(this);
		}
	}
	public partial class RoutineLanguageContext : RoutineOptionContext {
		public ITerminalNode LANGUAGE() { return GetToken(MySqlParser.LANGUAGE, 0); }
		public ITerminalNode SQL() { return GetToken(MySqlParser.SQL, 0); }
		public RoutineLanguageContext(RoutineOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoutineLanguage(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoutineLanguage(this);
		}
	}
	public partial class RoutineCommentContext : RoutineOptionContext {
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public RoutineCommentContext(RoutineOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoutineComment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoutineComment(this);
		}
	}
	public partial class RoutineSecurityContext : RoutineOptionContext {
		public IToken context;
		public ITerminalNode SQL() { return GetToken(MySqlParser.SQL, 0); }
		public ITerminalNode SECURITY() { return GetToken(MySqlParser.SECURITY, 0); }
		public ITerminalNode DEFINER() { return GetToken(MySqlParser.DEFINER, 0); }
		public ITerminalNode INVOKER() { return GetToken(MySqlParser.INVOKER, 0); }
		public RoutineSecurityContext(RoutineOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoutineSecurity(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoutineSecurity(this);
		}
	}
	public partial class RoutineDataContext : RoutineOptionContext {
		public ITerminalNode CONTAINS() { return GetToken(MySqlParser.CONTAINS, 0); }
		public ITerminalNode SQL() { return GetToken(MySqlParser.SQL, 0); }
		public ITerminalNode NO() { return GetToken(MySqlParser.NO, 0); }
		public ITerminalNode READS() { return GetToken(MySqlParser.READS, 0); }
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode MODIFIES() { return GetToken(MySqlParser.MODIFIES, 0); }
		public RoutineDataContext(RoutineOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoutineData(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoutineData(this);
		}
	}

	[RuleVersion(0)]
	public RoutineOptionContext routineOption() {
		RoutineOptionContext _localctx = new RoutineOptionContext(Context, State);
		EnterRule(_localctx, 70, RULE_routineOption);
		int _la;
		try {
			State = 1357;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMMENT:
				_localctx = new RoutineCommentContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1334; Match(COMMENT);
				State = 1335; Match(STRING_LITERAL);
				}
				break;
			case LANGUAGE:
				_localctx = new RoutineLanguageContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1336; Match(LANGUAGE);
				State = 1337; Match(SQL);
				}
				break;
			case DETERMINISTIC:
			case NOT:
				_localctx = new RoutineBehaviorContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1339;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 1338; Match(NOT);
					}
				}

				State = 1341; Match(DETERMINISTIC);
				}
				break;
			case MODIFIES:
			case READS:
			case CONTAINS:
			case NO:
				_localctx = new RoutineDataContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1352;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case CONTAINS:
					{
					State = 1342; Match(CONTAINS);
					State = 1343; Match(SQL);
					}
					break;
				case NO:
					{
					State = 1344; Match(NO);
					State = 1345; Match(SQL);
					}
					break;
				case READS:
					{
					State = 1346; Match(READS);
					State = 1347; Match(SQL);
					State = 1348; Match(DATA);
					}
					break;
				case MODIFIES:
					{
					State = 1349; Match(MODIFIES);
					State = 1350; Match(SQL);
					State = 1351; Match(DATA);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case SQL:
				_localctx = new RoutineSecurityContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1354; Match(SQL);
				State = 1355; Match(SECURITY);
				State = 1356;
				((RoutineSecurityContext)_localctx).context = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFINER || _la==INVOKER) ) {
					((RoutineSecurityContext)_localctx).context = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ServerOptionContext : ParserRuleContext {
		public ITerminalNode HOST() { return GetToken(MySqlParser.HOST, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode SOCKET() { return GetToken(MySqlParser.SOCKET, 0); }
		public ITerminalNode OWNER() { return GetToken(MySqlParser.OWNER, 0); }
		public ITerminalNode PORT() { return GetToken(MySqlParser.PORT, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ServerOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_serverOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterServerOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitServerOption(this);
		}
	}

	[RuleVersion(0)]
	public ServerOptionContext serverOption() {
		ServerOptionContext _localctx = new ServerOptionContext(Context, State);
		EnterRule(_localctx, 72, RULE_serverOption);
		try {
			State = 1373;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case HOST:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1359; Match(HOST);
				State = 1360; Match(STRING_LITERAL);
				}
				break;
			case DATABASE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1361; Match(DATABASE);
				State = 1362; Match(STRING_LITERAL);
				}
				break;
			case USER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1363; Match(USER);
				State = 1364; Match(STRING_LITERAL);
				}
				break;
			case PASSWORD:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1365; Match(PASSWORD);
				State = 1366; Match(STRING_LITERAL);
				}
				break;
			case SOCKET:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1367; Match(SOCKET);
				State = 1368; Match(STRING_LITERAL);
				}
				break;
			case OWNER:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1369; Match(OWNER);
				State = 1370; Match(STRING_LITERAL);
				}
				break;
			case PORT:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1371; Match(PORT);
				State = 1372; decimalLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateDefinitionsContext : ParserRuleContext {
		public CreateDefinitionContext[] createDefinition() {
			return GetRuleContexts<CreateDefinitionContext>();
		}
		public CreateDefinitionContext createDefinition(int i) {
			return GetRuleContext<CreateDefinitionContext>(i);
		}
		public CreateDefinitionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createDefinitions; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateDefinitions(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateDefinitions(this);
		}
	}

	[RuleVersion(0)]
	public CreateDefinitionsContext createDefinitions() {
		CreateDefinitionsContext _localctx = new CreateDefinitionsContext(Context, State);
		EnterRule(_localctx, 74, RULE_createDefinitions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1375; Match(LR_BRACKET);
			State = 1376; createDefinition();
			State = 1381;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1377; Match(COMMA);
				State = 1378; createDefinition();
				}
				}
				State = 1383;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1384; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateDefinitionContext : ParserRuleContext {
		public CreateDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createDefinition; } }
	 
		public CreateDefinitionContext() { }
		public virtual void CopyFrom(CreateDefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ColumnDeclarationContext : CreateDefinitionContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ColumnDefinitionContext columnDefinition() {
			return GetRuleContext<ColumnDefinitionContext>(0);
		}
		public ColumnDeclarationContext(CreateDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterColumnDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitColumnDeclaration(this);
		}
	}
	public partial class ConstraintDeclarationContext : CreateDefinitionContext {
		public TableConstraintContext tableConstraint() {
			return GetRuleContext<TableConstraintContext>(0);
		}
		public ConstraintDeclarationContext(CreateDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterConstraintDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitConstraintDeclaration(this);
		}
	}
	public partial class IndexDeclarationContext : CreateDefinitionContext {
		public IndexColumnDefinitionContext indexColumnDefinition() {
			return GetRuleContext<IndexColumnDefinitionContext>(0);
		}
		public IndexDeclarationContext(CreateDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public CreateDefinitionContext createDefinition() {
		CreateDefinitionContext _localctx = new CreateDefinitionContext(Context, State);
		EnterRule(_localctx, 76, RULE_createDefinition);
		try {
			State = 1391;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DATABASE:
			case LEFT:
			case RIGHT:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case TEXT:
			case ENUM:
			case SERIAL:
			case COUNT:
			case POSITION:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case CHARSET_REVERSE_QOUTE_STRING:
			case STRING_LITERAL:
			case ID:
			case REVERSE_QUOTE_ID:
				_localctx = new ColumnDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1386; uid();
				State = 1387; columnDefinition();
				}
				break;
			case CHECK:
			case CONSTRAINT:
			case FOREIGN:
			case PRIMARY:
			case UNIQUE:
				_localctx = new ConstraintDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1389; tableConstraint();
				}
				break;
			case FULLTEXT:
			case INDEX:
			case KEY:
			case SPATIAL:
				_localctx = new IndexDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1390; indexColumnDefinition();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnDefinitionContext : ParserRuleContext {
		public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		public ColumnConstraintContext[] columnConstraint() {
			return GetRuleContexts<ColumnConstraintContext>();
		}
		public ColumnConstraintContext columnConstraint(int i) {
			return GetRuleContext<ColumnConstraintContext>(i);
		}
		public ColumnDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnDefinition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterColumnDefinition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitColumnDefinition(this);
		}
	}

	[RuleVersion(0)]
	public ColumnDefinitionContext columnDefinition() {
		ColumnDefinitionContext _localctx = new ColumnDefinitionContext(Context, State);
		EnterRule(_localctx, 78, RULE_columnDefinition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1393; dataType();
			State = 1397;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AS) | (1L << COLLATE) | (1L << DEFAULT) | (1L << GENERATED))) != 0) || ((((_la - 79)) & ~0x3f) == 0 && ((1L << (_la - 79)) & ((1L << (KEY - 79)) | (1L << (NOT - 79)) | (1L << (NULL_LITERAL - 79)) | (1L << (ON - 79)) | (1L << (PRIMARY - 79)) | (1L << (REFERENCES - 79)))) != 0) || _la==UNIQUE || _la==SERIAL || ((((_la - 262)) & ~0x3f) == 0 && ((1L << (_la - 262)) & ((1L << (AUTO_INCREMENT - 262)) | (1L << (COLUMN_FORMAT - 262)) | (1L << (COMMENT - 262)))) != 0) || _la==STORAGE || _la==NULL_SPEC_LITERAL) {
				{
				{
				State = 1394; columnConstraint();
				}
				}
				State = 1399;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnConstraintContext : ParserRuleContext {
		public ColumnConstraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnConstraint; } }
	 
		public ColumnConstraintContext() { }
		public virtual void CopyFrom(ColumnConstraintContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class StorageColumnConstraintContext : ColumnConstraintContext {
		public IToken storageval;
		public ITerminalNode STORAGE() { return GetToken(MySqlParser.STORAGE, 0); }
		public ITerminalNode DISK() { return GetToken(MySqlParser.DISK, 0); }
		public ITerminalNode MEMORY() { return GetToken(MySqlParser.MEMORY, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public StorageColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStorageColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStorageColumnConstraint(this);
		}
	}
	public partial class FormatColumnConstraintContext : ColumnConstraintContext {
		public IToken colformat;
		public ITerminalNode COLUMN_FORMAT() { return GetToken(MySqlParser.COLUMN_FORMAT, 0); }
		public ITerminalNode FIXED() { return GetToken(MySqlParser.FIXED, 0); }
		public ITerminalNode DYNAMIC() { return GetToken(MySqlParser.DYNAMIC, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public FormatColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFormatColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFormatColumnConstraint(this);
		}
	}
	public partial class CollateColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public CollateColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCollateColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCollateColumnConstraint(this);
		}
	}
	public partial class AutoIncrementColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode AUTO_INCREMENT() { return GetToken(MySqlParser.AUTO_INCREMENT, 0); }
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public CurrentTimestampContext currentTimestamp() {
			return GetRuleContext<CurrentTimestampContext>(0);
		}
		public AutoIncrementColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAutoIncrementColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAutoIncrementColumnConstraint(this);
		}
	}
	public partial class CommentColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public CommentColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCommentColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCommentColumnConstraint(this);
		}
	}
	public partial class PrimaryKeyColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public ITerminalNode PRIMARY() { return GetToken(MySqlParser.PRIMARY, 0); }
		public PrimaryKeyColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPrimaryKeyColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPrimaryKeyColumnConstraint(this);
		}
	}
	public partial class UniqueKeyColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode UNIQUE() { return GetToken(MySqlParser.UNIQUE, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UniqueKeyColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUniqueKeyColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUniqueKeyColumnConstraint(this);
		}
	}
	public partial class SerialDefaultColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode SERIAL() { return GetToken(MySqlParser.SERIAL, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode VALUE() { return GetToken(MySqlParser.VALUE, 0); }
		public SerialDefaultColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSerialDefaultColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSerialDefaultColumnConstraint(this);
		}
	}
	public partial class NullColumnConstraintContext : ColumnConstraintContext {
		public NullNotnullContext nullNotnull() {
			return GetRuleContext<NullNotnullContext>(0);
		}
		public NullColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNullColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNullColumnConstraint(this);
		}
	}
	public partial class DefaultColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public DefaultValueContext defaultValue() {
			return GetRuleContext<DefaultValueContext>(0);
		}
		public DefaultColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDefaultColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDefaultColumnConstraint(this);
		}
	}
	public partial class ReferenceColumnConstraintContext : ColumnConstraintContext {
		public ReferenceDefinitionContext referenceDefinition() {
			return GetRuleContext<ReferenceDefinitionContext>(0);
		}
		public ReferenceColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReferenceColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReferenceColumnConstraint(this);
		}
	}
	public partial class GeneratedColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode GENERATED() { return GetToken(MySqlParser.GENERATED, 0); }
		public ITerminalNode ALWAYS() { return GetToken(MySqlParser.ALWAYS, 0); }
		public ITerminalNode VIRTUAL() { return GetToken(MySqlParser.VIRTUAL, 0); }
		public ITerminalNode STORED() { return GetToken(MySqlParser.STORED, 0); }
		public GeneratedColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGeneratedColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGeneratedColumnConstraint(this);
		}
	}

	[RuleVersion(0)]
	public ColumnConstraintContext columnConstraint() {
		ColumnConstraintContext _localctx = new ColumnConstraintContext(Context, State);
		EnterRule(_localctx, 80, RULE_columnConstraint);
		int _la;
		try {
			State = 1440;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOT:
			case NULL_LITERAL:
			case NULL_SPEC_LITERAL:
				_localctx = new NullColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1400; nullNotnull();
				}
				break;
			case DEFAULT:
				_localctx = new DefaultColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1401; Match(DEFAULT);
				State = 1402; defaultValue();
				}
				break;
			case ON:
			case AUTO_INCREMENT:
				_localctx = new AutoIncrementColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1407;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case AUTO_INCREMENT:
					{
					State = 1403; Match(AUTO_INCREMENT);
					}
					break;
				case ON:
					{
					State = 1404; Match(ON);
					State = 1405; Match(UPDATE);
					State = 1406; currentTimestamp();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case KEY:
			case PRIMARY:
				_localctx = new PrimaryKeyColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1410;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PRIMARY) {
					{
					State = 1409; Match(PRIMARY);
					}
				}

				State = 1412; Match(KEY);
				}
				break;
			case UNIQUE:
				_localctx = new UniqueKeyColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1413; Match(UNIQUE);
				State = 1415;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,131,Context) ) {
				case 1:
					{
					State = 1414; Match(KEY);
					}
					break;
				}
				}
				break;
			case COMMENT:
				_localctx = new CommentColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 1417; Match(COMMENT);
				State = 1418; Match(STRING_LITERAL);
				}
				break;
			case COLUMN_FORMAT:
				_localctx = new FormatColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 1419; Match(COLUMN_FORMAT);
				State = 1420;
				((FormatColumnConstraintContext)_localctx).colformat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==DYNAMIC || _la==FIXED) ) {
					((FormatColumnConstraintContext)_localctx).colformat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case STORAGE:
				_localctx = new StorageColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 1421; Match(STORAGE);
				State = 1422;
				((StorageColumnConstraintContext)_localctx).storageval = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==DISK || _la==MEMORY) ) {
					((StorageColumnConstraintContext)_localctx).storageval = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case REFERENCES:
				_localctx = new ReferenceColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 1423; referenceDefinition();
				}
				break;
			case COLLATE:
				_localctx = new CollateColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 1424; Match(COLLATE);
				State = 1425; collationName();
				}
				break;
			case AS:
			case GENERATED:
				_localctx = new GeneratedColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 1428;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==GENERATED) {
					{
					State = 1426; Match(GENERATED);
					State = 1427; Match(ALWAYS);
					}
				}

				State = 1430; Match(AS);
				State = 1431; Match(LR_BRACKET);
				State = 1432; expression(0);
				State = 1433; Match(RR_BRACKET);
				State = 1435;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==STORED || _la==VIRTUAL) {
					{
					State = 1434;
					_la = TokenStream.LA(1);
					if ( !(_la==STORED || _la==VIRTUAL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case SERIAL:
				_localctx = new SerialDefaultColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 1437; Match(SERIAL);
				State = 1438; Match(DEFAULT);
				State = 1439; Match(VALUE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableConstraintContext : ParserRuleContext {
		public TableConstraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableConstraint; } }
	 
		public TableConstraintContext() { }
		public virtual void CopyFrom(TableConstraintContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class UniqueKeyTableConstraintContext : TableConstraintContext {
		public UidContext name;
		public IToken indexFormat;
		public UidContext index;
		public ITerminalNode UNIQUE() { return GetToken(MySqlParser.UNIQUE, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UniqueKeyTableConstraintContext(TableConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUniqueKeyTableConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUniqueKeyTableConstraint(this);
		}
	}
	public partial class CheckTableConstraintContext : TableConstraintContext {
		public UidContext name;
		public ITerminalNode CHECK() { return GetToken(MySqlParser.CHECK, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public CheckTableConstraintContext(TableConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCheckTableConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCheckTableConstraint(this);
		}
	}
	public partial class PrimaryKeyTableConstraintContext : TableConstraintContext {
		public UidContext name;
		public UidContext index;
		public ITerminalNode PRIMARY() { return GetToken(MySqlParser.PRIMARY, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public PrimaryKeyTableConstraintContext(TableConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPrimaryKeyTableConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPrimaryKeyTableConstraint(this);
		}
	}
	public partial class ForeignKeyTableConstraintContext : TableConstraintContext {
		public UidContext name;
		public UidContext index;
		public ITerminalNode FOREIGN() { return GetToken(MySqlParser.FOREIGN, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ReferenceDefinitionContext referenceDefinition() {
			return GetRuleContext<ReferenceDefinitionContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ForeignKeyTableConstraintContext(TableConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterForeignKeyTableConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitForeignKeyTableConstraint(this);
		}
	}

	[RuleVersion(0)]
	public TableConstraintContext tableConstraint() {
		TableConstraintContext _localctx = new TableConstraintContext(Context, State);
		EnterRule(_localctx, 82, RULE_tableConstraint);
		int _la;
		try {
			State = 1511;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,151,Context) ) {
			case 1:
				_localctx = new PrimaryKeyTableConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1446;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 1442; Match(CONSTRAINT);
					State = 1444;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
						{
						State = 1443; ((PrimaryKeyTableConstraintContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 1448; Match(PRIMARY);
				State = 1449; Match(KEY);
				State = 1451;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
					{
					State = 1450; ((PrimaryKeyTableConstraintContext)_localctx).index = uid();
					}
				}

				State = 1454;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 1453; indexType();
					}
				}

				State = 1456; indexColumnNames();
				State = 1460;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==KEY_BLOCK_SIZE) {
					{
					{
					State = 1457; indexOption();
					}
					}
					State = 1462;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new UniqueKeyTableConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1467;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 1463; Match(CONSTRAINT);
					State = 1465;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
						{
						State = 1464; ((UniqueKeyTableConstraintContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 1469; Match(UNIQUE);
				State = 1471;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDEX || _la==KEY) {
					{
					State = 1470;
					((UniqueKeyTableConstraintContext)_localctx).indexFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==INDEX || _la==KEY) ) {
						((UniqueKeyTableConstraintContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1474;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
					{
					State = 1473; ((UniqueKeyTableConstraintContext)_localctx).index = uid();
					}
				}

				State = 1477;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 1476; indexType();
					}
				}

				State = 1479; indexColumnNames();
				State = 1483;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==KEY_BLOCK_SIZE) {
					{
					{
					State = 1480; indexOption();
					}
					}
					State = 1485;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 3:
				_localctx = new ForeignKeyTableConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1490;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 1486; Match(CONSTRAINT);
					State = 1488;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
						{
						State = 1487; ((ForeignKeyTableConstraintContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 1492; Match(FOREIGN);
				State = 1493; Match(KEY);
				State = 1495;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
					{
					State = 1494; ((ForeignKeyTableConstraintContext)_localctx).index = uid();
					}
				}

				State = 1497; indexColumnNames();
				State = 1498; referenceDefinition();
				}
				break;
			case 4:
				_localctx = new CheckTableConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1504;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 1500; Match(CONSTRAINT);
					State = 1502;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
						{
						State = 1501; ((CheckTableConstraintContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 1506; Match(CHECK);
				State = 1507; Match(LR_BRACKET);
				State = 1508; expression(0);
				State = 1509; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReferenceDefinitionContext : ParserRuleContext {
		public IToken matchType;
		public ITerminalNode REFERENCES() { return GetToken(MySqlParser.REFERENCES, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode MATCH() { return GetToken(MySqlParser.MATCH, 0); }
		public ReferenceActionContext referenceAction() {
			return GetRuleContext<ReferenceActionContext>(0);
		}
		public ITerminalNode FULL() { return GetToken(MySqlParser.FULL, 0); }
		public ITerminalNode PARTIAL() { return GetToken(MySqlParser.PARTIAL, 0); }
		public ITerminalNode SIMPLE() { return GetToken(MySqlParser.SIMPLE, 0); }
		public ReferenceDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referenceDefinition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReferenceDefinition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReferenceDefinition(this);
		}
	}

	[RuleVersion(0)]
	public ReferenceDefinitionContext referenceDefinition() {
		ReferenceDefinitionContext _localctx = new ReferenceDefinitionContext(Context, State);
		EnterRule(_localctx, 84, RULE_referenceDefinition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1513; Match(REFERENCES);
			State = 1514; tableName();
			State = 1516;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,152,Context) ) {
			case 1:
				{
				State = 1515; indexColumnNames();
				}
				break;
			}
			State = 1520;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MATCH) {
				{
				State = 1518; Match(MATCH);
				State = 1519;
				_localctx.matchType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FULL || _la==PARTIAL || _la==SIMPLE) ) {
					_localctx.matchType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 1523;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,154,Context) ) {
			case 1:
				{
				State = 1522; referenceAction();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReferenceActionContext : ParserRuleContext {
		public ReferenceControlTypeContext onDelete;
		public ReferenceControlTypeContext onUpdate;
		public ITerminalNode[] ON() { return GetTokens(MySqlParser.ON); }
		public ITerminalNode ON(int i) {
			return GetToken(MySqlParser.ON, i);
		}
		public ITerminalNode DELETE() { return GetToken(MySqlParser.DELETE, 0); }
		public ReferenceControlTypeContext[] referenceControlType() {
			return GetRuleContexts<ReferenceControlTypeContext>();
		}
		public ReferenceControlTypeContext referenceControlType(int i) {
			return GetRuleContext<ReferenceControlTypeContext>(i);
		}
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public ReferenceActionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referenceAction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReferenceAction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReferenceAction(this);
		}
	}

	[RuleVersion(0)]
	public ReferenceActionContext referenceAction() {
		ReferenceActionContext _localctx = new ReferenceActionContext(Context, State);
		EnterRule(_localctx, 86, RULE_referenceAction);
		try {
			State = 1541;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,157,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1525; Match(ON);
				State = 1526; Match(DELETE);
				State = 1527; _localctx.onDelete = referenceControlType();
				State = 1531;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,155,Context) ) {
				case 1:
					{
					State = 1528; Match(ON);
					State = 1529; Match(UPDATE);
					State = 1530; _localctx.onUpdate = referenceControlType();
					}
					break;
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1533; Match(ON);
				State = 1534; Match(UPDATE);
				State = 1535; _localctx.onUpdate = referenceControlType();
				State = 1539;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,156,Context) ) {
				case 1:
					{
					State = 1536; Match(ON);
					State = 1537; Match(DELETE);
					State = 1538; _localctx.onDelete = referenceControlType();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReferenceControlTypeContext : ParserRuleContext {
		public ITerminalNode RESTRICT() { return GetToken(MySqlParser.RESTRICT, 0); }
		public ITerminalNode CASCADE() { return GetToken(MySqlParser.CASCADE, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode NULL_LITERAL() { return GetToken(MySqlParser.NULL_LITERAL, 0); }
		public ITerminalNode NO() { return GetToken(MySqlParser.NO, 0); }
		public ITerminalNode ACTION() { return GetToken(MySqlParser.ACTION, 0); }
		public ReferenceControlTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referenceControlType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReferenceControlType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReferenceControlType(this);
		}
	}

	[RuleVersion(0)]
	public ReferenceControlTypeContext referenceControlType() {
		ReferenceControlTypeContext _localctx = new ReferenceControlTypeContext(Context, State);
		EnterRule(_localctx, 88, RULE_referenceControlType);
		try {
			State = 1549;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case RESTRICT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1543; Match(RESTRICT);
				}
				break;
			case CASCADE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1544; Match(CASCADE);
				}
				break;
			case SET:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1545; Match(SET);
				State = 1546; Match(NULL_LITERAL);
				}
				break;
			case NO:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1547; Match(NO);
				State = 1548; Match(ACTION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexColumnDefinitionContext : ParserRuleContext {
		public IndexColumnDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexColumnDefinition; } }
	 
		public IndexColumnDefinitionContext() { }
		public virtual void CopyFrom(IndexColumnDefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SpecialIndexDeclarationContext : IndexColumnDefinitionContext {
		public IToken indexFormat;
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode FULLTEXT() { return GetToken(MySqlParser.FULLTEXT, 0); }
		public ITerminalNode SPATIAL() { return GetToken(MySqlParser.SPATIAL, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public SpecialIndexDeclarationContext(IndexColumnDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSpecialIndexDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSpecialIndexDeclaration(this);
		}
	}
	public partial class SimpleIndexDeclarationContext : IndexColumnDefinitionContext {
		public IToken indexFormat;
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public SimpleIndexDeclarationContext(IndexColumnDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleIndexDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleIndexDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public IndexColumnDefinitionContext indexColumnDefinition() {
		IndexColumnDefinitionContext _localctx = new IndexColumnDefinitionContext(Context, State);
		EnterRule(_localctx, 90, RULE_indexColumnDefinition);
		int _la;
		try {
			State = 1579;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INDEX:
			case KEY:
				_localctx = new SimpleIndexDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1551;
				((SimpleIndexDeclarationContext)_localctx).indexFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==INDEX || _la==KEY) ) {
					((SimpleIndexDeclarationContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1553;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
					{
					State = 1552; uid();
					}
				}

				State = 1556;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 1555; indexType();
					}
				}

				State = 1558; indexColumnNames();
				State = 1562;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==KEY_BLOCK_SIZE) {
					{
					{
					State = 1559; indexOption();
					}
					}
					State = 1564;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case FULLTEXT:
			case SPATIAL:
				_localctx = new SpecialIndexDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1565;
				_la = TokenStream.LA(1);
				if ( !(_la==FULLTEXT || _la==SPATIAL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1567;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDEX || _la==KEY) {
					{
					State = 1566;
					((SpecialIndexDeclarationContext)_localctx).indexFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==INDEX || _la==KEY) ) {
						((SpecialIndexDeclarationContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1570;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
					{
					State = 1569; uid();
					}
				}

				State = 1572; indexColumnNames();
				State = 1576;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==KEY_BLOCK_SIZE) {
					{
					{
					State = 1573; indexOption();
					}
					}
					State = 1578;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableOptionContext : ParserRuleContext {
		public TableOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableOption; } }
	 
		public TableOptionContext() { }
		public virtual void CopyFrom(TableOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TableOptionEngineContext : TableOptionContext {
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public TableOptionEngineContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionEngine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionEngine(this);
		}
	}
	public partial class TableOptionMaxRowsContext : TableOptionContext {
		public ITerminalNode MAX_ROWS() { return GetToken(MySqlParser.MAX_ROWS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public TableOptionMaxRowsContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionMaxRows(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionMaxRows(this);
		}
	}
	public partial class TableOptionCollateContext : TableOptionContext {
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public TableOptionCollateContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionCollate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionCollate(this);
		}
	}
	public partial class TableOptionPersistentContext : TableOptionContext {
		public IToken extBoolValue;
		public ITerminalNode STATS_PERSISTENT() { return GetToken(MySqlParser.STATS_PERSISTENT, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public TableOptionPersistentContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionPersistent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionPersistent(this);
		}
	}
	public partial class TableOptionTablespaceContext : TableOptionContext {
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public TablespaceStorageContext tablespaceStorage() {
			return GetRuleContext<TablespaceStorageContext>(0);
		}
		public TableOptionTablespaceContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionTablespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionTablespace(this);
		}
	}
	public partial class TableOptionPackKeysContext : TableOptionContext {
		public IToken extBoolValue;
		public ITerminalNode PACK_KEYS() { return GetToken(MySqlParser.PACK_KEYS, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public TableOptionPackKeysContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionPackKeys(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionPackKeys(this);
		}
	}
	public partial class TableOptionPasswordContext : TableOptionContext {
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public TableOptionPasswordContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionPassword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionPassword(this);
		}
	}
	public partial class TableOptionUnionContext : TableOptionContext {
		public ITerminalNode UNION() { return GetToken(MySqlParser.UNION, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public TableOptionUnionContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionUnion(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionUnion(this);
		}
	}
	public partial class TableOptionSamplePageContext : TableOptionContext {
		public ITerminalNode STATS_SAMPLE_PAGES() { return GetToken(MySqlParser.STATS_SAMPLE_PAGES, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public TableOptionSamplePageContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionSamplePage(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionSamplePage(this);
		}
	}
	public partial class TableOptionCharsetContext : TableOptionContext {
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public TableOptionCharsetContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionCharset(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionCharset(this);
		}
	}
	public partial class TableOptionIndexDirectoryContext : TableOptionContext {
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(MySqlParser.DIRECTORY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public TableOptionIndexDirectoryContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionIndexDirectory(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionIndexDirectory(this);
		}
	}
	public partial class TableOptionKeyBlockSizeContext : TableOptionContext {
		public ITerminalNode KEY_BLOCK_SIZE() { return GetToken(MySqlParser.KEY_BLOCK_SIZE, 0); }
		public FileSizeLiteralContext fileSizeLiteral() {
			return GetRuleContext<FileSizeLiteralContext>(0);
		}
		public TableOptionKeyBlockSizeContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionKeyBlockSize(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionKeyBlockSize(this);
		}
	}
	public partial class TableOptionEncryptionContext : TableOptionContext {
		public ITerminalNode ENCRYPTION() { return GetToken(MySqlParser.ENCRYPTION, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public TableOptionEncryptionContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionEncryption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionEncryption(this);
		}
	}
	public partial class TableOptionDataDirectoryContext : TableOptionContext {
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(MySqlParser.DIRECTORY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public TableOptionDataDirectoryContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionDataDirectory(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionDataDirectory(this);
		}
	}
	public partial class TableOptionRecalculationContext : TableOptionContext {
		public IToken extBoolValue;
		public ITerminalNode STATS_AUTO_RECALC() { return GetToken(MySqlParser.STATS_AUTO_RECALC, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public TableOptionRecalculationContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionRecalculation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionRecalculation(this);
		}
	}
	public partial class TableOptionAutoIncrementContext : TableOptionContext {
		public ITerminalNode AUTO_INCREMENT() { return GetToken(MySqlParser.AUTO_INCREMENT, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public TableOptionAutoIncrementContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionAutoIncrement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionAutoIncrement(this);
		}
	}
	public partial class TableOptionChecksumContext : TableOptionContext {
		public IToken boolValue;
		public ITerminalNode CHECKSUM() { return GetToken(MySqlParser.CHECKSUM, 0); }
		public ITerminalNode PAGE_CHECKSUM() { return GetToken(MySqlParser.PAGE_CHECKSUM, 0); }
		public TableOptionChecksumContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionChecksum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionChecksum(this);
		}
	}
	public partial class TableOptionDelayContext : TableOptionContext {
		public IToken boolValue;
		public ITerminalNode DELAY_KEY_WRITE() { return GetToken(MySqlParser.DELAY_KEY_WRITE, 0); }
		public TableOptionDelayContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionDelay(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionDelay(this);
		}
	}
	public partial class TableOptionConnectionContext : TableOptionContext {
		public ITerminalNode CONNECTION() { return GetToken(MySqlParser.CONNECTION, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public TableOptionConnectionContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionConnection(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionConnection(this);
		}
	}
	public partial class TableOptionCommentContext : TableOptionContext {
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public TableOptionCommentContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionComment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionComment(this);
		}
	}
	public partial class TableOptionAverageContext : TableOptionContext {
		public ITerminalNode AVG_ROW_LENGTH() { return GetToken(MySqlParser.AVG_ROW_LENGTH, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public TableOptionAverageContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionAverage(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionAverage(this);
		}
	}
	public partial class TableOptionRowFormatContext : TableOptionContext {
		public IToken rowFormat;
		public ITerminalNode ROW_FORMAT() { return GetToken(MySqlParser.ROW_FORMAT, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode DYNAMIC() { return GetToken(MySqlParser.DYNAMIC, 0); }
		public ITerminalNode FIXED() { return GetToken(MySqlParser.FIXED, 0); }
		public ITerminalNode COMPRESSED() { return GetToken(MySqlParser.COMPRESSED, 0); }
		public ITerminalNode REDUNDANT() { return GetToken(MySqlParser.REDUNDANT, 0); }
		public ITerminalNode COMPACT() { return GetToken(MySqlParser.COMPACT, 0); }
		public TableOptionRowFormatContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionRowFormat(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionRowFormat(this);
		}
	}
	public partial class TableOptionCompressionContext : TableOptionContext {
		public ITerminalNode COMPRESSION() { return GetToken(MySqlParser.COMPRESSION, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode ID() { return GetToken(MySqlParser.ID, 0); }
		public TableOptionCompressionContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionCompression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionCompression(this);
		}
	}
	public partial class TableOptionInsertMethodContext : TableOptionContext {
		public IToken insertMethod;
		public ITerminalNode INSERT_METHOD() { return GetToken(MySqlParser.INSERT_METHOD, 0); }
		public ITerminalNode NO() { return GetToken(MySqlParser.NO, 0); }
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(MySqlParser.LAST, 0); }
		public TableOptionInsertMethodContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionInsertMethod(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionInsertMethod(this);
		}
	}
	public partial class TableOptionMinRowsContext : TableOptionContext {
		public ITerminalNode MIN_ROWS() { return GetToken(MySqlParser.MIN_ROWS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public TableOptionMinRowsContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionMinRows(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionMinRows(this);
		}
	}

	[RuleVersion(0)]
	public TableOptionContext tableOption() {
		TableOptionContext _localctx = new TableOptionContext(Context, State);
		EnterRule(_localctx, 92, RULE_tableOption);
		int _la;
		try {
			State = 1722;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,194,Context) ) {
			case 1:
				_localctx = new TableOptionEngineContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1581; Match(ENGINE);
				State = 1583;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1582; Match(EQUAL_SYMBOL);
					}
				}

				State = 1585; engineName();
				}
				break;
			case 2:
				_localctx = new TableOptionAutoIncrementContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1586; Match(AUTO_INCREMENT);
				State = 1588;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1587; Match(EQUAL_SYMBOL);
					}
				}

				State = 1590; decimalLiteral();
				}
				break;
			case 3:
				_localctx = new TableOptionAverageContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1591; Match(AVG_ROW_LENGTH);
				State = 1593;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1592; Match(EQUAL_SYMBOL);
					}
				}

				State = 1595; decimalLiteral();
				}
				break;
			case 4:
				_localctx = new TableOptionCharsetContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1597;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 1596; Match(DEFAULT);
					}
				}

				State = 1602;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case CHARACTER:
					{
					State = 1599; Match(CHARACTER);
					State = 1600; Match(SET);
					}
					break;
				case CHARSET:
					{
					State = 1601; Match(CHARSET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1605;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1604; Match(EQUAL_SYMBOL);
					}
				}

				State = 1607; charsetName();
				}
				break;
			case 5:
				_localctx = new TableOptionChecksumContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1608;
				_la = TokenStream.LA(1);
				if ( !(_la==CHECKSUM || _la==PAGE_CHECKSUM) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1610;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1609; Match(EQUAL_SYMBOL);
					}
				}

				State = 1612;
				((TableOptionChecksumContext)_localctx).boolValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
					((TableOptionChecksumContext)_localctx).boolValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 6:
				_localctx = new TableOptionCollateContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 1614;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 1613; Match(DEFAULT);
					}
				}

				State = 1616; Match(COLLATE);
				State = 1618;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1617; Match(EQUAL_SYMBOL);
					}
				}

				State = 1620; collationName();
				}
				break;
			case 7:
				_localctx = new TableOptionCommentContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 1621; Match(COMMENT);
				State = 1623;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1622; Match(EQUAL_SYMBOL);
					}
				}

				State = 1625; Match(STRING_LITERAL);
				}
				break;
			case 8:
				_localctx = new TableOptionCompressionContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 1626; Match(COMPRESSION);
				State = 1628;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1627; Match(EQUAL_SYMBOL);
					}
				}

				State = 1630;
				_la = TokenStream.LA(1);
				if ( !(_la==STRING_LITERAL || _la==ID) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 9:
				_localctx = new TableOptionConnectionContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 1631; Match(CONNECTION);
				State = 1633;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1632; Match(EQUAL_SYMBOL);
					}
				}

				State = 1635; Match(STRING_LITERAL);
				}
				break;
			case 10:
				_localctx = new TableOptionDataDirectoryContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 1636; Match(DATA);
				State = 1637; Match(DIRECTORY);
				State = 1639;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1638; Match(EQUAL_SYMBOL);
					}
				}

				State = 1641; Match(STRING_LITERAL);
				}
				break;
			case 11:
				_localctx = new TableOptionDelayContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 1642; Match(DELAY_KEY_WRITE);
				State = 1644;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1643; Match(EQUAL_SYMBOL);
					}
				}

				State = 1646;
				((TableOptionDelayContext)_localctx).boolValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
					((TableOptionDelayContext)_localctx).boolValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 12:
				_localctx = new TableOptionEncryptionContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 1647; Match(ENCRYPTION);
				State = 1649;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1648; Match(EQUAL_SYMBOL);
					}
				}

				State = 1651; Match(STRING_LITERAL);
				}
				break;
			case 13:
				_localctx = new TableOptionIndexDirectoryContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 1652; Match(INDEX);
				State = 1653; Match(DIRECTORY);
				State = 1655;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1654; Match(EQUAL_SYMBOL);
					}
				}

				State = 1657; Match(STRING_LITERAL);
				}
				break;
			case 14:
				_localctx = new TableOptionInsertMethodContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 1658; Match(INSERT_METHOD);
				State = 1660;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1659; Match(EQUAL_SYMBOL);
					}
				}

				State = 1662;
				((TableOptionInsertMethodContext)_localctx).insertMethod = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FIRST || _la==LAST || _la==NO) ) {
					((TableOptionInsertMethodContext)_localctx).insertMethod = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 15:
				_localctx = new TableOptionKeyBlockSizeContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 1663; Match(KEY_BLOCK_SIZE);
				State = 1665;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1664; Match(EQUAL_SYMBOL);
					}
				}

				State = 1667; fileSizeLiteral();
				}
				break;
			case 16:
				_localctx = new TableOptionMaxRowsContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 1668; Match(MAX_ROWS);
				State = 1670;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1669; Match(EQUAL_SYMBOL);
					}
				}

				State = 1672; decimalLiteral();
				}
				break;
			case 17:
				_localctx = new TableOptionMinRowsContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 1673; Match(MIN_ROWS);
				State = 1675;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1674; Match(EQUAL_SYMBOL);
					}
				}

				State = 1677; decimalLiteral();
				}
				break;
			case 18:
				_localctx = new TableOptionPackKeysContext(_localctx);
				EnterOuterAlt(_localctx, 18);
				{
				State = 1678; Match(PACK_KEYS);
				State = 1680;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1679; Match(EQUAL_SYMBOL);
					}
				}

				State = 1682;
				((TableOptionPackKeysContext)_localctx).extBoolValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
					((TableOptionPackKeysContext)_localctx).extBoolValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 19:
				_localctx = new TableOptionPasswordContext(_localctx);
				EnterOuterAlt(_localctx, 19);
				{
				State = 1683; Match(PASSWORD);
				State = 1685;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1684; Match(EQUAL_SYMBOL);
					}
				}

				State = 1687; Match(STRING_LITERAL);
				}
				break;
			case 20:
				_localctx = new TableOptionRowFormatContext(_localctx);
				EnterOuterAlt(_localctx, 20);
				{
				State = 1688; Match(ROW_FORMAT);
				State = 1690;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1689; Match(EQUAL_SYMBOL);
					}
				}

				State = 1692;
				((TableOptionRowFormatContext)_localctx).rowFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || ((((_la - 287)) & ~0x3f) == 0 && ((1L << (_la - 287)) & ((1L << (COMPACT - 287)) | (1L << (COMPRESSED - 287)) | (1L << (DYNAMIC - 287)) | (1L << (FIXED - 287)))) != 0) || _la==REDUNDANT) ) {
					((TableOptionRowFormatContext)_localctx).rowFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 21:
				_localctx = new TableOptionRecalculationContext(_localctx);
				EnterOuterAlt(_localctx, 21);
				{
				State = 1693; Match(STATS_AUTO_RECALC);
				State = 1695;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1694; Match(EQUAL_SYMBOL);
					}
				}

				State = 1697;
				((TableOptionRecalculationContext)_localctx).extBoolValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
					((TableOptionRecalculationContext)_localctx).extBoolValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 22:
				_localctx = new TableOptionPersistentContext(_localctx);
				EnterOuterAlt(_localctx, 22);
				{
				State = 1698; Match(STATS_PERSISTENT);
				State = 1700;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1699; Match(EQUAL_SYMBOL);
					}
				}

				State = 1702;
				((TableOptionPersistentContext)_localctx).extBoolValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
					((TableOptionPersistentContext)_localctx).extBoolValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 23:
				_localctx = new TableOptionSamplePageContext(_localctx);
				EnterOuterAlt(_localctx, 23);
				{
				State = 1703; Match(STATS_SAMPLE_PAGES);
				State = 1705;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1704; Match(EQUAL_SYMBOL);
					}
				}

				State = 1707; decimalLiteral();
				}
				break;
			case 24:
				_localctx = new TableOptionTablespaceContext(_localctx);
				EnterOuterAlt(_localctx, 24);
				{
				State = 1708; Match(TABLESPACE);
				State = 1709; uid();
				State = 1711;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,192,Context) ) {
				case 1:
					{
					State = 1710; tablespaceStorage();
					}
					break;
				}
				}
				break;
			case 25:
				_localctx = new TableOptionTablespaceContext(_localctx);
				EnterOuterAlt(_localctx, 25);
				{
				State = 1713; tablespaceStorage();
				}
				break;
			case 26:
				_localctx = new TableOptionUnionContext(_localctx);
				EnterOuterAlt(_localctx, 26);
				{
				State = 1714; Match(UNION);
				State = 1716;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1715; Match(EQUAL_SYMBOL);
					}
				}

				State = 1718; Match(LR_BRACKET);
				State = 1719; tables();
				State = 1720; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablespaceStorageContext : ParserRuleContext {
		public ITerminalNode STORAGE() { return GetToken(MySqlParser.STORAGE, 0); }
		public ITerminalNode DISK() { return GetToken(MySqlParser.DISK, 0); }
		public ITerminalNode MEMORY() { return GetToken(MySqlParser.MEMORY, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public TablespaceStorageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablespaceStorage; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTablespaceStorage(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTablespaceStorage(this);
		}
	}

	[RuleVersion(0)]
	public TablespaceStorageContext tablespaceStorage() {
		TablespaceStorageContext _localctx = new TablespaceStorageContext(Context, State);
		EnterRule(_localctx, 94, RULE_tablespaceStorage);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1724; Match(STORAGE);
			State = 1725;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==DISK || _la==MEMORY) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionDefinitionsContext : ParserRuleContext {
		public DecimalLiteralContext count;
		public DecimalLiteralContext subCount;
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public ITerminalNode[] BY() { return GetTokens(MySqlParser.BY); }
		public ITerminalNode BY(int i) {
			return GetToken(MySqlParser.BY, i);
		}
		public PartitionFunctionDefinitionContext partitionFunctionDefinition() {
			return GetRuleContext<PartitionFunctionDefinitionContext>(0);
		}
		public ITerminalNode PARTITIONS() { return GetToken(MySqlParser.PARTITIONS, 0); }
		public ITerminalNode SUBPARTITION() { return GetToken(MySqlParser.SUBPARTITION, 0); }
		public SubpartitionFunctionDefinitionContext subpartitionFunctionDefinition() {
			return GetRuleContext<SubpartitionFunctionDefinitionContext>(0);
		}
		public PartitionDefinitionContext[] partitionDefinition() {
			return GetRuleContexts<PartitionDefinitionContext>();
		}
		public PartitionDefinitionContext partitionDefinition(int i) {
			return GetRuleContext<PartitionDefinitionContext>(i);
		}
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public ITerminalNode SUBPARTITIONS() { return GetToken(MySqlParser.SUBPARTITIONS, 0); }
		public PartitionDefinitionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionDefinitions; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionDefinitions(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionDefinitions(this);
		}
	}

	[RuleVersion(0)]
	public PartitionDefinitionsContext partitionDefinitions() {
		PartitionDefinitionsContext _localctx = new PartitionDefinitionsContext(Context, State);
		EnterRule(_localctx, 96, RULE_partitionDefinitions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1727; Match(PARTITION);
			State = 1728; Match(BY);
			State = 1729; partitionFunctionDefinition();
			State = 1732;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITIONS) {
				{
				State = 1730; Match(PARTITIONS);
				State = 1731; _localctx.count = decimalLiteral();
				}
			}

			State = 1741;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SUBPARTITION) {
				{
				State = 1734; Match(SUBPARTITION);
				State = 1735; Match(BY);
				State = 1736; subpartitionFunctionDefinition();
				State = 1739;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SUBPARTITIONS) {
					{
					State = 1737; Match(SUBPARTITIONS);
					State = 1738; _localctx.subCount = decimalLiteral();
					}
				}

				}
			}

			State = 1754;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,199,Context) ) {
			case 1:
				{
				State = 1743; Match(LR_BRACKET);
				State = 1744; partitionDefinition();
				State = 1749;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1745; Match(COMMA);
					State = 1746; partitionDefinition();
					}
					}
					State = 1751;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1752; Match(RR_BRACKET);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionFunctionDefinitionContext : ParserRuleContext {
		public PartitionFunctionDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionFunctionDefinition; } }
	 
		public PartitionFunctionDefinitionContext() { }
		public virtual void CopyFrom(PartitionFunctionDefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PartitionFunctionKeyContext : PartitionFunctionDefinitionContext {
		public IToken algType;
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode LINEAR() { return GetToken(MySqlParser.LINEAR, 0); }
		public ITerminalNode ALGORITHM() { return GetToken(MySqlParser.ALGORITHM, 0); }
		public PartitionFunctionKeyContext(PartitionFunctionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionFunctionKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionFunctionKey(this);
		}
	}
	public partial class PartitionFunctionHashContext : PartitionFunctionDefinitionContext {
		public ITerminalNode HASH() { return GetToken(MySqlParser.HASH, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LINEAR() { return GetToken(MySqlParser.LINEAR, 0); }
		public PartitionFunctionHashContext(PartitionFunctionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionFunctionHash(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionFunctionHash(this);
		}
	}
	public partial class PartitionFunctionListContext : PartitionFunctionDefinitionContext {
		public ITerminalNode LIST() { return GetToken(MySqlParser.LIST, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode COLUMNS() { return GetToken(MySqlParser.COLUMNS, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public PartitionFunctionListContext(PartitionFunctionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionFunctionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionFunctionList(this);
		}
	}
	public partial class PartitionFunctionRangeContext : PartitionFunctionDefinitionContext {
		public ITerminalNode RANGE() { return GetToken(MySqlParser.RANGE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode COLUMNS() { return GetToken(MySqlParser.COLUMNS, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public PartitionFunctionRangeContext(PartitionFunctionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionFunctionRange(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionFunctionRange(this);
		}
	}

	[RuleVersion(0)]
	public PartitionFunctionDefinitionContext partitionFunctionDefinition() {
		PartitionFunctionDefinitionContext _localctx = new PartitionFunctionDefinitionContext(Context, State);
		EnterRule(_localctx, 98, RULE_partitionFunctionDefinition);
		int _la;
		try {
			State = 1801;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,205,Context) ) {
			case 1:
				_localctx = new PartitionFunctionHashContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1757;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LINEAR) {
					{
					State = 1756; Match(LINEAR);
					}
				}

				State = 1759; Match(HASH);
				State = 1760; Match(LR_BRACKET);
				State = 1761; expression(0);
				State = 1762; Match(RR_BRACKET);
				}
				break;
			case 2:
				_localctx = new PartitionFunctionKeyContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1765;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LINEAR) {
					{
					State = 1764; Match(LINEAR);
					}
				}

				State = 1767; Match(KEY);
				State = 1771;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALGORITHM) {
					{
					State = 1768; Match(ALGORITHM);
					State = 1769; Match(EQUAL_SYMBOL);
					State = 1770;
					((PartitionFunctionKeyContext)_localctx).algType = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==ONE_DECIMAL || _la==TWO_DECIMAL) ) {
						((PartitionFunctionKeyContext)_localctx).algType = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1773; Match(LR_BRACKET);
				State = 1774; uidList();
				State = 1775; Match(RR_BRACKET);
				}
				break;
			case 3:
				_localctx = new PartitionFunctionRangeContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1777; Match(RANGE);
				State = 1787;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case LR_BRACKET:
					{
					State = 1778; Match(LR_BRACKET);
					State = 1779; expression(0);
					State = 1780; Match(RR_BRACKET);
					}
					break;
				case COLUMNS:
					{
					State = 1782; Match(COLUMNS);
					State = 1783; Match(LR_BRACKET);
					State = 1784; uidList();
					State = 1785; Match(RR_BRACKET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 4:
				_localctx = new PartitionFunctionListContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1789; Match(LIST);
				State = 1799;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case LR_BRACKET:
					{
					State = 1790; Match(LR_BRACKET);
					State = 1791; expression(0);
					State = 1792; Match(RR_BRACKET);
					}
					break;
				case COLUMNS:
					{
					State = 1794; Match(COLUMNS);
					State = 1795; Match(LR_BRACKET);
					State = 1796; uidList();
					State = 1797; Match(RR_BRACKET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubpartitionFunctionDefinitionContext : ParserRuleContext {
		public SubpartitionFunctionDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartitionFunctionDefinition; } }
	 
		public SubpartitionFunctionDefinitionContext() { }
		public virtual void CopyFrom(SubpartitionFunctionDefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SubPartitionFunctionHashContext : SubpartitionFunctionDefinitionContext {
		public ITerminalNode HASH() { return GetToken(MySqlParser.HASH, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LINEAR() { return GetToken(MySqlParser.LINEAR, 0); }
		public SubPartitionFunctionHashContext(SubpartitionFunctionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubPartitionFunctionHash(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubPartitionFunctionHash(this);
		}
	}
	public partial class SubPartitionFunctionKeyContext : SubpartitionFunctionDefinitionContext {
		public IToken algType;
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode LINEAR() { return GetToken(MySqlParser.LINEAR, 0); }
		public ITerminalNode ALGORITHM() { return GetToken(MySqlParser.ALGORITHM, 0); }
		public SubPartitionFunctionKeyContext(SubpartitionFunctionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubPartitionFunctionKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubPartitionFunctionKey(this);
		}
	}

	[RuleVersion(0)]
	public SubpartitionFunctionDefinitionContext subpartitionFunctionDefinition() {
		SubpartitionFunctionDefinitionContext _localctx = new SubpartitionFunctionDefinitionContext(Context, State);
		EnterRule(_localctx, 100, RULE_subpartitionFunctionDefinition);
		int _la;
		try {
			State = 1824;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,209,Context) ) {
			case 1:
				_localctx = new SubPartitionFunctionHashContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1804;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LINEAR) {
					{
					State = 1803; Match(LINEAR);
					}
				}

				State = 1806; Match(HASH);
				State = 1807; Match(LR_BRACKET);
				State = 1808; expression(0);
				State = 1809; Match(RR_BRACKET);
				}
				break;
			case 2:
				_localctx = new SubPartitionFunctionKeyContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1812;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LINEAR) {
					{
					State = 1811; Match(LINEAR);
					}
				}

				State = 1814; Match(KEY);
				State = 1818;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALGORITHM) {
					{
					State = 1815; Match(ALGORITHM);
					State = 1816; Match(EQUAL_SYMBOL);
					State = 1817;
					((SubPartitionFunctionKeyContext)_localctx).algType = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==ONE_DECIMAL || _la==TWO_DECIMAL) ) {
						((SubPartitionFunctionKeyContext)_localctx).algType = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1820; Match(LR_BRACKET);
				State = 1821; uidList();
				State = 1822; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionDefinitionContext : ParserRuleContext {
		public PartitionDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionDefinition; } }
	 
		public PartitionDefinitionContext() { }
		public virtual void CopyFrom(PartitionDefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PartitionComparisionContext : PartitionDefinitionContext {
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode VALUES() { return GetToken(MySqlParser.VALUES, 0); }
		public ITerminalNode LESS() { return GetToken(MySqlParser.LESS, 0); }
		public ITerminalNode THAN() { return GetToken(MySqlParser.THAN, 0); }
		public PartitionDefinerAtomContext[] partitionDefinerAtom() {
			return GetRuleContexts<PartitionDefinerAtomContext>();
		}
		public PartitionDefinerAtomContext partitionDefinerAtom(int i) {
			return GetRuleContext<PartitionDefinerAtomContext>(i);
		}
		public PartitionOptionContext[] partitionOption() {
			return GetRuleContexts<PartitionOptionContext>();
		}
		public PartitionOptionContext partitionOption(int i) {
			return GetRuleContext<PartitionOptionContext>(i);
		}
		public SubpartitionDefinitionContext[] subpartitionDefinition() {
			return GetRuleContexts<SubpartitionDefinitionContext>();
		}
		public SubpartitionDefinitionContext subpartitionDefinition(int i) {
			return GetRuleContext<SubpartitionDefinitionContext>(i);
		}
		public PartitionComparisionContext(PartitionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionComparision(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionComparision(this);
		}
	}
	public partial class PartitionListAtomContext : PartitionDefinitionContext {
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode VALUES() { return GetToken(MySqlParser.VALUES, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public PartitionDefinerAtomContext[] partitionDefinerAtom() {
			return GetRuleContexts<PartitionDefinerAtomContext>();
		}
		public PartitionDefinerAtomContext partitionDefinerAtom(int i) {
			return GetRuleContext<PartitionDefinerAtomContext>(i);
		}
		public PartitionOptionContext[] partitionOption() {
			return GetRuleContexts<PartitionOptionContext>();
		}
		public PartitionOptionContext partitionOption(int i) {
			return GetRuleContext<PartitionOptionContext>(i);
		}
		public SubpartitionDefinitionContext[] subpartitionDefinition() {
			return GetRuleContexts<SubpartitionDefinitionContext>();
		}
		public SubpartitionDefinitionContext subpartitionDefinition(int i) {
			return GetRuleContext<SubpartitionDefinitionContext>(i);
		}
		public PartitionListAtomContext(PartitionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionListAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionListAtom(this);
		}
	}
	public partial class PartitionListVectorContext : PartitionDefinitionContext {
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode VALUES() { return GetToken(MySqlParser.VALUES, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public PartitionDefinerVectorContext[] partitionDefinerVector() {
			return GetRuleContexts<PartitionDefinerVectorContext>();
		}
		public PartitionDefinerVectorContext partitionDefinerVector(int i) {
			return GetRuleContext<PartitionDefinerVectorContext>(i);
		}
		public PartitionOptionContext[] partitionOption() {
			return GetRuleContexts<PartitionOptionContext>();
		}
		public PartitionOptionContext partitionOption(int i) {
			return GetRuleContext<PartitionOptionContext>(i);
		}
		public SubpartitionDefinitionContext[] subpartitionDefinition() {
			return GetRuleContexts<SubpartitionDefinitionContext>();
		}
		public SubpartitionDefinitionContext subpartitionDefinition(int i) {
			return GetRuleContext<SubpartitionDefinitionContext>(i);
		}
		public PartitionListVectorContext(PartitionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionListVector(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionListVector(this);
		}
	}
	public partial class PartitionSimpleContext : PartitionDefinitionContext {
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public PartitionOptionContext[] partitionOption() {
			return GetRuleContexts<PartitionOptionContext>();
		}
		public PartitionOptionContext partitionOption(int i) {
			return GetRuleContext<PartitionOptionContext>(i);
		}
		public SubpartitionDefinitionContext[] subpartitionDefinition() {
			return GetRuleContexts<SubpartitionDefinitionContext>();
		}
		public SubpartitionDefinitionContext subpartitionDefinition(int i) {
			return GetRuleContext<SubpartitionDefinitionContext>(i);
		}
		public PartitionSimpleContext(PartitionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionSimple(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionSimple(this);
		}
	}

	[RuleVersion(0)]
	public PartitionDefinitionContext partitionDefinition() {
		PartitionDefinitionContext _localctx = new PartitionDefinitionContext(Context, State);
		EnterRule(_localctx, 102, RULE_partitionDefinition);
		int _la;
		try {
			int _alt;
			State = 1957;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,228,Context) ) {
			case 1:
				_localctx = new PartitionComparisionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1826; Match(PARTITION);
				State = 1827; uid();
				State = 1828; Match(VALUES);
				State = 1829; Match(LESS);
				State = 1830; Match(THAN);
				State = 1831; Match(LR_BRACKET);
				State = 1832; partitionDefinerAtom();
				State = 1837;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1833; Match(COMMA);
					State = 1834; partitionDefinerAtom();
					}
					}
					State = 1839;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1840; Match(RR_BRACKET);
				State = 1844;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==INDEX || ((((_la - 285)) & ~0x3f) == 0 && ((1L << (_la - 285)) & ((1L << (COMMENT - 285)) | (1L << (DATA - 285)) | (1L << (ENGINE - 285)))) != 0) || ((((_la - 403)) & ~0x3f) == 0 && ((1L << (_la - 403)) & ((1L << (MAX_ROWS - 403)) | (1L << (MIN_ROWS - 403)) | (1L << (NODEGROUP - 403)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
					{
					{
					State = 1841; partitionOption();
					}
					}
					State = 1846;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1855;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SUBPARTITION) {
					{
					State = 1847; subpartitionDefinition();
					State = 1852;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,212,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 1848; Match(COMMA);
							State = 1849; subpartitionDefinition();
							}
							} 
						}
						State = 1854;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,212,Context);
					}
					}
				}

				}
				break;
			case 2:
				_localctx = new PartitionComparisionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1857; Match(PARTITION);
				State = 1858; uid();
				State = 1859; Match(VALUES);
				State = 1860; Match(LESS);
				State = 1861; Match(THAN);
				State = 1862; partitionDefinerAtom();
				State = 1866;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==INDEX || ((((_la - 285)) & ~0x3f) == 0 && ((1L << (_la - 285)) & ((1L << (COMMENT - 285)) | (1L << (DATA - 285)) | (1L << (ENGINE - 285)))) != 0) || ((((_la - 403)) & ~0x3f) == 0 && ((1L << (_la - 403)) & ((1L << (MAX_ROWS - 403)) | (1L << (MIN_ROWS - 403)) | (1L << (NODEGROUP - 403)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
					{
					{
					State = 1863; partitionOption();
					}
					}
					State = 1868;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1877;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SUBPARTITION) {
					{
					State = 1869; subpartitionDefinition();
					State = 1874;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,215,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 1870; Match(COMMA);
							State = 1871; subpartitionDefinition();
							}
							} 
						}
						State = 1876;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,215,Context);
					}
					}
				}

				}
				break;
			case 3:
				_localctx = new PartitionListAtomContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1879; Match(PARTITION);
				State = 1880; uid();
				State = 1881; Match(VALUES);
				State = 1882; Match(IN);
				State = 1883; Match(LR_BRACKET);
				State = 1884; partitionDefinerAtom();
				State = 1889;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1885; Match(COMMA);
					State = 1886; partitionDefinerAtom();
					}
					}
					State = 1891;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1892; Match(RR_BRACKET);
				State = 1896;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==INDEX || ((((_la - 285)) & ~0x3f) == 0 && ((1L << (_la - 285)) & ((1L << (COMMENT - 285)) | (1L << (DATA - 285)) | (1L << (ENGINE - 285)))) != 0) || ((((_la - 403)) & ~0x3f) == 0 && ((1L << (_la - 403)) & ((1L << (MAX_ROWS - 403)) | (1L << (MIN_ROWS - 403)) | (1L << (NODEGROUP - 403)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
					{
					{
					State = 1893; partitionOption();
					}
					}
					State = 1898;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1907;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SUBPARTITION) {
					{
					State = 1899; subpartitionDefinition();
					State = 1904;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,219,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 1900; Match(COMMA);
							State = 1901; subpartitionDefinition();
							}
							} 
						}
						State = 1906;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,219,Context);
					}
					}
				}

				}
				break;
			case 4:
				_localctx = new PartitionListVectorContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1909; Match(PARTITION);
				State = 1910; uid();
				State = 1911; Match(VALUES);
				State = 1912; Match(IN);
				State = 1913; Match(LR_BRACKET);
				State = 1914; partitionDefinerVector();
				State = 1919;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1915; Match(COMMA);
					State = 1916; partitionDefinerVector();
					}
					}
					State = 1921;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1922; Match(RR_BRACKET);
				State = 1926;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==INDEX || ((((_la - 285)) & ~0x3f) == 0 && ((1L << (_la - 285)) & ((1L << (COMMENT - 285)) | (1L << (DATA - 285)) | (1L << (ENGINE - 285)))) != 0) || ((((_la - 403)) & ~0x3f) == 0 && ((1L << (_la - 403)) & ((1L << (MAX_ROWS - 403)) | (1L << (MIN_ROWS - 403)) | (1L << (NODEGROUP - 403)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
					{
					{
					State = 1923; partitionOption();
					}
					}
					State = 1928;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1937;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SUBPARTITION) {
					{
					State = 1929; subpartitionDefinition();
					State = 1934;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,223,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 1930; Match(COMMA);
							State = 1931; subpartitionDefinition();
							}
							} 
						}
						State = 1936;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,223,Context);
					}
					}
				}

				}
				break;
			case 5:
				_localctx = new PartitionSimpleContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1939; Match(PARTITION);
				State = 1940; uid();
				State = 1944;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==INDEX || ((((_la - 285)) & ~0x3f) == 0 && ((1L << (_la - 285)) & ((1L << (COMMENT - 285)) | (1L << (DATA - 285)) | (1L << (ENGINE - 285)))) != 0) || ((((_la - 403)) & ~0x3f) == 0 && ((1L << (_la - 403)) & ((1L << (MAX_ROWS - 403)) | (1L << (MIN_ROWS - 403)) | (1L << (NODEGROUP - 403)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
					{
					{
					State = 1941; partitionOption();
					}
					}
					State = 1946;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1955;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SUBPARTITION) {
					{
					State = 1947; subpartitionDefinition();
					State = 1952;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,226,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 1948; Match(COMMA);
							State = 1949; subpartitionDefinition();
							}
							} 
						}
						State = 1954;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,226,Context);
					}
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionDefinerAtomContext : ParserRuleContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode MAXVALUE() { return GetToken(MySqlParser.MAXVALUE, 0); }
		public PartitionDefinerAtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionDefinerAtom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionDefinerAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionDefinerAtom(this);
		}
	}

	[RuleVersion(0)]
	public PartitionDefinerAtomContext partitionDefinerAtom() {
		PartitionDefinerAtomContext _localctx = new PartitionDefinerAtomContext(Context, State);
		EnterRule(_localctx, 104, RULE_partitionDefinerAtom);
		try {
			State = 1962;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,229,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1959; constant();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1960; expression(0);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1961; Match(MAXVALUE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionDefinerVectorContext : ParserRuleContext {
		public PartitionDefinerAtomContext[] partitionDefinerAtom() {
			return GetRuleContexts<PartitionDefinerAtomContext>();
		}
		public PartitionDefinerAtomContext partitionDefinerAtom(int i) {
			return GetRuleContext<PartitionDefinerAtomContext>(i);
		}
		public PartitionDefinerVectorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionDefinerVector; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionDefinerVector(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionDefinerVector(this);
		}
	}

	[RuleVersion(0)]
	public PartitionDefinerVectorContext partitionDefinerVector() {
		PartitionDefinerVectorContext _localctx = new PartitionDefinerVectorContext(Context, State);
		EnterRule(_localctx, 106, RULE_partitionDefinerVector);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1964; Match(LR_BRACKET);
			State = 1965; partitionDefinerAtom();
			State = 1968;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 1966; Match(COMMA);
				State = 1967; partitionDefinerAtom();
				}
				}
				State = 1970;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COMMA );
			State = 1972; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubpartitionDefinitionContext : ParserRuleContext {
		public ITerminalNode SUBPARTITION() { return GetToken(MySqlParser.SUBPARTITION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public PartitionOptionContext[] partitionOption() {
			return GetRuleContexts<PartitionOptionContext>();
		}
		public PartitionOptionContext partitionOption(int i) {
			return GetRuleContext<PartitionOptionContext>(i);
		}
		public SubpartitionDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartitionDefinition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubpartitionDefinition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubpartitionDefinition(this);
		}
	}

	[RuleVersion(0)]
	public SubpartitionDefinitionContext subpartitionDefinition() {
		SubpartitionDefinitionContext _localctx = new SubpartitionDefinitionContext(Context, State);
		EnterRule(_localctx, 108, RULE_subpartitionDefinition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1974; Match(SUBPARTITION);
			State = 1975; uid();
			State = 1979;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==INDEX || ((((_la - 285)) & ~0x3f) == 0 && ((1L << (_la - 285)) & ((1L << (COMMENT - 285)) | (1L << (DATA - 285)) | (1L << (ENGINE - 285)))) != 0) || ((((_la - 403)) & ~0x3f) == 0 && ((1L << (_la - 403)) & ((1L << (MAX_ROWS - 403)) | (1L << (MIN_ROWS - 403)) | (1L << (NODEGROUP - 403)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
				{
				{
				State = 1976; partitionOption();
				}
				}
				State = 1981;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionOptionContext : ParserRuleContext {
		public PartitionOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionOption; } }
	 
		public PartitionOptionContext() { }
		public virtual void CopyFrom(PartitionOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PartitionOptionCommentContext : PartitionOptionContext {
		public IToken comment;
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PartitionOptionCommentContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionComment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionComment(this);
		}
	}
	public partial class PartitionOptionNodeGroupContext : PartitionOptionContext {
		public UidContext nodegroup;
		public ITerminalNode NODEGROUP() { return GetToken(MySqlParser.NODEGROUP, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public PartitionOptionNodeGroupContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionNodeGroup(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionNodeGroup(this);
		}
	}
	public partial class PartitionOptionIndexDirectoryContext : PartitionOptionContext {
		public IToken indexDirectory;
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(MySqlParser.DIRECTORY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PartitionOptionIndexDirectoryContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionIndexDirectory(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionIndexDirectory(this);
		}
	}
	public partial class PartitionOptionMaxRowsContext : PartitionOptionContext {
		public DecimalLiteralContext maxRows;
		public ITerminalNode MAX_ROWS() { return GetToken(MySqlParser.MAX_ROWS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public PartitionOptionMaxRowsContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionMaxRows(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionMaxRows(this);
		}
	}
	public partial class PartitionOptionTablespaceContext : PartitionOptionContext {
		public UidContext tablespace;
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public PartitionOptionTablespaceContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionTablespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionTablespace(this);
		}
	}
	public partial class PartitionOptionEngineContext : PartitionOptionContext {
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public ITerminalNode STORAGE() { return GetToken(MySqlParser.STORAGE, 0); }
		public PartitionOptionEngineContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionEngine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionEngine(this);
		}
	}
	public partial class PartitionOptionMinRowsContext : PartitionOptionContext {
		public DecimalLiteralContext minRows;
		public ITerminalNode MIN_ROWS() { return GetToken(MySqlParser.MIN_ROWS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public PartitionOptionMinRowsContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionMinRows(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionMinRows(this);
		}
	}
	public partial class PartitionOptionDataDirectoryContext : PartitionOptionContext {
		public IToken dataDirectory;
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(MySqlParser.DIRECTORY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PartitionOptionDataDirectoryContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionDataDirectory(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionDataDirectory(this);
		}
	}

	[RuleVersion(0)]
	public PartitionOptionContext partitionOption() {
		PartitionOptionContext _localctx = new PartitionOptionContext(Context, State);
		EnterRule(_localctx, 110, RULE_partitionOption);
		int _la;
		try {
			State = 2027;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ENGINE:
			case STORAGE:
				_localctx = new PartitionOptionEngineContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1983;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==STORAGE) {
					{
					State = 1982; Match(STORAGE);
					}
				}

				State = 1985; Match(ENGINE);
				State = 1987;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1986; Match(EQUAL_SYMBOL);
					}
				}

				State = 1989; engineName();
				}
				break;
			case COMMENT:
				_localctx = new PartitionOptionCommentContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1990; Match(COMMENT);
				State = 1992;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1991; Match(EQUAL_SYMBOL);
					}
				}

				State = 1994; ((PartitionOptionCommentContext)_localctx).comment = Match(STRING_LITERAL);
				}
				break;
			case DATA:
				_localctx = new PartitionOptionDataDirectoryContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1995; Match(DATA);
				State = 1996; Match(DIRECTORY);
				State = 1998;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1997; Match(EQUAL_SYMBOL);
					}
				}

				State = 2000; ((PartitionOptionDataDirectoryContext)_localctx).dataDirectory = Match(STRING_LITERAL);
				}
				break;
			case INDEX:
				_localctx = new PartitionOptionIndexDirectoryContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 2001; Match(INDEX);
				State = 2002; Match(DIRECTORY);
				State = 2004;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2003; Match(EQUAL_SYMBOL);
					}
				}

				State = 2006; ((PartitionOptionIndexDirectoryContext)_localctx).indexDirectory = Match(STRING_LITERAL);
				}
				break;
			case MAX_ROWS:
				_localctx = new PartitionOptionMaxRowsContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 2007; Match(MAX_ROWS);
				State = 2009;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2008; Match(EQUAL_SYMBOL);
					}
				}

				State = 2011; ((PartitionOptionMaxRowsContext)_localctx).maxRows = decimalLiteral();
				}
				break;
			case MIN_ROWS:
				_localctx = new PartitionOptionMinRowsContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 2012; Match(MIN_ROWS);
				State = 2014;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2013; Match(EQUAL_SYMBOL);
					}
				}

				State = 2016; ((PartitionOptionMinRowsContext)_localctx).minRows = decimalLiteral();
				}
				break;
			case TABLESPACE:
				_localctx = new PartitionOptionTablespaceContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 2017; Match(TABLESPACE);
				State = 2019;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2018; Match(EQUAL_SYMBOL);
					}
				}

				State = 2021; ((PartitionOptionTablespaceContext)_localctx).tablespace = uid();
				}
				break;
			case NODEGROUP:
				_localctx = new PartitionOptionNodeGroupContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 2022; Match(NODEGROUP);
				State = 2024;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2023; Match(EQUAL_SYMBOL);
					}
				}

				State = 2026; ((PartitionOptionNodeGroupContext)_localctx).nodegroup = uid();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterDatabaseContext : ParserRuleContext {
		public AlterDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterDatabase; } }
	 
		public AlterDatabaseContext() { }
		public virtual void CopyFrom(AlterDatabaseContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AlterUpgradeNameContext : AlterDatabaseContext {
		public IToken dbFormat;
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode UPGRADE() { return GetToken(MySqlParser.UPGRADE, 0); }
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(MySqlParser.DIRECTORY, 0); }
		public ITerminalNode NAME() { return GetToken(MySqlParser.NAME, 0); }
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(MySqlParser.SCHEMA, 0); }
		public AlterUpgradeNameContext(AlterDatabaseContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterUpgradeName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterUpgradeName(this);
		}
	}
	public partial class AlterSimpleDatabaseContext : AlterDatabaseContext {
		public IToken dbFormat;
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(MySqlParser.SCHEMA, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public CreateDatabaseOptionContext[] createDatabaseOption() {
			return GetRuleContexts<CreateDatabaseOptionContext>();
		}
		public CreateDatabaseOptionContext createDatabaseOption(int i) {
			return GetRuleContext<CreateDatabaseOptionContext>(i);
		}
		public AlterSimpleDatabaseContext(AlterDatabaseContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterSimpleDatabase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterSimpleDatabase(this);
		}
	}

	[RuleVersion(0)]
	public AlterDatabaseContext alterDatabase() {
		AlterDatabaseContext _localctx = new AlterDatabaseContext(Context, State);
		EnterRule(_localctx, 112, RULE_alterDatabase);
		int _la;
		try {
			State = 2047;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,244,Context) ) {
			case 1:
				_localctx = new AlterSimpleDatabaseContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 2029; Match(ALTER);
				State = 2030;
				((AlterSimpleDatabaseContext)_localctx).dbFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DATABASE || _la==SCHEMA) ) {
					((AlterSimpleDatabaseContext)_localctx).dbFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2032;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,242,Context) ) {
				case 1:
					{
					State = 2031; uid();
					}
					break;
				}
				State = 2035;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 2034; createDatabaseOption();
					}
					}
					State = 2037;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << CHARACTER) | (1L << COLLATE) | (1L << DEFAULT))) != 0) || _la==CHARSET );
				}
				break;
			case 2:
				_localctx = new AlterUpgradeNameContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 2039; Match(ALTER);
				State = 2040;
				((AlterUpgradeNameContext)_localctx).dbFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DATABASE || _la==SCHEMA) ) {
					((AlterUpgradeNameContext)_localctx).dbFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2041; uid();
				State = 2042; Match(UPGRADE);
				State = 2043; Match(DATA);
				State = 2044; Match(DIRECTORY);
				State = 2045; Match(NAME);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterEventContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode EVENT() { return GetToken(MySqlParser.EVENT, 0); }
		public FullIdContext[] fullId() {
			return GetRuleContexts<FullIdContext>();
		}
		public FullIdContext fullId(int i) {
			return GetRuleContext<FullIdContext>(i);
		}
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public ITerminalNode[] ON() { return GetTokens(MySqlParser.ON); }
		public ITerminalNode ON(int i) {
			return GetToken(MySqlParser.ON, i);
		}
		public ITerminalNode SCHEDULE() { return GetToken(MySqlParser.SCHEDULE, 0); }
		public ScheduleExpressionContext scheduleExpression() {
			return GetRuleContext<ScheduleExpressionContext>(0);
		}
		public ITerminalNode COMPLETION() { return GetToken(MySqlParser.COMPLETION, 0); }
		public ITerminalNode PRESERVE() { return GetToken(MySqlParser.PRESERVE, 0); }
		public ITerminalNode RENAME() { return GetToken(MySqlParser.RENAME, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public EnableTypeContext enableType() {
			return GetRuleContext<EnableTypeContext>(0);
		}
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode DO() { return GetToken(MySqlParser.DO, 0); }
		public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public AlterEventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterEvent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterEvent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterEvent(this);
		}
	}

	[RuleVersion(0)]
	public AlterEventContext alterEvent() {
		AlterEventContext _localctx = new AlterEventContext(Context, State);
		EnterRule(_localctx, 114, RULE_alterEvent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2049; Match(ALTER);
			State = 2051;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 2050; ownerStatement();
				}
			}

			State = 2053; Match(EVENT);
			State = 2054; fullId();
			State = 2058;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,246,Context) ) {
			case 1:
				{
				State = 2055; Match(ON);
				State = 2056; Match(SCHEDULE);
				State = 2057; scheduleExpression();
				}
				break;
			}
			State = 2066;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 2060; Match(ON);
				State = 2061; Match(COMPLETION);
				State = 2063;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 2062; Match(NOT);
					}
				}

				State = 2065; Match(PRESERVE);
				}
			}

			State = 2071;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,249,Context) ) {
			case 1:
				{
				State = 2068; Match(RENAME);
				State = 2069; Match(TO);
				State = 2070; fullId();
				}
				break;
			}
			State = 2074;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DISABLE || _la==ENABLE) {
				{
				State = 2073; enableType();
				}
			}

			State = 2078;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMENT) {
				{
				State = 2076; Match(COMMENT);
				State = 2077; Match(STRING_LITERAL);
				}
			}

			State = 2082;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,252,Context) ) {
			case 1:
				{
				State = 2080; Match(DO);
				State = 2081; routineBody();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterFunctionContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public RoutineOptionContext[] routineOption() {
			return GetRuleContexts<RoutineOptionContext>();
		}
		public RoutineOptionContext routineOption(int i) {
			return GetRuleContext<RoutineOptionContext>(i);
		}
		public AlterFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterFunction(this);
		}
	}

	[RuleVersion(0)]
	public AlterFunctionContext alterFunction() {
		AlterFunctionContext _localctx = new AlterFunctionContext(Context, State);
		EnterRule(_localctx, 116, RULE_alterFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2084; Match(ALTER);
			State = 2085; Match(FUNCTION);
			State = 2086; fullId();
			State = 2090;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DETERMINISTIC || ((((_la - 97)) & ~0x3f) == 0 && ((1L << (_la - 97)) & ((1L << (MODIFIES - 97)) | (1L << (NOT - 97)) | (1L << (READS - 97)) | (1L << (SQL - 97)))) != 0) || _la==COMMENT || _la==CONTAINS || _la==LANGUAGE || _la==NO) {
				{
				{
				State = 2087; routineOption();
				}
				}
				State = 2092;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterInstanceContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode INSTANCE() { return GetToken(MySqlParser.INSTANCE, 0); }
		public ITerminalNode ROTATE() { return GetToken(MySqlParser.ROTATE, 0); }
		public ITerminalNode INNODB() { return GetToken(MySqlParser.INNODB, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public AlterInstanceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterInstance; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterInstance(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterInstance(this);
		}
	}

	[RuleVersion(0)]
	public AlterInstanceContext alterInstance() {
		AlterInstanceContext _localctx = new AlterInstanceContext(Context, State);
		EnterRule(_localctx, 118, RULE_alterInstance);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2093; Match(ALTER);
			State = 2094; Match(INSTANCE);
			State = 2095; Match(ROTATE);
			State = 2096; Match(INNODB);
			State = 2097; Match(MASTER);
			State = 2098; Match(KEY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterLogfileGroupContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode LOGFILE() { return GetToken(MySqlParser.LOGFILE, 0); }
		public ITerminalNode GROUP() { return GetToken(MySqlParser.GROUP, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode UNDOFILE() { return GetToken(MySqlParser.UNDOFILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public ITerminalNode INITIAL_SIZE() { return GetToken(MySqlParser.INITIAL_SIZE, 0); }
		public FileSizeLiteralContext fileSizeLiteral() {
			return GetRuleContext<FileSizeLiteralContext>(0);
		}
		public ITerminalNode WAIT() { return GetToken(MySqlParser.WAIT, 0); }
		public AlterLogfileGroupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterLogfileGroup; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterLogfileGroup(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterLogfileGroup(this);
		}
	}

	[RuleVersion(0)]
	public AlterLogfileGroupContext alterLogfileGroup() {
		AlterLogfileGroupContext _localctx = new AlterLogfileGroupContext(Context, State);
		EnterRule(_localctx, 120, RULE_alterLogfileGroup);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2100; Match(ALTER);
			State = 2101; Match(LOGFILE);
			State = 2102; Match(GROUP);
			State = 2103; uid();
			State = 2104; Match(ADD);
			State = 2105; Match(UNDOFILE);
			State = 2106; Match(STRING_LITERAL);
			State = 2112;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INITIAL_SIZE) {
				{
				State = 2107; Match(INITIAL_SIZE);
				State = 2109;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2108; Match(EQUAL_SYMBOL);
					}
				}

				State = 2111; fileSizeLiteral();
				}
			}

			State = 2115;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WAIT) {
				{
				State = 2114; Match(WAIT);
				}
			}

			State = 2117; Match(ENGINE);
			State = 2119;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQUAL_SYMBOL) {
				{
				State = 2118; Match(EQUAL_SYMBOL);
				}
			}

			State = 2121; engineName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterProcedureContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public RoutineOptionContext[] routineOption() {
			return GetRuleContexts<RoutineOptionContext>();
		}
		public RoutineOptionContext routineOption(int i) {
			return GetRuleContext<RoutineOptionContext>(i);
		}
		public AlterProcedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterProcedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterProcedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterProcedure(this);
		}
	}

	[RuleVersion(0)]
	public AlterProcedureContext alterProcedure() {
		AlterProcedureContext _localctx = new AlterProcedureContext(Context, State);
		EnterRule(_localctx, 122, RULE_alterProcedure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2123; Match(ALTER);
			State = 2124; Match(PROCEDURE);
			State = 2125; fullId();
			State = 2129;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DETERMINISTIC || ((((_la - 97)) & ~0x3f) == 0 && ((1L << (_la - 97)) & ((1L << (MODIFIES - 97)) | (1L << (NOT - 97)) | (1L << (READS - 97)) | (1L << (SQL - 97)))) != 0) || _la==COMMENT || _la==CONTAINS || _la==LANGUAGE || _la==NO) {
				{
				{
				State = 2126; routineOption();
				}
				}
				State = 2131;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterServerContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode SERVER() { return GetToken(MySqlParser.SERVER, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode OPTIONS() { return GetToken(MySqlParser.OPTIONS, 0); }
		public ServerOptionContext[] serverOption() {
			return GetRuleContexts<ServerOptionContext>();
		}
		public ServerOptionContext serverOption(int i) {
			return GetRuleContext<ServerOptionContext>(i);
		}
		public AlterServerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterServer; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterServer(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterServer(this);
		}
	}

	[RuleVersion(0)]
	public AlterServerContext alterServer() {
		AlterServerContext _localctx = new AlterServerContext(Context, State);
		EnterRule(_localctx, 124, RULE_alterServer);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2132; Match(ALTER);
			State = 2133; Match(SERVER);
			State = 2134; uid();
			State = 2135; Match(OPTIONS);
			State = 2136; Match(LR_BRACKET);
			State = 2137; serverOption();
			State = 2142;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2138; Match(COMMA);
				State = 2139; serverOption();
				}
				}
				State = 2144;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2145; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTableContext : ParserRuleContext {
		public IToken intimeAction;
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public AlterSpecificationContext[] alterSpecification() {
			return GetRuleContexts<AlterSpecificationContext>();
		}
		public AlterSpecificationContext alterSpecification(int i) {
			return GetRuleContext<AlterSpecificationContext>(i);
		}
		public PartitionDefinitionsContext partitionDefinitions() {
			return GetRuleContext<PartitionDefinitionsContext>(0);
		}
		public ITerminalNode ONLINE() { return GetToken(MySqlParser.ONLINE, 0); }
		public ITerminalNode OFFLINE() { return GetToken(MySqlParser.OFFLINE, 0); }
		public AlterTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterTable(this);
		}
	}

	[RuleVersion(0)]
	public AlterTableContext alterTable() {
		AlterTableContext _localctx = new AlterTableContext(Context, State);
		EnterRule(_localctx, 126, RULE_alterTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2147; Match(ALTER);
			State = 2149;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OFFLINE || _la==ONLINE) {
				{
				State = 2148;
				_localctx.intimeAction = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==OFFLINE || _la==ONLINE) ) {
					_localctx.intimeAction = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2152;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 2151; Match(IGNORE);
				}
			}

			State = 2154; Match(TABLE);
			State = 2155; tableName();
			State = 2164;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,263,Context) ) {
			case 1:
				{
				State = 2156; alterSpecification();
				State = 2161;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2157; Match(COMMA);
					State = 2158; alterSpecification();
					}
					}
					State = 2163;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			State = 2167;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 2166; partitionDefinitions();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTablespaceContext : ParserRuleContext {
		public IToken objectAction;
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode DATAFILE() { return GetToken(MySqlParser.DATAFILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode INITIAL_SIZE() { return GetToken(MySqlParser.INITIAL_SIZE, 0); }
		public FileSizeLiteralContext fileSizeLiteral() {
			return GetRuleContext<FileSizeLiteralContext>(0);
		}
		public ITerminalNode WAIT() { return GetToken(MySqlParser.WAIT, 0); }
		public AlterTablespaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTablespace; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterTablespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterTablespace(this);
		}
	}

	[RuleVersion(0)]
	public AlterTablespaceContext alterTablespace() {
		AlterTablespaceContext _localctx = new AlterTablespaceContext(Context, State);
		EnterRule(_localctx, 128, RULE_alterTablespace);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2169; Match(ALTER);
			State = 2170; Match(TABLESPACE);
			State = 2171; uid();
			State = 2172;
			_localctx.objectAction = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==ADD || _la==DROP) ) {
				_localctx.objectAction = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2173; Match(DATAFILE);
			State = 2174; Match(STRING_LITERAL);
			State = 2178;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INITIAL_SIZE) {
				{
				State = 2175; Match(INITIAL_SIZE);
				State = 2176; Match(EQUAL_SYMBOL);
				State = 2177; fileSizeLiteral();
				}
			}

			State = 2181;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WAIT) {
				{
				State = 2180; Match(WAIT);
				}
			}

			State = 2183; Match(ENGINE);
			State = 2185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQUAL_SYMBOL) {
				{
				State = 2184; Match(EQUAL_SYMBOL);
				}
			}

			State = 2187; engineName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterViewContext : ParserRuleContext {
		public IToken algType;
		public IToken secContext;
		public IToken checkOpt;
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode VIEW() { return GetToken(MySqlParser.VIEW, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ITerminalNode ALGORITHM() { return GetToken(MySqlParser.ALGORITHM, 0); }
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public ITerminalNode SQL() { return GetToken(MySqlParser.SQL, 0); }
		public ITerminalNode SECURITY() { return GetToken(MySqlParser.SECURITY, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode CHECK() { return GetToken(MySqlParser.CHECK, 0); }
		public ITerminalNode OPTION() { return GetToken(MySqlParser.OPTION, 0); }
		public ITerminalNode UNDEFINED() { return GetToken(MySqlParser.UNDEFINED, 0); }
		public ITerminalNode MERGE() { return GetToken(MySqlParser.MERGE, 0); }
		public ITerminalNode TEMPTABLE() { return GetToken(MySqlParser.TEMPTABLE, 0); }
		public ITerminalNode DEFINER() { return GetToken(MySqlParser.DEFINER, 0); }
		public ITerminalNode INVOKER() { return GetToken(MySqlParser.INVOKER, 0); }
		public ITerminalNode CASCADED() { return GetToken(MySqlParser.CASCADED, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public AlterViewContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterView; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterView(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterView(this);
		}
	}

	[RuleVersion(0)]
	public AlterViewContext alterView() {
		AlterViewContext _localctx = new AlterViewContext(Context, State);
		EnterRule(_localctx, 130, RULE_alterView);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2189; Match(ALTER);
			State = 2193;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALGORITHM) {
				{
				State = 2190; Match(ALGORITHM);
				State = 2191; Match(EQUAL_SYMBOL);
				State = 2192;
				_localctx.algType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==MERGE || _la==TEMPTABLE || _la==UNDEFINED) ) {
					_localctx.algType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2196;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 2195; ownerStatement();
				}
			}

			State = 2201;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SQL) {
				{
				State = 2198; Match(SQL);
				State = 2199; Match(SECURITY);
				State = 2200;
				_localctx.secContext = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFINER || _la==INVOKER) ) {
					_localctx.secContext = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2203; Match(VIEW);
			State = 2204; fullId();
			State = 2209;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LR_BRACKET) {
				{
				State = 2205; Match(LR_BRACKET);
				State = 2206; uidList();
				State = 2207; Match(RR_BRACKET);
				}
			}

			State = 2211; Match(AS);
			State = 2212; selectStatement();
			State = 2219;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 2213; Match(WITH);
				State = 2215;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CASCADED || _la==LOCAL) {
					{
					State = 2214;
					_localctx.checkOpt = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==CASCADED || _la==LOCAL) ) {
						_localctx.checkOpt = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2217; Match(CHECK);
				State = 2218; Match(OPTION);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterSpecificationContext : ParserRuleContext {
		public AlterSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterSpecification; } }
	 
		public AlterSpecificationContext() { }
		public virtual void CopyFrom(AlterSpecificationContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AlterByDisableKeysContext : AlterSpecificationContext {
		public ITerminalNode DISABLE() { return GetToken(MySqlParser.DISABLE, 0); }
		public ITerminalNode KEYS() { return GetToken(MySqlParser.KEYS, 0); }
		public AlterByDisableKeysContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDisableKeys(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDisableKeys(this);
		}
	}
	public partial class AlterByDefaultCharsetContext : AlterSpecificationContext {
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public AlterByDefaultCharsetContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDefaultCharset(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDefaultCharset(this);
		}
	}
	public partial class AlterByRenameColumnContext : AlterSpecificationContext {
		public UidContext oldColumn;
		public UidContext newColumn;
		public ITerminalNode RENAME() { return GetToken(MySqlParser.RENAME, 0); }
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public AlterByRenameColumnContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByRenameColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByRenameColumn(this);
		}
	}
	public partial class AlterByConvertCharsetContext : AlterSpecificationContext {
		public ITerminalNode CONVERT() { return GetToken(MySqlParser.CONVERT, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public AlterByConvertCharsetContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByConvertCharset(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByConvertCharset(this);
		}
	}
	public partial class AlterByAddPartitionContext : AlterSpecificationContext {
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public PartitionDefinitionContext[] partitionDefinition() {
			return GetRuleContexts<PartitionDefinitionContext>();
		}
		public PartitionDefinitionContext partitionDefinition(int i) {
			return GetRuleContext<PartitionDefinitionContext>(i);
		}
		public AlterByAddPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddPartition(this);
		}
	}
	public partial class AlterByAddForeignKeyContext : AlterSpecificationContext {
		public UidContext name;
		public UidContext indexName;
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode FOREIGN() { return GetToken(MySqlParser.FOREIGN, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ReferenceDefinitionContext referenceDefinition() {
			return GetRuleContext<ReferenceDefinitionContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public AlterByAddForeignKeyContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddForeignKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddForeignKey(this);
		}
	}
	public partial class AlterByRenameIndexContext : AlterSpecificationContext {
		public IToken indexFormat;
		public ITerminalNode RENAME() { return GetToken(MySqlParser.RENAME, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public AlterByRenameIndexContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByRenameIndex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByRenameIndex(this);
		}
	}
	public partial class AlterByRemovePartitioningContext : AlterSpecificationContext {
		public ITerminalNode REMOVE() { return GetToken(MySqlParser.REMOVE, 0); }
		public ITerminalNode PARTITIONING() { return GetToken(MySqlParser.PARTITIONING, 0); }
		public AlterByRemovePartitioningContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByRemovePartitioning(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByRemovePartitioning(this);
		}
	}
	public partial class AlterByRenameContext : AlterSpecificationContext {
		public IToken renameFormat;
		public ITerminalNode RENAME() { return GetToken(MySqlParser.RENAME, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public AlterByRenameContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByRename(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByRename(this);
		}
	}
	public partial class AlterByOptimizePartitionContext : AlterSpecificationContext {
		public ITerminalNode OPTIMIZE() { return GetToken(MySqlParser.OPTIMIZE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByOptimizePartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByOptimizePartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByOptimizePartition(this);
		}
	}
	public partial class AlterByImportTablespaceContext : AlterSpecificationContext {
		public ITerminalNode IMPORT() { return GetToken(MySqlParser.IMPORT, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public AlterByImportTablespaceContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByImportTablespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByImportTablespace(this);
		}
	}
	public partial class AlterByCoalescePartitionContext : AlterSpecificationContext {
		public ITerminalNode COALESCE() { return GetToken(MySqlParser.COALESCE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public AlterByCoalescePartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByCoalescePartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByCoalescePartition(this);
		}
	}
	public partial class AlterByAddColumnsContext : AlterSpecificationContext {
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ColumnDefinitionContext[] columnDefinition() {
			return GetRuleContexts<ColumnDefinitionContext>();
		}
		public ColumnDefinitionContext columnDefinition(int i) {
			return GetRuleContext<ColumnDefinitionContext>(i);
		}
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public AlterByAddColumnsContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddColumns(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddColumns(this);
		}
	}
	public partial class AlterByDropForeignKeyContext : AlterSpecificationContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode FOREIGN() { return GetToken(MySqlParser.FOREIGN, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public AlterByDropForeignKeyContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDropForeignKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDropForeignKey(this);
		}
	}
	public partial class AlterByAddCheckTableConstraintContext : AlterSpecificationContext {
		public UidContext name;
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode CHECK() { return GetToken(MySqlParser.CHECK, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public AlterByAddCheckTableConstraintContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddCheckTableConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddCheckTableConstraint(this);
		}
	}
	public partial class AlterByRebuildPartitionContext : AlterSpecificationContext {
		public ITerminalNode REBUILD() { return GetToken(MySqlParser.REBUILD, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByRebuildPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByRebuildPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByRebuildPartition(this);
		}
	}
	public partial class AlterByUpgradePartitioningContext : AlterSpecificationContext {
		public ITerminalNode UPGRADE() { return GetToken(MySqlParser.UPGRADE, 0); }
		public ITerminalNode PARTITIONING() { return GetToken(MySqlParser.PARTITIONING, 0); }
		public AlterByUpgradePartitioningContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByUpgradePartitioning(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByUpgradePartitioning(this);
		}
	}
	public partial class AlterByRepairPartitionContext : AlterSpecificationContext {
		public ITerminalNode REPAIR() { return GetToken(MySqlParser.REPAIR, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByRepairPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByRepairPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByRepairPartition(this);
		}
	}
	public partial class AlterByExchangePartitionContext : AlterSpecificationContext {
		public IToken validationFormat;
		public ITerminalNode EXCHANGE() { return GetToken(MySqlParser.EXCHANGE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode[] WITH() { return GetTokens(MySqlParser.WITH); }
		public ITerminalNode WITH(int i) {
			return GetToken(MySqlParser.WITH, i);
		}
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode VALIDATION() { return GetToken(MySqlParser.VALIDATION, 0); }
		public ITerminalNode WITHOUT() { return GetToken(MySqlParser.WITHOUT, 0); }
		public AlterByExchangePartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByExchangePartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByExchangePartition(this);
		}
	}
	public partial class AlterByAddIndexContext : AlterSpecificationContext {
		public IToken indexFormat;
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public AlterByAddIndexContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddIndex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddIndex(this);
		}
	}
	public partial class AlterByDropColumnContext : AlterSpecificationContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public ITerminalNode RESTRICT() { return GetToken(MySqlParser.RESTRICT, 0); }
		public AlterByDropColumnContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDropColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDropColumn(this);
		}
	}
	public partial class AlterByImportPartitionContext : AlterSpecificationContext {
		public ITerminalNode IMPORT() { return GetToken(MySqlParser.IMPORT, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByImportPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByImportPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByImportPartition(this);
		}
	}
	public partial class AlterByChangeDefaultContext : AlterSpecificationContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public DefaultValueContext defaultValue() {
			return GetRuleContext<DefaultValueContext>(0);
		}
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public AlterByChangeDefaultContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByChangeDefault(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByChangeDefault(this);
		}
	}
	public partial class AlterByForceContext : AlterSpecificationContext {
		public ITerminalNode FORCE() { return GetToken(MySqlParser.FORCE, 0); }
		public AlterByForceContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByForce(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByForce(this);
		}
	}
	public partial class AlterByDropPartitionContext : AlterSpecificationContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public AlterByDropPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDropPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDropPartition(this);
		}
	}
	public partial class AlterByAddSpecialIndexContext : AlterSpecificationContext {
		public IToken keyType;
		public IToken indexFormat;
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode FULLTEXT() { return GetToken(MySqlParser.FULLTEXT, 0); }
		public ITerminalNode SPATIAL() { return GetToken(MySqlParser.SPATIAL, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public AlterByAddSpecialIndexContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddSpecialIndex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddSpecialIndex(this);
		}
	}
	public partial class AlterByModifyColumnContext : AlterSpecificationContext {
		public ITerminalNode MODIFY() { return GetToken(MySqlParser.MODIFY, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ColumnDefinitionContext columnDefinition() {
			return GetRuleContext<ColumnDefinitionContext>(0);
		}
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode AFTER() { return GetToken(MySqlParser.AFTER, 0); }
		public AlterByModifyColumnContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByModifyColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByModifyColumn(this);
		}
	}
	public partial class AlterByTableOptionContext : AlterSpecificationContext {
		public TableOptionContext[] tableOption() {
			return GetRuleContexts<TableOptionContext>();
		}
		public TableOptionContext tableOption(int i) {
			return GetRuleContext<TableOptionContext>(i);
		}
		public AlterByTableOptionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByTableOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByTableOption(this);
		}
	}
	public partial class AlterByDropPrimaryKeyContext : AlterSpecificationContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode PRIMARY() { return GetToken(MySqlParser.PRIMARY, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public AlterByDropPrimaryKeyContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDropPrimaryKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDropPrimaryKey(this);
		}
	}
	public partial class AlterByLockContext : AlterSpecificationContext {
		public IToken lockType;
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode NONE() { return GetToken(MySqlParser.NONE, 0); }
		public ITerminalNode SHARED() { return GetToken(MySqlParser.SHARED, 0); }
		public ITerminalNode EXCLUSIVE() { return GetToken(MySqlParser.EXCLUSIVE, 0); }
		public AlterByLockContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByLock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByLock(this);
		}
	}
	public partial class AlterByDiscardPartitionContext : AlterSpecificationContext {
		public ITerminalNode DISCARD() { return GetToken(MySqlParser.DISCARD, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByDiscardPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDiscardPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDiscardPartition(this);
		}
	}
	public partial class AlterByDiscardTablespaceContext : AlterSpecificationContext {
		public ITerminalNode DISCARD() { return GetToken(MySqlParser.DISCARD, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public AlterByDiscardTablespaceContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDiscardTablespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDiscardTablespace(this);
		}
	}
	public partial class AlterByValidateContext : AlterSpecificationContext {
		public IToken validationFormat;
		public ITerminalNode VALIDATION() { return GetToken(MySqlParser.VALIDATION, 0); }
		public ITerminalNode WITHOUT() { return GetToken(MySqlParser.WITHOUT, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public AlterByValidateContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByValidate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByValidate(this);
		}
	}
	public partial class AlterByAddPrimaryKeyContext : AlterSpecificationContext {
		public UidContext name;
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode PRIMARY() { return GetToken(MySqlParser.PRIMARY, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public AlterByAddPrimaryKeyContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddPrimaryKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddPrimaryKey(this);
		}
	}
	public partial class AlterByCheckPartitionContext : AlterSpecificationContext {
		public ITerminalNode CHECK() { return GetToken(MySqlParser.CHECK, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByCheckPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByCheckPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByCheckPartition(this);
		}
	}
	public partial class AlterByEnableKeysContext : AlterSpecificationContext {
		public ITerminalNode ENABLE() { return GetToken(MySqlParser.ENABLE, 0); }
		public ITerminalNode KEYS() { return GetToken(MySqlParser.KEYS, 0); }
		public AlterByEnableKeysContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByEnableKeys(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByEnableKeys(this);
		}
	}
	public partial class AlterByReorganizePartitionContext : AlterSpecificationContext {
		public ITerminalNode REORGANIZE() { return GetToken(MySqlParser.REORGANIZE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public PartitionDefinitionContext[] partitionDefinition() {
			return GetRuleContexts<PartitionDefinitionContext>();
		}
		public PartitionDefinitionContext partitionDefinition(int i) {
			return GetRuleContext<PartitionDefinitionContext>(i);
		}
		public AlterByReorganizePartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByReorganizePartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByReorganizePartition(this);
		}
	}
	public partial class AlterBySetAlgorithmContext : AlterSpecificationContext {
		public IToken algType;
		public ITerminalNode ALGORITHM() { return GetToken(MySqlParser.ALGORITHM, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode INPLACE() { return GetToken(MySqlParser.INPLACE, 0); }
		public ITerminalNode COPY() { return GetToken(MySqlParser.COPY, 0); }
		public AlterBySetAlgorithmContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterBySetAlgorithm(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterBySetAlgorithm(this);
		}
	}
	public partial class AlterByAnalyzePartitionContext : AlterSpecificationContext {
		public ITerminalNode ANALYZE() { return GetToken(MySqlParser.ANALYZE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByAnalyzePartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAnalyzePartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAnalyzePartition(this);
		}
	}
	public partial class AlterByChangeColumnContext : AlterSpecificationContext {
		public UidContext oldColumn;
		public UidContext newColumn;
		public UidContext afterColumn;
		public ITerminalNode CHANGE() { return GetToken(MySqlParser.CHANGE, 0); }
		public ColumnDefinitionContext columnDefinition() {
			return GetRuleContext<ColumnDefinitionContext>(0);
		}
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode AFTER() { return GetToken(MySqlParser.AFTER, 0); }
		public AlterByChangeColumnContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByChangeColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByChangeColumn(this);
		}
	}
	public partial class AlterByAddUniqueKeyContext : AlterSpecificationContext {
		public UidContext name;
		public IToken indexFormat;
		public UidContext indexName;
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode UNIQUE() { return GetToken(MySqlParser.UNIQUE, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public AlterByAddUniqueKeyContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddUniqueKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddUniqueKey(this);
		}
	}
	public partial class AlterByTruncatePartitionContext : AlterSpecificationContext {
		public ITerminalNode TRUNCATE() { return GetToken(MySqlParser.TRUNCATE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByTruncatePartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByTruncatePartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByTruncatePartition(this);
		}
	}
	public partial class AlterByDropIndexContext : AlterSpecificationContext {
		public IToken indexFormat;
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public AlterByDropIndexContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDropIndex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDropIndex(this);
		}
	}
	public partial class AlterByAddColumnContext : AlterSpecificationContext {
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ColumnDefinitionContext columnDefinition() {
			return GetRuleContext<ColumnDefinitionContext>(0);
		}
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode AFTER() { return GetToken(MySqlParser.AFTER, 0); }
		public AlterByAddColumnContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddColumn(this);
		}
	}
	public partial class AlterByOrderContext : AlterSpecificationContext {
		public ITerminalNode ORDER() { return GetToken(MySqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public AlterByOrderContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByOrder(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByOrder(this);
		}
	}

	[RuleVersion(0)]
	public AlterSpecificationContext alterSpecification() {
		AlterSpecificationContext _localctx = new AlterSpecificationContext(Context, State);
		EnterRule(_localctx, 132, RULE_alterSpecification);
		int _la;
		try {
			int _alt;
			State = 2576;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,327,Context) ) {
			case 1:
				_localctx = new AlterByTableOptionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 2221; tableOption();
				State = 2228;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,275,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 2223;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 2222; Match(COMMA);
							}
						}

						State = 2225; tableOption();
						}
						} 
					}
					State = 2230;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,275,Context);
				}
				}
				break;
			case 2:
				_localctx = new AlterByAddColumnContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 2231; Match(ADD);
				State = 2233;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLUMN) {
					{
					State = 2232; Match(COLUMN);
					}
				}

				State = 2235; uid();
				State = 2236; columnDefinition();
				State = 2240;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case FIRST:
					{
					State = 2237; Match(FIRST);
					}
					break;
				case AFTER:
					{
					State = 2238; Match(AFTER);
					State = 2239; uid();
					}
					break;
				case Eof:
				case ALTER:
				case ANALYZE:
				case CALL:
				case CHANGE:
				case CHECK:
				case CREATE:
				case DELETE:
				case DESC:
				case DESCRIBE:
				case DROP:
				case EXPLAIN:
				case GRANT:
				case INSERT:
				case KILL:
				case LOAD:
				case LOCK:
				case OPTIMIZE:
				case PARTITION:
				case PURGE:
				case RELEASE:
				case RENAME:
				case REPLACE:
				case REVOKE:
				case SELECT:
				case SET:
				case SHOW:
				case UNLOCK:
				case UPDATE:
				case USE:
				case BEGIN:
				case BINLOG:
				case CACHE:
				case CHECKSUM:
				case COMMIT:
				case DEALLOCATE:
				case DO:
				case FLUSH:
				case HANDLER:
				case HELP:
				case INSTALL:
				case PREPARE:
				case REPAIR:
				case RESET:
				case ROLLBACK:
				case SAVEPOINT:
				case START:
				case STOP:
				case TRUNCATE:
				case UNINSTALL:
				case XA:
				case EXECUTE:
				case SHUTDOWN:
				case MINUSMINUS:
				case LR_BRACKET:
				case COMMA:
				case SEMI:
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 3:
				_localctx = new AlterByAddColumnsContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 2242; Match(ADD);
				State = 2244;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLUMN) {
					{
					State = 2243; Match(COLUMN);
					}
				}

				State = 2246; Match(LR_BRACKET);
				State = 2247; uid();
				State = 2248; columnDefinition();
				State = 2255;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2249; Match(COMMA);
					State = 2250; uid();
					State = 2251; columnDefinition();
					}
					}
					State = 2257;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2258; Match(RR_BRACKET);
				}
				break;
			case 4:
				_localctx = new AlterByAddIndexContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 2260; Match(ADD);
				State = 2261;
				((AlterByAddIndexContext)_localctx).indexFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==INDEX || _la==KEY) ) {
					((AlterByAddIndexContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2263;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
					{
					State = 2262; uid();
					}
				}

				State = 2266;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 2265; indexType();
					}
				}

				State = 2268; indexColumnNames();
				State = 2272;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==KEY_BLOCK_SIZE) {
					{
					{
					State = 2269; indexOption();
					}
					}
					State = 2274;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 5:
				_localctx = new AlterByAddPrimaryKeyContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 2275; Match(ADD);
				State = 2280;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 2276; Match(CONSTRAINT);
					State = 2278;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
						{
						State = 2277; ((AlterByAddPrimaryKeyContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 2282; Match(PRIMARY);
				State = 2283; Match(KEY);
				State = 2285;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 2284; indexType();
					}
				}

				State = 2287; indexColumnNames();
				State = 2291;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==KEY_BLOCK_SIZE) {
					{
					{
					State = 2288; indexOption();
					}
					}
					State = 2293;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 6:
				_localctx = new AlterByAddUniqueKeyContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 2294; Match(ADD);
				State = 2299;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 2295; Match(CONSTRAINT);
					State = 2297;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
						{
						State = 2296; ((AlterByAddUniqueKeyContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 2301; Match(UNIQUE);
				State = 2303;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDEX || _la==KEY) {
					{
					State = 2302;
					((AlterByAddUniqueKeyContext)_localctx).indexFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==INDEX || _la==KEY) ) {
						((AlterByAddUniqueKeyContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2306;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
					{
					State = 2305; ((AlterByAddUniqueKeyContext)_localctx).indexName = uid();
					}
				}

				State = 2309;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 2308; indexType();
					}
				}

				State = 2311; indexColumnNames();
				State = 2315;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==KEY_BLOCK_SIZE) {
					{
					{
					State = 2312; indexOption();
					}
					}
					State = 2317;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 7:
				_localctx = new AlterByAddSpecialIndexContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 2318; Match(ADD);
				State = 2319;
				((AlterByAddSpecialIndexContext)_localctx).keyType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FULLTEXT || _la==SPATIAL) ) {
					((AlterByAddSpecialIndexContext)_localctx).keyType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2321;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDEX || _la==KEY) {
					{
					State = 2320;
					((AlterByAddSpecialIndexContext)_localctx).indexFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==INDEX || _la==KEY) ) {
						((AlterByAddSpecialIndexContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2324;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
					{
					State = 2323; uid();
					}
				}

				State = 2326; indexColumnNames();
				State = 2330;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==KEY_BLOCK_SIZE) {
					{
					{
					State = 2327; indexOption();
					}
					}
					State = 2332;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 8:
				_localctx = new AlterByAddForeignKeyContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 2333; Match(ADD);
				State = 2338;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 2334; Match(CONSTRAINT);
					State = 2336;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
						{
						State = 2335; ((AlterByAddForeignKeyContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 2340; Match(FOREIGN);
				State = 2341; Match(KEY);
				State = 2343;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
					{
					State = 2342; ((AlterByAddForeignKeyContext)_localctx).indexName = uid();
					}
				}

				State = 2345; indexColumnNames();
				State = 2346; referenceDefinition();
				}
				break;
			case 9:
				_localctx = new AlterByAddCheckTableConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 2348; Match(ADD);
				State = 2353;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 2349; Match(CONSTRAINT);
					State = 2351;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
						{
						State = 2350; ((AlterByAddCheckTableConstraintContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 2355; Match(CHECK);
				State = 2356; Match(LR_BRACKET);
				State = 2357; expression(0);
				State = 2358; Match(RR_BRACKET);
				}
				break;
			case 10:
				_localctx = new AlterBySetAlgorithmContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 2360; Match(ALGORITHM);
				State = 2362;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2361; Match(EQUAL_SYMBOL);
					}
				}

				State = 2364;
				((AlterBySetAlgorithmContext)_localctx).algType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==COPY || _la==INPLACE) ) {
					((AlterBySetAlgorithmContext)_localctx).algType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 11:
				_localctx = new AlterByChangeDefaultContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 2365; Match(ALTER);
				State = 2367;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLUMN) {
					{
					State = 2366; Match(COLUMN);
					}
				}

				State = 2369; uid();
				State = 2375;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case SET:
					{
					State = 2370; Match(SET);
					State = 2371; Match(DEFAULT);
					State = 2372; defaultValue();
					}
					break;
				case DROP:
					{
					State = 2373; Match(DROP);
					State = 2374; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 12:
				_localctx = new AlterByChangeColumnContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 2377; Match(CHANGE);
				State = 2379;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLUMN) {
					{
					State = 2378; Match(COLUMN);
					}
				}

				State = 2381; ((AlterByChangeColumnContext)_localctx).oldColumn = uid();
				State = 2382; ((AlterByChangeColumnContext)_localctx).newColumn = uid();
				State = 2383; columnDefinition();
				State = 2387;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case FIRST:
					{
					State = 2384; Match(FIRST);
					}
					break;
				case AFTER:
					{
					State = 2385; Match(AFTER);
					State = 2386; ((AlterByChangeColumnContext)_localctx).afterColumn = uid();
					}
					break;
				case Eof:
				case ALTER:
				case ANALYZE:
				case CALL:
				case CHANGE:
				case CHECK:
				case CREATE:
				case DELETE:
				case DESC:
				case DESCRIBE:
				case DROP:
				case EXPLAIN:
				case GRANT:
				case INSERT:
				case KILL:
				case LOAD:
				case LOCK:
				case OPTIMIZE:
				case PARTITION:
				case PURGE:
				case RELEASE:
				case RENAME:
				case REPLACE:
				case REVOKE:
				case SELECT:
				case SET:
				case SHOW:
				case UNLOCK:
				case UPDATE:
				case USE:
				case BEGIN:
				case BINLOG:
				case CACHE:
				case CHECKSUM:
				case COMMIT:
				case DEALLOCATE:
				case DO:
				case FLUSH:
				case HANDLER:
				case HELP:
				case INSTALL:
				case PREPARE:
				case REPAIR:
				case RESET:
				case ROLLBACK:
				case SAVEPOINT:
				case START:
				case STOP:
				case TRUNCATE:
				case UNINSTALL:
				case XA:
				case EXECUTE:
				case SHUTDOWN:
				case MINUSMINUS:
				case LR_BRACKET:
				case COMMA:
				case SEMI:
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 13:
				_localctx = new AlterByRenameColumnContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 2389; Match(RENAME);
				State = 2390; Match(COLUMN);
				State = 2391; ((AlterByRenameColumnContext)_localctx).oldColumn = uid();
				State = 2392; Match(TO);
				State = 2393; ((AlterByRenameColumnContext)_localctx).newColumn = uid();
				}
				break;
			case 14:
				_localctx = new AlterByLockContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 2395; Match(LOCK);
				State = 2397;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2396; Match(EQUAL_SYMBOL);
					}
				}

				State = 2399;
				((AlterByLockContext)_localctx).lockType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==EXCLUSIVE || _la==NONE || _la==SHARED) ) {
					((AlterByLockContext)_localctx).lockType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 15:
				_localctx = new AlterByModifyColumnContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 2400; Match(MODIFY);
				State = 2402;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLUMN) {
					{
					State = 2401; Match(COLUMN);
					}
				}

				State = 2404; uid();
				State = 2405; columnDefinition();
				State = 2409;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case FIRST:
					{
					State = 2406; Match(FIRST);
					}
					break;
				case AFTER:
					{
					State = 2407; Match(AFTER);
					State = 2408; uid();
					}
					break;
				case Eof:
				case ALTER:
				case ANALYZE:
				case CALL:
				case CHANGE:
				case CHECK:
				case CREATE:
				case DELETE:
				case DESC:
				case DESCRIBE:
				case DROP:
				case EXPLAIN:
				case GRANT:
				case INSERT:
				case KILL:
				case LOAD:
				case LOCK:
				case OPTIMIZE:
				case PARTITION:
				case PURGE:
				case RELEASE:
				case RENAME:
				case REPLACE:
				case REVOKE:
				case SELECT:
				case SET:
				case SHOW:
				case UNLOCK:
				case UPDATE:
				case USE:
				case BEGIN:
				case BINLOG:
				case CACHE:
				case CHECKSUM:
				case COMMIT:
				case DEALLOCATE:
				case DO:
				case FLUSH:
				case HANDLER:
				case HELP:
				case INSTALL:
				case PREPARE:
				case REPAIR:
				case RESET:
				case ROLLBACK:
				case SAVEPOINT:
				case START:
				case STOP:
				case TRUNCATE:
				case UNINSTALL:
				case XA:
				case EXECUTE:
				case SHUTDOWN:
				case MINUSMINUS:
				case LR_BRACKET:
				case COMMA:
				case SEMI:
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 16:
				_localctx = new AlterByDropColumnContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 2411; Match(DROP);
				State = 2413;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLUMN) {
					{
					State = 2412; Match(COLUMN);
					}
				}

				State = 2415; uid();
				State = 2417;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==RESTRICT) {
					{
					State = 2416; Match(RESTRICT);
					}
				}

				}
				break;
			case 17:
				_localctx = new AlterByDropPrimaryKeyContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 2419; Match(DROP);
				State = 2420; Match(PRIMARY);
				State = 2421; Match(KEY);
				}
				break;
			case 18:
				_localctx = new AlterByRenameIndexContext(_localctx);
				EnterOuterAlt(_localctx, 18);
				{
				State = 2422; Match(RENAME);
				State = 2423;
				((AlterByRenameIndexContext)_localctx).indexFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==INDEX || _la==KEY) ) {
					((AlterByRenameIndexContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2424; uid();
				State = 2425; Match(TO);
				State = 2426; uid();
				}
				break;
			case 19:
				_localctx = new AlterByDropIndexContext(_localctx);
				EnterOuterAlt(_localctx, 19);
				{
				State = 2428; Match(DROP);
				State = 2429;
				((AlterByDropIndexContext)_localctx).indexFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==INDEX || _la==KEY) ) {
					((AlterByDropIndexContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2430; uid();
				}
				break;
			case 20:
				_localctx = new AlterByDropForeignKeyContext(_localctx);
				EnterOuterAlt(_localctx, 20);
				{
				State = 2431; Match(DROP);
				State = 2432; Match(FOREIGN);
				State = 2433; Match(KEY);
				State = 2434; uid();
				}
				break;
			case 21:
				_localctx = new AlterByDisableKeysContext(_localctx);
				EnterOuterAlt(_localctx, 21);
				{
				State = 2435; Match(DISABLE);
				State = 2436; Match(KEYS);
				}
				break;
			case 22:
				_localctx = new AlterByEnableKeysContext(_localctx);
				EnterOuterAlt(_localctx, 22);
				{
				State = 2437; Match(ENABLE);
				State = 2438; Match(KEYS);
				}
				break;
			case 23:
				_localctx = new AlterByRenameContext(_localctx);
				EnterOuterAlt(_localctx, 23);
				{
				State = 2439; Match(RENAME);
				State = 2441;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS || _la==TO) {
					{
					State = 2440;
					((AlterByRenameContext)_localctx).renameFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==AS || _la==TO) ) {
						((AlterByRenameContext)_localctx).renameFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2445;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,312,Context) ) {
				case 1:
					{
					State = 2443; uid();
					}
					break;
				case 2:
					{
					State = 2444; fullId();
					}
					break;
				}
				}
				break;
			case 24:
				_localctx = new AlterByOrderContext(_localctx);
				EnterOuterAlt(_localctx, 24);
				{
				State = 2447; Match(ORDER);
				State = 2448; Match(BY);
				State = 2449; uidList();
				}
				break;
			case 25:
				_localctx = new AlterByConvertCharsetContext(_localctx);
				EnterOuterAlt(_localctx, 25);
				{
				State = 2450; Match(CONVERT);
				State = 2451; Match(TO);
				State = 2452; Match(CHARACTER);
				State = 2453; Match(SET);
				State = 2454; charsetName();
				State = 2457;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLLATE) {
					{
					State = 2455; Match(COLLATE);
					State = 2456; collationName();
					}
				}

				}
				break;
			case 26:
				_localctx = new AlterByDefaultCharsetContext(_localctx);
				EnterOuterAlt(_localctx, 26);
				{
				State = 2460;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 2459; Match(DEFAULT);
					}
				}

				State = 2462; Match(CHARACTER);
				State = 2463; Match(SET);
				State = 2464; Match(EQUAL_SYMBOL);
				State = 2465; charsetName();
				State = 2469;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLLATE) {
					{
					State = 2466; Match(COLLATE);
					State = 2467; Match(EQUAL_SYMBOL);
					State = 2468; collationName();
					}
				}

				}
				break;
			case 27:
				_localctx = new AlterByDiscardTablespaceContext(_localctx);
				EnterOuterAlt(_localctx, 27);
				{
				State = 2471; Match(DISCARD);
				State = 2472; Match(TABLESPACE);
				}
				break;
			case 28:
				_localctx = new AlterByImportTablespaceContext(_localctx);
				EnterOuterAlt(_localctx, 28);
				{
				State = 2473; Match(IMPORT);
				State = 2474; Match(TABLESPACE);
				}
				break;
			case 29:
				_localctx = new AlterByForceContext(_localctx);
				EnterOuterAlt(_localctx, 29);
				{
				State = 2475; Match(FORCE);
				}
				break;
			case 30:
				_localctx = new AlterByValidateContext(_localctx);
				EnterOuterAlt(_localctx, 30);
				{
				State = 2476;
				((AlterByValidateContext)_localctx).validationFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==WITH || _la==WITHOUT) ) {
					((AlterByValidateContext)_localctx).validationFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2477; Match(VALIDATION);
				}
				break;
			case 31:
				_localctx = new AlterByAddPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 31);
				{
				State = 2478; Match(ADD);
				State = 2479; Match(PARTITION);
				State = 2480; Match(LR_BRACKET);
				State = 2481; partitionDefinition();
				State = 2486;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2482; Match(COMMA);
					State = 2483; partitionDefinition();
					}
					}
					State = 2488;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2489; Match(RR_BRACKET);
				}
				break;
			case 32:
				_localctx = new AlterByDropPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 32);
				{
				State = 2491; Match(DROP);
				State = 2492; Match(PARTITION);
				State = 2493; uidList();
				}
				break;
			case 33:
				_localctx = new AlterByDiscardPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 33);
				{
				State = 2494; Match(DISCARD);
				State = 2495; Match(PARTITION);
				State = 2498;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2496; uidList();
					}
					break;
				case ALL:
					{
					State = 2497; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2500; Match(TABLESPACE);
				}
				break;
			case 34:
				_localctx = new AlterByImportPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 34);
				{
				State = 2501; Match(IMPORT);
				State = 2502; Match(PARTITION);
				State = 2505;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2503; uidList();
					}
					break;
				case ALL:
					{
					State = 2504; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2507; Match(TABLESPACE);
				}
				break;
			case 35:
				_localctx = new AlterByTruncatePartitionContext(_localctx);
				EnterOuterAlt(_localctx, 35);
				{
				State = 2508; Match(TRUNCATE);
				State = 2509; Match(PARTITION);
				State = 2512;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2510; uidList();
					}
					break;
				case ALL:
					{
					State = 2511; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 36:
				_localctx = new AlterByCoalescePartitionContext(_localctx);
				EnterOuterAlt(_localctx, 36);
				{
				State = 2514; Match(COALESCE);
				State = 2515; Match(PARTITION);
				State = 2516; decimalLiteral();
				}
				break;
			case 37:
				_localctx = new AlterByReorganizePartitionContext(_localctx);
				EnterOuterAlt(_localctx, 37);
				{
				State = 2517; Match(REORGANIZE);
				State = 2518; Match(PARTITION);
				State = 2519; uidList();
				State = 2520; Match(INTO);
				State = 2521; Match(LR_BRACKET);
				State = 2522; partitionDefinition();
				State = 2527;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2523; Match(COMMA);
					State = 2524; partitionDefinition();
					}
					}
					State = 2529;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2530; Match(RR_BRACKET);
				}
				break;
			case 38:
				_localctx = new AlterByExchangePartitionContext(_localctx);
				EnterOuterAlt(_localctx, 38);
				{
				State = 2532; Match(EXCHANGE);
				State = 2533; Match(PARTITION);
				State = 2534; uid();
				State = 2535; Match(WITH);
				State = 2536; Match(TABLE);
				State = 2537; tableName();
				State = 2540;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH || _la==WITHOUT) {
					{
					State = 2538;
					((AlterByExchangePartitionContext)_localctx).validationFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==WITH || _la==WITHOUT) ) {
						((AlterByExchangePartitionContext)_localctx).validationFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 2539; Match(VALIDATION);
					}
				}

				}
				break;
			case 39:
				_localctx = new AlterByAnalyzePartitionContext(_localctx);
				EnterOuterAlt(_localctx, 39);
				{
				State = 2542; Match(ANALYZE);
				State = 2543; Match(PARTITION);
				State = 2546;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2544; uidList();
					}
					break;
				case ALL:
					{
					State = 2545; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 40:
				_localctx = new AlterByCheckPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 40);
				{
				State = 2548; Match(CHECK);
				State = 2549; Match(PARTITION);
				State = 2552;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2550; uidList();
					}
					break;
				case ALL:
					{
					State = 2551; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 41:
				_localctx = new AlterByOptimizePartitionContext(_localctx);
				EnterOuterAlt(_localctx, 41);
				{
				State = 2554; Match(OPTIMIZE);
				State = 2555; Match(PARTITION);
				State = 2558;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2556; uidList();
					}
					break;
				case ALL:
					{
					State = 2557; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 42:
				_localctx = new AlterByRebuildPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 42);
				{
				State = 2560; Match(REBUILD);
				State = 2561; Match(PARTITION);
				State = 2564;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2562; uidList();
					}
					break;
				case ALL:
					{
					State = 2563; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 43:
				_localctx = new AlterByRepairPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 43);
				{
				State = 2566; Match(REPAIR);
				State = 2567; Match(PARTITION);
				State = 2570;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2568; uidList();
					}
					break;
				case ALL:
					{
					State = 2569; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 44:
				_localctx = new AlterByRemovePartitioningContext(_localctx);
				EnterOuterAlt(_localctx, 44);
				{
				State = 2572; Match(REMOVE);
				State = 2573; Match(PARTITIONING);
				}
				break;
			case 45:
				_localctx = new AlterByUpgradePartitioningContext(_localctx);
				EnterOuterAlt(_localctx, 45);
				{
				State = 2574; Match(UPGRADE);
				State = 2575; Match(PARTITIONING);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropDatabaseContext : ParserRuleContext {
		public IToken dbFormat;
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(MySqlParser.SCHEMA, 0); }
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropDatabase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropDatabase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropDatabase(this);
		}
	}

	[RuleVersion(0)]
	public DropDatabaseContext dropDatabase() {
		DropDatabaseContext _localctx = new DropDatabaseContext(Context, State);
		EnterRule(_localctx, 134, RULE_dropDatabase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2578; Match(DROP);
			State = 2579;
			_localctx.dbFormat = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DATABASE || _la==SCHEMA) ) {
				_localctx.dbFormat = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2581;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2580; ifExists();
				}
			}

			State = 2583; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropEventContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode EVENT() { return GetToken(MySqlParser.EVENT, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropEventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropEvent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropEvent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropEvent(this);
		}
	}

	[RuleVersion(0)]
	public DropEventContext dropEvent() {
		DropEventContext _localctx = new DropEventContext(Context, State);
		EnterRule(_localctx, 136, RULE_dropEvent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2585; Match(DROP);
			State = 2586; Match(EVENT);
			State = 2588;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2587; ifExists();
				}
			}

			State = 2590; fullId();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropIndexContext : ParserRuleContext {
		public IToken intimeAction;
		public IToken algType;
		public IToken lockType;
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode[] ALGORITHM() { return GetTokens(MySqlParser.ALGORITHM); }
		public ITerminalNode ALGORITHM(int i) {
			return GetToken(MySqlParser.ALGORITHM, i);
		}
		public ITerminalNode[] LOCK() { return GetTokens(MySqlParser.LOCK); }
		public ITerminalNode LOCK(int i) {
			return GetToken(MySqlParser.LOCK, i);
		}
		public ITerminalNode ONLINE() { return GetToken(MySqlParser.ONLINE, 0); }
		public ITerminalNode OFFLINE() { return GetToken(MySqlParser.OFFLINE, 0); }
		public ITerminalNode[] DEFAULT() { return GetTokens(MySqlParser.DEFAULT); }
		public ITerminalNode DEFAULT(int i) {
			return GetToken(MySqlParser.DEFAULT, i);
		}
		public ITerminalNode[] INPLACE() { return GetTokens(MySqlParser.INPLACE); }
		public ITerminalNode INPLACE(int i) {
			return GetToken(MySqlParser.INPLACE, i);
		}
		public ITerminalNode[] COPY() { return GetTokens(MySqlParser.COPY); }
		public ITerminalNode COPY(int i) {
			return GetToken(MySqlParser.COPY, i);
		}
		public ITerminalNode[] NONE() { return GetTokens(MySqlParser.NONE); }
		public ITerminalNode NONE(int i) {
			return GetToken(MySqlParser.NONE, i);
		}
		public ITerminalNode[] SHARED() { return GetTokens(MySqlParser.SHARED); }
		public ITerminalNode SHARED(int i) {
			return GetToken(MySqlParser.SHARED, i);
		}
		public ITerminalNode[] EXCLUSIVE() { return GetTokens(MySqlParser.EXCLUSIVE); }
		public ITerminalNode EXCLUSIVE(int i) {
			return GetToken(MySqlParser.EXCLUSIVE, i);
		}
		public DropIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropIndex; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropIndex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropIndex(this);
		}
	}

	[RuleVersion(0)]
	public DropIndexContext dropIndex() {
		DropIndexContext _localctx = new DropIndexContext(Context, State);
		EnterRule(_localctx, 138, RULE_dropIndex);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2592; Match(DROP);
			State = 2593; Match(INDEX);
			State = 2595;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,330,Context) ) {
			case 1:
				{
				State = 2594;
				_localctx.intimeAction = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==OFFLINE || _la==ONLINE) ) {
					_localctx.intimeAction = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 2597; uid();
			State = 2598; Match(ON);
			State = 2599; tableName();
			State = 2612;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,334,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 2610;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ALGORITHM:
						{
						State = 2600; Match(ALGORITHM);
						State = 2602;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==EQUAL_SYMBOL) {
							{
							State = 2601; Match(EQUAL_SYMBOL);
							}
						}

						State = 2604;
						_localctx.algType = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==DEFAULT || _la==COPY || _la==INPLACE) ) {
							_localctx.algType = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					case LOCK:
						{
						State = 2605; Match(LOCK);
						State = 2607;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==EQUAL_SYMBOL) {
							{
							State = 2606; Match(EQUAL_SYMBOL);
							}
						}

						State = 2609;
						_localctx.lockType = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==DEFAULT || _la==EXCLUSIVE || _la==NONE || _la==SHARED) ) {
							_localctx.lockType = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 2614;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,334,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropLogfileGroupContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode LOGFILE() { return GetToken(MySqlParser.LOGFILE, 0); }
		public ITerminalNode GROUP() { return GetToken(MySqlParser.GROUP, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public DropLogfileGroupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropLogfileGroup; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropLogfileGroup(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropLogfileGroup(this);
		}
	}

	[RuleVersion(0)]
	public DropLogfileGroupContext dropLogfileGroup() {
		DropLogfileGroupContext _localctx = new DropLogfileGroupContext(Context, State);
		EnterRule(_localctx, 140, RULE_dropLogfileGroup);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2615; Match(DROP);
			State = 2616; Match(LOGFILE);
			State = 2617; Match(GROUP);
			State = 2618; uid();
			State = 2619; Match(ENGINE);
			State = 2620; Match(EQUAL_SYMBOL);
			State = 2621; engineName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropProcedureContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropProcedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropProcedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropProcedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropProcedure(this);
		}
	}

	[RuleVersion(0)]
	public DropProcedureContext dropProcedure() {
		DropProcedureContext _localctx = new DropProcedureContext(Context, State);
		EnterRule(_localctx, 142, RULE_dropProcedure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2623; Match(DROP);
			State = 2624; Match(PROCEDURE);
			State = 2626;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2625; ifExists();
				}
			}

			State = 2628; fullId();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropFunctionContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropFunction(this);
		}
	}

	[RuleVersion(0)]
	public DropFunctionContext dropFunction() {
		DropFunctionContext _localctx = new DropFunctionContext(Context, State);
		EnterRule(_localctx, 144, RULE_dropFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2630; Match(DROP);
			State = 2631; Match(FUNCTION);
			State = 2633;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2632; ifExists();
				}
			}

			State = 2635; fullId();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropServerContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode SERVER() { return GetToken(MySqlParser.SERVER, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropServerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropServer; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropServer(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropServer(this);
		}
	}

	[RuleVersion(0)]
	public DropServerContext dropServer() {
		DropServerContext _localctx = new DropServerContext(Context, State);
		EnterRule(_localctx, 146, RULE_dropServer);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2637; Match(DROP);
			State = 2638; Match(SERVER);
			State = 2640;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2639; ifExists();
				}
			}

			State = 2642; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropTableContext : ParserRuleContext {
		public IToken dropType;
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public ITerminalNode TEMPORARY() { return GetToken(MySqlParser.TEMPORARY, 0); }
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public ITerminalNode RESTRICT() { return GetToken(MySqlParser.RESTRICT, 0); }
		public ITerminalNode CASCADE() { return GetToken(MySqlParser.CASCADE, 0); }
		public DropTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropTable(this);
		}
	}

	[RuleVersion(0)]
	public DropTableContext dropTable() {
		DropTableContext _localctx = new DropTableContext(Context, State);
		EnterRule(_localctx, 148, RULE_dropTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2644; Match(DROP);
			State = 2646;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TEMPORARY) {
				{
				State = 2645; Match(TEMPORARY);
				}
			}

			State = 2648; Match(TABLE);
			State = 2650;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2649; ifExists();
				}
			}

			State = 2652; tables();
			State = 2654;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CASCADE || _la==RESTRICT) {
				{
				State = 2653;
				_localctx.dropType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==CASCADE || _la==RESTRICT) ) {
					_localctx.dropType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropTablespaceContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public DropTablespaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropTablespace; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropTablespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropTablespace(this);
		}
	}

	[RuleVersion(0)]
	public DropTablespaceContext dropTablespace() {
		DropTablespaceContext _localctx = new DropTablespaceContext(Context, State);
		EnterRule(_localctx, 150, RULE_dropTablespace);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2656; Match(DROP);
			State = 2657; Match(TABLESPACE);
			State = 2658; uid();
			State = 2664;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ENGINE) {
				{
				State = 2659; Match(ENGINE);
				State = 2661;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2660; Match(EQUAL_SYMBOL);
					}
				}

				State = 2663; engineName();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropTriggerContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode TRIGGER() { return GetToken(MySqlParser.TRIGGER, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropTrigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropTrigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropTrigger(this);
		}
	}

	[RuleVersion(0)]
	public DropTriggerContext dropTrigger() {
		DropTriggerContext _localctx = new DropTriggerContext(Context, State);
		EnterRule(_localctx, 152, RULE_dropTrigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2666; Match(DROP);
			State = 2667; Match(TRIGGER);
			State = 2669;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2668; ifExists();
				}
			}

			State = 2671; fullId();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropViewContext : ParserRuleContext {
		public IToken dropType;
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode VIEW() { return GetToken(MySqlParser.VIEW, 0); }
		public FullIdContext[] fullId() {
			return GetRuleContexts<FullIdContext>();
		}
		public FullIdContext fullId(int i) {
			return GetRuleContext<FullIdContext>(i);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public ITerminalNode RESTRICT() { return GetToken(MySqlParser.RESTRICT, 0); }
		public ITerminalNode CASCADE() { return GetToken(MySqlParser.CASCADE, 0); }
		public DropViewContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropView; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropView(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropView(this);
		}
	}

	[RuleVersion(0)]
	public DropViewContext dropView() {
		DropViewContext _localctx = new DropViewContext(Context, State);
		EnterRule(_localctx, 154, RULE_dropView);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2673; Match(DROP);
			State = 2674; Match(VIEW);
			State = 2676;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2675; ifExists();
				}
			}

			State = 2678; fullId();
			State = 2683;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2679; Match(COMMA);
				State = 2680; fullId();
				}
				}
				State = 2685;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2687;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CASCADE || _la==RESTRICT) {
				{
				State = 2686;
				_localctx.dropType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==CASCADE || _la==RESTRICT) ) {
					_localctx.dropType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameTableContext : ParserRuleContext {
		public ITerminalNode RENAME() { return GetToken(MySqlParser.RENAME, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public RenameTableClauseContext[] renameTableClause() {
			return GetRuleContexts<RenameTableClauseContext>();
		}
		public RenameTableClauseContext renameTableClause(int i) {
			return GetRuleContext<RenameTableClauseContext>(i);
		}
		public RenameTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRenameTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRenameTable(this);
		}
	}

	[RuleVersion(0)]
	public RenameTableContext renameTable() {
		RenameTableContext _localctx = new RenameTableContext(Context, State);
		EnterRule(_localctx, 156, RULE_renameTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2689; Match(RENAME);
			State = 2690; Match(TABLE);
			State = 2691; renameTableClause();
			State = 2696;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2692; Match(COMMA);
				State = 2693; renameTableClause();
				}
				}
				State = 2698;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameTableClauseContext : ParserRuleContext {
		public TableNameContext[] tableName() {
			return GetRuleContexts<TableNameContext>();
		}
		public TableNameContext tableName(int i) {
			return GetRuleContext<TableNameContext>(i);
		}
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public RenameTableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameTableClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRenameTableClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRenameTableClause(this);
		}
	}

	[RuleVersion(0)]
	public RenameTableClauseContext renameTableClause() {
		RenameTableClauseContext _localctx = new RenameTableClauseContext(Context, State);
		EnterRule(_localctx, 158, RULE_renameTableClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2699; tableName();
			State = 2700; Match(TO);
			State = 2701; tableName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TruncateTableContext : ParserRuleContext {
		public ITerminalNode TRUNCATE() { return GetToken(MySqlParser.TRUNCATE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TruncateTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_truncateTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTruncateTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTruncateTable(this);
		}
	}

	[RuleVersion(0)]
	public TruncateTableContext truncateTable() {
		TruncateTableContext _localctx = new TruncateTableContext(Context, State);
		EnterRule(_localctx, 160, RULE_truncateTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2703; Match(TRUNCATE);
			State = 2705;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLE) {
				{
				State = 2704; Match(TABLE);
				}
			}

			State = 2707; tableName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallStatementContext : ParserRuleContext {
		public ITerminalNode CALL() { return GetToken(MySqlParser.CALL, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ConstantsContext constants() {
			return GetRuleContext<ConstantsContext>(0);
		}
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public CallStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCallStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCallStatement(this);
		}
	}

	[RuleVersion(0)]
	public CallStatementContext callStatement() {
		CallStatementContext _localctx = new CallStatementContext(Context, State);
		EnterRule(_localctx, 162, RULE_callStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2709; Match(CALL);
			State = 2710; fullId();
			State = 2717;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,350,Context) ) {
			case 1:
				{
				State = 2711; Match(LR_BRACKET);
				State = 2714;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,349,Context) ) {
				case 1:
					{
					State = 2712; constants();
					}
					break;
				case 2:
					{
					State = 2713; expressions();
					}
					break;
				}
				State = 2716; Match(RR_BRACKET);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeleteStatementContext : ParserRuleContext {
		public SingleDeleteStatementContext singleDeleteStatement() {
			return GetRuleContext<SingleDeleteStatementContext>(0);
		}
		public MultipleDeleteStatementContext multipleDeleteStatement() {
			return GetRuleContext<MultipleDeleteStatementContext>(0);
		}
		public DeleteStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deleteStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDeleteStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDeleteStatement(this);
		}
	}

	[RuleVersion(0)]
	public DeleteStatementContext deleteStatement() {
		DeleteStatementContext _localctx = new DeleteStatementContext(Context, State);
		EnterRule(_localctx, 164, RULE_deleteStatement);
		try {
			State = 2721;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,351,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2719; singleDeleteStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2720; multipleDeleteStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DoStatementContext : ParserRuleContext {
		public ITerminalNode DO() { return GetToken(MySqlParser.DO, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public DoStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_doStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDoStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDoStatement(this);
		}
	}

	[RuleVersion(0)]
	public DoStatementContext doStatement() {
		DoStatementContext _localctx = new DoStatementContext(Context, State);
		EnterRule(_localctx, 166, RULE_doStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2723; Match(DO);
			State = 2724; expressions();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandlerStatementContext : ParserRuleContext {
		public HandlerOpenStatementContext handlerOpenStatement() {
			return GetRuleContext<HandlerOpenStatementContext>(0);
		}
		public HandlerReadIndexStatementContext handlerReadIndexStatement() {
			return GetRuleContext<HandlerReadIndexStatementContext>(0);
		}
		public HandlerReadStatementContext handlerReadStatement() {
			return GetRuleContext<HandlerReadStatementContext>(0);
		}
		public HandlerCloseStatementContext handlerCloseStatement() {
			return GetRuleContext<HandlerCloseStatementContext>(0);
		}
		public HandlerStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handlerStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerStatement(this);
		}
	}

	[RuleVersion(0)]
	public HandlerStatementContext handlerStatement() {
		HandlerStatementContext _localctx = new HandlerStatementContext(Context, State);
		EnterRule(_localctx, 168, RULE_handlerStatement);
		try {
			State = 2730;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,352,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2726; handlerOpenStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2727; handlerReadIndexStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2728; handlerReadStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2729; handlerCloseStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertStatementContext : ParserRuleContext {
		public IToken priority;
		public UidListContext partitions;
		public UidListContext columns;
		public UpdatedElementContext setFirst;
		public UpdatedElementContext _updatedElement;
		public IList<UpdatedElementContext> _setElements = new List<UpdatedElementContext>();
		public UpdatedElementContext duplicatedFirst;
		public IList<UpdatedElementContext> _duplicatedElements = new List<UpdatedElementContext>();
		public ITerminalNode INSERT() { return GetToken(MySqlParser.INSERT, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public InsertStatementValueContext insertStatementValue() {
			return GetRuleContext<InsertStatementValueContext>(0);
		}
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UpdatedElementContext[] updatedElement() {
			return GetRuleContexts<UpdatedElementContext>();
		}
		public UpdatedElementContext updatedElement(int i) {
			return GetRuleContext<UpdatedElementContext>(i);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ITerminalNode DUPLICATE() { return GetToken(MySqlParser.DUPLICATE, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public UidListContext[] uidList() {
			return GetRuleContexts<UidListContext>();
		}
		public UidListContext uidList(int i) {
			return GetRuleContext<UidListContext>(i);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public ITerminalNode DELAYED() { return GetToken(MySqlParser.DELAYED, 0); }
		public ITerminalNode HIGH_PRIORITY() { return GetToken(MySqlParser.HIGH_PRIORITY, 0); }
		public InsertStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterInsertStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitInsertStatement(this);
		}
	}

	[RuleVersion(0)]
	public InsertStatementContext insertStatement() {
		InsertStatementContext _localctx = new InsertStatementContext(Context, State);
		EnterRule(_localctx, 170, RULE_insertStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2732; Match(INSERT);
			State = 2734;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 38)) & ~0x3f) == 0 && ((1L << (_la - 38)) & ((1L << (DELAYED - 38)) | (1L << (HIGH_PRIORITY - 38)) | (1L << (LOW_PRIORITY - 38)))) != 0)) {
				{
				State = 2733;
				_localctx.priority = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 38)) & ~0x3f) == 0 && ((1L << (_la - 38)) & ((1L << (DELAYED - 38)) | (1L << (HIGH_PRIORITY - 38)) | (1L << (LOW_PRIORITY - 38)))) != 0)) ) {
					_localctx.priority = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2737;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 2736; Match(IGNORE);
				}
			}

			State = 2740;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTO) {
				{
				State = 2739; Match(INTO);
				}
			}

			State = 2742; tableName();
			State = 2748;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 2743; Match(PARTITION);
				State = 2744; Match(LR_BRACKET);
				State = 2745; _localctx.partitions = uidList();
				State = 2746; Match(RR_BRACKET);
				}
			}

			State = 2766;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
			case VALUES:
			case VALUE:
			case LR_BRACKET:
				{
				State = 2754;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,357,Context) ) {
				case 1:
					{
					State = 2750; Match(LR_BRACKET);
					State = 2751; _localctx.columns = uidList();
					State = 2752; Match(RR_BRACKET);
					}
					break;
				}
				State = 2756; insertStatementValue();
				}
				break;
			case SET:
				{
				State = 2757; Match(SET);
				State = 2758; _localctx.setFirst = updatedElement();
				State = 2763;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2759; Match(COMMA);
					State = 2760; _localctx._updatedElement = updatedElement();
					_localctx._setElements.Add(_localctx._updatedElement);
					}
					}
					State = 2765;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2780;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 2768; Match(ON);
				State = 2769; Match(DUPLICATE);
				State = 2770; Match(KEY);
				State = 2771; Match(UPDATE);
				State = 2772; _localctx.duplicatedFirst = updatedElement();
				State = 2777;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2773; Match(COMMA);
					State = 2774; _localctx._updatedElement = updatedElement();
					_localctx._duplicatedElements.Add(_localctx._updatedElement);
					}
					}
					State = 2779;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoadDataStatementContext : ParserRuleContext {
		public IToken priority;
		public IToken filename;
		public IToken violation;
		public CharsetNameContext charset;
		public IToken fieldsFormat;
		public IToken linesFormat;
		public ITerminalNode LOAD() { return GetToken(MySqlParser.LOAD, 0); }
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode INFILE() { return GetToken(MySqlParser.INFILE, 0); }
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode[] SET() { return GetTokens(MySqlParser.SET); }
		public ITerminalNode SET(int i) {
			return GetToken(MySqlParser.SET, i);
		}
		public ITerminalNode[] LINES() { return GetTokens(MySqlParser.LINES); }
		public ITerminalNode LINES(int i) {
			return GetToken(MySqlParser.LINES, i);
		}
		public ITerminalNode[] IGNORE() { return GetTokens(MySqlParser.IGNORE); }
		public ITerminalNode IGNORE(int i) {
			return GetToken(MySqlParser.IGNORE, i);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public AssignmentFieldContext[] assignmentField() {
			return GetRuleContexts<AssignmentFieldContext>();
		}
		public AssignmentFieldContext assignmentField(int i) {
			return GetRuleContext<AssignmentFieldContext>(i);
		}
		public UpdatedElementContext[] updatedElement() {
			return GetRuleContexts<UpdatedElementContext>();
		}
		public UpdatedElementContext updatedElement(int i) {
			return GetRuleContext<UpdatedElementContext>(i);
		}
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public ITerminalNode CONCURRENT() { return GetToken(MySqlParser.CONCURRENT, 0); }
		public ITerminalNode REPLACE() { return GetToken(MySqlParser.REPLACE, 0); }
		public ITerminalNode FIELDS() { return GetToken(MySqlParser.FIELDS, 0); }
		public ITerminalNode COLUMNS() { return GetToken(MySqlParser.COLUMNS, 0); }
		public ITerminalNode ROWS() { return GetToken(MySqlParser.ROWS, 0); }
		public SelectFieldsIntoContext[] selectFieldsInto() {
			return GetRuleContexts<SelectFieldsIntoContext>();
		}
		public SelectFieldsIntoContext selectFieldsInto(int i) {
			return GetRuleContext<SelectFieldsIntoContext>(i);
		}
		public SelectLinesIntoContext[] selectLinesInto() {
			return GetRuleContexts<SelectLinesIntoContext>();
		}
		public SelectLinesIntoContext selectLinesInto(int i) {
			return GetRuleContext<SelectLinesIntoContext>(i);
		}
		public LoadDataStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loadDataStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLoadDataStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLoadDataStatement(this);
		}
	}

	[RuleVersion(0)]
	public LoadDataStatementContext loadDataStatement() {
		LoadDataStatementContext _localctx = new LoadDataStatementContext(Context, State);
		EnterRule(_localctx, 172, RULE_loadDataStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2782; Match(LOAD);
			State = 2783; Match(DATA);
			State = 2785;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOW_PRIORITY || _la==CONCURRENT) {
				{
				State = 2784;
				_localctx.priority = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==LOW_PRIORITY || _la==CONCURRENT) ) {
					_localctx.priority = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2788;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOCAL) {
				{
				State = 2787; Match(LOCAL);
				}
			}

			State = 2790; Match(INFILE);
			State = 2791; _localctx.filename = Match(STRING_LITERAL);
			State = 2793;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE || _la==REPLACE) {
				{
				State = 2792;
				_localctx.violation = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==IGNORE || _la==REPLACE) ) {
					_localctx.violation = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2795; Match(INTO);
			State = 2796; Match(TABLE);
			State = 2797; tableName();
			State = 2803;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 2798; Match(PARTITION);
				State = 2799; Match(LR_BRACKET);
				State = 2800; uidList();
				State = 2801; Match(RR_BRACKET);
				}
			}

			State = 2808;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CHARACTER) {
				{
				State = 2805; Match(CHARACTER);
				State = 2806; Match(SET);
				State = 2807; _localctx.charset = charsetName();
				}
			}

			State = 2816;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMNS || _la==FIELDS) {
				{
				State = 2810;
				_localctx.fieldsFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==COLUMNS || _la==FIELDS) ) {
					_localctx.fieldsFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2812;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 2811; selectFieldsInto();
					}
					}
					State = 2814;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==ENCLOSED || _la==ESCAPED || _la==OPTIONALLY || _la==TERMINATED );
				}
			}

			State = 2824;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LINES) {
				{
				State = 2818; Match(LINES);
				State = 2820;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 2819; selectLinesInto();
					}
					}
					State = 2822;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==STARTING || _la==TERMINATED );
				}
			}

			State = 2830;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 2826; Match(IGNORE);
				State = 2827; decimalLiteral();
				State = 2828;
				_localctx.linesFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==LINES || _la==ROWS) ) {
					_localctx.linesFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2843;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,373,Context) ) {
			case 1:
				{
				State = 2832; Match(LR_BRACKET);
				State = 2833; assignmentField();
				State = 2838;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2834; Match(COMMA);
					State = 2835; assignmentField();
					}
					}
					State = 2840;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2841; Match(RR_BRACKET);
				}
				break;
			}
			State = 2854;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,375,Context) ) {
			case 1:
				{
				State = 2845; Match(SET);
				State = 2846; updatedElement();
				State = 2851;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2847; Match(COMMA);
					State = 2848; updatedElement();
					}
					}
					State = 2853;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoadXmlStatementContext : ParserRuleContext {
		public IToken priority;
		public IToken filename;
		public IToken violation;
		public CharsetNameContext charset;
		public IToken tag;
		public IToken linesFormat;
		public ITerminalNode LOAD() { return GetToken(MySqlParser.LOAD, 0); }
		public ITerminalNode XML() { return GetToken(MySqlParser.XML, 0); }
		public ITerminalNode INFILE() { return GetToken(MySqlParser.INFILE, 0); }
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(MySqlParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(MySqlParser.STRING_LITERAL, i);
		}
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode[] SET() { return GetTokens(MySqlParser.SET); }
		public ITerminalNode SET(int i) {
			return GetToken(MySqlParser.SET, i);
		}
		public ITerminalNode[] ROWS() { return GetTokens(MySqlParser.ROWS); }
		public ITerminalNode ROWS(int i) {
			return GetToken(MySqlParser.ROWS, i);
		}
		public ITerminalNode IDENTIFIED() { return GetToken(MySqlParser.IDENTIFIED, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public ITerminalNode[] IGNORE() { return GetTokens(MySqlParser.IGNORE); }
		public ITerminalNode IGNORE(int i) {
			return GetToken(MySqlParser.IGNORE, i);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public AssignmentFieldContext[] assignmentField() {
			return GetRuleContexts<AssignmentFieldContext>();
		}
		public AssignmentFieldContext assignmentField(int i) {
			return GetRuleContext<AssignmentFieldContext>(i);
		}
		public UpdatedElementContext[] updatedElement() {
			return GetRuleContexts<UpdatedElementContext>();
		}
		public UpdatedElementContext updatedElement(int i) {
			return GetRuleContext<UpdatedElementContext>(i);
		}
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public ITerminalNode CONCURRENT() { return GetToken(MySqlParser.CONCURRENT, 0); }
		public ITerminalNode REPLACE() { return GetToken(MySqlParser.REPLACE, 0); }
		public ITerminalNode LINES() { return GetToken(MySqlParser.LINES, 0); }
		public LoadXmlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loadXmlStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLoadXmlStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLoadXmlStatement(this);
		}
	}

	[RuleVersion(0)]
	public LoadXmlStatementContext loadXmlStatement() {
		LoadXmlStatementContext _localctx = new LoadXmlStatementContext(Context, State);
		EnterRule(_localctx, 174, RULE_loadXmlStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2856; Match(LOAD);
			State = 2857; Match(XML);
			State = 2859;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOW_PRIORITY || _la==CONCURRENT) {
				{
				State = 2858;
				_localctx.priority = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==LOW_PRIORITY || _la==CONCURRENT) ) {
					_localctx.priority = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2862;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOCAL) {
				{
				State = 2861; Match(LOCAL);
				}
			}

			State = 2864; Match(INFILE);
			State = 2865; _localctx.filename = Match(STRING_LITERAL);
			State = 2867;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE || _la==REPLACE) {
				{
				State = 2866;
				_localctx.violation = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==IGNORE || _la==REPLACE) ) {
					_localctx.violation = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2869; Match(INTO);
			State = 2870; Match(TABLE);
			State = 2871; tableName();
			State = 2875;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CHARACTER) {
				{
				State = 2872; Match(CHARACTER);
				State = 2873; Match(SET);
				State = 2874; _localctx.charset = charsetName();
				}
			}

			State = 2883;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ROWS) {
				{
				State = 2877; Match(ROWS);
				State = 2878; Match(IDENTIFIED);
				State = 2879; Match(BY);
				State = 2880; Match(LESS_SYMBOL);
				State = 2881; _localctx.tag = Match(STRING_LITERAL);
				State = 2882; Match(GREATER_SYMBOL);
				}
			}

			State = 2889;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 2885; Match(IGNORE);
				State = 2886; decimalLiteral();
				State = 2887;
				_localctx.linesFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==LINES || _la==ROWS) ) {
					_localctx.linesFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2902;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,383,Context) ) {
			case 1:
				{
				State = 2891; Match(LR_BRACKET);
				State = 2892; assignmentField();
				State = 2897;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2893; Match(COMMA);
					State = 2894; assignmentField();
					}
					}
					State = 2899;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2900; Match(RR_BRACKET);
				}
				break;
			}
			State = 2913;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,385,Context) ) {
			case 1:
				{
				State = 2904; Match(SET);
				State = 2905; updatedElement();
				State = 2910;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2906; Match(COMMA);
					State = 2907; updatedElement();
					}
					}
					State = 2912;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReplaceStatementContext : ParserRuleContext {
		public IToken priority;
		public UidListContext partitions;
		public UidListContext columns;
		public UpdatedElementContext setFirst;
		public UpdatedElementContext _updatedElement;
		public IList<UpdatedElementContext> _setElements = new List<UpdatedElementContext>();
		public ITerminalNode REPLACE() { return GetToken(MySqlParser.REPLACE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public InsertStatementValueContext insertStatementValue() {
			return GetRuleContext<InsertStatementValueContext>(0);
		}
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UpdatedElementContext[] updatedElement() {
			return GetRuleContexts<UpdatedElementContext>();
		}
		public UpdatedElementContext updatedElement(int i) {
			return GetRuleContext<UpdatedElementContext>(i);
		}
		public UidListContext[] uidList() {
			return GetRuleContexts<UidListContext>();
		}
		public UidListContext uidList(int i) {
			return GetRuleContext<UidListContext>(i);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public ITerminalNode DELAYED() { return GetToken(MySqlParser.DELAYED, 0); }
		public ReplaceStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_replaceStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReplaceStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReplaceStatement(this);
		}
	}

	[RuleVersion(0)]
	public ReplaceStatementContext replaceStatement() {
		ReplaceStatementContext _localctx = new ReplaceStatementContext(Context, State);
		EnterRule(_localctx, 176, RULE_replaceStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2915; Match(REPLACE);
			State = 2917;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DELAYED || _la==LOW_PRIORITY) {
				{
				State = 2916;
				_localctx.priority = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DELAYED || _la==LOW_PRIORITY) ) {
					_localctx.priority = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2920;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTO) {
				{
				State = 2919; Match(INTO);
				}
			}

			State = 2922; tableName();
			State = 2928;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 2923; Match(PARTITION);
				State = 2924; Match(LR_BRACKET);
				State = 2925; _localctx.partitions = uidList();
				State = 2926; Match(RR_BRACKET);
				}
			}

			State = 2946;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
			case VALUES:
			case VALUE:
			case LR_BRACKET:
				{
				State = 2934;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,389,Context) ) {
				case 1:
					{
					State = 2930; Match(LR_BRACKET);
					State = 2931; _localctx.columns = uidList();
					State = 2932; Match(RR_BRACKET);
					}
					break;
				}
				State = 2936; insertStatementValue();
				}
				break;
			case SET:
				{
				State = 2937; Match(SET);
				State = 2938; _localctx.setFirst = updatedElement();
				State = 2943;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2939; Match(COMMA);
					State = 2940; _localctx._updatedElement = updatedElement();
					_localctx._setElements.Add(_localctx._updatedElement);
					}
					}
					State = 2945;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectStatementContext : ParserRuleContext {
		public SelectStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectStatement; } }
	 
		public SelectStatementContext() { }
		public virtual void CopyFrom(SelectStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class UnionSelectContext : SelectStatementContext {
		public IToken unionType;
		public QuerySpecificationNointoContext querySpecificationNointo() {
			return GetRuleContext<QuerySpecificationNointoContext>(0);
		}
		public UnionStatementContext[] unionStatement() {
			return GetRuleContexts<UnionStatementContext>();
		}
		public UnionStatementContext unionStatement(int i) {
			return GetRuleContext<UnionStatementContext>(i);
		}
		public ITerminalNode UNION() { return GetToken(MySqlParser.UNION, 0); }
		public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public LimitClauseContext limitClause() {
			return GetRuleContext<LimitClauseContext>(0);
		}
		public LockClauseContext lockClause() {
			return GetRuleContext<LockClauseContext>(0);
		}
		public QuerySpecificationContext querySpecification() {
			return GetRuleContext<QuerySpecificationContext>(0);
		}
		public QueryExpressionContext queryExpression() {
			return GetRuleContext<QueryExpressionContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(MySqlParser.DISTINCT, 0); }
		public UnionSelectContext(SelectStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnionSelect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnionSelect(this);
		}
	}
	public partial class UnionParenthesisSelectContext : SelectStatementContext {
		public IToken unionType;
		public QueryExpressionNointoContext queryExpressionNointo() {
			return GetRuleContext<QueryExpressionNointoContext>(0);
		}
		public UnionParenthesisContext[] unionParenthesis() {
			return GetRuleContexts<UnionParenthesisContext>();
		}
		public UnionParenthesisContext unionParenthesis(int i) {
			return GetRuleContext<UnionParenthesisContext>(i);
		}
		public ITerminalNode UNION() { return GetToken(MySqlParser.UNION, 0); }
		public QueryExpressionContext queryExpression() {
			return GetRuleContext<QueryExpressionContext>(0);
		}
		public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public LimitClauseContext limitClause() {
			return GetRuleContext<LimitClauseContext>(0);
		}
		public LockClauseContext lockClause() {
			return GetRuleContext<LockClauseContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(MySqlParser.DISTINCT, 0); }
		public UnionParenthesisSelectContext(SelectStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnionParenthesisSelect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnionParenthesisSelect(this);
		}
	}
	public partial class SimpleSelectContext : SelectStatementContext {
		public QuerySpecificationContext querySpecification() {
			return GetRuleContext<QuerySpecificationContext>(0);
		}
		public LockClauseContext lockClause() {
			return GetRuleContext<LockClauseContext>(0);
		}
		public SimpleSelectContext(SelectStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleSelect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleSelect(this);
		}
	}
	public partial class ParenthesisSelectContext : SelectStatementContext {
		public QueryExpressionContext queryExpression() {
			return GetRuleContext<QueryExpressionContext>(0);
		}
		public LockClauseContext lockClause() {
			return GetRuleContext<LockClauseContext>(0);
		}
		public ParenthesisSelectContext(SelectStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterParenthesisSelect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitParenthesisSelect(this);
		}
	}

	[RuleVersion(0)]
	public SelectStatementContext selectStatement() {
		SelectStatementContext _localctx = new SelectStatementContext(Context, State);
		EnterRule(_localctx, 178, RULE_selectStatement);
		int _la;
		try {
			int _alt;
			State = 3003;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,407,Context) ) {
			case 1:
				_localctx = new SimpleSelectContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 2948; querySpecification();
				State = 2950;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,392,Context) ) {
				case 1:
					{
					State = 2949; lockClause();
					}
					break;
				}
				}
				break;
			case 2:
				_localctx = new ParenthesisSelectContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 2952; queryExpression();
				State = 2954;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,393,Context) ) {
				case 1:
					{
					State = 2953; lockClause();
					}
					break;
				}
				}
				break;
			case 3:
				_localctx = new UnionSelectContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 2956; querySpecificationNointo();
				State = 2958;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 2957; unionStatement();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2960;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,394,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 2970;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNION) {
					{
					State = 2962; Match(UNION);
					State = 2964;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==ALL || _la==DISTINCT) {
						{
						State = 2963;
						((UnionSelectContext)_localctx).unionType = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==ALL || _la==DISTINCT) ) {
							((UnionSelectContext)_localctx).unionType = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					State = 2968;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case SELECT:
						{
						State = 2966; querySpecification();
						}
						break;
					case LR_BRACKET:
						{
						State = 2967; queryExpression();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				State = 2973;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ORDER) {
					{
					State = 2972; orderByClause();
					}
				}

				State = 2976;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIMIT) {
					{
					State = 2975; limitClause();
					}
				}

				State = 2979;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,400,Context) ) {
				case 1:
					{
					State = 2978; lockClause();
					}
					break;
				}
				}
				break;
			case 4:
				_localctx = new UnionParenthesisSelectContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 2981; queryExpressionNointo();
				State = 2983;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 2982; unionParenthesis();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2985;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,401,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 2992;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNION) {
					{
					State = 2987; Match(UNION);
					State = 2989;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==ALL || _la==DISTINCT) {
						{
						State = 2988;
						((UnionParenthesisSelectContext)_localctx).unionType = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==ALL || _la==DISTINCT) ) {
							((UnionParenthesisSelectContext)_localctx).unionType = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					State = 2991; queryExpression();
					}
				}

				State = 2995;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ORDER) {
					{
					State = 2994; orderByClause();
					}
				}

				State = 2998;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIMIT) {
					{
					State = 2997; limitClause();
					}
				}

				State = 3001;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,406,Context) ) {
				case 1:
					{
					State = 3000; lockClause();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UpdateStatementContext : ParserRuleContext {
		public SingleUpdateStatementContext singleUpdateStatement() {
			return GetRuleContext<SingleUpdateStatementContext>(0);
		}
		public MultipleUpdateStatementContext multipleUpdateStatement() {
			return GetRuleContext<MultipleUpdateStatementContext>(0);
		}
		public UpdateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_updateStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUpdateStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUpdateStatement(this);
		}
	}

	[RuleVersion(0)]
	public UpdateStatementContext updateStatement() {
		UpdateStatementContext _localctx = new UpdateStatementContext(Context, State);
		EnterRule(_localctx, 180, RULE_updateStatement);
		try {
			State = 3007;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,408,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3005; singleUpdateStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3006; multipleUpdateStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertStatementValueContext : ParserRuleContext {
		public IToken insertFormat;
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ExpressionsWithDefaultsContext[] expressionsWithDefaults() {
			return GetRuleContexts<ExpressionsWithDefaultsContext>();
		}
		public ExpressionsWithDefaultsContext expressionsWithDefaults(int i) {
			return GetRuleContext<ExpressionsWithDefaultsContext>(i);
		}
		public ITerminalNode VALUES() { return GetToken(MySqlParser.VALUES, 0); }
		public ITerminalNode VALUE() { return GetToken(MySqlParser.VALUE, 0); }
		public InsertStatementValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertStatementValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterInsertStatementValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitInsertStatementValue(this);
		}
	}

	[RuleVersion(0)]
	public InsertStatementValueContext insertStatementValue() {
		InsertStatementValueContext _localctx = new InsertStatementValueContext(Context, State);
		EnterRule(_localctx, 182, RULE_insertStatementValue);
		int _la;
		try {
			State = 3024;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
			case LR_BRACKET:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3009; selectStatement();
				}
				break;
			case VALUES:
			case VALUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3010;
				_localctx.insertFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==VALUES || _la==VALUE) ) {
					_localctx.insertFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3011; Match(LR_BRACKET);
				State = 3012; expressionsWithDefaults();
				State = 3013; Match(RR_BRACKET);
				State = 3021;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3014; Match(COMMA);
					State = 3015; Match(LR_BRACKET);
					State = 3016; expressionsWithDefaults();
					State = 3017; Match(RR_BRACKET);
					}
					}
					State = 3023;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UpdatedElementContext : ParserRuleContext {
		public FullColumnNameContext fullColumnName() {
			return GetRuleContext<FullColumnNameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public UpdatedElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_updatedElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUpdatedElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUpdatedElement(this);
		}
	}

	[RuleVersion(0)]
	public UpdatedElementContext updatedElement() {
		UpdatedElementContext _localctx = new UpdatedElementContext(Context, State);
		EnterRule(_localctx, 184, RULE_updatedElement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3026; fullColumnName();
			State = 3027; Match(EQUAL_SYMBOL);
			State = 3030;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CASE:
			case CAST:
			case CONVERT:
			case CURRENT_USER:
			case DATABASE:
			case EXISTS:
			case FALSE:
			case IF:
			case INSERT:
			case INTERVAL:
			case LEFT:
			case NOT:
			case NULL_LITERAL:
			case REPLACE:
			case RIGHT:
			case TRUE:
			case VALUES:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case CHAR:
			case BINARY:
			case TEXT:
			case ENUM:
			case SERIAL:
			case AVG:
			case BIT_AND:
			case BIT_OR:
			case BIT_XOR:
			case COUNT:
			case GROUP_CONCAT:
			case MAX:
			case MIN:
			case STD:
			case STDDEV:
			case STDDEV_POP:
			case STDDEV_SAMP:
			case SUM:
			case VAR_POP:
			case VAR_SAMP:
			case VARIANCE:
			case CURRENT_DATE:
			case CURRENT_TIME:
			case CURRENT_TIMESTAMP:
			case LOCALTIME:
			case CURDATE:
			case CURTIME:
			case DATE_ADD:
			case DATE_SUB:
			case EXTRACT:
			case LOCALTIMESTAMP:
			case NOW:
			case POSITION:
			case SUBSTR:
			case SUBSTRING:
			case SYSDATE:
			case TRIM:
			case UTC_DATE:
			case UTC_TIME:
			case UTC_TIMESTAMP:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case PLUS:
			case MINUS:
			case EXCLAMATION_SYMBOL:
			case BIT_NOT_OP:
			case LR_BRACKET:
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case CHARSET_REVERSE_QOUTE_STRING:
			case START_NATIONAL_STRING_LITERAL:
			case STRING_LITERAL:
			case DECIMAL_LITERAL:
			case HEXADECIMAL_LITERAL:
			case REAL_LITERAL:
			case NULL_SPEC_LITERAL:
			case BIT_STRING:
			case STRING_CHARSET_NAME:
			case ID:
			case REVERSE_QUOTE_ID:
			case LOCAL_ID:
			case GLOBAL_ID:
				{
				State = 3028; expression(0);
				}
				break;
			case DEFAULT:
				{
				State = 3029; Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentFieldContext : ParserRuleContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode LOCAL_ID() { return GetToken(MySqlParser.LOCAL_ID, 0); }
		public AssignmentFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignmentField; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAssignmentField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAssignmentField(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentFieldContext assignmentField() {
		AssignmentFieldContext _localctx = new AssignmentFieldContext(Context, State);
		EnterRule(_localctx, 186, RULE_assignmentField);
		try {
			State = 3034;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DATABASE:
			case LEFT:
			case RIGHT:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case TEXT:
			case ENUM:
			case SERIAL:
			case COUNT:
			case POSITION:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case CHARSET_REVERSE_QOUTE_STRING:
			case STRING_LITERAL:
			case ID:
			case REVERSE_QUOTE_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3032; uid();
				}
				break;
			case LOCAL_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3033; Match(LOCAL_ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockClauseContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public ITerminalNode SHARE() { return GetToken(MySqlParser.SHARE, 0); }
		public ITerminalNode MODE() { return GetToken(MySqlParser.MODE, 0); }
		public LockClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLockClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLockClause(this);
		}
	}

	[RuleVersion(0)]
	public LockClauseContext lockClause() {
		LockClauseContext _localctx = new LockClauseContext(Context, State);
		EnterRule(_localctx, 188, RULE_lockClause);
		try {
			State = 3042;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FOR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3036; Match(FOR);
				State = 3037; Match(UPDATE);
				}
				break;
			case LOCK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3038; Match(LOCK);
				State = 3039; Match(IN);
				State = 3040; Match(SHARE);
				State = 3041; Match(MODE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleDeleteStatementContext : ParserRuleContext {
		public IToken priority;
		public ITerminalNode DELETE() { return GetToken(MySqlParser.DELETE, 0); }
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode QUICK() { return GetToken(MySqlParser.QUICK, 0); }
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public SingleDeleteStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleDeleteStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSingleDeleteStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSingleDeleteStatement(this);
		}
	}

	[RuleVersion(0)]
	public SingleDeleteStatementContext singleDeleteStatement() {
		SingleDeleteStatementContext _localctx = new SingleDeleteStatementContext(Context, State);
		EnterRule(_localctx, 190, RULE_singleDeleteStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3044; Match(DELETE);
			State = 3046;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOW_PRIORITY) {
				{
				State = 3045; _localctx.priority = Match(LOW_PRIORITY);
				}
			}

			State = 3049;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==QUICK) {
				{
				State = 3048; Match(QUICK);
				}
			}

			State = 3052;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 3051; Match(IGNORE);
				}
			}

			State = 3054; Match(FROM);
			State = 3055; tableName();
			State = 3061;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 3056; Match(PARTITION);
				State = 3057; Match(LR_BRACKET);
				State = 3058; uidList();
				State = 3059; Match(RR_BRACKET);
				}
			}

			State = 3065;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3063; Match(WHERE);
				State = 3064; expression(0);
				}
			}

			State = 3068;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 3067; orderByClause();
				}
			}

			State = 3072;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LIMIT) {
				{
				State = 3070; Match(LIMIT);
				State = 3071; decimalLiteral();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultipleDeleteStatementContext : ParserRuleContext {
		public IToken priority;
		public ITerminalNode DELETE() { return GetToken(MySqlParser.DELETE, 0); }
		public TableNameContext[] tableName() {
			return GetRuleContexts<TableNameContext>();
		}
		public TableNameContext tableName(int i) {
			return GetRuleContext<TableNameContext>(i);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public TableSourcesContext tableSources() {
			return GetRuleContext<TableSourcesContext>(0);
		}
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public ITerminalNode QUICK() { return GetToken(MySqlParser.QUICK, 0); }
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public MultipleDeleteStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multipleDeleteStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMultipleDeleteStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMultipleDeleteStatement(this);
		}
	}

	[RuleVersion(0)]
	public MultipleDeleteStatementContext multipleDeleteStatement() {
		MultipleDeleteStatementContext _localctx = new MultipleDeleteStatementContext(Context, State);
		EnterRule(_localctx, 192, RULE_multipleDeleteStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3074; Match(DELETE);
			State = 3076;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOW_PRIORITY) {
				{
				State = 3075; _localctx.priority = Match(LOW_PRIORITY);
				}
			}

			State = 3079;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,422,Context) ) {
			case 1:
				{
				State = 3078; Match(QUICK);
				}
				break;
			}
			State = 3082;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 3081; Match(IGNORE);
				}
			}

			State = 3123;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DATABASE:
			case LEFT:
			case RIGHT:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case TEXT:
			case ENUM:
			case SERIAL:
			case COUNT:
			case POSITION:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case CHARSET_REVERSE_QOUTE_STRING:
			case STRING_LITERAL:
			case ID:
			case REVERSE_QUOTE_ID:
				{
				State = 3084; tableName();
				State = 3087;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOT) {
					{
					State = 3085; Match(DOT);
					State = 3086; Match(STAR);
					}
				}

				State = 3097;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3089; Match(COMMA);
					State = 3090; tableName();
					State = 3093;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DOT) {
						{
						State = 3091; Match(DOT);
						State = 3092; Match(STAR);
						}
					}

					}
					}
					State = 3099;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3100; Match(FROM);
				State = 3101; tableSources();
				}
				break;
			case FROM:
				{
				State = 3103; Match(FROM);
				State = 3104; tableName();
				State = 3107;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOT) {
					{
					State = 3105; Match(DOT);
					State = 3106; Match(STAR);
					}
				}

				State = 3117;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3109; Match(COMMA);
					State = 3110; tableName();
					State = 3113;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DOT) {
						{
						State = 3111; Match(DOT);
						State = 3112; Match(STAR);
						}
					}

					}
					}
					State = 3119;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3120; Match(USING);
				State = 3121; tableSources();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3127;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3125; Match(WHERE);
				State = 3126; expression(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandlerOpenStatementContext : ParserRuleContext {
		public ITerminalNode HANDLER() { return GetToken(MySqlParser.HANDLER, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode OPEN() { return GetToken(MySqlParser.OPEN, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public HandlerOpenStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handlerOpenStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerOpenStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerOpenStatement(this);
		}
	}

	[RuleVersion(0)]
	public HandlerOpenStatementContext handlerOpenStatement() {
		HandlerOpenStatementContext _localctx = new HandlerOpenStatementContext(Context, State);
		EnterRule(_localctx, 194, RULE_handlerOpenStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3129; Match(HANDLER);
			State = 3130; tableName();
			State = 3131; Match(OPEN);
			State = 3136;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,433,Context) ) {
			case 1:
				{
				State = 3133;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 3132; Match(AS);
					}
				}

				State = 3135; uid();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandlerReadIndexStatementContext : ParserRuleContext {
		public UidContext index;
		public IToken moveOrder;
		public ITerminalNode HANDLER() { return GetToken(MySqlParser.HANDLER, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ComparisonOperatorContext comparisonOperator() {
			return GetRuleContext<ComparisonOperatorContext>(0);
		}
		public ConstantsContext constants() {
			return GetRuleContext<ConstantsContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode NEXT() { return GetToken(MySqlParser.NEXT, 0); }
		public ITerminalNode PREV() { return GetToken(MySqlParser.PREV, 0); }
		public ITerminalNode LAST() { return GetToken(MySqlParser.LAST, 0); }
		public HandlerReadIndexStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handlerReadIndexStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerReadIndexStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerReadIndexStatement(this);
		}
	}

	[RuleVersion(0)]
	public HandlerReadIndexStatementContext handlerReadIndexStatement() {
		HandlerReadIndexStatementContext _localctx = new HandlerReadIndexStatementContext(Context, State);
		EnterRule(_localctx, 196, RULE_handlerReadIndexStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3138; Match(HANDLER);
			State = 3139; tableName();
			State = 3140; Match(READ);
			State = 3141; _localctx.index = uid();
			State = 3148;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EQUAL_SYMBOL:
			case GREATER_SYMBOL:
			case LESS_SYMBOL:
			case EXCLAMATION_SYMBOL:
				{
				State = 3142; comparisonOperator();
				State = 3143; Match(LR_BRACKET);
				State = 3144; constants();
				State = 3145; Match(RR_BRACKET);
				}
				break;
			case FIRST:
			case LAST:
			case NEXT:
			case PREV:
				{
				State = 3147;
				_localctx.moveOrder = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FIRST || _la==LAST || _la==NEXT || _la==PREV) ) {
					_localctx.moveOrder = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3152;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3150; Match(WHERE);
				State = 3151; expression(0);
				}
			}

			State = 3156;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LIMIT) {
				{
				State = 3154; Match(LIMIT);
				State = 3155; decimalLiteral();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandlerReadStatementContext : ParserRuleContext {
		public IToken moveOrder;
		public ITerminalNode HANDLER() { return GetToken(MySqlParser.HANDLER, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode NEXT() { return GetToken(MySqlParser.NEXT, 0); }
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public HandlerReadStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handlerReadStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerReadStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerReadStatement(this);
		}
	}

	[RuleVersion(0)]
	public HandlerReadStatementContext handlerReadStatement() {
		HandlerReadStatementContext _localctx = new HandlerReadStatementContext(Context, State);
		EnterRule(_localctx, 198, RULE_handlerReadStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3158; Match(HANDLER);
			State = 3159; tableName();
			State = 3160; Match(READ);
			State = 3161;
			_localctx.moveOrder = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==FIRST || _la==NEXT) ) {
				_localctx.moveOrder = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3164;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3162; Match(WHERE);
				State = 3163; expression(0);
				}
			}

			State = 3168;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LIMIT) {
				{
				State = 3166; Match(LIMIT);
				State = 3167; decimalLiteral();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandlerCloseStatementContext : ParserRuleContext {
		public ITerminalNode HANDLER() { return GetToken(MySqlParser.HANDLER, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode CLOSE() { return GetToken(MySqlParser.CLOSE, 0); }
		public HandlerCloseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handlerCloseStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerCloseStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerCloseStatement(this);
		}
	}

	[RuleVersion(0)]
	public HandlerCloseStatementContext handlerCloseStatement() {
		HandlerCloseStatementContext _localctx = new HandlerCloseStatementContext(Context, State);
		EnterRule(_localctx, 200, RULE_handlerCloseStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3170; Match(HANDLER);
			State = 3171; tableName();
			State = 3172; Match(CLOSE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleUpdateStatementContext : ParserRuleContext {
		public IToken priority;
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public UpdatedElementContext[] updatedElement() {
			return GetRuleContexts<UpdatedElementContext>();
		}
		public UpdatedElementContext updatedElement(int i) {
			return GetRuleContext<UpdatedElementContext>(i);
		}
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public LimitClauseContext limitClause() {
			return GetRuleContext<LimitClauseContext>(0);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SingleUpdateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleUpdateStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSingleUpdateStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSingleUpdateStatement(this);
		}
	}

	[RuleVersion(0)]
	public SingleUpdateStatementContext singleUpdateStatement() {
		SingleUpdateStatementContext _localctx = new SingleUpdateStatementContext(Context, State);
		EnterRule(_localctx, 202, RULE_singleUpdateStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3174; Match(UPDATE);
			State = 3176;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOW_PRIORITY) {
				{
				State = 3175; _localctx.priority = Match(LOW_PRIORITY);
				}
			}

			State = 3179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 3178; Match(IGNORE);
				}
			}

			State = 3181; tableName();
			State = 3186;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
				{
				State = 3183;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 3182; Match(AS);
					}
				}

				State = 3185; uid();
				}
			}

			State = 3188; Match(SET);
			State = 3189; updatedElement();
			State = 3194;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3190; Match(COMMA);
				State = 3191; updatedElement();
				}
				}
				State = 3196;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3199;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3197; Match(WHERE);
				State = 3198; expression(0);
				}
			}

			State = 3202;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 3201; orderByClause();
				}
			}

			State = 3205;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LIMIT) {
				{
				State = 3204; limitClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultipleUpdateStatementContext : ParserRuleContext {
		public IToken priority;
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public TableSourcesContext tableSources() {
			return GetRuleContext<TableSourcesContext>(0);
		}
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public UpdatedElementContext[] updatedElement() {
			return GetRuleContexts<UpdatedElementContext>();
		}
		public UpdatedElementContext updatedElement(int i) {
			return GetRuleContext<UpdatedElementContext>(i);
		}
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public MultipleUpdateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multipleUpdateStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMultipleUpdateStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMultipleUpdateStatement(this);
		}
	}

	[RuleVersion(0)]
	public MultipleUpdateStatementContext multipleUpdateStatement() {
		MultipleUpdateStatementContext _localctx = new MultipleUpdateStatementContext(Context, State);
		EnterRule(_localctx, 204, RULE_multipleUpdateStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3207; Match(UPDATE);
			State = 3209;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOW_PRIORITY) {
				{
				State = 3208; _localctx.priority = Match(LOW_PRIORITY);
				}
			}

			State = 3212;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 3211; Match(IGNORE);
				}
			}

			State = 3214; tableSources();
			State = 3215; Match(SET);
			State = 3216; updatedElement();
			State = 3221;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3217; Match(COMMA);
				State = 3218; updatedElement();
				}
				}
				State = 3223;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3226;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3224; Match(WHERE);
				State = 3225; expression(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByClauseContext : ParserRuleContext {
		public ITerminalNode ORDER() { return GetToken(MySqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public OrderByExpressionContext[] orderByExpression() {
			return GetRuleContexts<OrderByExpressionContext>();
		}
		public OrderByExpressionContext orderByExpression(int i) {
			return GetRuleContext<OrderByExpressionContext>(i);
		}
		public OrderByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterOrderByClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitOrderByClause(this);
		}
	}

	[RuleVersion(0)]
	public OrderByClauseContext orderByClause() {
		OrderByClauseContext _localctx = new OrderByClauseContext(Context, State);
		EnterRule(_localctx, 206, RULE_orderByClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3228; Match(ORDER);
			State = 3229; Match(BY);
			State = 3230; orderByExpression();
			State = 3235;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3231; Match(COMMA);
				State = 3232; orderByExpression();
				}
				}
				State = 3237;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByExpressionContext : ParserRuleContext {
		public IToken order;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASC() { return GetToken(MySqlParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(MySqlParser.DESC, 0); }
		public OrderByExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterOrderByExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitOrderByExpression(this);
		}
	}

	[RuleVersion(0)]
	public OrderByExpressionContext orderByExpression() {
		OrderByExpressionContext _localctx = new OrderByExpressionContext(Context, State);
		EnterRule(_localctx, 208, RULE_orderByExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3238; expression(0);
			State = 3240;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,452,Context) ) {
			case 1:
				{
				State = 3239;
				_localctx.order = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ASC || _la==DESC) ) {
					_localctx.order = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableSourcesContext : ParserRuleContext {
		public TableSourceContext[] tableSource() {
			return GetRuleContexts<TableSourceContext>();
		}
		public TableSourceContext tableSource(int i) {
			return GetRuleContext<TableSourceContext>(i);
		}
		public TableSourcesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableSources; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableSources(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableSources(this);
		}
	}

	[RuleVersion(0)]
	public TableSourcesContext tableSources() {
		TableSourcesContext _localctx = new TableSourcesContext(Context, State);
		EnterRule(_localctx, 210, RULE_tableSources);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3242; tableSource();
			State = 3247;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3243; Match(COMMA);
				State = 3244; tableSource();
				}
				}
				State = 3249;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableSourceContext : ParserRuleContext {
		public TableSourceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableSource; } }
	 
		public TableSourceContext() { }
		public virtual void CopyFrom(TableSourceContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TableSourceNestedContext : TableSourceContext {
		public TableSourceItemContext tableSourceItem() {
			return GetRuleContext<TableSourceItemContext>(0);
		}
		public JoinPartContext[] joinPart() {
			return GetRuleContexts<JoinPartContext>();
		}
		public JoinPartContext joinPart(int i) {
			return GetRuleContext<JoinPartContext>(i);
		}
		public TableSourceNestedContext(TableSourceContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableSourceNested(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableSourceNested(this);
		}
	}
	public partial class TableSourceBaseContext : TableSourceContext {
		public TableSourceItemContext tableSourceItem() {
			return GetRuleContext<TableSourceItemContext>(0);
		}
		public JoinPartContext[] joinPart() {
			return GetRuleContexts<JoinPartContext>();
		}
		public JoinPartContext joinPart(int i) {
			return GetRuleContext<JoinPartContext>(i);
		}
		public TableSourceBaseContext(TableSourceContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableSourceBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableSourceBase(this);
		}
	}

	[RuleVersion(0)]
	public TableSourceContext tableSource() {
		TableSourceContext _localctx = new TableSourceContext(Context, State);
		EnterRule(_localctx, 212, RULE_tableSource);
		int _la;
		try {
			int _alt;
			State = 3267;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,456,Context) ) {
			case 1:
				_localctx = new TableSourceBaseContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3250; tableSourceItem();
				State = 3254;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,454,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 3251; joinPart();
						}
						} 
					}
					State = 3256;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,454,Context);
				}
				}
				break;
			case 2:
				_localctx = new TableSourceNestedContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3257; Match(LR_BRACKET);
				State = 3258; tableSourceItem();
				State = 3262;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (((((_la - 31)) & ~0x3f) == 0 && ((1L << (_la - 31)) & ((1L << (CROSS - 31)) | (1L << (INNER - 31)) | (1L << (JOIN - 31)) | (1L << (LEFT - 31)))) != 0) || ((((_la - 98)) & ~0x3f) == 0 && ((1L << (_la - 98)) & ((1L << (NATURAL - 98)) | (1L << (RIGHT - 98)) | (1L << (STRAIGHT_JOIN - 98)))) != 0)) {
					{
					{
					State = 3259; joinPart();
					}
					}
					State = 3264;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3265; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableSourceItemContext : ParserRuleContext {
		public TableSourceItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableSourceItem; } }
	 
		public TableSourceItemContext() { }
		public virtual void CopyFrom(TableSourceItemContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SubqueryTableItemContext : TableSourceItemContext {
		public SelectStatementContext parenthesisSubquery;
		public UidContext alias;
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SubqueryTableItemContext(TableSourceItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubqueryTableItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubqueryTableItem(this);
		}
	}
	public partial class AtomTableItemContext : TableSourceItemContext {
		public UidContext alias;
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public IndexHintContext[] indexHint() {
			return GetRuleContexts<IndexHintContext>();
		}
		public IndexHintContext indexHint(int i) {
			return GetRuleContext<IndexHintContext>(i);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public AtomTableItemContext(TableSourceItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAtomTableItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAtomTableItem(this);
		}
	}
	public partial class TableSourcesItemContext : TableSourceItemContext {
		public TableSourcesContext tableSources() {
			return GetRuleContext<TableSourcesContext>(0);
		}
		public TableSourcesItemContext(TableSourceItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableSourcesItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableSourcesItem(this);
		}
	}

	[RuleVersion(0)]
	public TableSourceItemContext tableSourceItem() {
		TableSourceItemContext _localctx = new TableSourceItemContext(Context, State);
		EnterRule(_localctx, 214, RULE_tableSourceItem);
		int _la;
		try {
			int _alt;
			State = 3309;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,464,Context) ) {
			case 1:
				_localctx = new AtomTableItemContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3269; tableName();
				State = 3275;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PARTITION) {
					{
					State = 3270; Match(PARTITION);
					State = 3271; Match(LR_BRACKET);
					State = 3272; uidList();
					State = 3273; Match(RR_BRACKET);
					}
				}

				State = 3281;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,459,Context) ) {
				case 1:
					{
					State = 3278;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AS) {
						{
						State = 3277; Match(AS);
						}
					}

					State = 3280; ((AtomTableItemContext)_localctx).alias = uid();
					}
					break;
				}
				State = 3291;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,461,Context) ) {
				case 1:
					{
					State = 3283; indexHint();
					State = 3288;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,460,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 3284; Match(COMMA);
							State = 3285; indexHint();
							}
							} 
						}
						State = 3290;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,460,Context);
					}
					}
					break;
				}
				}
				break;
			case 2:
				_localctx = new SubqueryTableItemContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3298;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,462,Context) ) {
				case 1:
					{
					State = 3293; selectStatement();
					}
					break;
				case 2:
					{
					State = 3294; Match(LR_BRACKET);
					State = 3295; ((SubqueryTableItemContext)_localctx).parenthesisSubquery = selectStatement();
					State = 3296; Match(RR_BRACKET);
					}
					break;
				}
				State = 3301;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 3300; Match(AS);
					}
				}

				State = 3303; ((SubqueryTableItemContext)_localctx).alias = uid();
				}
				break;
			case 3:
				_localctx = new TableSourcesItemContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3305; Match(LR_BRACKET);
				State = 3306; tableSources();
				State = 3307; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexHintContext : ParserRuleContext {
		public IToken indexHintAction;
		public IToken keyFormat;
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode USE() { return GetToken(MySqlParser.USE, 0); }
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode FORCE() { return GetToken(MySqlParser.FORCE, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public IndexHintTypeContext indexHintType() {
			return GetRuleContext<IndexHintTypeContext>(0);
		}
		public IndexHintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexHint; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexHint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexHint(this);
		}
	}

	[RuleVersion(0)]
	public IndexHintContext indexHint() {
		IndexHintContext _localctx = new IndexHintContext(Context, State);
		EnterRule(_localctx, 216, RULE_indexHint);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3311;
			_localctx.indexHintAction = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==FORCE || _la==IGNORE || _la==USE) ) {
				_localctx.indexHintAction = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3312;
			_localctx.keyFormat = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==INDEX || _la==KEY) ) {
				_localctx.keyFormat = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3315;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 3313; Match(FOR);
				State = 3314; indexHintType();
				}
			}

			State = 3317; Match(LR_BRACKET);
			State = 3318; uidList();
			State = 3319; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexHintTypeContext : ParserRuleContext {
		public ITerminalNode JOIN() { return GetToken(MySqlParser.JOIN, 0); }
		public ITerminalNode ORDER() { return GetToken(MySqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public ITerminalNode GROUP() { return GetToken(MySqlParser.GROUP, 0); }
		public IndexHintTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexHintType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexHintType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexHintType(this);
		}
	}

	[RuleVersion(0)]
	public IndexHintTypeContext indexHintType() {
		IndexHintTypeContext _localctx = new IndexHintTypeContext(Context, State);
		EnterRule(_localctx, 218, RULE_indexHintType);
		try {
			State = 3326;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case JOIN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3321; Match(JOIN);
				}
				break;
			case ORDER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3322; Match(ORDER);
				State = 3323; Match(BY);
				}
				break;
			case GROUP:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3324; Match(GROUP);
				State = 3325; Match(BY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JoinPartContext : ParserRuleContext {
		public JoinPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_joinPart; } }
	 
		public JoinPartContext() { }
		public virtual void CopyFrom(JoinPartContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class InnerJoinContext : JoinPartContext {
		public ITerminalNode JOIN() { return GetToken(MySqlParser.JOIN, 0); }
		public TableSourceItemContext tableSourceItem() {
			return GetRuleContext<TableSourceItemContext>(0);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode INNER() { return GetToken(MySqlParser.INNER, 0); }
		public ITerminalNode CROSS() { return GetToken(MySqlParser.CROSS, 0); }
		public InnerJoinContext(JoinPartContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterInnerJoin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitInnerJoin(this);
		}
	}
	public partial class NaturalJoinContext : JoinPartContext {
		public ITerminalNode NATURAL() { return GetToken(MySqlParser.NATURAL, 0); }
		public ITerminalNode JOIN() { return GetToken(MySqlParser.JOIN, 0); }
		public TableSourceItemContext tableSourceItem() {
			return GetRuleContext<TableSourceItemContext>(0);
		}
		public ITerminalNode LEFT() { return GetToken(MySqlParser.LEFT, 0); }
		public ITerminalNode RIGHT() { return GetToken(MySqlParser.RIGHT, 0); }
		public ITerminalNode OUTER() { return GetToken(MySqlParser.OUTER, 0); }
		public NaturalJoinContext(JoinPartContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNaturalJoin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNaturalJoin(this);
		}
	}
	public partial class OuterJoinContext : JoinPartContext {
		public ITerminalNode JOIN() { return GetToken(MySqlParser.JOIN, 0); }
		public TableSourceItemContext tableSourceItem() {
			return GetRuleContext<TableSourceItemContext>(0);
		}
		public ITerminalNode LEFT() { return GetToken(MySqlParser.LEFT, 0); }
		public ITerminalNode RIGHT() { return GetToken(MySqlParser.RIGHT, 0); }
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode OUTER() { return GetToken(MySqlParser.OUTER, 0); }
		public OuterJoinContext(JoinPartContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterOuterJoin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitOuterJoin(this);
		}
	}
	public partial class StraightJoinContext : JoinPartContext {
		public ITerminalNode STRAIGHT_JOIN() { return GetToken(MySqlParser.STRAIGHT_JOIN, 0); }
		public TableSourceItemContext tableSourceItem() {
			return GetRuleContext<TableSourceItemContext>(0);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StraightJoinContext(JoinPartContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStraightJoin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStraightJoin(this);
		}
	}

	[RuleVersion(0)]
	public JoinPartContext joinPart() {
		JoinPartContext _localctx = new JoinPartContext(Context, State);
		EnterRule(_localctx, 220, RULE_joinPart);
		int _la;
		try {
			State = 3372;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CROSS:
			case INNER:
			case JOIN:
				_localctx = new InnerJoinContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3329;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CROSS || _la==INNER) {
					{
					State = 3328;
					_la = TokenStream.LA(1);
					if ( !(_la==CROSS || _la==INNER) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 3331; Match(JOIN);
				State = 3332; tableSourceItem();
				State = 3340;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,468,Context) ) {
				case 1:
					{
					State = 3333; Match(ON);
					State = 3334; expression(0);
					}
					break;
				case 2:
					{
					State = 3335; Match(USING);
					State = 3336; Match(LR_BRACKET);
					State = 3337; uidList();
					State = 3338; Match(RR_BRACKET);
					}
					break;
				}
				}
				break;
			case STRAIGHT_JOIN:
				_localctx = new StraightJoinContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3342; Match(STRAIGHT_JOIN);
				State = 3343; tableSourceItem();
				State = 3346;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,469,Context) ) {
				case 1:
					{
					State = 3344; Match(ON);
					State = 3345; expression(0);
					}
					break;
				}
				}
				break;
			case LEFT:
			case RIGHT:
				_localctx = new OuterJoinContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3348;
				_la = TokenStream.LA(1);
				if ( !(_la==LEFT || _la==RIGHT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3350;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==OUTER) {
					{
					State = 3349; Match(OUTER);
					}
				}

				State = 3352; Match(JOIN);
				State = 3353; tableSourceItem();
				State = 3361;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ON:
					{
					State = 3354; Match(ON);
					State = 3355; expression(0);
					}
					break;
				case USING:
					{
					State = 3356; Match(USING);
					State = 3357; Match(LR_BRACKET);
					State = 3358; uidList();
					State = 3359; Match(RR_BRACKET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case NATURAL:
				_localctx = new NaturalJoinContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 3363; Match(NATURAL);
				State = 3368;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LEFT || _la==RIGHT) {
					{
					State = 3364;
					_la = TokenStream.LA(1);
					if ( !(_la==LEFT || _la==RIGHT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 3366;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==OUTER) {
						{
						State = 3365; Match(OUTER);
						}
					}

					}
				}

				State = 3370; Match(JOIN);
				State = 3371; tableSourceItem();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryExpressionContext : ParserRuleContext {
		public QuerySpecificationContext querySpecification() {
			return GetRuleContext<QuerySpecificationContext>(0);
		}
		public QueryExpressionContext queryExpression() {
			return GetRuleContext<QueryExpressionContext>(0);
		}
		public QueryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterQueryExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitQueryExpression(this);
		}
	}

	[RuleVersion(0)]
	public QueryExpressionContext queryExpression() {
		QueryExpressionContext _localctx = new QueryExpressionContext(Context, State);
		EnterRule(_localctx, 222, RULE_queryExpression);
		try {
			State = 3382;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,475,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3374; Match(LR_BRACKET);
				State = 3375; querySpecification();
				State = 3376; Match(RR_BRACKET);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3378; Match(LR_BRACKET);
				State = 3379; queryExpression();
				State = 3380; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryExpressionNointoContext : ParserRuleContext {
		public QuerySpecificationNointoContext querySpecificationNointo() {
			return GetRuleContext<QuerySpecificationNointoContext>(0);
		}
		public QueryExpressionNointoContext queryExpressionNointo() {
			return GetRuleContext<QueryExpressionNointoContext>(0);
		}
		public QueryExpressionNointoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryExpressionNointo; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterQueryExpressionNointo(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitQueryExpressionNointo(this);
		}
	}

	[RuleVersion(0)]
	public QueryExpressionNointoContext queryExpressionNointo() {
		QueryExpressionNointoContext _localctx = new QueryExpressionNointoContext(Context, State);
		EnterRule(_localctx, 224, RULE_queryExpressionNointo);
		try {
			State = 3392;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,476,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3384; Match(LR_BRACKET);
				State = 3385; querySpecificationNointo();
				State = 3386; Match(RR_BRACKET);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3388; Match(LR_BRACKET);
				State = 3389; queryExpressionNointo();
				State = 3390; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QuerySpecificationContext : ParserRuleContext {
		public ITerminalNode SELECT() { return GetToken(MySqlParser.SELECT, 0); }
		public SelectElementsContext selectElements() {
			return GetRuleContext<SelectElementsContext>(0);
		}
		public SelectSpecContext[] selectSpec() {
			return GetRuleContexts<SelectSpecContext>();
		}
		public SelectSpecContext selectSpec(int i) {
			return GetRuleContext<SelectSpecContext>(i);
		}
		public SelectIntoExpressionContext selectIntoExpression() {
			return GetRuleContext<SelectIntoExpressionContext>(0);
		}
		public FromClauseContext fromClause() {
			return GetRuleContext<FromClauseContext>(0);
		}
		public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public LimitClauseContext limitClause() {
			return GetRuleContext<LimitClauseContext>(0);
		}
		public QuerySpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_querySpecification; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterQuerySpecification(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitQuerySpecification(this);
		}
	}

	[RuleVersion(0)]
	public QuerySpecificationContext querySpecification() {
		QuerySpecificationContext _localctx = new QuerySpecificationContext(Context, State);
		EnterRule(_localctx, 226, RULE_querySpecification);
		int _la;
		try {
			int _alt;
			State = 3434;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,487,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3394; Match(SELECT);
				State = 3398;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,477,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 3395; selectSpec();
						}
						} 
					}
					State = 3400;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,477,Context);
				}
				State = 3401; selectElements();
				State = 3403;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INTO) {
					{
					State = 3402; selectIntoExpression();
					}
				}

				State = 3406;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM) {
					{
					State = 3405; fromClause();
					}
				}

				State = 3409;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,480,Context) ) {
				case 1:
					{
					State = 3408; orderByClause();
					}
					break;
				}
				State = 3412;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,481,Context) ) {
				case 1:
					{
					State = 3411; limitClause();
					}
					break;
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3414; Match(SELECT);
				State = 3418;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,482,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 3415; selectSpec();
						}
						} 
					}
					State = 3420;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,482,Context);
				}
				State = 3421; selectElements();
				State = 3423;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM) {
					{
					State = 3422; fromClause();
					}
				}

				State = 3426;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,484,Context) ) {
				case 1:
					{
					State = 3425; orderByClause();
					}
					break;
				}
				State = 3429;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,485,Context) ) {
				case 1:
					{
					State = 3428; limitClause();
					}
					break;
				}
				State = 3432;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INTO) {
					{
					State = 3431; selectIntoExpression();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QuerySpecificationNointoContext : ParserRuleContext {
		public ITerminalNode SELECT() { return GetToken(MySqlParser.SELECT, 0); }
		public SelectElementsContext selectElements() {
			return GetRuleContext<SelectElementsContext>(0);
		}
		public SelectSpecContext[] selectSpec() {
			return GetRuleContexts<SelectSpecContext>();
		}
		public SelectSpecContext selectSpec(int i) {
			return GetRuleContext<SelectSpecContext>(i);
		}
		public FromClauseContext fromClause() {
			return GetRuleContext<FromClauseContext>(0);
		}
		public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public LimitClauseContext limitClause() {
			return GetRuleContext<LimitClauseContext>(0);
		}
		public QuerySpecificationNointoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_querySpecificationNointo; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterQuerySpecificationNointo(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitQuerySpecificationNointo(this);
		}
	}

	[RuleVersion(0)]
	public QuerySpecificationNointoContext querySpecificationNointo() {
		QuerySpecificationNointoContext _localctx = new QuerySpecificationNointoContext(Context, State);
		EnterRule(_localctx, 228, RULE_querySpecificationNointo);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3436; Match(SELECT);
			State = 3440;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,488,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 3437; selectSpec();
					}
					} 
				}
				State = 3442;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,488,Context);
			}
			State = 3443; selectElements();
			State = 3445;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FROM) {
				{
				State = 3444; fromClause();
				}
			}

			State = 3448;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,490,Context) ) {
			case 1:
				{
				State = 3447; orderByClause();
				}
				break;
			}
			State = 3451;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,491,Context) ) {
			case 1:
				{
				State = 3450; limitClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnionParenthesisContext : ParserRuleContext {
		public IToken unionType;
		public ITerminalNode UNION() { return GetToken(MySqlParser.UNION, 0); }
		public QueryExpressionNointoContext queryExpressionNointo() {
			return GetRuleContext<QueryExpressionNointoContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(MySqlParser.DISTINCT, 0); }
		public UnionParenthesisContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unionParenthesis; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnionParenthesis(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnionParenthesis(this);
		}
	}

	[RuleVersion(0)]
	public UnionParenthesisContext unionParenthesis() {
		UnionParenthesisContext _localctx = new UnionParenthesisContext(Context, State);
		EnterRule(_localctx, 230, RULE_unionParenthesis);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3453; Match(UNION);
			State = 3455;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==DISTINCT) {
				{
				State = 3454;
				_localctx.unionType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==DISTINCT) ) {
					_localctx.unionType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3457; queryExpressionNointo();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnionStatementContext : ParserRuleContext {
		public IToken unionType;
		public ITerminalNode UNION() { return GetToken(MySqlParser.UNION, 0); }
		public QuerySpecificationNointoContext querySpecificationNointo() {
			return GetRuleContext<QuerySpecificationNointoContext>(0);
		}
		public QueryExpressionNointoContext queryExpressionNointo() {
			return GetRuleContext<QueryExpressionNointoContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(MySqlParser.DISTINCT, 0); }
		public UnionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unionStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnionStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnionStatement(this);
		}
	}

	[RuleVersion(0)]
	public UnionStatementContext unionStatement() {
		UnionStatementContext _localctx = new UnionStatementContext(Context, State);
		EnterRule(_localctx, 232, RULE_unionStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3459; Match(UNION);
			State = 3461;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==DISTINCT) {
				{
				State = 3460;
				_localctx.unionType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==DISTINCT) ) {
					_localctx.unionType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3465;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
				{
				State = 3463; querySpecificationNointo();
				}
				break;
			case LR_BRACKET:
				{
				State = 3464; queryExpressionNointo();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectSpecContext : ParserRuleContext {
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(MySqlParser.DISTINCT, 0); }
		public ITerminalNode DISTINCTROW() { return GetToken(MySqlParser.DISTINCTROW, 0); }
		public ITerminalNode HIGH_PRIORITY() { return GetToken(MySqlParser.HIGH_PRIORITY, 0); }
		public ITerminalNode STRAIGHT_JOIN() { return GetToken(MySqlParser.STRAIGHT_JOIN, 0); }
		public ITerminalNode SQL_SMALL_RESULT() { return GetToken(MySqlParser.SQL_SMALL_RESULT, 0); }
		public ITerminalNode SQL_BIG_RESULT() { return GetToken(MySqlParser.SQL_BIG_RESULT, 0); }
		public ITerminalNode SQL_BUFFER_RESULT() { return GetToken(MySqlParser.SQL_BUFFER_RESULT, 0); }
		public ITerminalNode SQL_CACHE() { return GetToken(MySqlParser.SQL_CACHE, 0); }
		public ITerminalNode SQL_NO_CACHE() { return GetToken(MySqlParser.SQL_NO_CACHE, 0); }
		public ITerminalNode SQL_CALC_FOUND_ROWS() { return GetToken(MySqlParser.SQL_CALC_FOUND_ROWS, 0); }
		public SelectSpecContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectSpec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectSpec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectSpec(this);
		}
	}

	[RuleVersion(0)]
	public SelectSpecContext selectSpec() {
		SelectSpecContext _localctx = new SelectSpecContext(Context, State);
		EnterRule(_localctx, 234, RULE_selectSpec);
		int _la;
		try {
			State = 3475;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALL:
			case DISTINCT:
			case DISTINCTROW:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3467;
				_la = TokenStream.LA(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ALL) | (1L << DISTINCT) | (1L << DISTINCTROW))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case HIGH_PRIORITY:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3468; Match(HIGH_PRIORITY);
				}
				break;
			case STRAIGHT_JOIN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3469; Match(STRAIGHT_JOIN);
				}
				break;
			case SQL_SMALL_RESULT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3470; Match(SQL_SMALL_RESULT);
				}
				break;
			case SQL_BIG_RESULT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3471; Match(SQL_BIG_RESULT);
				}
				break;
			case SQL_BUFFER_RESULT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 3472; Match(SQL_BUFFER_RESULT);
				}
				break;
			case SQL_CACHE:
			case SQL_NO_CACHE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 3473;
				_la = TokenStream.LA(1);
				if ( !(_la==SQL_CACHE || _la==SQL_NO_CACHE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case SQL_CALC_FOUND_ROWS:
				EnterOuterAlt(_localctx, 8);
				{
				State = 3474; Match(SQL_CALC_FOUND_ROWS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectElementsContext : ParserRuleContext {
		public IToken star;
		public SelectElementContext[] selectElement() {
			return GetRuleContexts<SelectElementContext>();
		}
		public SelectElementContext selectElement(int i) {
			return GetRuleContext<SelectElementContext>(i);
		}
		public SelectElementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectElements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectElements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectElements(this);
		}
	}

	[RuleVersion(0)]
	public SelectElementsContext selectElements() {
		SelectElementsContext _localctx = new SelectElementsContext(Context, State);
		EnterRule(_localctx, 236, RULE_selectElements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3479;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STAR:
				{
				State = 3477; _localctx.star = Match(STAR);
				}
				break;
			case CASE:
			case CAST:
			case CONVERT:
			case CURRENT_USER:
			case DATABASE:
			case EXISTS:
			case FALSE:
			case IF:
			case INSERT:
			case INTERVAL:
			case LEFT:
			case NOT:
			case NULL_LITERAL:
			case REPLACE:
			case RIGHT:
			case TRUE:
			case VALUES:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case CHAR:
			case BINARY:
			case TEXT:
			case ENUM:
			case SERIAL:
			case AVG:
			case BIT_AND:
			case BIT_OR:
			case BIT_XOR:
			case COUNT:
			case GROUP_CONCAT:
			case MAX:
			case MIN:
			case STD:
			case STDDEV:
			case STDDEV_POP:
			case STDDEV_SAMP:
			case SUM:
			case VAR_POP:
			case VAR_SAMP:
			case VARIANCE:
			case CURRENT_DATE:
			case CURRENT_TIME:
			case CURRENT_TIMESTAMP:
			case LOCALTIME:
			case CURDATE:
			case CURTIME:
			case DATE_ADD:
			case DATE_SUB:
			case EXTRACT:
			case LOCALTIMESTAMP:
			case NOW:
			case POSITION:
			case SUBSTR:
			case SUBSTRING:
			case SYSDATE:
			case TRIM:
			case UTC_DATE:
			case UTC_TIME:
			case UTC_TIMESTAMP:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case PLUS:
			case MINUS:
			case EXCLAMATION_SYMBOL:
			case BIT_NOT_OP:
			case LR_BRACKET:
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case CHARSET_REVERSE_QOUTE_STRING:
			case START_NATIONAL_STRING_LITERAL:
			case STRING_LITERAL:
			case DECIMAL_LITERAL:
			case HEXADECIMAL_LITERAL:
			case REAL_LITERAL:
			case NULL_SPEC_LITERAL:
			case BIT_STRING:
			case STRING_CHARSET_NAME:
			case ID:
			case REVERSE_QUOTE_ID:
			case LOCAL_ID:
			case GLOBAL_ID:
				{
				State = 3478; selectElement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3485;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3481; Match(COMMA);
				State = 3482; selectElement();
				}
				}
				State = 3487;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectElementContext : ParserRuleContext {
		public SelectElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectElement; } }
	 
		public SelectElementContext() { }
		public virtual void CopyFrom(SelectElementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SelectExpressionElementContext : SelectElementContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LOCAL_ID() { return GetToken(MySqlParser.LOCAL_ID, 0); }
		public ITerminalNode VAR_ASSIGN() { return GetToken(MySqlParser.VAR_ASSIGN, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SelectExpressionElementContext(SelectElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectExpressionElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectExpressionElement(this);
		}
	}
	public partial class SelectFunctionElementContext : SelectElementContext {
		public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SelectFunctionElementContext(SelectElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectFunctionElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectFunctionElement(this);
		}
	}
	public partial class SelectStarElementContext : SelectElementContext {
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public SelectStarElementContext(SelectElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectStarElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectStarElement(this);
		}
	}
	public partial class SelectColumnElementContext : SelectElementContext {
		public FullColumnNameContext fullColumnName() {
			return GetRuleContext<FullColumnNameContext>(0);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SelectColumnElementContext(SelectElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectColumnElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectColumnElement(this);
		}
	}

	[RuleVersion(0)]
	public SelectElementContext selectElement() {
		SelectElementContext _localctx = new SelectElementContext(Context, State);
		EnterRule(_localctx, 238, RULE_selectElement);
		int _la;
		try {
			State = 3517;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,505,Context) ) {
			case 1:
				_localctx = new SelectStarElementContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3488; fullId();
				State = 3489; Match(DOT);
				State = 3490; Match(STAR);
				}
				break;
			case 2:
				_localctx = new SelectColumnElementContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3492; fullColumnName();
				State = 3497;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,499,Context) ) {
				case 1:
					{
					State = 3494;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AS) {
						{
						State = 3493; Match(AS);
						}
					}

					State = 3496; uid();
					}
					break;
				}
				}
				break;
			case 3:
				_localctx = new SelectFunctionElementContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3499; functionCall();
				State = 3504;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,501,Context) ) {
				case 1:
					{
					State = 3501;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AS) {
						{
						State = 3500; Match(AS);
						}
					}

					State = 3503; uid();
					}
					break;
				}
				}
				break;
			case 4:
				_localctx = new SelectExpressionElementContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 3508;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,502,Context) ) {
				case 1:
					{
					State = 3506; Match(LOCAL_ID);
					State = 3507; Match(VAR_ASSIGN);
					}
					break;
				}
				State = 3510; expression(0);
				State = 3515;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,504,Context) ) {
				case 1:
					{
					State = 3512;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AS) {
						{
						State = 3511; Match(AS);
						}
					}

					State = 3514; uid();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectIntoExpressionContext : ParserRuleContext {
		public SelectIntoExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectIntoExpression; } }
	 
		public SelectIntoExpressionContext() { }
		public virtual void CopyFrom(SelectIntoExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SelectIntoVariablesContext : SelectIntoExpressionContext {
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public AssignmentFieldContext[] assignmentField() {
			return GetRuleContexts<AssignmentFieldContext>();
		}
		public AssignmentFieldContext assignmentField(int i) {
			return GetRuleContext<AssignmentFieldContext>(i);
		}
		public SelectIntoVariablesContext(SelectIntoExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectIntoVariables(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectIntoVariables(this);
		}
	}
	public partial class SelectIntoTextFileContext : SelectIntoExpressionContext {
		public IToken filename;
		public CharsetNameContext charset;
		public IToken fieldsFormat;
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode OUTFILE() { return GetToken(MySqlParser.OUTFILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode LINES() { return GetToken(MySqlParser.LINES, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode FIELDS() { return GetToken(MySqlParser.FIELDS, 0); }
		public ITerminalNode COLUMNS() { return GetToken(MySqlParser.COLUMNS, 0); }
		public SelectFieldsIntoContext[] selectFieldsInto() {
			return GetRuleContexts<SelectFieldsIntoContext>();
		}
		public SelectFieldsIntoContext selectFieldsInto(int i) {
			return GetRuleContext<SelectFieldsIntoContext>(i);
		}
		public SelectLinesIntoContext[] selectLinesInto() {
			return GetRuleContexts<SelectLinesIntoContext>();
		}
		public SelectLinesIntoContext selectLinesInto(int i) {
			return GetRuleContext<SelectLinesIntoContext>(i);
		}
		public SelectIntoTextFileContext(SelectIntoExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectIntoTextFile(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectIntoTextFile(this);
		}
	}
	public partial class SelectIntoDumpFileContext : SelectIntoExpressionContext {
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode DUMPFILE() { return GetToken(MySqlParser.DUMPFILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public SelectIntoDumpFileContext(SelectIntoExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectIntoDumpFile(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectIntoDumpFile(this);
		}
	}

	[RuleVersion(0)]
	public SelectIntoExpressionContext selectIntoExpression() {
		SelectIntoExpressionContext _localctx = new SelectIntoExpressionContext(Context, State);
		EnterRule(_localctx, 240, RULE_selectIntoExpression);
		int _la;
		try {
			State = 3555;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,512,Context) ) {
			case 1:
				_localctx = new SelectIntoVariablesContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3519; Match(INTO);
				State = 3520; assignmentField();
				State = 3525;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3521; Match(COMMA);
					State = 3522; assignmentField();
					}
					}
					State = 3527;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new SelectIntoDumpFileContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3528; Match(INTO);
				State = 3529; Match(DUMPFILE);
				State = 3530; Match(STRING_LITERAL);
				}
				break;
			case 3:
				_localctx = new SelectIntoTextFileContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				{
				State = 3531; Match(INTO);
				State = 3532; Match(OUTFILE);
				State = 3533; ((SelectIntoTextFileContext)_localctx).filename = Match(STRING_LITERAL);
				State = 3537;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CHARACTER) {
					{
					State = 3534; Match(CHARACTER);
					State = 3535; Match(SET);
					State = 3536; ((SelectIntoTextFileContext)_localctx).charset = charsetName();
					}
				}

				State = 3545;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,509,Context) ) {
				case 1:
					{
					State = 3539;
					((SelectIntoTextFileContext)_localctx).fieldsFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==COLUMNS || _la==FIELDS) ) {
						((SelectIntoTextFileContext)_localctx).fieldsFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 3541;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 3540; selectFieldsInto();
						}
						}
						State = 3543;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( _la==ENCLOSED || _la==ESCAPED || _la==OPTIONALLY || _la==TERMINATED );
					}
					break;
				}
				State = 3553;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LINES) {
					{
					State = 3547; Match(LINES);
					State = 3549;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 3548; selectLinesInto();
						}
						}
						State = 3551;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( _la==STARTING || _la==TERMINATED );
					}
				}

				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectFieldsIntoContext : ParserRuleContext {
		public IToken terminationField;
		public IToken enclosion;
		public IToken escaping;
		public ITerminalNode TERMINATED() { return GetToken(MySqlParser.TERMINATED, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode ENCLOSED() { return GetToken(MySqlParser.ENCLOSED, 0); }
		public ITerminalNode OPTIONALLY() { return GetToken(MySqlParser.OPTIONALLY, 0); }
		public ITerminalNode ESCAPED() { return GetToken(MySqlParser.ESCAPED, 0); }
		public SelectFieldsIntoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectFieldsInto; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectFieldsInto(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectFieldsInto(this);
		}
	}

	[RuleVersion(0)]
	public SelectFieldsIntoContext selectFieldsInto() {
		SelectFieldsIntoContext _localctx = new SelectFieldsIntoContext(Context, State);
		EnterRule(_localctx, 242, RULE_selectFieldsInto);
		int _la;
		try {
			State = 3569;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TERMINATED:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3557; Match(TERMINATED);
				State = 3558; Match(BY);
				State = 3559; _localctx.terminationField = Match(STRING_LITERAL);
				}
				break;
			case ENCLOSED:
			case OPTIONALLY:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3561;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==OPTIONALLY) {
					{
					State = 3560; Match(OPTIONALLY);
					}
				}

				State = 3563; Match(ENCLOSED);
				State = 3564; Match(BY);
				State = 3565; _localctx.enclosion = Match(STRING_LITERAL);
				}
				break;
			case ESCAPED:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3566; Match(ESCAPED);
				State = 3567; Match(BY);
				State = 3568; _localctx.escaping = Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectLinesIntoContext : ParserRuleContext {
		public IToken starting;
		public IToken terminationLine;
		public ITerminalNode STARTING() { return GetToken(MySqlParser.STARTING, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode TERMINATED() { return GetToken(MySqlParser.TERMINATED, 0); }
		public SelectLinesIntoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectLinesInto; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectLinesInto(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectLinesInto(this);
		}
	}

	[RuleVersion(0)]
	public SelectLinesIntoContext selectLinesInto() {
		SelectLinesIntoContext _localctx = new SelectLinesIntoContext(Context, State);
		EnterRule(_localctx, 244, RULE_selectLinesInto);
		try {
			State = 3577;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STARTING:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3571; Match(STARTING);
				State = 3572; Match(BY);
				State = 3573; _localctx.starting = Match(STRING_LITERAL);
				}
				break;
			case TERMINATED:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3574; Match(TERMINATED);
				State = 3575; Match(BY);
				State = 3576; _localctx.terminationLine = Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FromClauseContext : ParserRuleContext {
		public ExpressionContext whereExpr;
		public ExpressionContext havingExpr;
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public TableSourcesContext tableSources() {
			return GetRuleContext<TableSourcesContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ITerminalNode GROUP() { return GetToken(MySqlParser.GROUP, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public GroupByItemContext[] groupByItem() {
			return GetRuleContexts<GroupByItemContext>();
		}
		public GroupByItemContext groupByItem(int i) {
			return GetRuleContext<GroupByItemContext>(i);
		}
		public ITerminalNode HAVING() { return GetToken(MySqlParser.HAVING, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode ROLLUP() { return GetToken(MySqlParser.ROLLUP, 0); }
		public FromClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fromClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFromClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFromClause(this);
		}
	}

	[RuleVersion(0)]
	public FromClauseContext fromClause() {
		FromClauseContext _localctx = new FromClauseContext(Context, State);
		EnterRule(_localctx, 246, RULE_fromClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3579; Match(FROM);
			State = 3580; tableSources();
			State = 3583;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3581; Match(WHERE);
				State = 3582; _localctx.whereExpr = expression(0);
				}
			}

			State = 3599;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GROUP) {
				{
				State = 3585; Match(GROUP);
				State = 3586; Match(BY);
				State = 3587; groupByItem();
				State = 3592;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3588; Match(COMMA);
					State = 3589; groupByItem();
					}
					}
					State = 3594;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3597;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,518,Context) ) {
				case 1:
					{
					State = 3595; Match(WITH);
					State = 3596; Match(ROLLUP);
					}
					break;
				}
				}
			}

			State = 3603;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==HAVING) {
				{
				State = 3601; Match(HAVING);
				State = 3602; _localctx.havingExpr = expression(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByItemContext : ParserRuleContext {
		public IToken order;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASC() { return GetToken(MySqlParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(MySqlParser.DESC, 0); }
		public GroupByItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGroupByItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGroupByItem(this);
		}
	}

	[RuleVersion(0)]
	public GroupByItemContext groupByItem() {
		GroupByItemContext _localctx = new GroupByItemContext(Context, State);
		EnterRule(_localctx, 248, RULE_groupByItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3605; expression(0);
			State = 3607;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,521,Context) ) {
			case 1:
				{
				State = 3606;
				_localctx.order = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ASC || _la==DESC) ) {
					_localctx.order = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LimitClauseContext : ParserRuleContext {
		public LimitClauseAtomContext offset;
		public LimitClauseAtomContext limit;
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public ITerminalNode OFFSET() { return GetToken(MySqlParser.OFFSET, 0); }
		public LimitClauseAtomContext[] limitClauseAtom() {
			return GetRuleContexts<LimitClauseAtomContext>();
		}
		public LimitClauseAtomContext limitClauseAtom(int i) {
			return GetRuleContext<LimitClauseAtomContext>(i);
		}
		public LimitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_limitClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLimitClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLimitClause(this);
		}
	}

	[RuleVersion(0)]
	public LimitClauseContext limitClause() {
		LimitClauseContext _localctx = new LimitClauseContext(Context, State);
		EnterRule(_localctx, 250, RULE_limitClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3609; Match(LIMIT);
			State = 3620;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,523,Context) ) {
			case 1:
				{
				State = 3613;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,522,Context) ) {
				case 1:
					{
					State = 3610; _localctx.offset = limitClauseAtom();
					State = 3611; Match(COMMA);
					}
					break;
				}
				State = 3615; _localctx.limit = limitClauseAtom();
				}
				break;
			case 2:
				{
				State = 3616; _localctx.limit = limitClauseAtom();
				State = 3617; Match(OFFSET);
				State = 3618; _localctx.offset = limitClauseAtom();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LimitClauseAtomContext : ParserRuleContext {
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public MysqlVariableContext mysqlVariable() {
			return GetRuleContext<MysqlVariableContext>(0);
		}
		public LimitClauseAtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_limitClauseAtom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLimitClauseAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLimitClauseAtom(this);
		}
	}

	[RuleVersion(0)]
	public LimitClauseAtomContext limitClauseAtom() {
		LimitClauseAtomContext _localctx = new LimitClauseAtomContext(Context, State);
		EnterRule(_localctx, 252, RULE_limitClauseAtom);
		try {
			State = 3624;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case DECIMAL_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3622; decimalLiteral();
				}
				break;
			case LOCAL_ID:
			case GLOBAL_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3623; mysqlVariable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartTransactionContext : ParserRuleContext {
		public ITerminalNode START() { return GetToken(MySqlParser.START, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(MySqlParser.TRANSACTION, 0); }
		public TransactionModeContext[] transactionMode() {
			return GetRuleContexts<TransactionModeContext>();
		}
		public TransactionModeContext transactionMode(int i) {
			return GetRuleContext<TransactionModeContext>(i);
		}
		public StartTransactionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startTransaction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStartTransaction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStartTransaction(this);
		}
	}

	[RuleVersion(0)]
	public StartTransactionContext startTransaction() {
		StartTransactionContext _localctx = new StartTransactionContext(Context, State);
		EnterRule(_localctx, 254, RULE_startTransaction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3626; Match(START);
			State = 3627; Match(TRANSACTION);
			State = 3636;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==READ || _la==WITH) {
				{
				State = 3628; transactionMode();
				State = 3633;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3629; Match(COMMA);
					State = 3630; transactionMode();
					}
					}
					State = 3635;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BeginWorkContext : ParserRuleContext {
		public ITerminalNode BEGIN() { return GetToken(MySqlParser.BEGIN, 0); }
		public ITerminalNode WORK() { return GetToken(MySqlParser.WORK, 0); }
		public BeginWorkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_beginWork; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBeginWork(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBeginWork(this);
		}
	}

	[RuleVersion(0)]
	public BeginWorkContext beginWork() {
		BeginWorkContext _localctx = new BeginWorkContext(Context, State);
		EnterRule(_localctx, 256, RULE_beginWork);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3638; Match(BEGIN);
			State = 3640;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WORK) {
				{
				State = 3639; Match(WORK);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommitWorkContext : ParserRuleContext {
		public IToken nochain;
		public IToken norelease;
		public ITerminalNode COMMIT() { return GetToken(MySqlParser.COMMIT, 0); }
		public ITerminalNode WORK() { return GetToken(MySqlParser.WORK, 0); }
		public ITerminalNode AND() { return GetToken(MySqlParser.AND, 0); }
		public ITerminalNode CHAIN() { return GetToken(MySqlParser.CHAIN, 0); }
		public ITerminalNode RELEASE() { return GetToken(MySqlParser.RELEASE, 0); }
		public ITerminalNode[] NO() { return GetTokens(MySqlParser.NO); }
		public ITerminalNode NO(int i) {
			return GetToken(MySqlParser.NO, i);
		}
		public CommitWorkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commitWork; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCommitWork(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCommitWork(this);
		}
	}

	[RuleVersion(0)]
	public CommitWorkContext commitWork() {
		CommitWorkContext _localctx = new CommitWorkContext(Context, State);
		EnterRule(_localctx, 258, RULE_commitWork);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3642; Match(COMMIT);
			State = 3644;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WORK) {
				{
				State = 3643; Match(WORK);
				}
			}

			State = 3651;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AND) {
				{
				State = 3646; Match(AND);
				State = 3648;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO) {
					{
					State = 3647; _localctx.nochain = Match(NO);
					}
				}

				State = 3650; Match(CHAIN);
				}
			}

			State = 3657;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,532,Context) ) {
			case 1:
				{
				State = 3654;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO) {
					{
					State = 3653; _localctx.norelease = Match(NO);
					}
				}

				State = 3656; Match(RELEASE);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RollbackWorkContext : ParserRuleContext {
		public IToken nochain;
		public IToken norelease;
		public ITerminalNode ROLLBACK() { return GetToken(MySqlParser.ROLLBACK, 0); }
		public ITerminalNode WORK() { return GetToken(MySqlParser.WORK, 0); }
		public ITerminalNode AND() { return GetToken(MySqlParser.AND, 0); }
		public ITerminalNode CHAIN() { return GetToken(MySqlParser.CHAIN, 0); }
		public ITerminalNode RELEASE() { return GetToken(MySqlParser.RELEASE, 0); }
		public ITerminalNode[] NO() { return GetTokens(MySqlParser.NO); }
		public ITerminalNode NO(int i) {
			return GetToken(MySqlParser.NO, i);
		}
		public RollbackWorkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollbackWork; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRollbackWork(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRollbackWork(this);
		}
	}

	[RuleVersion(0)]
	public RollbackWorkContext rollbackWork() {
		RollbackWorkContext _localctx = new RollbackWorkContext(Context, State);
		EnterRule(_localctx, 260, RULE_rollbackWork);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3659; Match(ROLLBACK);
			State = 3661;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WORK) {
				{
				State = 3660; Match(WORK);
				}
			}

			State = 3668;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AND) {
				{
				State = 3663; Match(AND);
				State = 3665;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO) {
					{
					State = 3664; _localctx.nochain = Match(NO);
					}
				}

				State = 3667; Match(CHAIN);
				}
			}

			State = 3674;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,537,Context) ) {
			case 1:
				{
				State = 3671;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO) {
					{
					State = 3670; _localctx.norelease = Match(NO);
					}
				}

				State = 3673; Match(RELEASE);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SavepointStatementContext : ParserRuleContext {
		public ITerminalNode SAVEPOINT() { return GetToken(MySqlParser.SAVEPOINT, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public SavepointStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_savepointStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSavepointStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSavepointStatement(this);
		}
	}

	[RuleVersion(0)]
	public SavepointStatementContext savepointStatement() {
		SavepointStatementContext _localctx = new SavepointStatementContext(Context, State);
		EnterRule(_localctx, 262, RULE_savepointStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3676; Match(SAVEPOINT);
			State = 3677; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RollbackStatementContext : ParserRuleContext {
		public ITerminalNode ROLLBACK() { return GetToken(MySqlParser.ROLLBACK, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode WORK() { return GetToken(MySqlParser.WORK, 0); }
		public ITerminalNode SAVEPOINT() { return GetToken(MySqlParser.SAVEPOINT, 0); }
		public RollbackStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollbackStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRollbackStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRollbackStatement(this);
		}
	}

	[RuleVersion(0)]
	public RollbackStatementContext rollbackStatement() {
		RollbackStatementContext _localctx = new RollbackStatementContext(Context, State);
		EnterRule(_localctx, 264, RULE_rollbackStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3679; Match(ROLLBACK);
			State = 3681;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WORK) {
				{
				State = 3680; Match(WORK);
				}
			}

			State = 3683; Match(TO);
			State = 3685;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,539,Context) ) {
			case 1:
				{
				State = 3684; Match(SAVEPOINT);
				}
				break;
			}
			State = 3687; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReleaseStatementContext : ParserRuleContext {
		public ITerminalNode RELEASE() { return GetToken(MySqlParser.RELEASE, 0); }
		public ITerminalNode SAVEPOINT() { return GetToken(MySqlParser.SAVEPOINT, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ReleaseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_releaseStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReleaseStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReleaseStatement(this);
		}
	}

	[RuleVersion(0)]
	public ReleaseStatementContext releaseStatement() {
		ReleaseStatementContext _localctx = new ReleaseStatementContext(Context, State);
		EnterRule(_localctx, 266, RULE_releaseStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3689; Match(RELEASE);
			State = 3690; Match(SAVEPOINT);
			State = 3691; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockTablesContext : ParserRuleContext {
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public LockTableElementContext[] lockTableElement() {
			return GetRuleContexts<LockTableElementContext>();
		}
		public LockTableElementContext lockTableElement(int i) {
			return GetRuleContext<LockTableElementContext>(i);
		}
		public LockTablesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockTables; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLockTables(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLockTables(this);
		}
	}

	[RuleVersion(0)]
	public LockTablesContext lockTables() {
		LockTablesContext _localctx = new LockTablesContext(Context, State);
		EnterRule(_localctx, 268, RULE_lockTables);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3693; Match(LOCK);
			State = 3694; Match(TABLES);
			State = 3695; lockTableElement();
			State = 3700;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3696; Match(COMMA);
				State = 3697; lockTableElement();
				}
				}
				State = 3702;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnlockTablesContext : ParserRuleContext {
		public ITerminalNode UNLOCK() { return GetToken(MySqlParser.UNLOCK, 0); }
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public UnlockTablesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unlockTables; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnlockTables(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnlockTables(this);
		}
	}

	[RuleVersion(0)]
	public UnlockTablesContext unlockTables() {
		UnlockTablesContext _localctx = new UnlockTablesContext(Context, State);
		EnterRule(_localctx, 270, RULE_unlockTables);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3703; Match(UNLOCK);
			State = 3704; Match(TABLES);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetAutocommitStatementContext : ParserRuleContext {
		public IToken autocommitValue;
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode AUTOCOMMIT() { return GetToken(MySqlParser.AUTOCOMMIT, 0); }
		public SetAutocommitStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setAutocommitStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetAutocommitStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetAutocommitStatement(this);
		}
	}

	[RuleVersion(0)]
	public SetAutocommitStatementContext setAutocommitStatement() {
		SetAutocommitStatementContext _localctx = new SetAutocommitStatementContext(Context, State);
		EnterRule(_localctx, 272, RULE_setAutocommitStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3706; Match(SET);
			State = 3707; Match(AUTOCOMMIT);
			State = 3708; Match(EQUAL_SYMBOL);
			State = 3709;
			_localctx.autocommitValue = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
				_localctx.autocommitValue = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetTransactionStatementContext : ParserRuleContext {
		public IToken transactionContext;
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(MySqlParser.TRANSACTION, 0); }
		public TransactionOptionContext[] transactionOption() {
			return GetRuleContexts<TransactionOptionContext>();
		}
		public TransactionOptionContext transactionOption(int i) {
			return GetRuleContext<TransactionOptionContext>(i);
		}
		public ITerminalNode GLOBAL() { return GetToken(MySqlParser.GLOBAL, 0); }
		public ITerminalNode SESSION() { return GetToken(MySqlParser.SESSION, 0); }
		public SetTransactionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setTransactionStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetTransactionStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetTransactionStatement(this);
		}
	}

	[RuleVersion(0)]
	public SetTransactionStatementContext setTransactionStatement() {
		SetTransactionStatementContext _localctx = new SetTransactionStatementContext(Context, State);
		EnterRule(_localctx, 274, RULE_setTransactionStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3711; Match(SET);
			State = 3713;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GLOBAL || _la==SESSION) {
				{
				State = 3712;
				_localctx.transactionContext = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==GLOBAL || _la==SESSION) ) {
					_localctx.transactionContext = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3715; Match(TRANSACTION);
			State = 3716; transactionOption();
			State = 3721;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3717; Match(COMMA);
				State = 3718; transactionOption();
				}
				}
				State = 3723;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TransactionModeContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode CONSISTENT() { return GetToken(MySqlParser.CONSISTENT, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(MySqlParser.SNAPSHOT, 0); }
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode WRITE() { return GetToken(MySqlParser.WRITE, 0); }
		public ITerminalNode ONLY() { return GetToken(MySqlParser.ONLY, 0); }
		public TransactionModeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transactionMode; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTransactionMode(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTransactionMode(this);
		}
	}

	[RuleVersion(0)]
	public TransactionModeContext transactionMode() {
		TransactionModeContext _localctx = new TransactionModeContext(Context, State);
		EnterRule(_localctx, 276, RULE_transactionMode);
		try {
			State = 3731;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,543,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3724; Match(WITH);
				State = 3725; Match(CONSISTENT);
				State = 3726; Match(SNAPSHOT);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3727; Match(READ);
				State = 3728; Match(WRITE);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3729; Match(READ);
				State = 3730; Match(ONLY);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockTableElementContext : ParserRuleContext {
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public LockActionContext lockAction() {
			return GetRuleContext<LockActionContext>(0);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public LockTableElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockTableElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLockTableElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLockTableElement(this);
		}
	}

	[RuleVersion(0)]
	public LockTableElementContext lockTableElement() {
		LockTableElementContext _localctx = new LockTableElementContext(Context, State);
		EnterRule(_localctx, 278, RULE_lockTableElement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3733; tableName();
			State = 3738;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
				{
				State = 3735;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 3734; Match(AS);
					}
				}

				State = 3737; uid();
				}
			}

			State = 3740; lockAction();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockActionContext : ParserRuleContext {
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public ITerminalNode WRITE() { return GetToken(MySqlParser.WRITE, 0); }
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public LockActionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockAction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLockAction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLockAction(this);
		}
	}

	[RuleVersion(0)]
	public LockActionContext lockAction() {
		LockActionContext _localctx = new LockActionContext(Context, State);
		EnterRule(_localctx, 280, RULE_lockAction);
		int _la;
		try {
			State = 3750;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case READ:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3742; Match(READ);
				State = 3744;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOCAL) {
					{
					State = 3743; Match(LOCAL);
					}
				}

				}
				break;
			case LOW_PRIORITY:
			case WRITE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3747;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOW_PRIORITY) {
					{
					State = 3746; Match(LOW_PRIORITY);
					}
				}

				State = 3749; Match(WRITE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TransactionOptionContext : ParserRuleContext {
		public ITerminalNode ISOLATION() { return GetToken(MySqlParser.ISOLATION, 0); }
		public ITerminalNode LEVEL() { return GetToken(MySqlParser.LEVEL, 0); }
		public TransactionLevelContext transactionLevel() {
			return GetRuleContext<TransactionLevelContext>(0);
		}
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode WRITE() { return GetToken(MySqlParser.WRITE, 0); }
		public ITerminalNode ONLY() { return GetToken(MySqlParser.ONLY, 0); }
		public TransactionOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transactionOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTransactionOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTransactionOption(this);
		}
	}

	[RuleVersion(0)]
	public TransactionOptionContext transactionOption() {
		TransactionOptionContext _localctx = new TransactionOptionContext(Context, State);
		EnterRule(_localctx, 282, RULE_transactionOption);
		try {
			State = 3759;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,549,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3752; Match(ISOLATION);
				State = 3753; Match(LEVEL);
				State = 3754; transactionLevel();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3755; Match(READ);
				State = 3756; Match(WRITE);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3757; Match(READ);
				State = 3758; Match(ONLY);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TransactionLevelContext : ParserRuleContext {
		public ITerminalNode REPEATABLE() { return GetToken(MySqlParser.REPEATABLE, 0); }
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode COMMITTED() { return GetToken(MySqlParser.COMMITTED, 0); }
		public ITerminalNode UNCOMMITTED() { return GetToken(MySqlParser.UNCOMMITTED, 0); }
		public ITerminalNode SERIALIZABLE() { return GetToken(MySqlParser.SERIALIZABLE, 0); }
		public TransactionLevelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transactionLevel; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTransactionLevel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTransactionLevel(this);
		}
	}

	[RuleVersion(0)]
	public TransactionLevelContext transactionLevel() {
		TransactionLevelContext _localctx = new TransactionLevelContext(Context, State);
		EnterRule(_localctx, 284, RULE_transactionLevel);
		try {
			State = 3768;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,550,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3761; Match(REPEATABLE);
				State = 3762; Match(READ);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3763; Match(READ);
				State = 3764; Match(COMMITTED);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3765; Match(READ);
				State = 3766; Match(UNCOMMITTED);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3767; Match(SERIALIZABLE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ChangeMasterContext : ParserRuleContext {
		public ITerminalNode CHANGE() { return GetToken(MySqlParser.CHANGE, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public MasterOptionContext[] masterOption() {
			return GetRuleContexts<MasterOptionContext>();
		}
		public MasterOptionContext masterOption(int i) {
			return GetRuleContext<MasterOptionContext>(i);
		}
		public ChannelOptionContext channelOption() {
			return GetRuleContext<ChannelOptionContext>(0);
		}
		public ChangeMasterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_changeMaster; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterChangeMaster(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitChangeMaster(this);
		}
	}

	[RuleVersion(0)]
	public ChangeMasterContext changeMaster() {
		ChangeMasterContext _localctx = new ChangeMasterContext(Context, State);
		EnterRule(_localctx, 286, RULE_changeMaster);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3770; Match(CHANGE);
			State = 3771; Match(MASTER);
			State = 3772; Match(TO);
			State = 3773; masterOption();
			State = 3778;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3774; Match(COMMA);
				State = 3775; masterOption();
				}
				}
				State = 3780;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3782;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 3781; channelOption();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ChangeReplicationFilterContext : ParserRuleContext {
		public ITerminalNode CHANGE() { return GetToken(MySqlParser.CHANGE, 0); }
		public ITerminalNode REPLICATION() { return GetToken(MySqlParser.REPLICATION, 0); }
		public ITerminalNode FILTER() { return GetToken(MySqlParser.FILTER, 0); }
		public ReplicationFilterContext[] replicationFilter() {
			return GetRuleContexts<ReplicationFilterContext>();
		}
		public ReplicationFilterContext replicationFilter(int i) {
			return GetRuleContext<ReplicationFilterContext>(i);
		}
		public ChangeReplicationFilterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_changeReplicationFilter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterChangeReplicationFilter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitChangeReplicationFilter(this);
		}
	}

	[RuleVersion(0)]
	public ChangeReplicationFilterContext changeReplicationFilter() {
		ChangeReplicationFilterContext _localctx = new ChangeReplicationFilterContext(Context, State);
		EnterRule(_localctx, 288, RULE_changeReplicationFilter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3784; Match(CHANGE);
			State = 3785; Match(REPLICATION);
			State = 3786; Match(FILTER);
			State = 3787; replicationFilter();
			State = 3792;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3788; Match(COMMA);
				State = 3789; replicationFilter();
				}
				}
				State = 3794;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PurgeBinaryLogsContext : ParserRuleContext {
		public IToken purgeFormat;
		public IToken fileName;
		public IToken timeValue;
		public ITerminalNode PURGE() { return GetToken(MySqlParser.PURGE, 0); }
		public ITerminalNode LOGS() { return GetToken(MySqlParser.LOGS, 0); }
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public ITerminalNode BEFORE() { return GetToken(MySqlParser.BEFORE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PurgeBinaryLogsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_purgeBinaryLogs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPurgeBinaryLogs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPurgeBinaryLogs(this);
		}
	}

	[RuleVersion(0)]
	public PurgeBinaryLogsContext purgeBinaryLogs() {
		PurgeBinaryLogsContext _localctx = new PurgeBinaryLogsContext(Context, State);
		EnterRule(_localctx, 290, RULE_purgeBinaryLogs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3795; Match(PURGE);
			State = 3796;
			_localctx.purgeFormat = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==BINARY || _la==MASTER) ) {
				_localctx.purgeFormat = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3797; Match(LOGS);
			State = 3802;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TO:
				{
				State = 3798; Match(TO);
				State = 3799; _localctx.fileName = Match(STRING_LITERAL);
				}
				break;
			case BEFORE:
				{
				State = 3800; Match(BEFORE);
				State = 3801; _localctx.timeValue = Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResetMasterContext : ParserRuleContext {
		public ITerminalNode RESET() { return GetToken(MySqlParser.RESET, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ResetMasterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_resetMaster; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterResetMaster(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitResetMaster(this);
		}
	}

	[RuleVersion(0)]
	public ResetMasterContext resetMaster() {
		ResetMasterContext _localctx = new ResetMasterContext(Context, State);
		EnterRule(_localctx, 292, RULE_resetMaster);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3804; Match(RESET);
			State = 3805; Match(MASTER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResetSlaveContext : ParserRuleContext {
		public ITerminalNode RESET() { return GetToken(MySqlParser.RESET, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ChannelOptionContext channelOption() {
			return GetRuleContext<ChannelOptionContext>(0);
		}
		public ResetSlaveContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_resetSlave; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterResetSlave(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitResetSlave(this);
		}
	}

	[RuleVersion(0)]
	public ResetSlaveContext resetSlave() {
		ResetSlaveContext _localctx = new ResetSlaveContext(Context, State);
		EnterRule(_localctx, 294, RULE_resetSlave);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3807; Match(RESET);
			State = 3808; Match(SLAVE);
			State = 3810;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL) {
				{
				State = 3809; Match(ALL);
				}
			}

			State = 3813;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 3812; channelOption();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartSlaveContext : ParserRuleContext {
		public ITerminalNode START() { return GetToken(MySqlParser.START, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ThreadTypeContext[] threadType() {
			return GetRuleContexts<ThreadTypeContext>();
		}
		public ThreadTypeContext threadType(int i) {
			return GetRuleContext<ThreadTypeContext>(i);
		}
		public ITerminalNode UNTIL() { return GetToken(MySqlParser.UNTIL, 0); }
		public UntilOptionContext untilOption() {
			return GetRuleContext<UntilOptionContext>(0);
		}
		public ConnectionOptionContext[] connectionOption() {
			return GetRuleContexts<ConnectionOptionContext>();
		}
		public ConnectionOptionContext connectionOption(int i) {
			return GetRuleContext<ConnectionOptionContext>(i);
		}
		public ChannelOptionContext channelOption() {
			return GetRuleContext<ChannelOptionContext>(0);
		}
		public StartSlaveContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startSlave; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStartSlave(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStartSlave(this);
		}
	}

	[RuleVersion(0)]
	public StartSlaveContext startSlave() {
		StartSlaveContext _localctx = new StartSlaveContext(Context, State);
		EnterRule(_localctx, 296, RULE_startSlave);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3815; Match(START);
			State = 3816; Match(SLAVE);
			State = 3825;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IO_THREAD || _la==SQL_THREAD) {
				{
				State = 3817; threadType();
				State = 3822;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3818; Match(COMMA);
					State = 3819; threadType();
					}
					}
					State = 3824;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 3829;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNTIL) {
				{
				State = 3827; Match(UNTIL);
				State = 3828; untilOption();
				}
			}

			State = 3834;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DEFAULT_AUTH || _la==PASSWORD || _la==PLUGIN_DIR || _la==USER) {
				{
				{
				State = 3831; connectionOption();
				}
				}
				State = 3836;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3838;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 3837; channelOption();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StopSlaveContext : ParserRuleContext {
		public ITerminalNode STOP() { return GetToken(MySqlParser.STOP, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ThreadTypeContext[] threadType() {
			return GetRuleContexts<ThreadTypeContext>();
		}
		public ThreadTypeContext threadType(int i) {
			return GetRuleContext<ThreadTypeContext>(i);
		}
		public StopSlaveContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stopSlave; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStopSlave(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStopSlave(this);
		}
	}

	[RuleVersion(0)]
	public StopSlaveContext stopSlave() {
		StopSlaveContext _localctx = new StopSlaveContext(Context, State);
		EnterRule(_localctx, 298, RULE_stopSlave);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3840; Match(STOP);
			State = 3841; Match(SLAVE);
			State = 3850;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IO_THREAD || _la==SQL_THREAD) {
				{
				State = 3842; threadType();
				State = 3847;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3843; Match(COMMA);
					State = 3844; threadType();
					}
					}
					State = 3849;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartGroupReplicationContext : ParserRuleContext {
		public ITerminalNode START() { return GetToken(MySqlParser.START, 0); }
		public ITerminalNode GROUP_REPLICATION() { return GetToken(MySqlParser.GROUP_REPLICATION, 0); }
		public StartGroupReplicationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startGroupReplication; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStartGroupReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStartGroupReplication(this);
		}
	}

	[RuleVersion(0)]
	public StartGroupReplicationContext startGroupReplication() {
		StartGroupReplicationContext _localctx = new StartGroupReplicationContext(Context, State);
		EnterRule(_localctx, 300, RULE_startGroupReplication);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3852; Match(START);
			State = 3853; Match(GROUP_REPLICATION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StopGroupReplicationContext : ParserRuleContext {
		public ITerminalNode STOP() { return GetToken(MySqlParser.STOP, 0); }
		public ITerminalNode GROUP_REPLICATION() { return GetToken(MySqlParser.GROUP_REPLICATION, 0); }
		public StopGroupReplicationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stopGroupReplication; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStopGroupReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStopGroupReplication(this);
		}
	}

	[RuleVersion(0)]
	public StopGroupReplicationContext stopGroupReplication() {
		StopGroupReplicationContext _localctx = new StopGroupReplicationContext(Context, State);
		EnterRule(_localctx, 302, RULE_stopGroupReplication);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3855; Match(STOP);
			State = 3856; Match(GROUP_REPLICATION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MasterOptionContext : ParserRuleContext {
		public MasterOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_masterOption; } }
	 
		public MasterOptionContext() { }
		public virtual void CopyFrom(MasterOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class MasterStringOptionContext : MasterOptionContext {
		public StringMasterOptionContext stringMasterOption() {
			return GetRuleContext<StringMasterOptionContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public MasterStringOptionContext(MasterOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMasterStringOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMasterStringOption(this);
		}
	}
	public partial class MasterRealOptionContext : MasterOptionContext {
		public ITerminalNode MASTER_HEARTBEAT_PERIOD() { return GetToken(MySqlParser.MASTER_HEARTBEAT_PERIOD, 0); }
		public ITerminalNode REAL_LITERAL() { return GetToken(MySqlParser.REAL_LITERAL, 0); }
		public MasterRealOptionContext(MasterOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMasterRealOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMasterRealOption(this);
		}
	}
	public partial class MasterBoolOptionContext : MasterOptionContext {
		public IToken boolVal;
		public BoolMasterOptionContext boolMasterOption() {
			return GetRuleContext<BoolMasterOptionContext>(0);
		}
		public MasterBoolOptionContext(MasterOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMasterBoolOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMasterBoolOption(this);
		}
	}
	public partial class MasterUidListOptionContext : MasterOptionContext {
		public ITerminalNode IGNORE_SERVER_IDS() { return GetToken(MySqlParser.IGNORE_SERVER_IDS, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public MasterUidListOptionContext(MasterOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMasterUidListOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMasterUidListOption(this);
		}
	}
	public partial class MasterDecimalOptionContext : MasterOptionContext {
		public DecimalMasterOptionContext decimalMasterOption() {
			return GetRuleContext<DecimalMasterOptionContext>(0);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public MasterDecimalOptionContext(MasterOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMasterDecimalOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMasterDecimalOption(this);
		}
	}

	[RuleVersion(0)]
	public MasterOptionContext masterOption() {
		MasterOptionContext _localctx = new MasterOptionContext(Context, State);
		EnterRule(_localctx, 304, RULE_masterOption);
		int _la;
		try {
			State = 3887;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MASTER_BIND:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_PASSWORD:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case RELAY_LOG_FILE:
				_localctx = new MasterStringOptionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3858; stringMasterOption();
				State = 3859; Match(EQUAL_SYMBOL);
				State = 3860; Match(STRING_LITERAL);
				}
				break;
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_LOG_POS:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case RELAY_LOG_POS:
				_localctx = new MasterDecimalOptionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3862; decimalMasterOption();
				State = 3863; Match(EQUAL_SYMBOL);
				State = 3864; decimalLiteral();
				}
				break;
			case MASTER_SSL_VERIFY_SERVER_CERT:
			case MASTER_AUTO_POSITION:
			case MASTER_SSL:
				_localctx = new MasterBoolOptionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3866; boolMasterOption();
				State = 3867; Match(EQUAL_SYMBOL);
				State = 3868;
				((MasterBoolOptionContext)_localctx).boolVal = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
					((MasterBoolOptionContext)_localctx).boolVal = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case MASTER_HEARTBEAT_PERIOD:
				_localctx = new MasterRealOptionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 3870; Match(MASTER_HEARTBEAT_PERIOD);
				State = 3871; Match(EQUAL_SYMBOL);
				State = 3872; Match(REAL_LITERAL);
				}
				break;
			case IGNORE_SERVER_IDS:
				_localctx = new MasterUidListOptionContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 3873; Match(IGNORE_SERVER_IDS);
				State = 3874; Match(EQUAL_SYMBOL);
				State = 3875; Match(LR_BRACKET);
				State = 3884;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
					{
					State = 3876; uid();
					State = 3881;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 3877; Match(COMMA);
						State = 3878; uid();
						}
						}
						State = 3883;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 3886; Match(RR_BRACKET);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringMasterOptionContext : ParserRuleContext {
		public ITerminalNode MASTER_BIND() { return GetToken(MySqlParser.MASTER_BIND, 0); }
		public ITerminalNode MASTER_HOST() { return GetToken(MySqlParser.MASTER_HOST, 0); }
		public ITerminalNode MASTER_USER() { return GetToken(MySqlParser.MASTER_USER, 0); }
		public ITerminalNode MASTER_PASSWORD() { return GetToken(MySqlParser.MASTER_PASSWORD, 0); }
		public ITerminalNode MASTER_LOG_FILE() { return GetToken(MySqlParser.MASTER_LOG_FILE, 0); }
		public ITerminalNode RELAY_LOG_FILE() { return GetToken(MySqlParser.RELAY_LOG_FILE, 0); }
		public ITerminalNode MASTER_SSL_CA() { return GetToken(MySqlParser.MASTER_SSL_CA, 0); }
		public ITerminalNode MASTER_SSL_CAPATH() { return GetToken(MySqlParser.MASTER_SSL_CAPATH, 0); }
		public ITerminalNode MASTER_SSL_CERT() { return GetToken(MySqlParser.MASTER_SSL_CERT, 0); }
		public ITerminalNode MASTER_SSL_CRL() { return GetToken(MySqlParser.MASTER_SSL_CRL, 0); }
		public ITerminalNode MASTER_SSL_CRLPATH() { return GetToken(MySqlParser.MASTER_SSL_CRLPATH, 0); }
		public ITerminalNode MASTER_SSL_KEY() { return GetToken(MySqlParser.MASTER_SSL_KEY, 0); }
		public ITerminalNode MASTER_SSL_CIPHER() { return GetToken(MySqlParser.MASTER_SSL_CIPHER, 0); }
		public ITerminalNode MASTER_TLS_VERSION() { return GetToken(MySqlParser.MASTER_TLS_VERSION, 0); }
		public StringMasterOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringMasterOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStringMasterOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStringMasterOption(this);
		}
	}

	[RuleVersion(0)]
	public StringMasterOptionContext stringMasterOption() {
		StringMasterOptionContext _localctx = new StringMasterOptionContext(Context, State);
		EnterRule(_localctx, 306, RULE_stringMasterOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3889;
			_la = TokenStream.LA(1);
			if ( !(_la==MASTER_BIND || ((((_la - 385)) & ~0x3f) == 0 && ((1L << (_la - 385)) & ((1L << (MASTER_HOST - 385)) | (1L << (MASTER_LOG_FILE - 385)) | (1L << (MASTER_PASSWORD - 385)) | (1L << (MASTER_SSL_CA - 385)) | (1L << (MASTER_SSL_CAPATH - 385)) | (1L << (MASTER_SSL_CERT - 385)) | (1L << (MASTER_SSL_CIPHER - 385)) | (1L << (MASTER_SSL_CRL - 385)) | (1L << (MASTER_SSL_CRLPATH - 385)) | (1L << (MASTER_SSL_KEY - 385)) | (1L << (MASTER_TLS_VERSION - 385)) | (1L << (MASTER_USER - 385)))) != 0) || _la==RELAY_LOG_FILE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DecimalMasterOptionContext : ParserRuleContext {
		public ITerminalNode MASTER_PORT() { return GetToken(MySqlParser.MASTER_PORT, 0); }
		public ITerminalNode MASTER_CONNECT_RETRY() { return GetToken(MySqlParser.MASTER_CONNECT_RETRY, 0); }
		public ITerminalNode MASTER_RETRY_COUNT() { return GetToken(MySqlParser.MASTER_RETRY_COUNT, 0); }
		public ITerminalNode MASTER_DELAY() { return GetToken(MySqlParser.MASTER_DELAY, 0); }
		public ITerminalNode MASTER_LOG_POS() { return GetToken(MySqlParser.MASTER_LOG_POS, 0); }
		public ITerminalNode RELAY_LOG_POS() { return GetToken(MySqlParser.RELAY_LOG_POS, 0); }
		public DecimalMasterOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_decimalMasterOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDecimalMasterOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDecimalMasterOption(this);
		}
	}

	[RuleVersion(0)]
	public DecimalMasterOptionContext decimalMasterOption() {
		DecimalMasterOptionContext _localctx = new DecimalMasterOptionContext(Context, State);
		EnterRule(_localctx, 308, RULE_decimalMasterOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3891;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 382)) & ~0x3f) == 0 && ((1L << (_la - 382)) & ((1L << (MASTER_CONNECT_RETRY - 382)) | (1L << (MASTER_DELAY - 382)) | (1L << (MASTER_LOG_POS - 382)) | (1L << (MASTER_PORT - 382)) | (1L << (MASTER_RETRY_COUNT - 382)))) != 0) || _la==RELAY_LOG_POS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BoolMasterOptionContext : ParserRuleContext {
		public ITerminalNode MASTER_AUTO_POSITION() { return GetToken(MySqlParser.MASTER_AUTO_POSITION, 0); }
		public ITerminalNode MASTER_SSL() { return GetToken(MySqlParser.MASTER_SSL, 0); }
		public ITerminalNode MASTER_SSL_VERIFY_SERVER_CERT() { return GetToken(MySqlParser.MASTER_SSL_VERIFY_SERVER_CERT, 0); }
		public BoolMasterOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_boolMasterOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBoolMasterOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBoolMasterOption(this);
		}
	}

	[RuleVersion(0)]
	public BoolMasterOptionContext boolMasterOption() {
		BoolMasterOptionContext _localctx = new BoolMasterOptionContext(Context, State);
		EnterRule(_localctx, 310, RULE_boolMasterOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3893;
			_la = TokenStream.LA(1);
			if ( !(_la==MASTER_SSL_VERIFY_SERVER_CERT || _la==MASTER_AUTO_POSITION || _la==MASTER_SSL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ChannelOptionContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode CHANNEL() { return GetToken(MySqlParser.CHANNEL, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ChannelOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_channelOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterChannelOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitChannelOption(this);
		}
	}

	[RuleVersion(0)]
	public ChannelOptionContext channelOption() {
		ChannelOptionContext _localctx = new ChannelOptionContext(Context, State);
		EnterRule(_localctx, 312, RULE_channelOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3895; Match(FOR);
			State = 3896; Match(CHANNEL);
			State = 3897; Match(STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReplicationFilterContext : ParserRuleContext {
		public ReplicationFilterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_replicationFilter; } }
	 
		public ReplicationFilterContext() { }
		public virtual void CopyFrom(ReplicationFilterContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class WildIgnoreTableReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_WILD_IGNORE_TABLE() { return GetToken(MySqlParser.REPLICATE_WILD_IGNORE_TABLE, 0); }
		public SimpleStringsContext simpleStrings() {
			return GetRuleContext<SimpleStringsContext>(0);
		}
		public WildIgnoreTableReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterWildIgnoreTableReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitWildIgnoreTableReplication(this);
		}
	}
	public partial class DoTableReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_DO_TABLE() { return GetToken(MySqlParser.REPLICATE_DO_TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public DoTableReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDoTableReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDoTableReplication(this);
		}
	}
	public partial class IgnoreTableReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_IGNORE_TABLE() { return GetToken(MySqlParser.REPLICATE_IGNORE_TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public IgnoreTableReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIgnoreTableReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIgnoreTableReplication(this);
		}
	}
	public partial class RewriteDbReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_REWRITE_DB() { return GetToken(MySqlParser.REPLICATE_REWRITE_DB, 0); }
		public TablePairContext[] tablePair() {
			return GetRuleContexts<TablePairContext>();
		}
		public TablePairContext tablePair(int i) {
			return GetRuleContext<TablePairContext>(i);
		}
		public RewriteDbReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRewriteDbReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRewriteDbReplication(this);
		}
	}
	public partial class DoDbReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_DO_DB() { return GetToken(MySqlParser.REPLICATE_DO_DB, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public DoDbReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDoDbReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDoDbReplication(this);
		}
	}
	public partial class IgnoreDbReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_IGNORE_DB() { return GetToken(MySqlParser.REPLICATE_IGNORE_DB, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public IgnoreDbReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIgnoreDbReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIgnoreDbReplication(this);
		}
	}
	public partial class WildDoTableReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_WILD_DO_TABLE() { return GetToken(MySqlParser.REPLICATE_WILD_DO_TABLE, 0); }
		public SimpleStringsContext simpleStrings() {
			return GetRuleContext<SimpleStringsContext>(0);
		}
		public WildDoTableReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterWildDoTableReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitWildDoTableReplication(this);
		}
	}

	[RuleVersion(0)]
	public ReplicationFilterContext replicationFilter() {
		ReplicationFilterContext _localctx = new ReplicationFilterContext(Context, State);
		EnterRule(_localctx, 314, RULE_replicationFilter);
		int _la;
		try {
			State = 3948;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case REPLICATE_DO_DB:
				_localctx = new DoDbReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3899; Match(REPLICATE_DO_DB);
				State = 3900; Match(EQUAL_SYMBOL);
				State = 3901; Match(LR_BRACKET);
				State = 3902; uidList();
				State = 3903; Match(RR_BRACKET);
				}
				break;
			case REPLICATE_IGNORE_DB:
				_localctx = new IgnoreDbReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3905; Match(REPLICATE_IGNORE_DB);
				State = 3906; Match(EQUAL_SYMBOL);
				State = 3907; Match(LR_BRACKET);
				State = 3908; uidList();
				State = 3909; Match(RR_BRACKET);
				}
				break;
			case REPLICATE_DO_TABLE:
				_localctx = new DoTableReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3911; Match(REPLICATE_DO_TABLE);
				State = 3912; Match(EQUAL_SYMBOL);
				State = 3913; Match(LR_BRACKET);
				State = 3914; tables();
				State = 3915; Match(RR_BRACKET);
				}
				break;
			case REPLICATE_IGNORE_TABLE:
				_localctx = new IgnoreTableReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 3917; Match(REPLICATE_IGNORE_TABLE);
				State = 3918; Match(EQUAL_SYMBOL);
				State = 3919; Match(LR_BRACKET);
				State = 3920; tables();
				State = 3921; Match(RR_BRACKET);
				}
				break;
			case REPLICATE_WILD_DO_TABLE:
				_localctx = new WildDoTableReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 3923; Match(REPLICATE_WILD_DO_TABLE);
				State = 3924; Match(EQUAL_SYMBOL);
				State = 3925; Match(LR_BRACKET);
				State = 3926; simpleStrings();
				State = 3927; Match(RR_BRACKET);
				}
				break;
			case REPLICATE_WILD_IGNORE_TABLE:
				_localctx = new WildIgnoreTableReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 3929; Match(REPLICATE_WILD_IGNORE_TABLE);
				State = 3930; Match(EQUAL_SYMBOL);
				State = 3931; Match(LR_BRACKET);
				State = 3932; simpleStrings();
				State = 3933; Match(RR_BRACKET);
				}
				break;
			case REPLICATE_REWRITE_DB:
				_localctx = new RewriteDbReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 3935; Match(REPLICATE_REWRITE_DB);
				State = 3936; Match(EQUAL_SYMBOL);
				State = 3937; Match(LR_BRACKET);
				State = 3938; tablePair();
				State = 3943;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3939; Match(COMMA);
					State = 3940; tablePair();
					}
					}
					State = 3945;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3946; Match(RR_BRACKET);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablePairContext : ParserRuleContext {
		public TableNameContext firstTable;
		public TableNameContext secondTable;
		public TableNameContext[] tableName() {
			return GetRuleContexts<TableNameContext>();
		}
		public TableNameContext tableName(int i) {
			return GetRuleContext<TableNameContext>(i);
		}
		public TablePairContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablePair; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTablePair(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTablePair(this);
		}
	}

	[RuleVersion(0)]
	public TablePairContext tablePair() {
		TablePairContext _localctx = new TablePairContext(Context, State);
		EnterRule(_localctx, 316, RULE_tablePair);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3950; Match(LR_BRACKET);
			State = 3951; _localctx.firstTable = tableName();
			State = 3952; Match(COMMA);
			State = 3953; _localctx.secondTable = tableName();
			State = 3954; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ThreadTypeContext : ParserRuleContext {
		public ITerminalNode IO_THREAD() { return GetToken(MySqlParser.IO_THREAD, 0); }
		public ITerminalNode SQL_THREAD() { return GetToken(MySqlParser.SQL_THREAD, 0); }
		public ThreadTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_threadType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterThreadType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitThreadType(this);
		}
	}

	[RuleVersion(0)]
	public ThreadTypeContext threadType() {
		ThreadTypeContext _localctx = new ThreadTypeContext(Context, State);
		EnterRule(_localctx, 318, RULE_threadType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3956;
			_la = TokenStream.LA(1);
			if ( !(_la==IO_THREAD || _la==SQL_THREAD) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UntilOptionContext : ParserRuleContext {
		public UntilOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_untilOption; } }
	 
		public UntilOptionContext() { }
		public virtual void CopyFrom(UntilOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class GtidsUntilOptionContext : UntilOptionContext {
		public IToken gtids;
		public GtuidSetContext gtuidSet() {
			return GetRuleContext<GtuidSetContext>(0);
		}
		public ITerminalNode SQL_BEFORE_GTIDS() { return GetToken(MySqlParser.SQL_BEFORE_GTIDS, 0); }
		public ITerminalNode SQL_AFTER_GTIDS() { return GetToken(MySqlParser.SQL_AFTER_GTIDS, 0); }
		public GtidsUntilOptionContext(UntilOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGtidsUntilOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGtidsUntilOption(this);
		}
	}
	public partial class SqlGapsUntilOptionContext : UntilOptionContext {
		public ITerminalNode SQL_AFTER_MTS_GAPS() { return GetToken(MySqlParser.SQL_AFTER_MTS_GAPS, 0); }
		public SqlGapsUntilOptionContext(UntilOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSqlGapsUntilOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSqlGapsUntilOption(this);
		}
	}
	public partial class MasterLogUntilOptionContext : UntilOptionContext {
		public ITerminalNode MASTER_LOG_FILE() { return GetToken(MySqlParser.MASTER_LOG_FILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode MASTER_LOG_POS() { return GetToken(MySqlParser.MASTER_LOG_POS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public MasterLogUntilOptionContext(UntilOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMasterLogUntilOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMasterLogUntilOption(this);
		}
	}
	public partial class RelayLogUntilOptionContext : UntilOptionContext {
		public ITerminalNode RELAY_LOG_FILE() { return GetToken(MySqlParser.RELAY_LOG_FILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode RELAY_LOG_POS() { return GetToken(MySqlParser.RELAY_LOG_POS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public RelayLogUntilOptionContext(UntilOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRelayLogUntilOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRelayLogUntilOption(this);
		}
	}

	[RuleVersion(0)]
	public UntilOptionContext untilOption() {
		UntilOptionContext _localctx = new UntilOptionContext(Context, State);
		EnterRule(_localctx, 320, RULE_untilOption);
		int _la;
		try {
			State = 3976;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SQL_AFTER_GTIDS:
			case SQL_BEFORE_GTIDS:
				_localctx = new GtidsUntilOptionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3958;
				((GtidsUntilOptionContext)_localctx).gtids = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==SQL_AFTER_GTIDS || _la==SQL_BEFORE_GTIDS) ) {
					((GtidsUntilOptionContext)_localctx).gtids = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3959; Match(EQUAL_SYMBOL);
				State = 3960; gtuidSet();
				}
				break;
			case MASTER_LOG_FILE:
				_localctx = new MasterLogUntilOptionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3961; Match(MASTER_LOG_FILE);
				State = 3962; Match(EQUAL_SYMBOL);
				State = 3963; Match(STRING_LITERAL);
				State = 3964; Match(COMMA);
				State = 3965; Match(MASTER_LOG_POS);
				State = 3966; Match(EQUAL_SYMBOL);
				State = 3967; decimalLiteral();
				}
				break;
			case RELAY_LOG_FILE:
				_localctx = new RelayLogUntilOptionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3968; Match(RELAY_LOG_FILE);
				State = 3969; Match(EQUAL_SYMBOL);
				State = 3970; Match(STRING_LITERAL);
				State = 3971; Match(COMMA);
				State = 3972; Match(RELAY_LOG_POS);
				State = 3973; Match(EQUAL_SYMBOL);
				State = 3974; decimalLiteral();
				}
				break;
			case SQL_AFTER_MTS_GAPS:
				_localctx = new SqlGapsUntilOptionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 3975; Match(SQL_AFTER_MTS_GAPS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConnectionOptionContext : ParserRuleContext {
		public ConnectionOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_connectionOption; } }
	 
		public ConnectionOptionContext() { }
		public virtual void CopyFrom(ConnectionOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PluginDirConnectionOptionContext : ConnectionOptionContext {
		public IToken conOptPluginDir;
		public ITerminalNode PLUGIN_DIR() { return GetToken(MySqlParser.PLUGIN_DIR, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PluginDirConnectionOptionContext(ConnectionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPluginDirConnectionOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPluginDirConnectionOption(this);
		}
	}
	public partial class UserConnectionOptionContext : ConnectionOptionContext {
		public IToken conOptUser;
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public UserConnectionOptionContext(ConnectionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserConnectionOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserConnectionOption(this);
		}
	}
	public partial class DefaultAuthConnectionOptionContext : ConnectionOptionContext {
		public IToken conOptDefAuth;
		public ITerminalNode DEFAULT_AUTH() { return GetToken(MySqlParser.DEFAULT_AUTH, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public DefaultAuthConnectionOptionContext(ConnectionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDefaultAuthConnectionOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDefaultAuthConnectionOption(this);
		}
	}
	public partial class PasswordConnectionOptionContext : ConnectionOptionContext {
		public IToken conOptPassword;
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PasswordConnectionOptionContext(ConnectionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPasswordConnectionOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPasswordConnectionOption(this);
		}
	}

	[RuleVersion(0)]
	public ConnectionOptionContext connectionOption() {
		ConnectionOptionContext _localctx = new ConnectionOptionContext(Context, State);
		EnterRule(_localctx, 322, RULE_connectionOption);
		try {
			State = 3990;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case USER:
				_localctx = new UserConnectionOptionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3978; Match(USER);
				State = 3979; Match(EQUAL_SYMBOL);
				State = 3980; ((UserConnectionOptionContext)_localctx).conOptUser = Match(STRING_LITERAL);
				}
				break;
			case PASSWORD:
				_localctx = new PasswordConnectionOptionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3981; Match(PASSWORD);
				State = 3982; Match(EQUAL_SYMBOL);
				State = 3983; ((PasswordConnectionOptionContext)_localctx).conOptPassword = Match(STRING_LITERAL);
				}
				break;
			case DEFAULT_AUTH:
				_localctx = new DefaultAuthConnectionOptionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3984; Match(DEFAULT_AUTH);
				State = 3985; Match(EQUAL_SYMBOL);
				State = 3986; ((DefaultAuthConnectionOptionContext)_localctx).conOptDefAuth = Match(STRING_LITERAL);
				}
				break;
			case PLUGIN_DIR:
				_localctx = new PluginDirConnectionOptionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 3987; Match(PLUGIN_DIR);
				State = 3988; Match(EQUAL_SYMBOL);
				State = 3989; ((PluginDirConnectionOptionContext)_localctx).conOptPluginDir = Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GtuidSetContext : ParserRuleContext {
		public UuidSetContext[] uuidSet() {
			return GetRuleContexts<UuidSetContext>();
		}
		public UuidSetContext uuidSet(int i) {
			return GetRuleContext<UuidSetContext>(i);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public GtuidSetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gtuidSet; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGtuidSet(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGtuidSet(this);
		}
	}

	[RuleVersion(0)]
	public GtuidSetContext gtuidSet() {
		GtuidSetContext _localctx = new GtuidSetContext(Context, State);
		EnterRule(_localctx, 324, RULE_gtuidSet);
		int _la;
		try {
			State = 4001;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case DECIMAL_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3992; uuidSet();
				State = 3997;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3993; Match(COMMA);
					State = 3994; uuidSet();
					}
					}
					State = 3999;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4000; Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XaStartTransactionContext : ParserRuleContext {
		public IToken xaStart;
		public IToken xaAction;
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public XidContext xid() {
			return GetRuleContext<XidContext>(0);
		}
		public ITerminalNode START() { return GetToken(MySqlParser.START, 0); }
		public ITerminalNode BEGIN() { return GetToken(MySqlParser.BEGIN, 0); }
		public ITerminalNode JOIN() { return GetToken(MySqlParser.JOIN, 0); }
		public ITerminalNode RESUME() { return GetToken(MySqlParser.RESUME, 0); }
		public XaStartTransactionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xaStartTransaction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXaStartTransaction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXaStartTransaction(this);
		}
	}

	[RuleVersion(0)]
	public XaStartTransactionContext xaStartTransaction() {
		XaStartTransactionContext _localctx = new XaStartTransactionContext(Context, State);
		EnterRule(_localctx, 326, RULE_xaStartTransaction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4003; Match(XA);
			State = 4004;
			_localctx.xaStart = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==BEGIN || _la==START) ) {
				_localctx.xaStart = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4005; xid();
			State = 4007;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==JOIN || _la==RESUME) {
				{
				State = 4006;
				_localctx.xaAction = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==JOIN || _la==RESUME) ) {
					_localctx.xaAction = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XaEndTransactionContext : ParserRuleContext {
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public XidContext xid() {
			return GetRuleContext<XidContext>(0);
		}
		public ITerminalNode SUSPEND() { return GetToken(MySqlParser.SUSPEND, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode MIGRATE() { return GetToken(MySqlParser.MIGRATE, 0); }
		public XaEndTransactionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xaEndTransaction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXaEndTransaction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXaEndTransaction(this);
		}
	}

	[RuleVersion(0)]
	public XaEndTransactionContext xaEndTransaction() {
		XaEndTransactionContext _localctx = new XaEndTransactionContext(Context, State);
		EnterRule(_localctx, 328, RULE_xaEndTransaction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4009; Match(XA);
			State = 4010; Match(END);
			State = 4011; xid();
			State = 4017;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SUSPEND) {
				{
				State = 4012; Match(SUSPEND);
				State = 4015;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 4013; Match(FOR);
					State = 4014; Match(MIGRATE);
					}
				}

				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XaPrepareStatementContext : ParserRuleContext {
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public ITerminalNode PREPARE() { return GetToken(MySqlParser.PREPARE, 0); }
		public XidContext xid() {
			return GetRuleContext<XidContext>(0);
		}
		public XaPrepareStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xaPrepareStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXaPrepareStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXaPrepareStatement(this);
		}
	}

	[RuleVersion(0)]
	public XaPrepareStatementContext xaPrepareStatement() {
		XaPrepareStatementContext _localctx = new XaPrepareStatementContext(Context, State);
		EnterRule(_localctx, 330, RULE_xaPrepareStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4019; Match(XA);
			State = 4020; Match(PREPARE);
			State = 4021; xid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XaCommitWorkContext : ParserRuleContext {
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public ITerminalNode COMMIT() { return GetToken(MySqlParser.COMMIT, 0); }
		public XidContext xid() {
			return GetRuleContext<XidContext>(0);
		}
		public ITerminalNode ONE() { return GetToken(MySqlParser.ONE, 0); }
		public ITerminalNode PHASE() { return GetToken(MySqlParser.PHASE, 0); }
		public XaCommitWorkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xaCommitWork; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXaCommitWork(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXaCommitWork(this);
		}
	}

	[RuleVersion(0)]
	public XaCommitWorkContext xaCommitWork() {
		XaCommitWorkContext _localctx = new XaCommitWorkContext(Context, State);
		EnterRule(_localctx, 332, RULE_xaCommitWork);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4023; Match(XA);
			State = 4024; Match(COMMIT);
			State = 4025; xid();
			State = 4028;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ONE) {
				{
				State = 4026; Match(ONE);
				State = 4027; Match(PHASE);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XaRollbackWorkContext : ParserRuleContext {
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(MySqlParser.ROLLBACK, 0); }
		public XidContext xid() {
			return GetRuleContext<XidContext>(0);
		}
		public XaRollbackWorkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xaRollbackWork; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXaRollbackWork(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXaRollbackWork(this);
		}
	}

	[RuleVersion(0)]
	public XaRollbackWorkContext xaRollbackWork() {
		XaRollbackWorkContext _localctx = new XaRollbackWorkContext(Context, State);
		EnterRule(_localctx, 334, RULE_xaRollbackWork);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4030; Match(XA);
			State = 4031; Match(ROLLBACK);
			State = 4032; xid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XaRecoverWorkContext : ParserRuleContext {
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public ITerminalNode RECOVER() { return GetToken(MySqlParser.RECOVER, 0); }
		public ITerminalNode CONVERT() { return GetToken(MySqlParser.CONVERT, 0); }
		public XidContext xid() {
			return GetRuleContext<XidContext>(0);
		}
		public XaRecoverWorkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xaRecoverWork; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXaRecoverWork(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXaRecoverWork(this);
		}
	}

	[RuleVersion(0)]
	public XaRecoverWorkContext xaRecoverWork() {
		XaRecoverWorkContext _localctx = new XaRecoverWorkContext(Context, State);
		EnterRule(_localctx, 336, RULE_xaRecoverWork);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4034; Match(XA);
			State = 4035; Match(RECOVER);
			State = 4038;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONVERT) {
				{
				State = 4036; Match(CONVERT);
				State = 4037; xid();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrepareStatementContext : ParserRuleContext {
		public IToken query;
		public IToken variable;
		public ITerminalNode PREPARE() { return GetToken(MySqlParser.PREPARE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode LOCAL_ID() { return GetToken(MySqlParser.LOCAL_ID, 0); }
		public PrepareStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prepareStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPrepareStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPrepareStatement(this);
		}
	}

	[RuleVersion(0)]
	public PrepareStatementContext prepareStatement() {
		PrepareStatementContext _localctx = new PrepareStatementContext(Context, State);
		EnterRule(_localctx, 338, RULE_prepareStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4040; Match(PREPARE);
			State = 4041; uid();
			State = 4042; Match(FROM);
			State = 4045;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STRING_LITERAL:
				{
				State = 4043; _localctx.query = Match(STRING_LITERAL);
				}
				break;
			case LOCAL_ID:
				{
				State = 4044; _localctx.variable = Match(LOCAL_ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExecuteStatementContext : ParserRuleContext {
		public ITerminalNode EXECUTE() { return GetToken(MySqlParser.EXECUTE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public UserVariablesContext userVariables() {
			return GetRuleContext<UserVariablesContext>(0);
		}
		public ExecuteStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_executeStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExecuteStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExecuteStatement(this);
		}
	}

	[RuleVersion(0)]
	public ExecuteStatementContext executeStatement() {
		ExecuteStatementContext _localctx = new ExecuteStatementContext(Context, State);
		EnterRule(_localctx, 340, RULE_executeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4047; Match(EXECUTE);
			State = 4048; uid();
			State = 4051;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 4049; Match(USING);
				State = 4050; userVariables();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeallocatePrepareContext : ParserRuleContext {
		public IToken dropFormat;
		public ITerminalNode PREPARE() { return GetToken(MySqlParser.PREPARE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode DEALLOCATE() { return GetToken(MySqlParser.DEALLOCATE, 0); }
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public DeallocatePrepareContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deallocatePrepare; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDeallocatePrepare(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDeallocatePrepare(this);
		}
	}

	[RuleVersion(0)]
	public DeallocatePrepareContext deallocatePrepare() {
		DeallocatePrepareContext _localctx = new DeallocatePrepareContext(Context, State);
		EnterRule(_localctx, 342, RULE_deallocatePrepare);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4053;
			_localctx.dropFormat = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DROP || _la==DEALLOCATE) ) {
				_localctx.dropFormat = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4054; Match(PREPARE);
			State = 4055; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RoutineBodyContext : ParserRuleContext {
		public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		public SqlStatementContext sqlStatement() {
			return GetRuleContext<SqlStatementContext>(0);
		}
		public RoutineBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routineBody; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoutineBody(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoutineBody(this);
		}
	}

	[RuleVersion(0)]
	public RoutineBodyContext routineBody() {
		RoutineBodyContext _localctx = new RoutineBodyContext(Context, State);
		EnterRule(_localctx, 344, RULE_routineBody);
		try {
			State = 4059;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,580,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4057; blockStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4058; sqlStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockStatementContext : ParserRuleContext {
		public ITerminalNode BEGIN() { return GetToken(MySqlParser.BEGIN, 0); }
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public DeclareVariableContext[] declareVariable() {
			return GetRuleContexts<DeclareVariableContext>();
		}
		public DeclareVariableContext declareVariable(int i) {
			return GetRuleContext<DeclareVariableContext>(i);
		}
		public ITerminalNode[] SEMI() { return GetTokens(MySqlParser.SEMI); }
		public ITerminalNode SEMI(int i) {
			return GetToken(MySqlParser.SEMI, i);
		}
		public DeclareConditionContext[] declareCondition() {
			return GetRuleContexts<DeclareConditionContext>();
		}
		public DeclareConditionContext declareCondition(int i) {
			return GetRuleContext<DeclareConditionContext>(i);
		}
		public DeclareCursorContext[] declareCursor() {
			return GetRuleContexts<DeclareCursorContext>();
		}
		public DeclareCursorContext declareCursor(int i) {
			return GetRuleContext<DeclareCursorContext>(i);
		}
		public DeclareHandlerContext[] declareHandler() {
			return GetRuleContexts<DeclareHandlerContext>();
		}
		public DeclareHandlerContext declareHandler(int i) {
			return GetRuleContext<DeclareHandlerContext>(i);
		}
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public BlockStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBlockStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBlockStatement(this);
		}
	}

	[RuleVersion(0)]
	public BlockStatementContext blockStatement() {
		BlockStatementContext _localctx = new BlockStatementContext(Context, State);
		EnterRule(_localctx, 346, RULE_blockStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4064;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,581,Context) ) {
			case 1:
				{
				State = 4061; uid();
				State = 4062; Match(COLON_SYMB);
				}
				break;
			}
			State = 4066; Match(BEGIN);
			State = 4105;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,587,Context) ) {
			case 1:
				{
				State = 4072;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,582,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 4067; declareVariable();
						State = 4068; Match(SEMI);
						}
						} 
					}
					State = 4074;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,582,Context);
				}
				State = 4080;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,583,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 4075; declareCondition();
						State = 4076; Match(SEMI);
						}
						} 
					}
					State = 4082;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,583,Context);
				}
				State = 4088;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,584,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 4083; declareCursor();
						State = 4084; Match(SEMI);
						}
						} 
					}
					State = 4090;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,584,Context);
				}
				State = 4096;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==DECLARE) {
					{
					{
					State = 4091; declareHandler();
					State = 4092; Match(SEMI);
					}
					}
					State = 4098;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4102;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,586,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 4099; procedureSqlStatement();
						}
						} 
					}
					State = 4104;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,586,Context);
				}
				}
				break;
			}
			State = 4107; Match(END);
			State = 4109;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,588,Context) ) {
			case 1:
				{
				State = 4108; uid();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseStatementContext : ParserRuleContext {
		public ITerminalNode[] CASE() { return GetTokens(MySqlParser.CASE); }
		public ITerminalNode CASE(int i) {
			return GetToken(MySqlParser.CASE, i);
		}
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CaseAlternativeContext[] caseAlternative() {
			return GetRuleContexts<CaseAlternativeContext>();
		}
		public CaseAlternativeContext caseAlternative(int i) {
			return GetRuleContext<CaseAlternativeContext>(i);
		}
		public ITerminalNode ELSE() { return GetToken(MySqlParser.ELSE, 0); }
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public CaseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCaseStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCaseStatement(this);
		}
	}

	[RuleVersion(0)]
	public CaseStatementContext caseStatement() {
		CaseStatementContext _localctx = new CaseStatementContext(Context, State);
		EnterRule(_localctx, 348, RULE_caseStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4111; Match(CASE);
			State = 4114;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,589,Context) ) {
			case 1:
				{
				State = 4112; uid();
				}
				break;
			case 2:
				{
				State = 4113; expression(0);
				}
				break;
			}
			State = 4117;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 4116; caseAlternative();
				}
				}
				State = 4119;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 4127;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 4121; Match(ELSE);
				State = 4123;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 4122; procedureSqlStatement();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4125;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,591,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
			}

			State = 4129; Match(END);
			State = 4130; Match(CASE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		public ProcedureSqlStatementContext _procedureSqlStatement;
		public IList<ProcedureSqlStatementContext> _thenStatements = new List<ProcedureSqlStatementContext>();
		public IList<ProcedureSqlStatementContext> _elseStatements = new List<ProcedureSqlStatementContext>();
		public ITerminalNode[] IF() { return GetTokens(MySqlParser.IF); }
		public ITerminalNode IF(int i) {
			return GetToken(MySqlParser.IF, i);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(MySqlParser.THEN, 0); }
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public ElifAlternativeContext[] elifAlternative() {
			return GetRuleContexts<ElifAlternativeContext>();
		}
		public ElifAlternativeContext elifAlternative(int i) {
			return GetRuleContext<ElifAlternativeContext>(i);
		}
		public ITerminalNode ELSE() { return GetToken(MySqlParser.ELSE, 0); }
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIfStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIfStatement(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		IfStatementContext _localctx = new IfStatementContext(Context, State);
		EnterRule(_localctx, 350, RULE_ifStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4132; Match(IF);
			State = 4133; expression(0);
			State = 4134; Match(THEN);
			State = 4136;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4135; _localctx._procedureSqlStatement = procedureSqlStatement();
					_localctx._thenStatements.Add(_localctx._procedureSqlStatement);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4138;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,593,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			State = 4143;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ELSEIF) {
				{
				{
				State = 4140; elifAlternative();
				}
				}
				State = 4145;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4152;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 4146; Match(ELSE);
				State = 4148;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 4147; _localctx._procedureSqlStatement = procedureSqlStatement();
						_localctx._elseStatements.Add(_localctx._procedureSqlStatement);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4150;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,595,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
			}

			State = 4154; Match(END);
			State = 4155; Match(IF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IterateStatementContext : ParserRuleContext {
		public ITerminalNode ITERATE() { return GetToken(MySqlParser.ITERATE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public IterateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_iterateStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIterateStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIterateStatement(this);
		}
	}

	[RuleVersion(0)]
	public IterateStatementContext iterateStatement() {
		IterateStatementContext _localctx = new IterateStatementContext(Context, State);
		EnterRule(_localctx, 352, RULE_iterateStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4157; Match(ITERATE);
			State = 4158; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LeaveStatementContext : ParserRuleContext {
		public ITerminalNode LEAVE() { return GetToken(MySqlParser.LEAVE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public LeaveStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_leaveStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLeaveStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLeaveStatement(this);
		}
	}

	[RuleVersion(0)]
	public LeaveStatementContext leaveStatement() {
		LeaveStatementContext _localctx = new LeaveStatementContext(Context, State);
		EnterRule(_localctx, 354, RULE_leaveStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4160; Match(LEAVE);
			State = 4161; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopStatementContext : ParserRuleContext {
		public ITerminalNode[] LOOP() { return GetTokens(MySqlParser.LOOP); }
		public ITerminalNode LOOP(int i) {
			return GetToken(MySqlParser.LOOP, i);
		}
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public LoopStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLoopStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLoopStatement(this);
		}
	}

	[RuleVersion(0)]
	public LoopStatementContext loopStatement() {
		LoopStatementContext _localctx = new LoopStatementContext(Context, State);
		EnterRule(_localctx, 356, RULE_loopStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4166;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
				{
				State = 4163; uid();
				State = 4164; Match(COLON_SYMB);
				}
			}

			State = 4168; Match(LOOP);
			State = 4170;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4169; procedureSqlStatement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4172;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,598,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			State = 4174; Match(END);
			State = 4175; Match(LOOP);
			State = 4177;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
				{
				State = 4176; uid();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RepeatStatementContext : ParserRuleContext {
		public ITerminalNode[] REPEAT() { return GetTokens(MySqlParser.REPEAT); }
		public ITerminalNode REPEAT(int i) {
			return GetToken(MySqlParser.REPEAT, i);
		}
		public ITerminalNode UNTIL() { return GetToken(MySqlParser.UNTIL, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public RepeatStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_repeatStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRepeatStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRepeatStatement(this);
		}
	}

	[RuleVersion(0)]
	public RepeatStatementContext repeatStatement() {
		RepeatStatementContext _localctx = new RepeatStatementContext(Context, State);
		EnterRule(_localctx, 358, RULE_repeatStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
				{
				State = 4179; uid();
				State = 4180; Match(COLON_SYMB);
				}
			}

			State = 4184; Match(REPEAT);
			State = 4186;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4185; procedureSqlStatement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4188;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,601,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			State = 4190; Match(UNTIL);
			State = 4191; expression(0);
			State = 4192; Match(END);
			State = 4193; Match(REPEAT);
			State = 4195;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
				{
				State = 4194; uid();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnStatementContext : ParserRuleContext {
		public ITerminalNode RETURN() { return GetToken(MySqlParser.RETURN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ReturnStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReturnStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReturnStatement(this);
		}
	}

	[RuleVersion(0)]
	public ReturnStatementContext returnStatement() {
		ReturnStatementContext _localctx = new ReturnStatementContext(Context, State);
		EnterRule(_localctx, 360, RULE_returnStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4197; Match(RETURN);
			State = 4198; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileStatementContext : ParserRuleContext {
		public ITerminalNode[] WHILE() { return GetTokens(MySqlParser.WHILE); }
		public ITerminalNode WHILE(int i) {
			return GetToken(MySqlParser.WHILE, i);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode DO() { return GetToken(MySqlParser.DO, 0); }
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public WhileStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterWhileStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitWhileStatement(this);
		}
	}

	[RuleVersion(0)]
	public WhileStatementContext whileStatement() {
		WhileStatementContext _localctx = new WhileStatementContext(Context, State);
		EnterRule(_localctx, 362, RULE_whileStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4203;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
				{
				State = 4200; uid();
				State = 4201; Match(COLON_SYMB);
				}
			}

			State = 4205; Match(WHILE);
			State = 4206; expression(0);
			State = 4207; Match(DO);
			State = 4209;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4208; procedureSqlStatement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4211;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,604,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			State = 4213; Match(END);
			State = 4214; Match(WHILE);
			State = 4216;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)) | (1L << (SERIAL - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 252)) & ~0x3f) == 0 && ((1L << (_la - 252)) & ((1L << (ACCOUNT - 252)) | (1L << (ACTION - 252)) | (1L << (AFTER - 252)) | (1L << (AGGREGATE - 252)) | (1L << (ALGORITHM - 252)) | (1L << (ANY - 252)) | (1L << (AT - 252)) | (1L << (AUTHORS - 252)) | (1L << (AUTOCOMMIT - 252)) | (1L << (AUTOEXTEND_SIZE - 252)) | (1L << (AUTO_INCREMENT - 252)) | (1L << (AVG_ROW_LENGTH - 252)) | (1L << (BEGIN - 252)) | (1L << (BINLOG - 252)) | (1L << (BIT - 252)) | (1L << (BLOCK - 252)) | (1L << (BOOL - 252)) | (1L << (BOOLEAN - 252)) | (1L << (BTREE - 252)) | (1L << (CACHE - 252)) | (1L << (CASCADED - 252)) | (1L << (CHAIN - 252)) | (1L << (CHANGED - 252)) | (1L << (CHANNEL - 252)) | (1L << (CHECKSUM - 252)) | (1L << (PAGE_CHECKSUM - 252)) | (1L << (CIPHER - 252)) | (1L << (CLIENT - 252)) | (1L << (CLOSE - 252)) | (1L << (COALESCE - 252)) | (1L << (CODE - 252)) | (1L << (COLUMNS - 252)) | (1L << (COLUMN_FORMAT - 252)) | (1L << (COMMENT - 252)) | (1L << (COMMIT - 252)) | (1L << (COMPACT - 252)) | (1L << (COMPLETION - 252)) | (1L << (COMPRESSED - 252)) | (1L << (COMPRESSION - 252)) | (1L << (CONCURRENT - 252)) | (1L << (CONNECTION - 252)) | (1L << (CONSISTENT - 252)) | (1L << (CONTAINS - 252)) | (1L << (CONTEXT - 252)) | (1L << (CONTRIBUTORS - 252)) | (1L << (COPY - 252)) | (1L << (CPU - 252)) | (1L << (DATA - 252)) | (1L << (DATAFILE - 252)) | (1L << (DEALLOCATE - 252)) | (1L << (DEFAULT_AUTH - 252)) | (1L << (DEFINER - 252)) | (1L << (DELAY_KEY_WRITE - 252)) | (1L << (DES_KEY_FILE - 252)) | (1L << (DIRECTORY - 252)) | (1L << (DISABLE - 252)) | (1L << (DISCARD - 252)) | (1L << (DISK - 252)) | (1L << (DO - 252)) | (1L << (DUMPFILE - 252)) | (1L << (DUPLICATE - 252)) | (1L << (DYNAMIC - 252)) | (1L << (ENABLE - 252)) | (1L << (ENCRYPTION - 252)))) != 0) || ((((_la - 316)) & ~0x3f) == 0 && ((1L << (_la - 316)) & ((1L << (END - 316)) | (1L << (ENDS - 316)) | (1L << (ENGINE - 316)) | (1L << (ENGINES - 316)) | (1L << (ERROR - 316)) | (1L << (ERRORS - 316)) | (1L << (ESCAPE - 316)) | (1L << (EVEN - 316)) | (1L << (EVENT - 316)) | (1L << (EVENTS - 316)) | (1L << (EVERY - 316)) | (1L << (EXCHANGE - 316)) | (1L << (EXCLUSIVE - 316)) | (1L << (EXPIRE - 316)) | (1L << (EXPORT - 316)) | (1L << (EXTENDED - 316)) | (1L << (EXTENT_SIZE - 316)) | (1L << (FAST - 316)) | (1L << (FAULTS - 316)) | (1L << (FIELDS - 316)) | (1L << (FILE_BLOCK_SIZE - 316)) | (1L << (FILTER - 316)) | (1L << (FIRST - 316)) | (1L << (FIXED - 316)) | (1L << (FLUSH - 316)) | (1L << (FOLLOWS - 316)) | (1L << (FOUND - 316)) | (1L << (FULL - 316)) | (1L << (FUNCTION - 316)) | (1L << (GENERAL - 316)) | (1L << (GLOBAL - 316)) | (1L << (GRANTS - 316)) | (1L << (GROUP_REPLICATION - 316)) | (1L << (HANDLER - 316)) | (1L << (HASH - 316)) | (1L << (HELP - 316)) | (1L << (HOST - 316)) | (1L << (HOSTS - 316)) | (1L << (IDENTIFIED - 316)) | (1L << (IGNORE_SERVER_IDS - 316)) | (1L << (IMPORT - 316)) | (1L << (INDEXES - 316)) | (1L << (INITIAL_SIZE - 316)) | (1L << (INPLACE - 316)) | (1L << (INSERT_METHOD - 316)) | (1L << (INSTALL - 316)) | (1L << (INSTANCE - 316)) | (1L << (INVOKER - 316)) | (1L << (IO - 316)) | (1L << (IO_THREAD - 316)) | (1L << (IPC - 316)) | (1L << (ISOLATION - 316)) | (1L << (ISSUER - 316)) | (1L << (JSON - 316)) | (1L << (KEY_BLOCK_SIZE - 316)) | (1L << (LANGUAGE - 316)) | (1L << (LAST - 316)) | (1L << (LEAVES - 316)) | (1L << (LESS - 316)) | (1L << (LEVEL - 316)) | (1L << (LIST - 316)) | (1L << (LOCAL - 316)) | (1L << (LOGFILE - 316)) | (1L << (LOGS - 316)))) != 0) || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (MASTER - 380)) | (1L << (MASTER_AUTO_POSITION - 380)) | (1L << (MASTER_CONNECT_RETRY - 380)) | (1L << (MASTER_DELAY - 380)) | (1L << (MASTER_HEARTBEAT_PERIOD - 380)) | (1L << (MASTER_HOST - 380)) | (1L << (MASTER_LOG_FILE - 380)) | (1L << (MASTER_LOG_POS - 380)) | (1L << (MASTER_PASSWORD - 380)) | (1L << (MASTER_PORT - 380)) | (1L << (MASTER_RETRY_COUNT - 380)) | (1L << (MASTER_SSL - 380)) | (1L << (MASTER_SSL_CA - 380)) | (1L << (MASTER_SSL_CAPATH - 380)) | (1L << (MASTER_SSL_CERT - 380)) | (1L << (MASTER_SSL_CIPHER - 380)) | (1L << (MASTER_SSL_CRL - 380)) | (1L << (MASTER_SSL_CRLPATH - 380)) | (1L << (MASTER_SSL_KEY - 380)) | (1L << (MASTER_TLS_VERSION - 380)) | (1L << (MASTER_USER - 380)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 380)) | (1L << (MAX_QUERIES_PER_HOUR - 380)) | (1L << (MAX_ROWS - 380)) | (1L << (MAX_SIZE - 380)) | (1L << (MAX_UPDATES_PER_HOUR - 380)) | (1L << (MAX_USER_CONNECTIONS - 380)) | (1L << (MEDIUM - 380)) | (1L << (MERGE - 380)) | (1L << (MID - 380)) | (1L << (MIGRATE - 380)) | (1L << (MIN_ROWS - 380)) | (1L << (MODE - 380)) | (1L << (MODIFY - 380)) | (1L << (MUTEX - 380)) | (1L << (MYSQL - 380)) | (1L << (NAME - 380)) | (1L << (NAMES - 380)) | (1L << (NCHAR - 380)) | (1L << (NEVER - 380)) | (1L << (NEXT - 380)) | (1L << (NO - 380)) | (1L << (NODEGROUP - 380)) | (1L << (NONE - 380)) | (1L << (OFFLINE - 380)) | (1L << (OFFSET - 380)) | (1L << (OJ - 380)) | (1L << (OLD_PASSWORD - 380)) | (1L << (ONE - 380)) | (1L << (ONLINE - 380)) | (1L << (ONLY - 380)) | (1L << (OPEN - 380)) | (1L << (OPTIMIZER_COSTS - 380)) | (1L << (OPTIONS - 380)) | (1L << (OWNER - 380)) | (1L << (PACK_KEYS - 380)) | (1L << (PAGE - 380)) | (1L << (PARSER - 380)) | (1L << (PARTIAL - 380)) | (1L << (PARTITIONING - 380)) | (1L << (PARTITIONS - 380)) | (1L << (PASSWORD - 380)) | (1L << (PHASE - 380)) | (1L << (PLUGIN - 380)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PLUGIN_DIR - 444)) | (1L << (PLUGINS - 444)) | (1L << (PORT - 444)) | (1L << (PRECEDES - 444)) | (1L << (PREPARE - 444)) | (1L << (PRESERVE - 444)) | (1L << (PREV - 444)) | (1L << (PROCESSLIST - 444)) | (1L << (PROFILE - 444)) | (1L << (PROFILES - 444)) | (1L << (PROXY - 444)) | (1L << (QUERY - 444)) | (1L << (QUICK - 444)) | (1L << (REBUILD - 444)) | (1L << (RECOVER - 444)) | (1L << (REDO_BUFFER_SIZE - 444)) | (1L << (REDUNDANT - 444)) | (1L << (RELAY - 444)) | (1L << (RELAY_LOG_FILE - 444)) | (1L << (RELAY_LOG_POS - 444)) | (1L << (RELAYLOG - 444)) | (1L << (REMOVE - 444)) | (1L << (REORGANIZE - 444)) | (1L << (REPAIR - 444)) | (1L << (REPLICATE_DO_DB - 444)) | (1L << (REPLICATE_DO_TABLE - 444)) | (1L << (REPLICATE_IGNORE_DB - 444)) | (1L << (REPLICATE_IGNORE_TABLE - 444)) | (1L << (REPLICATE_REWRITE_DB - 444)) | (1L << (REPLICATE_WILD_DO_TABLE - 444)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 444)) | (1L << (REPLICATION - 444)) | (1L << (RESET - 444)) | (1L << (RESUME - 444)) | (1L << (RETURNS - 444)) | (1L << (ROLLBACK - 444)) | (1L << (ROLLUP - 444)) | (1L << (ROTATE - 444)) | (1L << (ROW - 444)) | (1L << (ROWS - 444)) | (1L << (ROW_FORMAT - 444)) | (1L << (SAVEPOINT - 444)) | (1L << (SCHEDULE - 444)) | (1L << (SECURITY - 444)) | (1L << (SERVER - 444)) | (1L << (SESSION - 444)) | (1L << (SHARE - 444)) | (1L << (SHARED - 444)) | (1L << (SIGNED - 444)) | (1L << (SIMPLE - 444)) | (1L << (SLAVE - 444)) | (1L << (SLOW - 444)) | (1L << (SNAPSHOT - 444)) | (1L << (SOCKET - 444)) | (1L << (SOME - 444)) | (1L << (SONAME - 444)) | (1L << (SOUNDS - 444)) | (1L << (SOURCE - 444)) | (1L << (SQL_AFTER_GTIDS - 444)) | (1L << (SQL_AFTER_MTS_GAPS - 444)) | (1L << (SQL_BEFORE_GTIDS - 444)) | (1L << (SQL_BUFFER_RESULT - 444)) | (1L << (SQL_CACHE - 444)) | (1L << (SQL_NO_CACHE - 444)))) != 0) || ((((_la - 508)) & ~0x3f) == 0 && ((1L << (_la - 508)) & ((1L << (SQL_THREAD - 508)) | (1L << (START - 508)) | (1L << (STARTS - 508)) | (1L << (STATS_AUTO_RECALC - 508)) | (1L << (STATS_PERSISTENT - 508)) | (1L << (STATS_SAMPLE_PAGES - 508)) | (1L << (STATUS - 508)) | (1L << (STOP - 508)) | (1L << (STORAGE - 508)) | (1L << (STRING - 508)) | (1L << (SUBJECT - 508)) | (1L << (SUBPARTITION - 508)) | (1L << (SUBPARTITIONS - 508)) | (1L << (SUSPEND - 508)) | (1L << (SWAPS - 508)) | (1L << (SWITCHES - 508)) | (1L << (TABLESPACE - 508)) | (1L << (TEMPORARY - 508)) | (1L << (TEMPTABLE - 508)) | (1L << (THAN - 508)) | (1L << (TRADITIONAL - 508)) | (1L << (TRANSACTION - 508)) | (1L << (TRIGGERS - 508)) | (1L << (TRUNCATE - 508)) | (1L << (UNDEFINED - 508)) | (1L << (UNDOFILE - 508)) | (1L << (UNDO_BUFFER_SIZE - 508)) | (1L << (UNINSTALL - 508)) | (1L << (UNKNOWN - 508)) | (1L << (UNTIL - 508)) | (1L << (UPGRADE - 508)) | (1L << (USER - 508)) | (1L << (USE_FRM - 508)) | (1L << (USER_RESOURCES - 508)) | (1L << (VALIDATION - 508)) | (1L << (VALUE - 508)) | (1L << (VARIABLES - 508)) | (1L << (VIEW - 508)) | (1L << (WAIT - 508)) | (1L << (WARNINGS - 508)) | (1L << (WITHOUT - 508)) | (1L << (WORK - 508)) | (1L << (WRAPPER - 508)) | (1L << (X509 - 508)) | (1L << (XA - 508)) | (1L << (XML - 508)) | (1L << (INTERNAL - 508)) | (1L << (QUARTER - 508)) | (1L << (MONTH - 508)) | (1L << (DAY - 508)) | (1L << (HOUR - 508)) | (1L << (MINUTE - 508)) | (1L << (WEEK - 508)) | (1L << (SECOND - 508)) | (1L << (MICROSECOND - 508)) | (1L << (TABLES - 508)) | (1L << (ROUTINE - 508)) | (1L << (EXECUTE - 508)))) != 0) || ((((_la - 572)) & ~0x3f) == 0 && ((1L << (_la - 572)) & ((1L << (FILE - 572)) | (1L << (PROCESS - 572)) | (1L << (RELOAD - 572)) | (1L << (SHUTDOWN - 572)) | (1L << (SUPER - 572)) | (1L << (PRIVILEGES - 572)) | (1L << (ARMSCII8 - 572)) | (1L << (ASCII - 572)) | (1L << (BIG5 - 572)) | (1L << (CP1250 - 572)) | (1L << (CP1251 - 572)) | (1L << (CP1256 - 572)) | (1L << (CP1257 - 572)) | (1L << (CP850 - 572)) | (1L << (CP852 - 572)) | (1L << (CP866 - 572)) | (1L << (CP932 - 572)) | (1L << (DEC8 - 572)) | (1L << (EUCJPMS - 572)) | (1L << (EUCKR - 572)) | (1L << (GB2312 - 572)) | (1L << (GBK - 572)) | (1L << (GEOSTD8 - 572)) | (1L << (GREEK - 572)) | (1L << (HEBREW - 572)) | (1L << (HP8 - 572)) | (1L << (KEYBCS2 - 572)) | (1L << (KOI8R - 572)) | (1L << (KOI8U - 572)) | (1L << (LATIN1 - 572)) | (1L << (LATIN2 - 572)) | (1L << (LATIN5 - 572)) | (1L << (LATIN7 - 572)) | (1L << (MACCE - 572)) | (1L << (MACROMAN - 572)) | (1L << (SJIS - 572)) | (1L << (SWE7 - 572)) | (1L << (TIS620 - 572)) | (1L << (UCS2 - 572)) | (1L << (UJIS - 572)) | (1L << (UTF16 - 572)) | (1L << (UTF16LE - 572)) | (1L << (UTF32 - 572)) | (1L << (UTF8 - 572)) | (1L << (UTF8MB3 - 572)) | (1L << (UTF8MB4 - 572)) | (1L << (ARCHIVE - 572)) | (1L << (BLACKHOLE - 572)) | (1L << (CSV - 572)) | (1L << (FEDERATED - 572)) | (1L << (INNODB - 572)) | (1L << (MEMORY - 572)) | (1L << (MRG_MYISAM - 572)) | (1L << (MYISAM - 572)) | (1L << (NDB - 572)) | (1L << (NDBCLUSTER - 572)) | (1L << (PERFORMANCE_SCHEMA - 572)) | (1L << (TOKUDB - 572)) | (1L << (REPEATABLE - 572)) | (1L << (COMMITTED - 572)) | (1L << (UNCOMMITTED - 572)) | (1L << (SERIALIZABLE - 572)) | (1L << (GEOMETRYCOLLECTION - 572)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)) | (1L << (CREATE_DIGEST - 637)) | (1L << (CROSSES - 637)) | (1L << (DATEDIFF - 637)) | (1L << (DATE_FORMAT - 637)) | (1L << (DAYNAME - 637)) | (1L << (DAYOFMONTH - 637)) | (1L << (DAYOFWEEK - 637)) | (1L << (DAYOFYEAR - 637)) | (1L << (DECODE - 637)) | (1L << (DEGREES - 637)) | (1L << (DES_DECRYPT - 637)) | (1L << (DES_ENCRYPT - 637)) | (1L << (DIMENSION - 637)) | (1L << (DISJOINT - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)) | (1L << (IS_IPV4_MAPPED - 701)) | (1L << (IS_IPV6 - 701)) | (1L << (IS_USED_LOCK - 701)) | (1L << (LAST_INSERT_ID - 701)) | (1L << (LCASE - 701)) | (1L << (LEAST - 701)) | (1L << (LENGTH - 701)) | (1L << (LINEFROMTEXT - 701)) | (1L << (LINEFROMWKB - 701)) | (1L << (LINESTRINGFROMTEXT - 701)) | (1L << (LINESTRINGFROMWKB - 701)) | (1L << (LN - 701)) | (1L << (LOAD_FILE - 701)) | (1L << (LOCATE - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)) | (1L << (POW - 765)) | (1L << (POWER - 765)) | (1L << (QUOTE - 765)) | (1L << (RADIANS - 765)) | (1L << (RAND - 765)) | (1L << (RANDOM_BYTES - 765)) | (1L << (RELEASE_LOCK - 765)) | (1L << (REVERSE - 765)) | (1L << (ROUND - 765)) | (1L << (ROW_COUNT - 765)) | (1L << (RPAD - 765)) | (1L << (RTRIM - 765)) | (1L << (SEC_TO_TIME - 765)) | (1L << (SESSION_USER - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)) | (1L << (ST_LINESTRINGFROMTEXT - 829)) | (1L << (ST_LINESTRINGFROMWKB - 829)) | (1L << (ST_NUMGEOMETRIES - 829)) | (1L << (ST_NUMINTERIORRING - 829)) | (1L << (ST_NUMINTERIORRINGS - 829)) | (1L << (ST_NUMPOINTS - 829)) | (1L << (ST_OVERLAPS - 829)) | (1L << (ST_POINTFROMTEXT - 829)) | (1L << (ST_POINTFROMWKB - 829)) | (1L << (ST_POINTN - 829)) | (1L << (ST_POLYFROMTEXT - 829)) | (1L << (ST_POLYFROMWKB - 829)) | (1L << (ST_POLYGONFROMTEXT - 829)) | (1L << (ST_POLYGONFROMWKB - 829)) | (1L << (ST_SRID - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 971)) & ~0x3f) == 0 && ((1L << (_la - 971)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 971)) | (1L << (STRING_LITERAL - 971)) | (1L << (ID - 971)) | (1L << (REVERSE_QUOTE_ID - 971)))) != 0)) {
				{
				State = 4215; uid();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorStatementContext : ParserRuleContext {
		public CursorStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorStatement; } }
	 
		public CursorStatementContext() { }
		public virtual void CopyFrom(CursorStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CloseCursorContext : CursorStatementContext {
		public ITerminalNode CLOSE() { return GetToken(MySqlParser.CLOSE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public CloseCursorContext(CursorStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCloseCursor(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCloseCursor(this);
		}
	}
	public partial class OpenCursorContext : CursorStatementContext {
		public ITerminalNode OPEN() { return GetToken(MySqlParser.OPEN, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public OpenCursorContext(CursorStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterOpenCursor(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitOpenCursor(this);
		}
	}
	public partial class FetchCursorContext : CursorStatementContext {
		public ITerminalNode FETCH() { return GetToken(MySqlParser.FETCH, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode NEXT() { return GetToken(MySqlParser.NEXT, 0); }
		public FetchCursorContext(CursorStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFetchCursor(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFetchCursor(this);
		}
	}

	[RuleVersion(0)]
	public CursorStatementContext cursorStatement() {
		CursorStatementContext _localctx = new CursorStatementContext(Context, State);
		EnterRule(_localctx, 364, RULE_cursorStatement);
		int _la;
		try {
			State = 4233;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CLOSE:
				_localctx = new CloseCursorContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4218; Match(CLOSE);
				State = 4219; uid();
				}
				break;
			case FETCH:
				_localctx = new FetchCursorContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4220; Match(FETCH);
				State = 4225;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,607,Context) ) {
				case 1:
					{
					State = 4222;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NEXT) {
						{
						State = 4221; Match(NEXT);
						}
					}

					State = 4224; Match(FROM);
					}
					break;
				}
				State = 4227; uid();
				State = 4228; Match(INTO);
				State = 4229; uidList();
				}
				break;
			case OPEN:
				_localctx = new OpenCursorContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 4231; Match(OPEN);
				State = 4232; uid();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclareVariableContext : ParserRuleContext {
		public ITerminalNode DECLARE() { return GetToken(MySqlParser.DECLARE, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public DefaultValueContext defaultValue() {
			return GetRuleContext<DefaultValueContext>(0);
		}
		public DeclareVariableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declareVariable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDeclareVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDeclareVariable(this);
		}
	}

	[RuleVersion(0)]
	public DeclareVariableContext declareVariable() {
		DeclareVariableContext _localctx = new DeclareVariableContext(Context, State);
		EnterRule(_localctx, 366, RULE_declareVariable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4235; Match(DECLARE);
			State = 4236; uidList();
			State = 4237; dataType();
			State = 4240;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT) {
				{
				State = 4238; Match(DEFAULT);
				State = 4239; defaultValue();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclareConditionContext : ParserRuleContext {
		public ITerminalNode DECLARE() { return GetToken(MySqlParser.DECLARE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode CONDITION() { return GetToken(MySqlParser.CONDITION, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode SQLSTATE() { return GetToken(MySqlParser.SQLSTATE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode VALUE() { return GetToken(MySqlParser.VALUE, 0); }
		public DeclareConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declareCondition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDeclareCondition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDeclareCondition(this);
		}
	}

	[RuleVersion(0)]
	public DeclareConditionContext declareCondition() {
		DeclareConditionContext _localctx = new DeclareConditionContext(Context, State);
		EnterRule(_localctx, 368, RULE_declareCondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4242; Match(DECLARE);
			State = 4243; uid();
			State = 4244; Match(CONDITION);
			State = 4245; Match(FOR);
			State = 4252;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case DECIMAL_LITERAL:
				{
				State = 4246; decimalLiteral();
				}
				break;
			case SQLSTATE:
				{
				State = 4247; Match(SQLSTATE);
				State = 4249;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==VALUE) {
					{
					State = 4248; Match(VALUE);
					}
				}

				State = 4251; Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclareCursorContext : ParserRuleContext {
		public ITerminalNode DECLARE() { return GetToken(MySqlParser.DECLARE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode CURSOR() { return GetToken(MySqlParser.CURSOR, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public DeclareCursorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declareCursor; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDeclareCursor(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDeclareCursor(this);
		}
	}

	[RuleVersion(0)]
	public DeclareCursorContext declareCursor() {
		DeclareCursorContext _localctx = new DeclareCursorContext(Context, State);
		EnterRule(_localctx, 370, RULE_declareCursor);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4254; Match(DECLARE);
			State = 4255; uid();
			State = 4256; Match(CURSOR);
			State = 4257; Match(FOR);
			State = 4258; selectStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclareHandlerContext : ParserRuleContext {
		public IToken handlerAction;
		public ITerminalNode DECLARE() { return GetToken(MySqlParser.DECLARE, 0); }
		public ITerminalNode HANDLER() { return GetToken(MySqlParser.HANDLER, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public HandlerConditionValueContext[] handlerConditionValue() {
			return GetRuleContexts<HandlerConditionValueContext>();
		}
		public HandlerConditionValueContext handlerConditionValue(int i) {
			return GetRuleContext<HandlerConditionValueContext>(i);
		}
		public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		public ITerminalNode CONTINUE() { return GetToken(MySqlParser.CONTINUE, 0); }
		public ITerminalNode EXIT() { return GetToken(MySqlParser.EXIT, 0); }
		public ITerminalNode UNDO() { return GetToken(MySqlParser.UNDO, 0); }
		public DeclareHandlerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declareHandler; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDeclareHandler(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDeclareHandler(this);
		}
	}

	[RuleVersion(0)]
	public DeclareHandlerContext declareHandler() {
		DeclareHandlerContext _localctx = new DeclareHandlerContext(Context, State);
		EnterRule(_localctx, 372, RULE_declareHandler);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4260; Match(DECLARE);
			State = 4261;
			_localctx.handlerAction = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==CONTINUE || _la==EXIT || _la==UNDO) ) {
				_localctx.handlerAction = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4262; Match(HANDLER);
			State = 4263; Match(FOR);
			State = 4264; handlerConditionValue();
			State = 4269;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4265; Match(COMMA);
				State = 4266; handlerConditionValue();
				}
				}
				State = 4271;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4272; routineBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandlerConditionValueContext : ParserRuleContext {
		public HandlerConditionValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handlerConditionValue; } }
	 
		public HandlerConditionValueContext() { }
		public virtual void CopyFrom(HandlerConditionValueContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class HandlerConditionWarningContext : HandlerConditionValueContext {
		public ITerminalNode SQLWARNING() { return GetToken(MySqlParser.SQLWARNING, 0); }
		public HandlerConditionWarningContext(HandlerConditionValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerConditionWarning(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerConditionWarning(this);
		}
	}
	public partial class HandlerConditionCodeContext : HandlerConditionValueContext {
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public HandlerConditionCodeContext(HandlerConditionValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerConditionCode(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerConditionCode(this);
		}
	}
	public partial class HandlerConditionNotfoundContext : HandlerConditionValueContext {
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public ITerminalNode FOUND() { return GetToken(MySqlParser.FOUND, 0); }
		public HandlerConditionNotfoundContext(HandlerConditionValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerConditionNotfound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerConditionNotfound(this);
		}
	}
	public partial class HandlerConditionStateContext : HandlerConditionValueContext {
		public ITerminalNode SQLSTATE() { return GetToken(MySqlParser.SQLSTATE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode VALUE() { return GetToken(MySqlParser.VALUE, 0); }
		public HandlerConditionStateContext(HandlerConditionValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerConditionState(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerConditionState(this);
		}
	}
	public partial class HandlerConditionExceptionContext : HandlerConditionValueContext {
		public ITerminalNode SQLEXCEPTION() { return GetToken(MySqlParser.SQLEXCEPTION, 0); }
		public HandlerConditionExceptionContext(HandlerConditionValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerConditionException(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerConditionException(this);
		}
	}
	public partial class HandlerConditionNameContext : HandlerConditionValueContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public HandlerConditionNameContext(HandlerConditionValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerConditionName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerConditionName(this);
		}
	}

	[RuleVersion(0)]
	public HandlerConditionValueContext handlerConditionValue() {
		HandlerConditionValueContext _localctx = new HandlerConditionValueContext(Context, State);
		EnterRule(_localctx, 374, RULE_handlerConditionValue);
		int _la;
		try {
			State = 4285;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case DECIMAL_LITERAL:
				_localctx = new HandlerConditionCodeContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4274; decimalLiteral();
				}
				break;
			case SQLSTATE:
				_localctx = new HandlerConditionStateContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4275; Match(SQLSTATE);
				State = 4277;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==VALUE) {
					{
					State = 4276; Match(VALUE);
					}
				}

				State = 4279; Match(STRING_LITERAL);
				}
				break;
			case DATABASE:
			case LEFT:
			case RIGHT:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case TEXT:
			case ENUM:
			case SERIAL:
			case COUNT:
			case POSITION:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case CHARSET_REVERSE_QOUTE_STRING:
			case STRING_LITERAL:
			case ID:
			case REVERSE_QUOTE_ID:
				_localctx = new HandlerConditionNameContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 4280; uid();
				}
				break;
			case SQLWARNING:
				_localctx = new HandlerConditionWarningContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 4281; Match(SQLWARNING);
				}
				break;
			case NOT:
				_localctx = new HandlerConditionNotfoundContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 4282; Match(NOT);
				State = 4283; Match(FOUND);
				}
				break;
			case SQLEXCEPTION:
				_localctx = new HandlerConditionExceptionContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 4284; Match(SQLEXCEPTION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureSqlStatementContext : ParserRuleContext {
		public ITerminalNode SEMI() { return GetToken(MySqlParser.SEMI, 0); }
		public CompoundStatementContext compoundStatement() {
			return GetRuleContext<CompoundStatementContext>(0);
		}
		public SqlStatementContext sqlStatement() {
			return GetRuleContext<SqlStatementContext>(0);
		}
		public ProcedureSqlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureSqlStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterProcedureSqlStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitProcedureSqlStatement(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureSqlStatementContext procedureSqlStatement() {
		ProcedureSqlStatementContext _localctx = new ProcedureSqlStatementContext(Context, State);
		EnterRule(_localctx, 376, RULE_procedureSqlStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4289;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,615,Context) ) {
			case 1:
				{
				State = 4287; compoundStatement();
				}
				break;
			case 2:
				{
				State = 4288; sqlStatement();
				}
				break;
			}
			State = 4291; Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseAlternativeContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(MySqlParser.WHEN, 0); }
		public ITerminalNode THEN() { return GetToken(MySqlParser.THEN, 0); }
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public CaseAlternativeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseAlternative; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCaseAlternative(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCaseAlternative(this);
		}
	}

	[RuleVersion(0)]
	public CaseAlternativeContext caseAlternative() {
		CaseAlternativeContext _localctx = new CaseAlternativeContext(Context, State);
		EnterRule(_localctx, 378, RULE_caseAlternative);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4293; Match(WHEN);
			State = 4296;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,616,Context) ) {
			case 1:
				{
				State = 4294; constant();
				}
				break;
			case 2:
				{
				State = 4295; expression(0);
				}
				break;
			}
			State = 4298; Match(THEN);
			State = 4300;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4299; procedureSqlStatement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4302;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,617,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElifAlternativeContext : ParserRuleContext {
		public ITerminalNode ELSEIF() { return GetToken(MySqlParser.ELSEIF, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(MySqlParser.THEN, 0); }
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public ElifAlternativeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elifAlternative; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterElifAlternative(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitElifAlternative(this);
		}
	}

	[RuleVersion(0)]
	public ElifAlternativeContext elifAlternative() {
		ElifAlternativeContext _localctx = new ElifAlternativeContext(Context, State);
		EnterRule(_localctx, 380, RULE_elifAlternative);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4304; Match(ELSEIF);
			State = 4305; expression(0);
			State = 4306; Match(THEN);
			State = 4308;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4307; procedureSqlStatement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4310;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,618,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterUserContext : ParserRuleContext {
		public AlterUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterUser; } }
	 
		public AlterUserContext() { }
		public virtual void CopyFrom(AlterUserContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AlterUserMysqlV56Context : AlterUserContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public UserSpecificationContext[] userSpecification() {
			return GetRuleContexts<UserSpecificationContext>();
		}
		public UserSpecificationContext userSpecification(int i) {
			return GetRuleContext<UserSpecificationContext>(i);
		}
		public AlterUserMysqlV56Context(AlterUserContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterUserMysqlV56(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterUserMysqlV56(this);
		}
	}
	public partial class AlterUserMysqlV57Context : AlterUserContext {
		public IToken tlsNone;
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public UserAuthOptionContext[] userAuthOption() {
			return GetRuleContexts<UserAuthOptionContext>();
		}
		public UserAuthOptionContext userAuthOption(int i) {
			return GetRuleContext<UserAuthOptionContext>(i);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public ITerminalNode REQUIRE() { return GetToken(MySqlParser.REQUIRE, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public UserPasswordOptionContext[] userPasswordOption() {
			return GetRuleContexts<UserPasswordOptionContext>();
		}
		public UserPasswordOptionContext userPasswordOption(int i) {
			return GetRuleContext<UserPasswordOptionContext>(i);
		}
		public UserLockOptionContext[] userLockOption() {
			return GetRuleContexts<UserLockOptionContext>();
		}
		public UserLockOptionContext userLockOption(int i) {
			return GetRuleContext<UserLockOptionContext>(i);
		}
		public TlsOptionContext[] tlsOption() {
			return GetRuleContexts<TlsOptionContext>();
		}
		public TlsOptionContext tlsOption(int i) {
			return GetRuleContext<TlsOptionContext>(i);
		}
		public ITerminalNode NONE() { return GetToken(MySqlParser.NONE, 0); }
		public UserResourceOptionContext[] userResourceOption() {
			return GetRuleContexts<UserResourceOptionContext>();
		}
		public UserResourceOptionContext userResourceOption(int i) {
			return GetRuleContext<UserResourceOptionContext>(i);
		}
		public ITerminalNode[] AND() { return GetTokens(MySqlParser.AND); }
		public ITerminalNode AND(int i) {
			return GetToken(MySqlParser.AND, i);
		}
		public AlterUserMysqlV57Context(AlterUserContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterUserMysqlV57(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterUserMysqlV57(this);
		}
	}

	[RuleVersion(0)]
	public AlterUserContext alterUser() {
		AlterUserContext _localctx = new AlterUserContext(Context, State);
		EnterRule(_localctx, 382, RULE_alterUser);
		int _la;
		try {
			State = 4366;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,630,Context) ) {
			case 1:
				_localctx = new AlterUserMysqlV56Context(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4312; Match(ALTER);
				State = 4313; Match(USER);
				State = 4314; userSpecification();
				State = 4319;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4315; Match(COMMA);
					State = 4316; userSpecification();
					}
					}
					State = 4321;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new AlterUserMysqlV57Context(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4322; Match(ALTER);
				State = 4323; Match(USER);
				State = 4325;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IF) {
					{
					State = 4324; ifExists();
					}
				}

				State = 4327; userAuthOption();
				State = 4332;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4328; Match(COMMA);
					State = 4329; userAuthOption();
					}
					}
					State = 4334;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4349;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==REQUIRE) {
					{
					State = 4335; Match(REQUIRE);
					State = 4347;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case NONE:
						{
						State = 4336; ((AlterUserMysqlV57Context)_localctx).tlsNone = Match(NONE);
						}
						break;
					case SSL:
					case CIPHER:
					case ISSUER:
					case SUBJECT:
					case X509:
						{
						State = 4337; tlsOption();
						State = 4344;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==AND || _la==SSL || _la==CIPHER || _la==ISSUER || _la==SUBJECT || _la==X509) {
							{
							{
							State = 4339;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (_la==AND) {
								{
								State = 4338; Match(AND);
								}
							}

							State = 4341; tlsOption();
							}
							}
							State = 4346;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				State = 4357;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH) {
					{
					State = 4351; Match(WITH);
					State = 4353;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 4352; userResourceOption();
						}
						}
						State = 4355;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( ((((_la - 401)) & ~0x3f) == 0 && ((1L << (_la - 401)) & ((1L << (MAX_CONNECTIONS_PER_HOUR - 401)) | (1L << (MAX_QUERIES_PER_HOUR - 401)) | (1L << (MAX_UPDATES_PER_HOUR - 401)) | (1L << (MAX_USER_CONNECTIONS - 401)))) != 0) );
					}
				}

				State = 4363;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==ACCOUNT || _la==PASSWORD) {
					{
					State = 4361;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case PASSWORD:
						{
						State = 4359; userPasswordOption();
						}
						break;
					case ACCOUNT:
						{
						State = 4360; userLockOption();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 4365;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserContext : ParserRuleContext {
		public CreateUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUser; } }
	 
		public CreateUserContext() { }
		public virtual void CopyFrom(CreateUserContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CreateUserMysqlV57Context : CreateUserContext {
		public IToken tlsNone;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public UserAuthOptionContext[] userAuthOption() {
			return GetRuleContexts<UserAuthOptionContext>();
		}
		public UserAuthOptionContext userAuthOption(int i) {
			return GetRuleContext<UserAuthOptionContext>(i);
		}
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public ITerminalNode REQUIRE() { return GetToken(MySqlParser.REQUIRE, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public UserPasswordOptionContext[] userPasswordOption() {
			return GetRuleContexts<UserPasswordOptionContext>();
		}
		public UserPasswordOptionContext userPasswordOption(int i) {
			return GetRuleContext<UserPasswordOptionContext>(i);
		}
		public UserLockOptionContext[] userLockOption() {
			return GetRuleContexts<UserLockOptionContext>();
		}
		public UserLockOptionContext userLockOption(int i) {
			return GetRuleContext<UserLockOptionContext>(i);
		}
		public TlsOptionContext[] tlsOption() {
			return GetRuleContexts<TlsOptionContext>();
		}
		public TlsOptionContext tlsOption(int i) {
			return GetRuleContext<TlsOptionContext>(i);
		}
		public ITerminalNode NONE() { return GetToken(MySqlParser.NONE, 0); }
		public UserResourceOptionContext[] userResourceOption() {
			return GetRuleContexts<UserResourceOptionContext>();
		}
		public UserResourceOptionContext userResourceOption(int i) {
			return GetRuleContext<UserResourceOptionContext>(i);
		}
		public ITerminalNode[] AND() { return GetTokens(MySqlParser.AND); }
		public ITerminalNode AND(int i) {
			return GetToken(MySqlParser.AND, i);
		}
		public CreateUserMysqlV57Context(CreateUserContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateUserMysqlV57(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateUserMysqlV57(this);
		}
	}
	public partial class CreateUserMysqlV56Context : CreateUserContext {
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public UserAuthOptionContext[] userAuthOption() {
			return GetRuleContexts<UserAuthOptionContext>();
		}
		public UserAuthOptionContext userAuthOption(int i) {
			return GetRuleContext<UserAuthOptionContext>(i);
		}
		public CreateUserMysqlV56Context(CreateUserContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateUserMysqlV56(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateUserMysqlV56(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserContext createUser() {
		CreateUserContext _localctx = new CreateUserContext(Context, State);
		EnterRule(_localctx, 384, RULE_createUser);
		int _la;
		try {
			State = 4422;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,642,Context) ) {
			case 1:
				_localctx = new CreateUserMysqlV56Context(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4368; Match(CREATE);
				State = 4369; Match(USER);
				State = 4370; userAuthOption();
				State = 4375;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4371; Match(COMMA);
					State = 4372; userAuthOption();
					}
					}
					State = 4377;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new CreateUserMysqlV57Context(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4378; Match(CREATE);
				State = 4379; Match(USER);
				State = 4381;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IF) {
					{
					State = 4380; ifNotExists();
					}
				}

				State = 4383; userAuthOption();
				State = 4388;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4384; Match(COMMA);
					State = 4385; userAuthOption();
					}
					}
					State = 4390;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4405;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==REQUIRE) {
					{
					State = 4391; Match(REQUIRE);
					State = 4403;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case NONE:
						{
						State = 4392; ((CreateUserMysqlV57Context)_localctx).tlsNone = Match(NONE);
						}
						break;
					case SSL:
					case CIPHER:
					case ISSUER:
					case SUBJECT:
					case X509:
						{
						State = 4393; tlsOption();
						State = 4400;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==AND || _la==SSL || _la==CIPHER || _la==ISSUER || _la==SUBJECT || _la==X509) {
							{
							{
							State = 4395;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (_la==AND) {
								{
								State = 4394; Match(AND);
								}
							}

							State = 4397; tlsOption();
							}
							}
							State = 4402;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				State = 4413;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH) {
					{
					State = 4407; Match(WITH);
					State = 4409;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 4408; userResourceOption();
						}
						}
						State = 4411;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( ((((_la - 401)) & ~0x3f) == 0 && ((1L << (_la - 401)) & ((1L << (MAX_CONNECTIONS_PER_HOUR - 401)) | (1L << (MAX_QUERIES_PER_HOUR - 401)) | (1L << (MAX_UPDATES_PER_HOUR - 401)) | (1L << (MAX_USER_CONNECTIONS - 401)))) != 0) );
					}
				}

				State = 4419;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==ACCOUNT || _la==PASSWORD) {
					{
					State = 4417;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case PASSWORD:
						{
						State = 4415; userPasswordOption();
						}
						break;
					case ACCOUNT:
						{
						State = 4416; userLockOption();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 4421;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropUserContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public UserNameContext[] userName() {
			return GetRuleContexts<UserNameContext>();
		}
		public UserNameContext userName(int i) {
			return GetRuleContext<UserNameContext>(i);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropUser; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropUser(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropUser(this);
		}
	}

	[RuleVersion(0)]
	public DropUserContext dropUser() {
		DropUserContext _localctx = new DropUserContext(Context, State);
		EnterRule(_localctx, 386, RULE_dropUser);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4424; Match(DROP);
			State = 4425; Match(USER);
			State = 4427;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 4426; ifExists();
				}
			}

			State = 4429; userName();
			State = 4434;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4430; Match(COMMA);
				State = 4431; userName();
				}
				}
				State = 4436;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GrantStatementContext : ParserRuleContext {
		public IToken privilegeObject;
		public IToken tlsNone;
		public ITerminalNode[] GRANT() { return GetTokens(MySqlParser.GRANT); }
		public ITerminalNode GRANT(int i) {
			return GetToken(MySqlParser.GRANT, i);
		}
		public PrivelegeClauseContext[] privelegeClause() {
			return GetRuleContexts<PrivelegeClauseContext>();
		}
		public PrivelegeClauseContext privelegeClause(int i) {
			return GetRuleContext<PrivelegeClauseContext>(i);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public PrivilegeLevelContext privilegeLevel() {
			return GetRuleContext<PrivilegeLevelContext>(0);
		}
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public UserAuthOptionContext[] userAuthOption() {
			return GetRuleContexts<UserAuthOptionContext>();
		}
		public UserAuthOptionContext userAuthOption(int i) {
			return GetRuleContext<UserAuthOptionContext>(i);
		}
		public ITerminalNode REQUIRE() { return GetToken(MySqlParser.REQUIRE, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public TlsOptionContext[] tlsOption() {
			return GetRuleContexts<TlsOptionContext>();
		}
		public TlsOptionContext tlsOption(int i) {
			return GetRuleContext<TlsOptionContext>(i);
		}
		public ITerminalNode NONE() { return GetToken(MySqlParser.NONE, 0); }
		public ITerminalNode[] OPTION() { return GetTokens(MySqlParser.OPTION); }
		public ITerminalNode OPTION(int i) {
			return GetToken(MySqlParser.OPTION, i);
		}
		public UserResourceOptionContext[] userResourceOption() {
			return GetRuleContexts<UserResourceOptionContext>();
		}
		public UserResourceOptionContext userResourceOption(int i) {
			return GetRuleContext<UserResourceOptionContext>(i);
		}
		public ITerminalNode[] AND() { return GetTokens(MySqlParser.AND); }
		public ITerminalNode AND(int i) {
			return GetToken(MySqlParser.AND, i);
		}
		public GrantStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grantStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGrantStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGrantStatement(this);
		}
	}

	[RuleVersion(0)]
	public GrantStatementContext grantStatement() {
		GrantStatementContext _localctx = new GrantStatementContext(Context, State);
		EnterRule(_localctx, 388, RULE_grantStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4437; Match(GRANT);
			State = 4438; privelegeClause();
			State = 4443;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4439; Match(COMMA);
				State = 4440; privelegeClause();
				}
				}
				State = 4445;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4446; Match(ON);
			State = 4448;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,646,Context) ) {
			case 1:
				{
				State = 4447;
				_localctx.privilegeObject = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==PROCEDURE || _la==TABLE || _la==FUNCTION) ) {
					_localctx.privilegeObject = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 4450; privilegeLevel();
			State = 4451; Match(TO);
			State = 4452; userAuthOption();
			State = 4457;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4453; Match(COMMA);
				State = 4454; userAuthOption();
				}
				}
				State = 4459;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4474;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REQUIRE) {
				{
				State = 4460; Match(REQUIRE);
				State = 4472;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case NONE:
					{
					State = 4461; _localctx.tlsNone = Match(NONE);
					}
					break;
				case SSL:
				case CIPHER:
				case ISSUER:
				case SUBJECT:
				case X509:
					{
					State = 4462; tlsOption();
					State = 4469;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==AND || _la==SSL || _la==CIPHER || _la==ISSUER || _la==SUBJECT || _la==X509) {
						{
						{
						State = 4464;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==AND) {
							{
							State = 4463; Match(AND);
							}
						}

						State = 4466; tlsOption();
						}
						}
						State = 4471;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			State = 4485;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 4476; Match(WITH);
				State = 4482;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,653,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						State = 4480;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case GRANT:
							{
							State = 4477; Match(GRANT);
							State = 4478; Match(OPTION);
							}
							break;
						case MAX_CONNECTIONS_PER_HOUR:
						case MAX_QUERIES_PER_HOUR:
						case MAX_UPDATES_PER_HOUR:
						case MAX_USER_CONNECTIONS:
							{
							State = 4479; userResourceOption();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						} 
					}
					State = 4484;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,653,Context);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GrantProxyContext : ParserRuleContext {
		public UserNameContext fromFirst;
		public UserNameContext toFirst;
		public UserNameContext _userName;
		public IList<UserNameContext> _toOther = new List<UserNameContext>();
		public ITerminalNode[] GRANT() { return GetTokens(MySqlParser.GRANT); }
		public ITerminalNode GRANT(int i) {
			return GetToken(MySqlParser.GRANT, i);
		}
		public ITerminalNode PROXY() { return GetToken(MySqlParser.PROXY, 0); }
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public UserNameContext[] userName() {
			return GetRuleContexts<UserNameContext>();
		}
		public UserNameContext userName(int i) {
			return GetRuleContext<UserNameContext>(i);
		}
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode OPTION() { return GetToken(MySqlParser.OPTION, 0); }
		public GrantProxyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grantProxy; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGrantProxy(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGrantProxy(this);
		}
	}

	[RuleVersion(0)]
	public GrantProxyContext grantProxy() {
		GrantProxyContext _localctx = new GrantProxyContext(Context, State);
		EnterRule(_localctx, 390, RULE_grantProxy);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4487; Match(GRANT);
			State = 4488; Match(PROXY);
			State = 4489; Match(ON);
			State = 4490; _localctx.fromFirst = userName();
			State = 4491; Match(TO);
			State = 4492; _localctx.toFirst = userName();
			State = 4497;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4493; Match(COMMA);
				State = 4494; _localctx._userName = userName();
				_localctx._toOther.Add(_localctx._userName);
				}
				}
				State = 4499;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4503;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 4500; Match(WITH);
				State = 4501; Match(GRANT);
				State = 4502; Match(OPTION);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameUserContext : ParserRuleContext {
		public ITerminalNode RENAME() { return GetToken(MySqlParser.RENAME, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public RenameUserClauseContext[] renameUserClause() {
			return GetRuleContexts<RenameUserClauseContext>();
		}
		public RenameUserClauseContext renameUserClause(int i) {
			return GetRuleContext<RenameUserClauseContext>(i);
		}
		public RenameUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameUser; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRenameUser(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRenameUser(this);
		}
	}

	[RuleVersion(0)]
	public RenameUserContext renameUser() {
		RenameUserContext _localctx = new RenameUserContext(Context, State);
		EnterRule(_localctx, 392, RULE_renameUser);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4505; Match(RENAME);
			State = 4506; Match(USER);
			State = 4507; renameUserClause();
			State = 4512;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4508; Match(COMMA);
				State = 4509; renameUserClause();
				}
				}
				State = 4514;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RevokeStatementContext : ParserRuleContext {
		public RevokeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_revokeStatement; } }
	 
		public RevokeStatementContext() { }
		public virtual void CopyFrom(RevokeStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DetailRevokeContext : RevokeStatementContext {
		public IToken privilegeObject;
		public ITerminalNode REVOKE() { return GetToken(MySqlParser.REVOKE, 0); }
		public PrivelegeClauseContext[] privelegeClause() {
			return GetRuleContexts<PrivelegeClauseContext>();
		}
		public PrivelegeClauseContext privelegeClause(int i) {
			return GetRuleContext<PrivelegeClauseContext>(i);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public PrivilegeLevelContext privilegeLevel() {
			return GetRuleContext<PrivilegeLevelContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public UserNameContext[] userName() {
			return GetRuleContexts<UserNameContext>();
		}
		public UserNameContext userName(int i) {
			return GetRuleContext<UserNameContext>(i);
		}
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public DetailRevokeContext(RevokeStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDetailRevoke(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDetailRevoke(this);
		}
	}
	public partial class ShortRevokeContext : RevokeStatementContext {
		public ITerminalNode REVOKE() { return GetToken(MySqlParser.REVOKE, 0); }
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode GRANT() { return GetToken(MySqlParser.GRANT, 0); }
		public ITerminalNode OPTION() { return GetToken(MySqlParser.OPTION, 0); }
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public UserNameContext[] userName() {
			return GetRuleContexts<UserNameContext>();
		}
		public UserNameContext userName(int i) {
			return GetRuleContext<UserNameContext>(i);
		}
		public ITerminalNode PRIVILEGES() { return GetToken(MySqlParser.PRIVILEGES, 0); }
		public ShortRevokeContext(RevokeStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShortRevoke(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShortRevoke(this);
		}
	}

	[RuleVersion(0)]
	public RevokeStatementContext revokeStatement() {
		RevokeStatementContext _localctx = new RevokeStatementContext(Context, State);
		EnterRule(_localctx, 394, RULE_revokeStatement);
		int _la;
		try {
			State = 4555;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,663,Context) ) {
			case 1:
				_localctx = new DetailRevokeContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4515; Match(REVOKE);
				State = 4516; privelegeClause();
				State = 4521;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4517; Match(COMMA);
					State = 4518; privelegeClause();
					}
					}
					State = 4523;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4524; Match(ON);
				State = 4526;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,659,Context) ) {
				case 1:
					{
					State = 4525;
					((DetailRevokeContext)_localctx).privilegeObject = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==PROCEDURE || _la==TABLE || _la==FUNCTION) ) {
						((DetailRevokeContext)_localctx).privilegeObject = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 4528; privilegeLevel();
				State = 4529; Match(FROM);
				State = 4530; userName();
				State = 4535;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4531; Match(COMMA);
					State = 4532; userName();
					}
					}
					State = 4537;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new ShortRevokeContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4538; Match(REVOKE);
				State = 4539; Match(ALL);
				State = 4541;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PRIVILEGES) {
					{
					State = 4540; Match(PRIVILEGES);
					}
				}

				State = 4543; Match(COMMA);
				State = 4544; Match(GRANT);
				State = 4545; Match(OPTION);
				State = 4546; Match(FROM);
				State = 4547; userName();
				State = 4552;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4548; Match(COMMA);
					State = 4549; userName();
					}
					}
					State = 4554;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RevokeProxyContext : ParserRuleContext {
		public UserNameContext onUser;
		public UserNameContext fromFirst;
		public UserNameContext _userName;
		public IList<UserNameContext> _fromOther = new List<UserNameContext>();
		public ITerminalNode REVOKE() { return GetToken(MySqlParser.REVOKE, 0); }
		public ITerminalNode PROXY() { return GetToken(MySqlParser.PROXY, 0); }
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public UserNameContext[] userName() {
			return GetRuleContexts<UserNameContext>();
		}
		public UserNameContext userName(int i) {
			return GetRuleContext<UserNameContext>(i);
		}
		public RevokeProxyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_revokeProxy; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRevokeProxy(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRevokeProxy(this);
		}
	}

	[RuleVersion(0)]
	public RevokeProxyContext revokeProxy() {
		RevokeProxyContext _localctx = new RevokeProxyContext(Context, State);
		EnterRule(_localctx, 396, RULE_revokeProxy);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4557; Match(REVOKE);
			State = 4558; Match(PROXY);
			State = 4559; Match(ON);
			State = 4560; _localctx.onUser = userName();
			State = 4561; Match(FROM);
			State = 4562; _localctx.fromFirst = userName();
			State = 4567;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4563; Match(COMMA);
				State = 4564; _localctx._userName = userName();
				_localctx._fromOther.Add(_localctx._userName);
				}
				}
				State = 4569;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetPasswordStatementContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public PasswordFunctionClauseContext passwordFunctionClause() {
			return GetRuleContext<PasswordFunctionClauseContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public SetPasswordStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setPasswordStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetPasswordStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetPasswordStatement(this);
		}
	}

	[RuleVersion(0)]
	public SetPasswordStatementContext setPasswordStatement() {
		SetPasswordStatementContext _localctx = new SetPasswordStatementContext(Context, State);
		EnterRule(_localctx, 398, RULE_setPasswordStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4570; Match(SET);
			State = 4571; Match(PASSWORD);
			State = 4574;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 4572; Match(FOR);
				State = 4573; userName();
				}
			}

			State = 4576; Match(EQUAL_SYMBOL);
			State = 4579;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case OLD_PASSWORD:
			case PASSWORD:
				{
				State = 4577; passwordFunctionClause();
				}
				break;
			case STRING_LITERAL:
				{
				State = 4578; Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserSpecificationContext : ParserRuleContext {
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public UserPasswordOptionContext userPasswordOption() {
			return GetRuleContext<UserPasswordOptionContext>(0);
		}
		public UserSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userSpecification; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserSpecification(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserSpecification(this);
		}
	}

	[RuleVersion(0)]
	public UserSpecificationContext userSpecification() {
		UserSpecificationContext _localctx = new UserSpecificationContext(Context, State);
		EnterRule(_localctx, 400, RULE_userSpecification);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4581; userName();
			State = 4582; userPasswordOption();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserAuthOptionContext : ParserRuleContext {
		public UserAuthOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userAuthOption; } }
	 
		public UserAuthOptionContext() { }
		public virtual void CopyFrom(UserAuthOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SimpleAuthOptionContext : UserAuthOptionContext {
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public SimpleAuthOptionContext(UserAuthOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleAuthOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleAuthOption(this);
		}
	}
	public partial class PasswordAuthOptionContext : UserAuthOptionContext {
		public IToken hashed;
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public ITerminalNode IDENTIFIED() { return GetToken(MySqlParser.IDENTIFIED, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PasswordAuthOptionContext(UserAuthOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPasswordAuthOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPasswordAuthOption(this);
		}
	}
	public partial class StringAuthOptionContext : UserAuthOptionContext {
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public ITerminalNode IDENTIFIED() { return GetToken(MySqlParser.IDENTIFIED, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public AuthPluginContext authPlugin() {
			return GetRuleContext<AuthPluginContext>(0);
		}
		public StringAuthOptionContext(UserAuthOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStringAuthOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStringAuthOption(this);
		}
	}
	public partial class HashAuthOptionContext : UserAuthOptionContext {
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public ITerminalNode IDENTIFIED() { return GetToken(MySqlParser.IDENTIFIED, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public AuthPluginContext authPlugin() {
			return GetRuleContext<AuthPluginContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public HashAuthOptionContext(UserAuthOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHashAuthOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHashAuthOption(this);
		}
	}

	[RuleVersion(0)]
	public UserAuthOptionContext userAuthOption() {
		UserAuthOptionContext _localctx = new UserAuthOptionContext(Context, State);
		EnterRule(_localctx, 402, RULE_userAuthOption);
		int _la;
		try {
			State = 4608;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,669,Context) ) {
			case 1:
				_localctx = new PasswordAuthOptionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4584; userName();
				State = 4585; Match(IDENTIFIED);
				State = 4586; Match(BY);
				State = 4587; Match(PASSWORD);
				State = 4588; ((PasswordAuthOptionContext)_localctx).hashed = Match(STRING_LITERAL);
				}
				break;
			case 2:
				_localctx = new StringAuthOptionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4590; userName();
				State = 4591; Match(IDENTIFIED);
				State = 4594;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH) {
					{
					State = 4592; Match(WITH);
					State = 4593; authPlugin();
					}
				}

				State = 4596; Match(BY);
				State = 4597; Match(STRING_LITERAL);
				}
				break;
			case 3:
				_localctx = new HashAuthOptionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 4599; userName();
				State = 4600; Match(IDENTIFIED);
				State = 4601; Match(WITH);
				State = 4602; authPlugin();
				State = 4605;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 4603; Match(AS);
					State = 4604; Match(STRING_LITERAL);
					}
				}

				}
				break;
			case 4:
				_localctx = new SimpleAuthOptionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 4607; userName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TlsOptionContext : ParserRuleContext {
		public ITerminalNode SSL() { return GetToken(MySqlParser.SSL, 0); }
		public ITerminalNode X509() { return GetToken(MySqlParser.X509, 0); }
		public ITerminalNode CIPHER() { return GetToken(MySqlParser.CIPHER, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode ISSUER() { return GetToken(MySqlParser.ISSUER, 0); }
		public ITerminalNode SUBJECT() { return GetToken(MySqlParser.SUBJECT, 0); }
		public TlsOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tlsOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTlsOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTlsOption(this);
		}
	}

	[RuleVersion(0)]
	public TlsOptionContext tlsOption() {
		TlsOptionContext _localctx = new TlsOptionContext(Context, State);
		EnterRule(_localctx, 404, RULE_tlsOption);
		try {
			State = 4618;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SSL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4610; Match(SSL);
				}
				break;
			case X509:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4611; Match(X509);
				}
				break;
			case CIPHER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4612; Match(CIPHER);
				State = 4613; Match(STRING_LITERAL);
				}
				break;
			case ISSUER:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4614; Match(ISSUER);
				State = 4615; Match(STRING_LITERAL);
				}
				break;
			case SUBJECT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4616; Match(SUBJECT);
				State = 4617; Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserResourceOptionContext : ParserRuleContext {
		public ITerminalNode MAX_QUERIES_PER_HOUR() { return GetToken(MySqlParser.MAX_QUERIES_PER_HOUR, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode MAX_UPDATES_PER_HOUR() { return GetToken(MySqlParser.MAX_UPDATES_PER_HOUR, 0); }
		public ITerminalNode MAX_CONNECTIONS_PER_HOUR() { return GetToken(MySqlParser.MAX_CONNECTIONS_PER_HOUR, 0); }
		public ITerminalNode MAX_USER_CONNECTIONS() { return GetToken(MySqlParser.MAX_USER_CONNECTIONS, 0); }
		public UserResourceOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userResourceOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserResourceOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserResourceOption(this);
		}
	}

	[RuleVersion(0)]
	public UserResourceOptionContext userResourceOption() {
		UserResourceOptionContext _localctx = new UserResourceOptionContext(Context, State);
		EnterRule(_localctx, 406, RULE_userResourceOption);
		try {
			State = 4628;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAX_QUERIES_PER_HOUR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4620; Match(MAX_QUERIES_PER_HOUR);
				State = 4621; decimalLiteral();
				}
				break;
			case MAX_UPDATES_PER_HOUR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4622; Match(MAX_UPDATES_PER_HOUR);
				State = 4623; decimalLiteral();
				}
				break;
			case MAX_CONNECTIONS_PER_HOUR:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4624; Match(MAX_CONNECTIONS_PER_HOUR);
				State = 4625; decimalLiteral();
				}
				break;
			case MAX_USER_CONNECTIONS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4626; Match(MAX_USER_CONNECTIONS);
				State = 4627; decimalLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserPasswordOptionContext : ParserRuleContext {
		public IToken expireType;
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode EXPIRE() { return GetToken(MySqlParser.EXPIRE, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode DAY() { return GetToken(MySqlParser.DAY, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode NEVER() { return GetToken(MySqlParser.NEVER, 0); }
		public ITerminalNode INTERVAL() { return GetToken(MySqlParser.INTERVAL, 0); }
		public UserPasswordOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userPasswordOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserPasswordOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserPasswordOption(this);
		}
	}

	[RuleVersion(0)]
	public UserPasswordOptionContext userPasswordOption() {
		UserPasswordOptionContext _localctx = new UserPasswordOptionContext(Context, State);
		EnterRule(_localctx, 408, RULE_userPasswordOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4630; Match(PASSWORD);
			State = 4631; Match(EXPIRE);
			State = 4638;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
				{
				State = 4632; _localctx.expireType = Match(DEFAULT);
				}
				break;
			case NEVER:
				{
				State = 4633; _localctx.expireType = Match(NEVER);
				}
				break;
			case INTERVAL:
				{
				State = 4634; _localctx.expireType = Match(INTERVAL);
				State = 4635; decimalLiteral();
				State = 4636; Match(DAY);
				}
				break;
			case Eof:
			case ALTER:
			case ANALYZE:
			case CALL:
			case CHANGE:
			case CHECK:
			case CREATE:
			case DELETE:
			case DESC:
			case DESCRIBE:
			case DROP:
			case EXPLAIN:
			case GRANT:
			case INSERT:
			case KILL:
			case LOAD:
			case LOCK:
			case OPTIMIZE:
			case PURGE:
			case RELEASE:
			case RENAME:
			case REPLACE:
			case REVOKE:
			case SELECT:
			case SET:
			case SHOW:
			case UNLOCK:
			case UPDATE:
			case USE:
			case ACCOUNT:
			case BEGIN:
			case BINLOG:
			case CACHE:
			case CHECKSUM:
			case COMMIT:
			case DEALLOCATE:
			case DO:
			case FLUSH:
			case HANDLER:
			case HELP:
			case INSTALL:
			case PASSWORD:
			case PREPARE:
			case REPAIR:
			case RESET:
			case ROLLBACK:
			case SAVEPOINT:
			case START:
			case STOP:
			case TRUNCATE:
			case UNINSTALL:
			case XA:
			case EXECUTE:
			case SHUTDOWN:
			case MINUSMINUS:
			case LR_BRACKET:
			case COMMA:
			case SEMI:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserLockOptionContext : ParserRuleContext {
		public IToken lockType;
		public ITerminalNode ACCOUNT() { return GetToken(MySqlParser.ACCOUNT, 0); }
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode UNLOCK() { return GetToken(MySqlParser.UNLOCK, 0); }
		public UserLockOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userLockOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserLockOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserLockOption(this);
		}
	}

	[RuleVersion(0)]
	public UserLockOptionContext userLockOption() {
		UserLockOptionContext _localctx = new UserLockOptionContext(Context, State);
		EnterRule(_localctx, 410, RULE_userLockOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4640; Match(ACCOUNT);
			State = 4641;
			_localctx.lockType = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==LOCK || _la==UNLOCK) ) {
				_localctx.lockType = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrivelegeClauseContext : ParserRuleContext {
		public PrivilegeContext privilege() {
			return GetRuleContext<PrivilegeContext>(0);
		}
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public PrivelegeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_privelegeClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPrivelegeClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPrivelegeClause(this);
		}
	}

	[RuleVersion(0)]
	public PrivelegeClauseContext privelegeClause() {
		PrivelegeClauseContext _localctx = new PrivelegeClauseContext(Context, State);
		EnterRule(_localctx, 412, RULE_privelegeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4643; privilege();
			State = 4648;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LR_BRACKET) {
				{
				State = 4644; Match(LR_BRACKET);
				State = 4645; uidList();
				State = 4646; Match(RR_BRACKET);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrivilegeContext : ParserRuleContext {
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode PRIVILEGES() { return GetToken(MySqlParser.PRIVILEGES, 0); }
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode ROUTINE() { return GetToken(MySqlParser.ROUTINE, 0); }
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TEMPORARY() { return GetToken(MySqlParser.TEMPORARY, 0); }
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public ITerminalNode VIEW() { return GetToken(MySqlParser.VIEW, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public ITerminalNode DELETE() { return GetToken(MySqlParser.DELETE, 0); }
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode EVENT() { return GetToken(MySqlParser.EVENT, 0); }
		public ITerminalNode EXECUTE() { return GetToken(MySqlParser.EXECUTE, 0); }
		public ITerminalNode FILE() { return GetToken(MySqlParser.FILE, 0); }
		public ITerminalNode GRANT() { return GetToken(MySqlParser.GRANT, 0); }
		public ITerminalNode OPTION() { return GetToken(MySqlParser.OPTION, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode INSERT() { return GetToken(MySqlParser.INSERT, 0); }
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode PROCESS() { return GetToken(MySqlParser.PROCESS, 0); }
		public ITerminalNode PROXY() { return GetToken(MySqlParser.PROXY, 0); }
		public ITerminalNode REFERENCES() { return GetToken(MySqlParser.REFERENCES, 0); }
		public ITerminalNode RELOAD() { return GetToken(MySqlParser.RELOAD, 0); }
		public ITerminalNode REPLICATION() { return GetToken(MySqlParser.REPLICATION, 0); }
		public ITerminalNode CLIENT() { return GetToken(MySqlParser.CLIENT, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ITerminalNode SELECT() { return GetToken(MySqlParser.SELECT, 0); }
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode DATABASES() { return GetToken(MySqlParser.DATABASES, 0); }
		public ITerminalNode SHUTDOWN() { return GetToken(MySqlParser.SHUTDOWN, 0); }
		public ITerminalNode SUPER() { return GetToken(MySqlParser.SUPER, 0); }
		public ITerminalNode TRIGGER() { return GetToken(MySqlParser.TRIGGER, 0); }
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public ITerminalNode USAGE() { return GetToken(MySqlParser.USAGE, 0); }
		public PrivilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_privilege; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPrivilege(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPrivilege(this);
		}
	}

	[RuleVersion(0)]
	public PrivilegeContext privilege() {
		PrivilegeContext _localctx = new PrivilegeContext(Context, State);
		EnterRule(_localctx, 414, RULE_privilege);
		int _la;
		try {
			State = 4692;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4650; Match(ALL);
				State = 4652;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PRIVILEGES) {
					{
					State = 4651; Match(PRIVILEGES);
					}
				}

				}
				break;
			case ALTER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4654; Match(ALTER);
				State = 4656;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ROUTINE) {
					{
					State = 4655; Match(ROUTINE);
					}
				}

				}
				break;
			case CREATE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4658; Match(CREATE);
				State = 4665;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TEMPORARY:
					{
					State = 4659; Match(TEMPORARY);
					State = 4660; Match(TABLES);
					}
					break;
				case ROUTINE:
					{
					State = 4661; Match(ROUTINE);
					}
					break;
				case VIEW:
					{
					State = 4662; Match(VIEW);
					}
					break;
				case USER:
					{
					State = 4663; Match(USER);
					}
					break;
				case TABLESPACE:
					{
					State = 4664; Match(TABLESPACE);
					}
					break;
				case ON:
				case LR_BRACKET:
				case COMMA:
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case DELETE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4667; Match(DELETE);
				}
				break;
			case DROP:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4668; Match(DROP);
				}
				break;
			case EVENT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4669; Match(EVENT);
				}
				break;
			case EXECUTE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 4670; Match(EXECUTE);
				}
				break;
			case FILE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 4671; Match(FILE);
				}
				break;
			case GRANT:
				EnterOuterAlt(_localctx, 9);
				{
				State = 4672; Match(GRANT);
				State = 4673; Match(OPTION);
				}
				break;
			case INDEX:
				EnterOuterAlt(_localctx, 10);
				{
				State = 4674; Match(INDEX);
				}
				break;
			case INSERT:
				EnterOuterAlt(_localctx, 11);
				{
				State = 4675; Match(INSERT);
				}
				break;
			case LOCK:
				EnterOuterAlt(_localctx, 12);
				{
				State = 4676; Match(LOCK);
				State = 4677; Match(TABLES);
				}
				break;
			case PROCESS:
				EnterOuterAlt(_localctx, 13);
				{
				State = 4678; Match(PROCESS);
				}
				break;
			case PROXY:
				EnterOuterAlt(_localctx, 14);
				{
				State = 4679; Match(PROXY);
				}
				break;
			case REFERENCES:
				EnterOuterAlt(_localctx, 15);
				{
				State = 4680; Match(REFERENCES);
				}
				break;
			case RELOAD:
				EnterOuterAlt(_localctx, 16);
				{
				State = 4681; Match(RELOAD);
				}
				break;
			case REPLICATION:
				EnterOuterAlt(_localctx, 17);
				{
				State = 4682; Match(REPLICATION);
				State = 4683;
				_la = TokenStream.LA(1);
				if ( !(_la==CLIENT || _la==SLAVE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case SELECT:
				EnterOuterAlt(_localctx, 18);
				{
				State = 4684; Match(SELECT);
				}
				break;
			case SHOW:
				EnterOuterAlt(_localctx, 19);
				{
				State = 4685; Match(SHOW);
				State = 4686;
				_la = TokenStream.LA(1);
				if ( !(_la==DATABASES || _la==VIEW) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case SHUTDOWN:
				EnterOuterAlt(_localctx, 20);
				{
				State = 4687; Match(SHUTDOWN);
				}
				break;
			case SUPER:
				EnterOuterAlt(_localctx, 21);
				{
				State = 4688; Match(SUPER);
				}
				break;
			case TRIGGER:
				EnterOuterAlt(_localctx, 22);
				{
				State = 4689; Match(TRIGGER);
				}
				break;
			case UPDATE:
				EnterOuterAlt(_localctx, 23);
				{
				State = 4690; Match(UPDATE);
				}
				break;
			case USAGE:
				EnterOuterAlt(_localctx, 24);
				{
				State = 4691; Match(USAGE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrivilegeLevelContext : ParserRuleContext {
		public PrivilegeLevelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_privilegeLevel; } }
	 
		public PrivilegeLevelContext() { }
		public virtual void CopyFrom(PrivilegeLevelContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DefiniteSchemaPrivLevelContext : PrivilegeLevelContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DefiniteSchemaPrivLevelContext(PrivilegeLevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDefiniteSchemaPrivLevel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDefiniteSchemaPrivLevel(this);
		}
	}
	public partial class DefiniteFullTablePrivLevelContext : PrivilegeLevelContext {
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public DefiniteFullTablePrivLevelContext(PrivilegeLevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDefiniteFullTablePrivLevel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDefiniteFullTablePrivLevel(this);
		}
	}
	public partial class GlobalPrivLevelContext : PrivilegeLevelContext {
		public GlobalPrivLevelContext(PrivilegeLevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGlobalPrivLevel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGlobalPrivLevel(this);
		}
	}
	public partial class DefiniteTablePrivLevelContext : PrivilegeLevelContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DefiniteTablePrivLevelContext(PrivilegeLevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDefiniteTablePrivLevel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDefiniteTablePrivLevel(this);
		}
	}
	public partial class CurrentSchemaPriviLevelContext : PrivilegeLevelContext {
		public CurrentSchemaPriviLevelContext(PrivilegeLevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCurrentSchemaPriviLevel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCurrentSchemaPriviLevel(this);
		}
	}

	[RuleVersion(0)]
	public PrivilegeLevelContext privilegeLevel() {
		PrivilegeLevelContext _localctx = new PrivilegeLevelContext(Context, State);
		EnterRule(_localctx, 416, RULE_privilegeLevel);
		try {
			State = 4707;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,678,Context) ) {
			case 1:
				_localctx = new CurrentSchemaPriviLevelContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4694; Match(STAR);
				}
				break;
			case 2:
				_localctx = new GlobalPrivLevelContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4695; Match(STAR);
				State = 4696; Match(DOT);
				State = 4697; Match(STAR);
				}
				break;
			case 3:
				_localctx = new DefiniteSchemaPrivLevelContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 4698; uid();
				State = 4699; Match(DOT);
				State = 4700; Match(STAR);
				}
				break;
			case 4:
				_localctx = new DefiniteFullTablePrivLevelContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 4702; uid();
				State = 4703; Match(DOT);
				State = 4704; uid();
				}
				break;
			case 5:
				_localctx = new DefiniteTablePrivLevelContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 4706; uid();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameUserClauseContext : ParserRuleContext {
		public UserNameContext fromFirst;
		public UserNameContext toFirst;
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public UserNameContext[] userName() {
			return GetRuleContexts<UserNameContext>();
		}
		public UserNameContext userName(int i) {
			return GetRuleContext<UserNameContext>(i);
		}
		public RenameUserClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameUserClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRenameUserClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRenameUserClause(this);
		}
	}

	[RuleVersion(0)]
	public RenameUserClauseContext renameUserClause() {
		RenameUserClauseContext _localctx = new RenameUserClauseContext(Context, State);
		EnterRule(_localctx, 418, RULE_renameUserClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4709; _localctx.fromFirst = userName();
			State = 4710; Match(TO);
			State = 4711; _localctx.toFirst = userName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AnalyzeTableContext : ParserRuleContext {
		public IToken actionOption;
		public ITerminalNode ANALYZE() { return GetToken(MySqlParser.ANALYZE, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public ITerminalNode NO_WRITE_TO_BINLOG() { return GetToken(MySqlParser.NO_WRITE_TO_BINLOG, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public AnalyzeTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_analyzeTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAnalyzeTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAnalyzeTable(this);
		}
	}

	[RuleVersion(0)]
	public AnalyzeTableContext analyzeTable() {
		AnalyzeTableContext _localctx = new AnalyzeTableContext(Context, State);
		EnterRule(_localctx, 420, RULE_analyzeTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4713; Match(ANALYZE);
			State = 4715;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NO_WRITE_TO_BINLOG || _la==LOCAL) {
				{
				State = 4714;
				_localctx.actionOption = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==NO_WRITE_TO_BINLOG || _la==LOCAL) ) {
					_localctx.actionOption = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 4717; Match(TABLE);
			State = 4718; tables();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CheckTableContext : ParserRuleContext {
		public ITerminalNode CHECK() { return GetToken(MySqlParser.CHECK, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public CheckTableOptionContext[] checkTableOption() {
			return GetRuleContexts<CheckTableOptionContext>();
		}
		public CheckTableOptionContext checkTableOption(int i) {
			return GetRuleContext<CheckTableOptionContext>(i);
		}
		public CheckTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_checkTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCheckTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCheckTable(this);
		}
	}

	[RuleVersion(0)]
	public CheckTableContext checkTable() {
		CheckTableContext _localctx = new CheckTableContext(Context, State);
		EnterRule(_localctx, 422, RULE_checkTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4720; Match(CHECK);
			State = 4721; Match(TABLE);
			State = 4722; tables();
			State = 4726;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==FOR || ((((_la - 274)) & ~0x3f) == 0 && ((1L << (_la - 274)) & ((1L << (CHANGED - 274)) | (1L << (EXTENDED - 274)) | (1L << (FAST - 274)))) != 0) || _la==MEDIUM || _la==QUICK) {
				{
				{
				State = 4723; checkTableOption();
				}
				}
				State = 4728;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ChecksumTableContext : ParserRuleContext {
		public IToken actionOption;
		public ITerminalNode CHECKSUM() { return GetToken(MySqlParser.CHECKSUM, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public ITerminalNode QUICK() { return GetToken(MySqlParser.QUICK, 0); }
		public ITerminalNode EXTENDED() { return GetToken(MySqlParser.EXTENDED, 0); }
		public ChecksumTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_checksumTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterChecksumTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitChecksumTable(this);
		}
	}

	[RuleVersion(0)]
	public ChecksumTableContext checksumTable() {
		ChecksumTableContext _localctx = new ChecksumTableContext(Context, State);
		EnterRule(_localctx, 424, RULE_checksumTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4729; Match(CHECKSUM);
			State = 4730; Match(TABLE);
			State = 4731; tables();
			State = 4733;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXTENDED || _la==QUICK) {
				{
				State = 4732;
				_localctx.actionOption = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==EXTENDED || _la==QUICK) ) {
					_localctx.actionOption = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptimizeTableContext : ParserRuleContext {
		public IToken actionOption;
		public ITerminalNode OPTIMIZE() { return GetToken(MySqlParser.OPTIMIZE, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public ITerminalNode NO_WRITE_TO_BINLOG() { return GetToken(MySqlParser.NO_WRITE_TO_BINLOG, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public OptimizeTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optimizeTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterOptimizeTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitOptimizeTable(this);
		}
	}

	[RuleVersion(0)]
	public OptimizeTableContext optimizeTable() {
		OptimizeTableContext _localctx = new OptimizeTableContext(Context, State);
		EnterRule(_localctx, 426, RULE_optimizeTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4735; Match(OPTIMIZE);
			State = 4737;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NO_WRITE_TO_BINLOG || _la==LOCAL) {
				{
				State = 4736;
				_localctx.actionOption = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==NO_WRITE_TO_BINLOG || _la==LOCAL) ) {
					_localctx.actionOption = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 4739; Match(TABLE);
			State = 4740; tables();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RepairTableContext : ParserRuleContext {
		public IToken actionOption;
		public ITerminalNode REPAIR() { return GetToken(MySqlParser.REPAIR, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public ITerminalNode QUICK() { return GetToken(MySqlParser.QUICK, 0); }
		public ITerminalNode EXTENDED() { return GetToken(MySqlParser.EXTENDED, 0); }
		public ITerminalNode USE_FRM() { return GetToken(MySqlParser.USE_FRM, 0); }
		public ITerminalNode NO_WRITE_TO_BINLOG() { return GetToken(MySqlParser.NO_WRITE_TO_BINLOG, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public RepairTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_repairTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRepairTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRepairTable(this);
		}
	}

	[RuleVersion(0)]
	public RepairTableContext repairTable() {
		RepairTableContext _localctx = new RepairTableContext(Context, State);
		EnterRule(_localctx, 428, RULE_repairTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4742; Match(REPAIR);
			State = 4744;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NO_WRITE_TO_BINLOG || _la==LOCAL) {
				{
				State = 4743;
				_localctx.actionOption = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==NO_WRITE_TO_BINLOG || _la==LOCAL) ) {
					_localctx.actionOption = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 4746; Match(TABLE);
			State = 4747; tables();
			State = 4749;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==QUICK) {
				{
				State = 4748; Match(QUICK);
				}
			}

			State = 4752;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXTENDED) {
				{
				State = 4751; Match(EXTENDED);
				}
			}

			State = 4755;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USE_FRM) {
				{
				State = 4754; Match(USE_FRM);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CheckTableOptionContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode UPGRADE() { return GetToken(MySqlParser.UPGRADE, 0); }
		public ITerminalNode QUICK() { return GetToken(MySqlParser.QUICK, 0); }
		public ITerminalNode FAST() { return GetToken(MySqlParser.FAST, 0); }
		public ITerminalNode MEDIUM() { return GetToken(MySqlParser.MEDIUM, 0); }
		public ITerminalNode EXTENDED() { return GetToken(MySqlParser.EXTENDED, 0); }
		public ITerminalNode CHANGED() { return GetToken(MySqlParser.CHANGED, 0); }
		public CheckTableOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_checkTableOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCheckTableOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCheckTableOption(this);
		}
	}

	[RuleVersion(0)]
	public CheckTableOptionContext checkTableOption() {
		CheckTableOptionContext _localctx = new CheckTableOptionContext(Context, State);
		EnterRule(_localctx, 430, RULE_checkTableOption);
		try {
			State = 4764;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FOR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4757; Match(FOR);
				State = 4758; Match(UPGRADE);
				}
				break;
			case QUICK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4759; Match(QUICK);
				}
				break;
			case FAST:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4760; Match(FAST);
				}
				break;
			case MEDIUM:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4761; Match(MEDIUM);
				}
				break;
			case EXTENDED:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4762; Match(EXTENDED);
				}
				break;
			case CHANGED:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4763; Match(CHANGED);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUdfunctionContext : ParserRuleContext {
		public IToken returnType;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode RETURNS() { return GetToken(MySqlParser.RETURNS, 0); }
		public ITerminalNode SONAME() { return GetToken(MySqlParser.SONAME, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode STRING() { return GetToken(MySqlParser.STRING, 0); }
		public ITerminalNode INTEGER() { return GetToken(MySqlParser.INTEGER, 0); }
		public ITerminalNode REAL() { return GetToken(MySqlParser.REAL, 0); }
		public ITerminalNode DECIMAL() { return GetToken(MySqlParser.DECIMAL, 0); }
		public ITerminalNode AGGREGATE() { return GetToken(MySqlParser.AGGREGATE, 0); }
		public CreateUdfunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUdfunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateUdfunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateUdfunction(this);
		}
	}

	[RuleVersion(0)]
	public CreateUdfunctionContext createUdfunction() {
		CreateUdfunctionContext _localctx = new CreateUdfunctionContext(Context, State);
		EnterRule(_localctx, 432, RULE_createUdfunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4766; Match(CREATE);
			State = 4768;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AGGREGATE) {
				{
				State = 4767; Match(AGGREGATE);
				}
			}

			State = 4770; Match(FUNCTION);
			State = 4771; uid();
			State = 4772; Match(RETURNS);
			State = 4773;
			_localctx.returnType = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(((((_la - 175)) & ~0x3f) == 0 && ((1L << (_la - 175)) & ((1L << (INTEGER - 175)) | (1L << (REAL - 175)) | (1L << (DECIMAL - 175)))) != 0) || _la==STRING) ) {
				_localctx.returnType = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4774; Match(SONAME);
			State = 4775; Match(STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InstallPluginContext : ParserRuleContext {
		public ITerminalNode INSTALL() { return GetToken(MySqlParser.INSTALL, 0); }
		public ITerminalNode PLUGIN() { return GetToken(MySqlParser.PLUGIN, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode SONAME() { return GetToken(MySqlParser.SONAME, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public InstallPluginContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_installPlugin; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterInstallPlugin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitInstallPlugin(this);
		}
	}

	[RuleVersion(0)]
	public InstallPluginContext installPlugin() {
		InstallPluginContext _localctx = new InstallPluginContext(Context, State);
		EnterRule(_localctx, 434, RULE_installPlugin);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4777; Match(INSTALL);
			State = 4778; Match(PLUGIN);
			State = 4779; uid();
			State = 4780; Match(SONAME);
			State = 4781; Match(STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UninstallPluginContext : ParserRuleContext {
		public ITerminalNode UNINSTALL() { return GetToken(MySqlParser.UNINSTALL, 0); }
		public ITerminalNode PLUGIN() { return GetToken(MySqlParser.PLUGIN, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public UninstallPluginContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uninstallPlugin; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUninstallPlugin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUninstallPlugin(this);
		}
	}

	[RuleVersion(0)]
	public UninstallPluginContext uninstallPlugin() {
		UninstallPluginContext _localctx = new UninstallPluginContext(Context, State);
		EnterRule(_localctx, 436, RULE_uninstallPlugin);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4783; Match(UNINSTALL);
			State = 4784; Match(PLUGIN);
			State = 4785; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetStatementContext : ParserRuleContext {
		public SetStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setStatement; } }
	 
		public SetStatementContext() { }
		public virtual void CopyFrom(SetStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SetTransactionContext : SetStatementContext {
		public SetTransactionStatementContext setTransactionStatement() {
			return GetRuleContext<SetTransactionStatementContext>(0);
		}
		public SetTransactionContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetTransaction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetTransaction(this);
		}
	}
	public partial class SetCharsetContext : SetStatementContext {
		public ITerminalNode[] SET() { return GetTokens(MySqlParser.SET); }
		public ITerminalNode SET(int i) {
			return GetToken(MySqlParser.SET, i);
		}
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public SetCharsetContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetCharset(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetCharset(this);
		}
	}
	public partial class SetNamesContext : SetStatementContext {
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode NAMES() { return GetToken(MySqlParser.NAMES, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public SetNamesContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetNames(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetNames(this);
		}
	}
	public partial class SetPasswordContext : SetStatementContext {
		public SetPasswordStatementContext setPasswordStatement() {
			return GetRuleContext<SetPasswordStatementContext>(0);
		}
		public SetPasswordContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetPassword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetPassword(this);
		}
	}
	public partial class SetAutocommitContext : SetStatementContext {
		public SetAutocommitStatementContext setAutocommitStatement() {
			return GetRuleContext<SetAutocommitStatementContext>(0);
		}
		public SetAutocommitContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetAutocommit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetAutocommit(this);
		}
	}
	public partial class SetNewValueInsideTriggerContext : SetStatementContext {
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SetNewValueInsideTriggerContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetNewValueInsideTrigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetNewValueInsideTrigger(this);
		}
	}
	public partial class SetVariableContext : SetStatementContext {
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public VariableClauseContext[] variableClause() {
			return GetRuleContexts<VariableClauseContext>();
		}
		public VariableClauseContext variableClause(int i) {
			return GetRuleContext<VariableClauseContext>(i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public SetVariableContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetVariable(this);
		}
	}

	[RuleVersion(0)]
	public SetStatementContext setStatement() {
		SetStatementContext _localctx = new SetStatementContext(Context, State);
		EnterRule(_localctx, 438, RULE_setStatement);
		int _la;
		try {
			State = 4829;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,694,Context) ) {
			case 1:
				_localctx = new SetVariableContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4787; Match(SET);
				State = 4788; variableClause();
				State = 4789;
				_la = TokenStream.LA(1);
				if ( !(_la==VAR_ASSIGN || _la==EQUAL_SYMBOL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4790; expression(0);
				State = 4798;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4791; Match(COMMA);
					State = 4792; variableClause();
					State = 4793;
					_la = TokenStream.LA(1);
					if ( !(_la==VAR_ASSIGN || _la==EQUAL_SYMBOL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 4794; expression(0);
					}
					}
					State = 4800;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new SetCharsetContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4801; Match(SET);
				State = 4805;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case CHARACTER:
					{
					State = 4802; Match(CHARACTER);
					State = 4803; Match(SET);
					}
					break;
				case CHARSET:
					{
					State = 4804; Match(CHARSET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4809;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case BINARY:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
					{
					State = 4807; charsetName();
					}
					break;
				case DEFAULT:
					{
					State = 4808; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 3:
				_localctx = new SetNamesContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 4811; Match(SET);
				State = 4812; Match(NAMES);
				State = 4819;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case BINARY:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
					{
					State = 4813; charsetName();
					State = 4816;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COLLATE) {
						{
						State = 4814; Match(COLLATE);
						State = 4815; collationName();
						}
					}

					}
					break;
				case DEFAULT:
					{
					State = 4818; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 4:
				_localctx = new SetPasswordContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 4821; setPasswordStatement();
				}
				break;
			case 5:
				_localctx = new SetTransactionContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 4822; setTransactionStatement();
				}
				break;
			case 6:
				_localctx = new SetAutocommitContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 4823; setAutocommitStatement();
				}
				break;
			case 7:
				_localctx = new SetNewValueInsideTriggerContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 4824; Match(SET);
				State = 4825; fullId();
				State = 4826;
				_la = TokenStream.LA(1);
				if ( !(_la==VAR_ASSIGN || _la==EQUAL_SYMBOL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4827; expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowStatementContext : ParserRuleContext {
		public ShowStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showStatement; } }
	 
		public ShowStatementContext() { }
		public virtual void CopyFrom(ShowStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ShowOpenTablesContext : ShowStatementContext {
		public IToken schemaFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode OPEN() { return GetToken(MySqlParser.OPEN, 0); }
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ShowFilterContext showFilter() {
			return GetRuleContext<ShowFilterContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public ShowOpenTablesContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowOpenTables(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowOpenTables(this);
		}
	}
	public partial class ShowGlobalInfoContext : ShowStatementContext {
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ShowGlobalInfoClauseContext showGlobalInfoClause() {
			return GetRuleContext<ShowGlobalInfoClauseContext>(0);
		}
		public ShowGlobalInfoContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowGlobalInfo(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowGlobalInfo(this);
		}
	}
	public partial class ShowCreateFullIdObjectContext : ShowStatementContext {
		public IToken namedEntity;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode EVENT() { return GetToken(MySqlParser.EVENT, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public ITerminalNode TRIGGER() { return GetToken(MySqlParser.TRIGGER, 0); }
		public ITerminalNode VIEW() { return GetToken(MySqlParser.VIEW, 0); }
		public ShowCreateFullIdObjectContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowCreateFullIdObject(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowCreateFullIdObject(this);
		}
	}
	public partial class ShowCreateUserContext : ShowStatementContext {
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public ShowCreateUserContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowCreateUser(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowCreateUser(this);
		}
	}
	public partial class ShowErrorsContext : ShowStatementContext {
		public IToken errorFormat;
		public DecimalLiteralContext offset;
		public DecimalLiteralContext rowCount;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode ERRORS() { return GetToken(MySqlParser.ERRORS, 0); }
		public ITerminalNode WARNINGS() { return GetToken(MySqlParser.WARNINGS, 0); }
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public ShowErrorsContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowErrors(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowErrors(this);
		}
	}
	public partial class ShowCountErrorsContext : ShowStatementContext {
		public IToken errorFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode COUNT() { return GetToken(MySqlParser.COUNT, 0); }
		public ITerminalNode ERRORS() { return GetToken(MySqlParser.ERRORS, 0); }
		public ITerminalNode WARNINGS() { return GetToken(MySqlParser.WARNINGS, 0); }
		public ShowCountErrorsContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowCountErrors(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowCountErrors(this);
		}
	}
	public partial class ShowObjectFilterContext : ShowStatementContext {
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ShowCommonEntityContext showCommonEntity() {
			return GetRuleContext<ShowCommonEntityContext>(0);
		}
		public ShowFilterContext showFilter() {
			return GetRuleContext<ShowFilterContext>(0);
		}
		public ShowObjectFilterContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowObjectFilter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowObjectFilter(this);
		}
	}
	public partial class ShowCreateDbContext : ShowStatementContext {
		public IToken schemaFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(MySqlParser.SCHEMA, 0); }
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public ShowCreateDbContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowCreateDb(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowCreateDb(this);
		}
	}
	public partial class ShowEngineContext : ShowStatementContext {
		public IToken engineOption;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode MUTEX() { return GetToken(MySqlParser.MUTEX, 0); }
		public ShowEngineContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowEngine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowEngine(this);
		}
	}
	public partial class ShowSchemaFilterContext : ShowStatementContext {
		public IToken schemaFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ShowSchemaEntityContext showSchemaEntity() {
			return GetRuleContext<ShowSchemaEntityContext>(0);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ShowFilterContext showFilter() {
			return GetRuleContext<ShowFilterContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public ShowSchemaFilterContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowSchemaFilter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowSchemaFilter(this);
		}
	}
	public partial class ShowIndexesContext : ShowStatementContext {
		public IToken indexFormat;
		public IToken tableFormat;
		public IToken schemaFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode INDEXES() { return GetToken(MySqlParser.INDEXES, 0); }
		public ITerminalNode KEYS() { return GetToken(MySqlParser.KEYS, 0); }
		public ITerminalNode[] FROM() { return GetTokens(MySqlParser.FROM); }
		public ITerminalNode FROM(int i) {
			return GetToken(MySqlParser.FROM, i);
		}
		public ITerminalNode[] IN() { return GetTokens(MySqlParser.IN); }
		public ITerminalNode IN(int i) {
			return GetToken(MySqlParser.IN, i);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ShowIndexesContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowIndexes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowIndexes(this);
		}
	}
	public partial class ShowLogEventsContext : ShowStatementContext {
		public IToken logFormat;
		public IToken filename;
		public DecimalLiteralContext fromPosition;
		public DecimalLiteralContext offset;
		public DecimalLiteralContext rowCount;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode EVENTS() { return GetToken(MySqlParser.EVENTS, 0); }
		public ITerminalNode BINLOG() { return GetToken(MySqlParser.BINLOG, 0); }
		public ITerminalNode RELAYLOG() { return GetToken(MySqlParser.RELAYLOG, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public ShowLogEventsContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowLogEvents(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowLogEvents(this);
		}
	}
	public partial class ShowMasterLogsContext : ShowStatementContext {
		public IToken logFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode LOGS() { return GetToken(MySqlParser.LOGS, 0); }
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ShowMasterLogsContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowMasterLogs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowMasterLogs(this);
		}
	}
	public partial class ShowGrantsContext : ShowStatementContext {
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode GRANTS() { return GetToken(MySqlParser.GRANTS, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public ShowGrantsContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowGrants(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowGrants(this);
		}
	}
	public partial class ShowSlaveStatusContext : ShowStatementContext {
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode CHANNEL() { return GetToken(MySqlParser.CHANNEL, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ShowSlaveStatusContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowSlaveStatus(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowSlaveStatus(this);
		}
	}
	public partial class ShowRoutineContext : ShowStatementContext {
		public IToken routine;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode CODE() { return GetToken(MySqlParser.CODE, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public ShowRoutineContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowRoutine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowRoutine(this);
		}
	}
	public partial class ShowProfileContext : ShowStatementContext {
		public DecimalLiteralContext queryCount;
		public DecimalLiteralContext offset;
		public DecimalLiteralContext rowCount;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode PROFILE() { return GetToken(MySqlParser.PROFILE, 0); }
		public ShowProfileTypeContext[] showProfileType() {
			return GetRuleContexts<ShowProfileTypeContext>();
		}
		public ShowProfileTypeContext showProfileType(int i) {
			return GetRuleContext<ShowProfileTypeContext>(i);
		}
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode QUERY() { return GetToken(MySqlParser.QUERY, 0); }
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public ShowProfileContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowProfile(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowProfile(this);
		}
	}
	public partial class ShowColumnsContext : ShowStatementContext {
		public IToken columnsFormat;
		public IToken tableFormat;
		public IToken schemaFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode COLUMNS() { return GetToken(MySqlParser.COLUMNS, 0); }
		public ITerminalNode FIELDS() { return GetToken(MySqlParser.FIELDS, 0); }
		public ITerminalNode[] FROM() { return GetTokens(MySqlParser.FROM); }
		public ITerminalNode FROM(int i) {
			return GetToken(MySqlParser.FROM, i);
		}
		public ITerminalNode[] IN() { return GetTokens(MySqlParser.IN); }
		public ITerminalNode IN(int i) {
			return GetToken(MySqlParser.IN, i);
		}
		public ITerminalNode FULL() { return GetToken(MySqlParser.FULL, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ShowFilterContext showFilter() {
			return GetRuleContext<ShowFilterContext>(0);
		}
		public ShowColumnsContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowColumns(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowColumns(this);
		}
	}

	[RuleVersion(0)]
	public ShowStatementContext showStatement() {
		ShowStatementContext _localctx = new ShowStatementContext(Context, State);
		EnterRule(_localctx, 440, RULE_showStatement);
		int _la;
		try {
			State = 4982;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,716,Context) ) {
			case 1:
				_localctx = new ShowMasterLogsContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4831; Match(SHOW);
				State = 4832;
				((ShowMasterLogsContext)_localctx).logFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==BINARY || _la==MASTER) ) {
					((ShowMasterLogsContext)_localctx).logFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4833; Match(LOGS);
				}
				break;
			case 2:
				_localctx = new ShowLogEventsContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4834; Match(SHOW);
				State = 4835;
				((ShowLogEventsContext)_localctx).logFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==BINLOG || _la==RELAYLOG) ) {
					((ShowLogEventsContext)_localctx).logFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4836; Match(EVENTS);
				State = 4839;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IN) {
					{
					State = 4837; Match(IN);
					State = 4838; ((ShowLogEventsContext)_localctx).filename = Match(STRING_LITERAL);
					}
				}

				State = 4843;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM) {
					{
					State = 4841; Match(FROM);
					State = 4842; ((ShowLogEventsContext)_localctx).fromPosition = decimalLiteral();
					}
				}

				State = 4852;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIMIT) {
					{
					State = 4845; Match(LIMIT);
					State = 4849;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,697,Context) ) {
					case 1:
						{
						State = 4846; ((ShowLogEventsContext)_localctx).offset = decimalLiteral();
						State = 4847; Match(COMMA);
						}
						break;
					}
					State = 4851; ((ShowLogEventsContext)_localctx).rowCount = decimalLiteral();
					}
				}

				}
				break;
			case 3:
				_localctx = new ShowObjectFilterContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 4854; Match(SHOW);
				State = 4855; showCommonEntity();
				State = 4857;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIKE || _la==WHERE) {
					{
					State = 4856; showFilter();
					}
				}

				}
				break;
			case 4:
				_localctx = new ShowColumnsContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 4859; Match(SHOW);
				State = 4861;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FULL) {
					{
					State = 4860; Match(FULL);
					}
				}

				State = 4863;
				((ShowColumnsContext)_localctx).columnsFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==COLUMNS || _la==FIELDS) ) {
					((ShowColumnsContext)_localctx).columnsFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4864;
				((ShowColumnsContext)_localctx).tableFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FROM || _la==IN) ) {
					((ShowColumnsContext)_localctx).tableFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4865; tableName();
				State = 4868;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM || _la==IN) {
					{
					State = 4866;
					((ShowColumnsContext)_localctx).schemaFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==FROM || _la==IN) ) {
						((ShowColumnsContext)_localctx).schemaFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 4867; uid();
					}
				}

				State = 4871;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIKE || _la==WHERE) {
					{
					State = 4870; showFilter();
					}
				}

				}
				break;
			case 5:
				_localctx = new ShowCreateDbContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 4873; Match(SHOW);
				State = 4874; Match(CREATE);
				State = 4875;
				((ShowCreateDbContext)_localctx).schemaFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DATABASE || _la==SCHEMA) ) {
					((ShowCreateDbContext)_localctx).schemaFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4877;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IF) {
					{
					State = 4876; ifNotExists();
					}
				}

				State = 4879; uid();
				}
				break;
			case 6:
				_localctx = new ShowCreateFullIdObjectContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 4880; Match(SHOW);
				State = 4881; Match(CREATE);
				State = 4882;
				((ShowCreateFullIdObjectContext)_localctx).namedEntity = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 113)) & ~0x3f) == 0 && ((1L << (_la - 113)) & ((1L << (PROCEDURE - 113)) | (1L << (TABLE - 113)) | (1L << (TRIGGER - 113)))) != 0) || _la==EVENT || _la==FUNCTION || _la==VIEW) ) {
					((ShowCreateFullIdObjectContext)_localctx).namedEntity = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4883; fullId();
				}
				break;
			case 7:
				_localctx = new ShowCreateUserContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 4884; Match(SHOW);
				State = 4885; Match(CREATE);
				State = 4886; Match(USER);
				State = 4887; userName();
				}
				break;
			case 8:
				_localctx = new ShowEngineContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 4888; Match(SHOW);
				State = 4889; Match(ENGINE);
				State = 4890; engineName();
				State = 4891;
				((ShowEngineContext)_localctx).engineOption = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==MUTEX || _la==STATUS) ) {
					((ShowEngineContext)_localctx).engineOption = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 9:
				_localctx = new ShowGlobalInfoContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 4893; Match(SHOW);
				State = 4894; showGlobalInfoClause();
				}
				break;
			case 10:
				_localctx = new ShowErrorsContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 4895; Match(SHOW);
				State = 4896;
				((ShowErrorsContext)_localctx).errorFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ERRORS || _la==WARNINGS) ) {
					((ShowErrorsContext)_localctx).errorFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				{
				State = 4897; Match(LIMIT);
				State = 4901;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,704,Context) ) {
				case 1:
					{
					State = 4898; ((ShowErrorsContext)_localctx).offset = decimalLiteral();
					State = 4899; Match(COMMA);
					}
					break;
				}
				State = 4903; ((ShowErrorsContext)_localctx).rowCount = decimalLiteral();
				}
				}
				break;
			case 11:
				_localctx = new ShowCountErrorsContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 4904; Match(SHOW);
				State = 4905; Match(COUNT);
				State = 4906; Match(LR_BRACKET);
				State = 4907; Match(STAR);
				State = 4908; Match(RR_BRACKET);
				State = 4909;
				((ShowCountErrorsContext)_localctx).errorFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ERRORS || _la==WARNINGS) ) {
					((ShowCountErrorsContext)_localctx).errorFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 12:
				_localctx = new ShowSchemaFilterContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 4910; Match(SHOW);
				State = 4911; showSchemaEntity();
				State = 4914;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM || _la==IN) {
					{
					State = 4912;
					((ShowSchemaFilterContext)_localctx).schemaFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==FROM || _la==IN) ) {
						((ShowSchemaFilterContext)_localctx).schemaFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 4913; uid();
					}
				}

				State = 4917;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIKE || _la==WHERE) {
					{
					State = 4916; showFilter();
					}
				}

				}
				break;
			case 13:
				_localctx = new ShowRoutineContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 4919; Match(SHOW);
				State = 4920;
				((ShowRoutineContext)_localctx).routine = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==PROCEDURE || _la==FUNCTION) ) {
					((ShowRoutineContext)_localctx).routine = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4921; Match(CODE);
				State = 4922; fullId();
				}
				break;
			case 14:
				_localctx = new ShowGrantsContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 4923; Match(SHOW);
				State = 4924; Match(GRANTS);
				State = 4927;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 4925; Match(FOR);
					State = 4926; userName();
					}
				}

				}
				break;
			case 15:
				_localctx = new ShowIndexesContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 4929; Match(SHOW);
				State = 4930;
				((ShowIndexesContext)_localctx).indexFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==INDEX || _la==KEYS || _la==INDEXES) ) {
					((ShowIndexesContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4931;
				((ShowIndexesContext)_localctx).tableFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FROM || _la==IN) ) {
					((ShowIndexesContext)_localctx).tableFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4932; tableName();
				State = 4935;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM || _la==IN) {
					{
					State = 4933;
					((ShowIndexesContext)_localctx).schemaFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==FROM || _la==IN) ) {
						((ShowIndexesContext)_localctx).schemaFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 4934; uid();
					}
				}

				State = 4939;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE) {
					{
					State = 4937; Match(WHERE);
					State = 4938; expression(0);
					}
				}

				}
				break;
			case 16:
				_localctx = new ShowOpenTablesContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 4941; Match(SHOW);
				State = 4942; Match(OPEN);
				State = 4943; Match(TABLES);
				State = 4946;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM || _la==IN) {
					{
					State = 4944;
					((ShowOpenTablesContext)_localctx).schemaFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==FROM || _la==IN) ) {
						((ShowOpenTablesContext)_localctx).schemaFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 4945; uid();
					}
				}

				State = 4949;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIKE || _la==WHERE) {
					{
					State = 4948; showFilter();
					}
				}

				}
				break;
			case 17:
				_localctx = new ShowProfileContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 4951; Match(SHOW);
				State = 4952; Match(PROFILE);
				State = 4953; showProfileType();
				State = 4958;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4954; Match(COMMA);
					State = 4955; showProfileType();
					}
					}
					State = 4960;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4964;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 4961; Match(FOR);
					State = 4962; Match(QUERY);
					State = 4963; ((ShowProfileContext)_localctx).queryCount = decimalLiteral();
					}
				}

				{
				State = 4966; Match(LIMIT);
				State = 4970;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,714,Context) ) {
				case 1:
					{
					State = 4967; ((ShowProfileContext)_localctx).offset = decimalLiteral();
					State = 4968; Match(COMMA);
					}
					break;
				}
				State = 4972; ((ShowProfileContext)_localctx).rowCount = decimalLiteral();
				}
				}
				break;
			case 18:
				_localctx = new ShowSlaveStatusContext(_localctx);
				EnterOuterAlt(_localctx, 18);
				{
				State = 4974; Match(SHOW);
				State = 4975; Match(SLAVE);
				State = 4976; Match(STATUS);
				State = 4980;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 4977; Match(FOR);
					State = 4978; Match(CHANNEL);
					State = 4979; Match(STRING_LITERAL);
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableClauseContext : ParserRuleContext {
		public ITerminalNode LOCAL_ID() { return GetToken(MySqlParser.LOCAL_ID, 0); }
		public ITerminalNode GLOBAL_ID() { return GetToken(MySqlParser.GLOBAL_ID, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode GLOBAL() { return GetToken(MySqlParser.GLOBAL, 0); }
		public ITerminalNode SESSION() { return GetToken(MySqlParser.SESSION, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public VariableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterVariableClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitVariableClause(this);
		}
	}

	[RuleVersion(0)]
	public VariableClauseContext variableClause() {
		VariableClauseContext _localctx = new VariableClauseContext(Context, State);
		EnterRule(_localctx, 442, RULE_variableClause);
		int _la;
		try {
			State = 4994;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LOCAL_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4984; Match(LOCAL_ID);
				}
				break;
			case GLOBAL_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4985; Match(GLOBAL_ID);
				}
				break;
			case DATABASE:
			case LEFT:
			case RIGHT:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case TEXT:
			case ENUM:
			case SERIAL:
			case COUNT:
			case POSITION:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case AT_SIGN:
			case CHARSET_REVERSE_QOUTE_STRING:
			case STRING_LITERAL:
			case ID:
			case REVERSE_QUOTE_ID:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4991;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,718,Context) ) {
				case 1:
					{
					State = 4988;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AT_SIGN) {
						{
						State = 4986; Match(AT_SIGN);
						State = 4987; Match(AT_SIGN);
						}
					}

					State = 4990;
					_la = TokenStream.LA(1);
					if ( !(_la==GLOBAL || _la==LOCAL || _la==SESSION) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 4993; uid();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowCommonEntityContext : ParserRuleContext {
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode COLLATION() { return GetToken(MySqlParser.COLLATION, 0); }
		public ITerminalNode DATABASES() { return GetToken(MySqlParser.DATABASES, 0); }
		public ITerminalNode SCHEMAS() { return GetToken(MySqlParser.SCHEMAS, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public ITerminalNode VARIABLES() { return GetToken(MySqlParser.VARIABLES, 0); }
		public ITerminalNode GLOBAL() { return GetToken(MySqlParser.GLOBAL, 0); }
		public ITerminalNode SESSION() { return GetToken(MySqlParser.SESSION, 0); }
		public ShowCommonEntityContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showCommonEntity; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowCommonEntity(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowCommonEntity(this);
		}
	}

	[RuleVersion(0)]
	public ShowCommonEntityContext showCommonEntity() {
		ShowCommonEntityContext _localctx = new ShowCommonEntityContext(Context, State);
		EnterRule(_localctx, 444, RULE_showCommonEntity);
		int _la;
		try {
			State = 5009;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CHARACTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4996; Match(CHARACTER);
				State = 4997; Match(SET);
				}
				break;
			case COLLATION:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4998; Match(COLLATION);
				}
				break;
			case DATABASES:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4999; Match(DATABASES);
				}
				break;
			case SCHEMAS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5000; Match(SCHEMAS);
				}
				break;
			case FUNCTION:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5001; Match(FUNCTION);
				State = 5002; Match(STATUS);
				}
				break;
			case PROCEDURE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5003; Match(PROCEDURE);
				State = 5004; Match(STATUS);
				}
				break;
			case GLOBAL:
			case SESSION:
			case STATUS:
			case VARIABLES:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5006;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==GLOBAL || _la==SESSION) {
					{
					State = 5005;
					_la = TokenStream.LA(1);
					if ( !(_la==GLOBAL || _la==SESSION) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 5008;
				_la = TokenStream.LA(1);
				if ( !(_la==STATUS || _la==VARIABLES) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowFilterContext : ParserRuleContext {
		public ITerminalNode LIKE() { return GetToken(MySqlParser.LIKE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ShowFilterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showFilter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowFilter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowFilter(this);
		}
	}

	[RuleVersion(0)]
	public ShowFilterContext showFilter() {
		ShowFilterContext _localctx = new ShowFilterContext(Context, State);
		EnterRule(_localctx, 446, RULE_showFilter);
		try {
			State = 5015;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LIKE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5011; Match(LIKE);
				State = 5012; Match(STRING_LITERAL);
				}
				break;
			case WHERE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5013; Match(WHERE);
				State = 5014; expression(0);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowGlobalInfoClauseContext : ParserRuleContext {
		public ITerminalNode ENGINES() { return GetToken(MySqlParser.ENGINES, 0); }
		public ITerminalNode STORAGE() { return GetToken(MySqlParser.STORAGE, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode PLUGINS() { return GetToken(MySqlParser.PLUGINS, 0); }
		public ITerminalNode PRIVILEGES() { return GetToken(MySqlParser.PRIVILEGES, 0); }
		public ITerminalNode PROCESSLIST() { return GetToken(MySqlParser.PROCESSLIST, 0); }
		public ITerminalNode FULL() { return GetToken(MySqlParser.FULL, 0); }
		public ITerminalNode PROFILES() { return GetToken(MySqlParser.PROFILES, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ITerminalNode HOSTS() { return GetToken(MySqlParser.HOSTS, 0); }
		public ITerminalNode AUTHORS() { return GetToken(MySqlParser.AUTHORS, 0); }
		public ITerminalNode CONTRIBUTORS() { return GetToken(MySqlParser.CONTRIBUTORS, 0); }
		public ShowGlobalInfoClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showGlobalInfoClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowGlobalInfoClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowGlobalInfoClause(this);
		}
	}

	[RuleVersion(0)]
	public ShowGlobalInfoClauseContext showGlobalInfoClause() {
		ShowGlobalInfoClauseContext _localctx = new ShowGlobalInfoClauseContext(Context, State);
		EnterRule(_localctx, 448, RULE_showGlobalInfoClause);
		int _la;
		try {
			State = 5034;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ENGINES:
			case STORAGE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5018;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==STORAGE) {
					{
					State = 5017; Match(STORAGE);
					}
				}

				State = 5020; Match(ENGINES);
				}
				break;
			case MASTER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5021; Match(MASTER);
				State = 5022; Match(STATUS);
				}
				break;
			case PLUGINS:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5023; Match(PLUGINS);
				}
				break;
			case PRIVILEGES:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5024; Match(PRIVILEGES);
				}
				break;
			case FULL:
			case PROCESSLIST:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5026;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FULL) {
					{
					State = 5025; Match(FULL);
					}
				}

				State = 5028; Match(PROCESSLIST);
				}
				break;
			case PROFILES:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5029; Match(PROFILES);
				}
				break;
			case SLAVE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5030; Match(SLAVE);
				State = 5031; Match(HOSTS);
				}
				break;
			case AUTHORS:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5032; Match(AUTHORS);
				}
				break;
			case CONTRIBUTORS:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5033; Match(CONTRIBUTORS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowSchemaEntityContext : ParserRuleContext {
		public ITerminalNode EVENTS() { return GetToken(MySqlParser.EVENTS, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public ITerminalNode FULL() { return GetToken(MySqlParser.FULL, 0); }
		public ITerminalNode TRIGGERS() { return GetToken(MySqlParser.TRIGGERS, 0); }
		public ShowSchemaEntityContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showSchemaEntity; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowSchemaEntity(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowSchemaEntity(this);
		}
	}

	[RuleVersion(0)]
	public ShowSchemaEntityContext showSchemaEntity() {
		ShowSchemaEntityContext _localctx = new ShowSchemaEntityContext(Context, State);
		EnterRule(_localctx, 450, RULE_showSchemaEntity);
		int _la;
		try {
			State = 5044;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EVENTS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5036; Match(EVENTS);
				}
				break;
			case TABLE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5037; Match(TABLE);
				State = 5038; Match(STATUS);
				}
				break;
			case FULL:
			case TABLES:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5040;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FULL) {
					{
					State = 5039; Match(FULL);
					}
				}

				State = 5042; Match(TABLES);
				}
				break;
			case TRIGGERS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5043; Match(TRIGGERS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowProfileTypeContext : ParserRuleContext {
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode BLOCK() { return GetToken(MySqlParser.BLOCK, 0); }
		public ITerminalNode IO() { return GetToken(MySqlParser.IO, 0); }
		public ITerminalNode CONTEXT() { return GetToken(MySqlParser.CONTEXT, 0); }
		public ITerminalNode SWITCHES() { return GetToken(MySqlParser.SWITCHES, 0); }
		public ITerminalNode CPU() { return GetToken(MySqlParser.CPU, 0); }
		public ITerminalNode IPC() { return GetToken(MySqlParser.IPC, 0); }
		public ITerminalNode MEMORY() { return GetToken(MySqlParser.MEMORY, 0); }
		public ITerminalNode PAGE() { return GetToken(MySqlParser.PAGE, 0); }
		public ITerminalNode FAULTS() { return GetToken(MySqlParser.FAULTS, 0); }
		public ITerminalNode SOURCE() { return GetToken(MySqlParser.SOURCE, 0); }
		public ITerminalNode SWAPS() { return GetToken(MySqlParser.SWAPS, 0); }
		public ShowProfileTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showProfileType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowProfileType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowProfileType(this);
		}
	}

	[RuleVersion(0)]
	public ShowProfileTypeContext showProfileType() {
		ShowProfileTypeContext _localctx = new ShowProfileTypeContext(Context, State);
		EnterRule(_localctx, 452, RULE_showProfileType);
		try {
			State = 5058;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5046; Match(ALL);
				}
				break;
			case BLOCK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5047; Match(BLOCK);
				State = 5048; Match(IO);
				}
				break;
			case CONTEXT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5049; Match(CONTEXT);
				State = 5050; Match(SWITCHES);
				}
				break;
			case CPU:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5051; Match(CPU);
				}
				break;
			case IPC:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5052; Match(IPC);
				}
				break;
			case MEMORY:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5053; Match(MEMORY);
				}
				break;
			case PAGE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5054; Match(PAGE);
				State = 5055; Match(FAULTS);
				}
				break;
			case SOURCE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5056; Match(SOURCE);
				}
				break;
			case SWAPS:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5057; Match(SWAPS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BinlogStatementContext : ParserRuleContext {
		public ITerminalNode BINLOG() { return GetToken(MySqlParser.BINLOG, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public BinlogStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_binlogStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBinlogStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBinlogStatement(this);
		}
	}

	[RuleVersion(0)]
	public BinlogStatementContext binlogStatement() {
		BinlogStatementContext _localctx = new BinlogStatementContext(Context, State);
		EnterRule(_localctx, 454, RULE_binlogStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5060; Match(BINLOG);
			State = 5061; Match(STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CacheIndexStatementContext : ParserRuleContext {
		public UidContext schema;
		public ITerminalNode CACHE() { return GetToken(MySqlParser.CACHE, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public TableIndexesContext[] tableIndexes() {
			return GetRuleContexts<TableIndexesContext>();
		}
		public TableIndexesContext tableIndexes(int i) {
			return GetRuleContext<TableIndexesContext>(i);
		}
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public CacheIndexStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cacheIndexStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCacheIndexStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCacheIndexStatement(this);
		}
	}

	[RuleVersion(0)]
	public CacheIndexStatementContext cacheIndexStatement() {
		CacheIndexStatementContext _localctx = new CacheIndexStatementContext(Context, State);
		EnterRule(_localctx, 456, RULE_cacheIndexStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5063; Match(CACHE);
			State = 5064; Match(INDEX);
			State = 5065; tableIndexes();
			State = 5070;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5066; Match(COMMA);
				State = 5067; tableIndexes();
				}
				}
				State = 5072;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5080;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 5073; Match(PARTITION);
				State = 5074; Match(LR_BRACKET);
				State = 5077;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 5075; uidList();
					}
					break;
				case ALL:
					{
					State = 5076; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5079; Match(RR_BRACKET);
				}
			}

			State = 5082; Match(IN);
			State = 5083; _localctx.schema = uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlushStatementContext : ParserRuleContext {
		public IToken flushFormat;
		public ITerminalNode FLUSH() { return GetToken(MySqlParser.FLUSH, 0); }
		public FlushOptionContext[] flushOption() {
			return GetRuleContexts<FlushOptionContext>();
		}
		public FlushOptionContext flushOption(int i) {
			return GetRuleContext<FlushOptionContext>(i);
		}
		public ITerminalNode NO_WRITE_TO_BINLOG() { return GetToken(MySqlParser.NO_WRITE_TO_BINLOG, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public FlushStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flushStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFlushStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFlushStatement(this);
		}
	}

	[RuleVersion(0)]
	public FlushStatementContext flushStatement() {
		FlushStatementContext _localctx = new FlushStatementContext(Context, State);
		EnterRule(_localctx, 458, RULE_flushStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5085; Match(FLUSH);
			State = 5087;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NO_WRITE_TO_BINLOG || _la==LOCAL) {
				{
				State = 5086;
				_localctx.flushFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==NO_WRITE_TO_BINLOG || _la==LOCAL) ) {
					_localctx.flushFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 5089; flushOption();
			State = 5094;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5090; Match(COMMA);
				State = 5091; flushOption();
				}
				}
				State = 5096;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KillStatementContext : ParserRuleContext {
		public IToken connectionFormat;
		public ITerminalNode KILL() { return GetToken(MySqlParser.KILL, 0); }
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public ITerminalNode CONNECTION() { return GetToken(MySqlParser.CONNECTION, 0); }
		public ITerminalNode QUERY() { return GetToken(MySqlParser.QUERY, 0); }
		public KillStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_killStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterKillStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitKillStatement(this);
		}
	}

	[RuleVersion(0)]
	public KillStatementContext killStatement() {
		KillStatementContext _localctx = new KillStatementContext(Context, State);
		EnterRule(_localctx, 460, RULE_killStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5097; Match(KILL);
			State = 5099;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONNECTION || _la==QUERY) {
				{
				State = 5098;
				_localctx.connectionFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==CONNECTION || _la==QUERY) ) {
					_localctx.connectionFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 5102;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 5101; decimalLiteral();
				}
				}
				State = 5104;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( ((((_la - 964)) & ~0x3f) == 0 && ((1L << (_la - 964)) & ((1L << (ZERO_DECIMAL - 964)) | (1L << (ONE_DECIMAL - 964)) | (1L << (TWO_DECIMAL - 964)) | (1L << (DECIMAL_LITERAL - 964)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoadIndexIntoCacheContext : ParserRuleContext {
		public ITerminalNode LOAD() { return GetToken(MySqlParser.LOAD, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode CACHE() { return GetToken(MySqlParser.CACHE, 0); }
		public LoadedTableIndexesContext[] loadedTableIndexes() {
			return GetRuleContexts<LoadedTableIndexesContext>();
		}
		public LoadedTableIndexesContext loadedTableIndexes(int i) {
			return GetRuleContext<LoadedTableIndexesContext>(i);
		}
		public LoadIndexIntoCacheContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loadIndexIntoCache; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLoadIndexIntoCache(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLoadIndexIntoCache(this);
		}
	}

	[RuleVersion(0)]
	public LoadIndexIntoCacheContext loadIndexIntoCache() {
		LoadIndexIntoCacheContext _localctx = new LoadIndexIntoCacheContext(Context, State);
		EnterRule(_localctx, 462, RULE_loadIndexIntoCache);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5106; Match(LOAD);
			State = 5107; Match(INDEX);
			State = 5108; Match(INTO);
			State = 5109; Match(CACHE);
			State = 5110; loadedTableIndexes();
			State = 5115;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5111; Match(COMMA);
				State = 5112; loadedTableIndexes();
				}
				}
				State = 5117;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResetStatementContext : ParserRuleContext {
		public ITerminalNode RESET() { return GetToken(MySqlParser.RESET, 0); }
		public ITerminalNode QUERY() { return GetToken(MySqlParser.QUERY, 0); }
		public ITerminalNode CACHE() { return GetToken(MySqlParser.CACHE, 0); }
		public ResetStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_resetStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterResetStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitResetStatement(this);
		}
	}

	[RuleVersion(0)]
	public ResetStatementContext resetStatement() {
		ResetStatementContext _localctx = new ResetStatementContext(Context, State);
		EnterRule(_localctx, 464, RULE_resetStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5118; Match(RESET);
			State = 5119; Match(QUERY);
			State = 5120; Match(CACHE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShutdownStatementContext : ParserRuleContext {
		public ITerminalNode SHUTDOWN() { return GetToken(MySqlParser.SHUTDOWN, 0); }
		public ShutdownStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shutdownStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShutdownStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShutdownStatement(this);
		}
	}

	[RuleVersion(0)]
	public ShutdownStatementContext shutdownStatement() {
		ShutdownStatementContext _localctx = new ShutdownStatementContext(Context, State);
		EnterRule(_localctx, 466, RULE_shutdownStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5122; Match(SHUTDOWN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableIndexesContext : ParserRuleContext {
		public IToken indexFormat;
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public TableIndexesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableIndexes; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableIndexes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableIndexes(this);
		}
	}

	[RuleVersion(0)]
	public TableIndexesContext tableIndexes() {
		TableIndexesContext _localctx = new TableIndexesContext(Context, State);
		EnterRule(_localctx, 468, RULE_tableIndexes);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5124; tableName();
			State = 5132;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INDEX || _la==KEY || _la==LR_BRACKET) {
				{
				State = 5126;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDEX || _la==KEY) {
					{
					State = 5125;
					_localctx.indexFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==INDEX || _la==KEY) ) {
						_localctx.indexFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 5128; Match(LR_BRACKET);
				State = 5129; uidList();
				State = 5130; Match(RR_BRACKET);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlushOptionContext : ParserRuleContext {
		public FlushOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flushOption; } }
	 
		public FlushOptionContext() { }
		public virtual void CopyFrom(FlushOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TableFlushOptionContext : FlushOptionContext {
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public FlushTableOptionContext flushTableOption() {
			return GetRuleContext<FlushTableOptionContext>(0);
		}
		public TableFlushOptionContext(FlushOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableFlushOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableFlushOption(this);
		}
	}
	public partial class ChannelFlushOptionContext : FlushOptionContext {
		public ITerminalNode RELAY() { return GetToken(MySqlParser.RELAY, 0); }
		public ITerminalNode LOGS() { return GetToken(MySqlParser.LOGS, 0); }
		public ChannelOptionContext channelOption() {
			return GetRuleContext<ChannelOptionContext>(0);
		}
		public ChannelFlushOptionContext(FlushOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterChannelFlushOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitChannelFlushOption(this);
		}
	}
	public partial class SimpleFlushOptionContext : FlushOptionContext {
		public ITerminalNode DES_KEY_FILE() { return GetToken(MySqlParser.DES_KEY_FILE, 0); }
		public ITerminalNode HOSTS() { return GetToken(MySqlParser.HOSTS, 0); }
		public ITerminalNode LOGS() { return GetToken(MySqlParser.LOGS, 0); }
		public ITerminalNode OPTIMIZER_COSTS() { return GetToken(MySqlParser.OPTIMIZER_COSTS, 0); }
		public ITerminalNode PRIVILEGES() { return GetToken(MySqlParser.PRIVILEGES, 0); }
		public ITerminalNode QUERY() { return GetToken(MySqlParser.QUERY, 0); }
		public ITerminalNode CACHE() { return GetToken(MySqlParser.CACHE, 0); }
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode USER_RESOURCES() { return GetToken(MySqlParser.USER_RESOURCES, 0); }
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public ITerminalNode ERROR() { return GetToken(MySqlParser.ERROR, 0); }
		public ITerminalNode GENERAL() { return GetToken(MySqlParser.GENERAL, 0); }
		public ITerminalNode RELAY() { return GetToken(MySqlParser.RELAY, 0); }
		public ITerminalNode SLOW() { return GetToken(MySqlParser.SLOW, 0); }
		public SimpleFlushOptionContext(FlushOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleFlushOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleFlushOption(this);
		}
	}

	[RuleVersion(0)]
	public FlushOptionContext flushOption() {
		FlushOptionContext _localctx = new FlushOptionContext(Context, State);
		EnterRule(_localctx, 470, RULE_flushOption);
		int _la;
		try {
			State = 5164;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,744,Context) ) {
			case 1:
				_localctx = new SimpleFlushOptionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 5152;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DES_KEY_FILE:
					{
					State = 5134; Match(DES_KEY_FILE);
					}
					break;
				case HOSTS:
					{
					State = 5135; Match(HOSTS);
					}
					break;
				case BINARY:
				case ENGINE:
				case ERROR:
				case GENERAL:
				case LOGS:
				case RELAY:
				case SLOW:
					{
					State = 5137;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==BINARY || ((((_la - 318)) & ~0x3f) == 0 && ((1L << (_la - 318)) & ((1L << (ENGINE - 318)) | (1L << (ERROR - 318)) | (1L << (GENERAL - 318)))) != 0) || _la==RELAY || _la==SLOW) {
						{
						State = 5136;
						_la = TokenStream.LA(1);
						if ( !(_la==BINARY || ((((_la - 318)) & ~0x3f) == 0 && ((1L << (_la - 318)) & ((1L << (ENGINE - 318)) | (1L << (ERROR - 318)) | (1L << (GENERAL - 318)))) != 0) || _la==RELAY || _la==SLOW) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					State = 5139; Match(LOGS);
					}
					break;
				case OPTIMIZER_COSTS:
					{
					State = 5140; Match(OPTIMIZER_COSTS);
					}
					break;
				case PRIVILEGES:
					{
					State = 5141; Match(PRIVILEGES);
					}
					break;
				case QUERY:
					{
					State = 5142; Match(QUERY);
					State = 5143; Match(CACHE);
					}
					break;
				case STATUS:
					{
					State = 5144; Match(STATUS);
					}
					break;
				case USER_RESOURCES:
					{
					State = 5145; Match(USER_RESOURCES);
					}
					break;
				case TABLES:
					{
					State = 5146; Match(TABLES);
					State = 5150;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==WITH) {
						{
						State = 5147; Match(WITH);
						State = 5148; Match(READ);
						State = 5149; Match(LOCK);
						}
					}

					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				_localctx = new ChannelFlushOptionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 5154; Match(RELAY);
				State = 5155; Match(LOGS);
				State = 5157;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 5156; channelOption();
					}
				}

				}
				break;
			case 3:
				_localctx = new TableFlushOptionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 5159; Match(TABLES);
				State = 5160; tables();
				State = 5162;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR || _la==WITH) {
					{
					State = 5161; flushTableOption();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlushTableOptionContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode EXPORT() { return GetToken(MySqlParser.EXPORT, 0); }
		public FlushTableOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flushTableOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFlushTableOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFlushTableOption(this);
		}
	}

	[RuleVersion(0)]
	public FlushTableOptionContext flushTableOption() {
		FlushTableOptionContext _localctx = new FlushTableOptionContext(Context, State);
		EnterRule(_localctx, 472, RULE_flushTableOption);
		try {
			State = 5171;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WITH:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5166; Match(WITH);
				State = 5167; Match(READ);
				State = 5168; Match(LOCK);
				}
				break;
			case FOR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5169; Match(FOR);
				State = 5170; Match(EXPORT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoadedTableIndexesContext : ParserRuleContext {
		public UidListContext partitionList;
		public IToken indexFormat;
		public UidListContext indexList;
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode LEAVES() { return GetToken(MySqlParser.LEAVES, 0); }
		public UidListContext[] uidList() {
			return GetRuleContexts<UidListContext>();
		}
		public UidListContext uidList(int i) {
			return GetRuleContext<UidListContext>(i);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public LoadedTableIndexesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loadedTableIndexes; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLoadedTableIndexes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLoadedTableIndexes(this);
		}
	}

	[RuleVersion(0)]
	public LoadedTableIndexesContext loadedTableIndexes() {
		LoadedTableIndexesContext _localctx = new LoadedTableIndexesContext(Context, State);
		EnterRule(_localctx, 474, RULE_loadedTableIndexes);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5173; tableName();
			State = 5181;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 5174; Match(PARTITION);
				State = 5175; Match(LR_BRACKET);
				State = 5178;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 5176; _localctx.partitionList = uidList();
					}
					break;
				case ALL:
					{
					State = 5177; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5180; Match(RR_BRACKET);
				}
			}

			State = 5190;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,749,Context) ) {
			case 1:
				{
				State = 5184;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDEX || _la==KEY) {
					{
					State = 5183;
					_localctx.indexFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==INDEX || _la==KEY) ) {
						_localctx.indexFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 5186; Match(LR_BRACKET);
				State = 5187; _localctx.indexList = uidList();
				State = 5188; Match(RR_BRACKET);
				}
				break;
			}
			State = 5194;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 5192; Match(IGNORE);
				State = 5193; Match(LEAVES);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleDescribeStatementContext : ParserRuleContext {
		public IToken command;
		public UidContext column;
		public IToken pattern;
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode EXPLAIN() { return GetToken(MySqlParser.EXPLAIN, 0); }
		public ITerminalNode DESCRIBE() { return GetToken(MySqlParser.DESCRIBE, 0); }
		public ITerminalNode DESC() { return GetToken(MySqlParser.DESC, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public SimpleDescribeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleDescribeStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleDescribeStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleDescribeStatement(this);
		}
	}

	[RuleVersion(0)]
	public SimpleDescribeStatementContext simpleDescribeStatement() {
		SimpleDescribeStatementContext _localctx = new SimpleDescribeStatementContext(Context, State);
		EnterRule(_localctx, 476, RULE_simpleDescribeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5196;
			_localctx.command = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DESC) | (1L << DESCRIBE) | (1L << EXPLAIN))) != 0)) ) {
				_localctx.command = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5197; tableName();
			State = 5200;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,751,Context) ) {
			case 1:
				{
				State = 5198; _localctx.column = uid();
				}
				break;
			case 2:
				{
				State = 5199; _localctx.pattern = Match(STRING_LITERAL);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullDescribeStatementContext : ParserRuleContext {
		public IToken command;
		public IToken formatType;
		public IToken formatValue;
		public DescribeObjectClauseContext describeObjectClause() {
			return GetRuleContext<DescribeObjectClauseContext>(0);
		}
		public ITerminalNode EXPLAIN() { return GetToken(MySqlParser.EXPLAIN, 0); }
		public ITerminalNode DESCRIBE() { return GetToken(MySqlParser.DESCRIBE, 0); }
		public ITerminalNode DESC() { return GetToken(MySqlParser.DESC, 0); }
		public ITerminalNode EXTENDED() { return GetToken(MySqlParser.EXTENDED, 0); }
		public ITerminalNode PARTITIONS() { return GetToken(MySqlParser.PARTITIONS, 0); }
		public ITerminalNode FORMAT() { return GetToken(MySqlParser.FORMAT, 0); }
		public ITerminalNode TRADITIONAL() { return GetToken(MySqlParser.TRADITIONAL, 0); }
		public ITerminalNode JSON() { return GetToken(MySqlParser.JSON, 0); }
		public FullDescribeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullDescribeStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFullDescribeStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFullDescribeStatement(this);
		}
	}

	[RuleVersion(0)]
	public FullDescribeStatementContext fullDescribeStatement() {
		FullDescribeStatementContext _localctx = new FullDescribeStatementContext(Context, State);
		EnterRule(_localctx, 478, RULE_fullDescribeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5202;
			_localctx.command = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DESC) | (1L << DESCRIBE) | (1L << EXPLAIN))) != 0)) ) {
				_localctx.command = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5206;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXTENDED || _la==PARTITIONS || _la==FORMAT) {
				{
				State = 5203;
				_localctx.formatType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==EXTENDED || _la==PARTITIONS || _la==FORMAT) ) {
					_localctx.formatType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5204; Match(EQUAL_SYMBOL);
				State = 5205;
				_localctx.formatValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==JSON || _la==TRADITIONAL) ) {
					_localctx.formatValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 5208; describeObjectClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HelpStatementContext : ParserRuleContext {
		public ITerminalNode HELP() { return GetToken(MySqlParser.HELP, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public HelpStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_helpStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHelpStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHelpStatement(this);
		}
	}

	[RuleVersion(0)]
	public HelpStatementContext helpStatement() {
		HelpStatementContext _localctx = new HelpStatementContext(Context, State);
		EnterRule(_localctx, 480, RULE_helpStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5210; Match(HELP);
			State = 5211; Match(STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UseStatementContext : ParserRuleContext {
		public ITerminalNode USE() { return GetToken(MySqlParser.USE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public UseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_useStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUseStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUseStatement(this);
		}
	}

	[RuleVersion(0)]
	public UseStatementContext useStatement() {
		UseStatementContext _localctx = new UseStatementContext(Context, State);
		EnterRule(_localctx, 482, RULE_useStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5213; Match(USE);
			State = 5214; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DescribeObjectClauseContext : ParserRuleContext {
		public DescribeObjectClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_describeObjectClause; } }
	 
		public DescribeObjectClauseContext() { }
		public virtual void CopyFrom(DescribeObjectClauseContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DescribeStatementsContext : DescribeObjectClauseContext {
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public DeleteStatementContext deleteStatement() {
			return GetRuleContext<DeleteStatementContext>(0);
		}
		public InsertStatementContext insertStatement() {
			return GetRuleContext<InsertStatementContext>(0);
		}
		public ReplaceStatementContext replaceStatement() {
			return GetRuleContext<ReplaceStatementContext>(0);
		}
		public UpdateStatementContext updateStatement() {
			return GetRuleContext<UpdateStatementContext>(0);
		}
		public DescribeStatementsContext(DescribeObjectClauseContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDescribeStatements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDescribeStatements(this);
		}
	}
	public partial class DescribeConnectionContext : DescribeObjectClauseContext {
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode CONNECTION() { return GetToken(MySqlParser.CONNECTION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DescribeConnectionContext(DescribeObjectClauseContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDescribeConnection(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDescribeConnection(this);
		}
	}

	[RuleVersion(0)]
	public DescribeObjectClauseContext describeObjectClause() {
		DescribeObjectClauseContext _localctx = new DescribeObjectClauseContext(Context, State);
		EnterRule(_localctx, 484, RULE_describeObjectClause);
		try {
			State = 5226;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DELETE:
			case INSERT:
			case REPLACE:
			case SELECT:
			case UPDATE:
			case LR_BRACKET:
				_localctx = new DescribeStatementsContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 5221;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case SELECT:
				case LR_BRACKET:
					{
					State = 5216; selectStatement();
					}
					break;
				case DELETE:
					{
					State = 5217; deleteStatement();
					}
					break;
				case INSERT:
					{
					State = 5218; insertStatement();
					}
					break;
				case REPLACE:
					{
					State = 5219; replaceStatement();
					}
					break;
				case UPDATE:
					{
					State = 5220; updateStatement();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case FOR:
				_localctx = new DescribeConnectionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 5223; Match(FOR);
				State = 5224; Match(CONNECTION);
				State = 5225; uid();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullIdContext : ParserRuleContext {
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode DOT_ID() { return GetToken(MySqlParser.DOT_ID, 0); }
		public FullIdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullId; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFullId(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFullId(this);
		}
	}

	[RuleVersion(0)]
	public FullIdContext fullId() {
		FullIdContext _localctx = new FullIdContext(Context, State);
		EnterRule(_localctx, 486, RULE_fullId);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5228; uid();
			State = 5232;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,755,Context) ) {
			case 1:
				{
				State = 5229; Match(DOT_ID);
				}
				break;
			case 2:
				{
				State = 5230; Match(DOT);
				State = 5231; uid();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableNameContext : ParserRuleContext {
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public TableNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableName(this);
		}
	}

	[RuleVersion(0)]
	public TableNameContext tableName() {
		TableNameContext _localctx = new TableNameContext(Context, State);
		EnterRule(_localctx, 488, RULE_tableName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5234; fullId();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullColumnNameContext : ParserRuleContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DottedIdContext[] dottedId() {
			return GetRuleContexts<DottedIdContext>();
		}
		public DottedIdContext dottedId(int i) {
			return GetRuleContext<DottedIdContext>(i);
		}
		public FullColumnNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullColumnName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFullColumnName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFullColumnName(this);
		}
	}

	[RuleVersion(0)]
	public FullColumnNameContext fullColumnName() {
		FullColumnNameContext _localctx = new FullColumnNameContext(Context, State);
		EnterRule(_localctx, 490, RULE_fullColumnName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5236; uid();
			State = 5241;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,757,Context) ) {
			case 1:
				{
				State = 5237; dottedId();
				State = 5239;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,756,Context) ) {
				case 1:
					{
					State = 5238; dottedId();
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexColumnNameContext : ParserRuleContext {
		public IToken sortType;
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode ASC() { return GetToken(MySqlParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(MySqlParser.DESC, 0); }
		public IndexColumnNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexColumnName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexColumnName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexColumnName(this);
		}
	}

	[RuleVersion(0)]
	public IndexColumnNameContext indexColumnName() {
		IndexColumnNameContext _localctx = new IndexColumnNameContext(Context, State);
		EnterRule(_localctx, 492, RULE_indexColumnName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5245;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,758,Context) ) {
			case 1:
				{
				State = 5243; uid();
				}
				break;
			case 2:
				{
				State = 5244; Match(STRING_LITERAL);
				}
				break;
			}
			State = 5251;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LR_BRACKET) {
				{
				State = 5247; Match(LR_BRACKET);
				State = 5248; decimalLiteral();
				State = 5249; Match(RR_BRACKET);
				}
			}

			State = 5254;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASC || _la==DESC) {
				{
				State = 5253;
				_localctx.sortType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ASC || _la==DESC) ) {
					_localctx.sortType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserNameContext : ParserRuleContext {
		public ITerminalNode STRING_USER_NAME() { return GetToken(MySqlParser.STRING_USER_NAME, 0); }
		public ITerminalNode ID() { return GetToken(MySqlParser.ID, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public UserNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserName(this);
		}
	}

	[RuleVersion(0)]
	public UserNameContext userName() {
		UserNameContext _localctx = new UserNameContext(Context, State);
		EnterRule(_localctx, 494, RULE_userName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5256;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 974)) & ~0x3f) == 0 && ((1L << (_la - 974)) & ((1L << (STRING_LITERAL - 974)) | (1L << (ID - 974)) | (1L << (STRING_USER_NAME - 974)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MysqlVariableContext : ParserRuleContext {
		public ITerminalNode LOCAL_ID() { return GetToken(MySqlParser.LOCAL_ID, 0); }
		public ITerminalNode GLOBAL_ID() { return GetToken(MySqlParser.GLOBAL_ID, 0); }
		public MysqlVariableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mysqlVariable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMysqlVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMysqlVariable(this);
		}
	}

	[RuleVersion(0)]
	public MysqlVariableContext mysqlVariable() {
		MysqlVariableContext _localctx = new MysqlVariableContext(Context, State);
		EnterRule(_localctx, 496, RULE_mysqlVariable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5258;
			_la = TokenStream.LA(1);
			if ( !(_la==LOCAL_ID || _la==GLOBAL_ID) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CharsetNameContext : ParserRuleContext {
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public CharsetNameBaseContext charsetNameBase() {
			return GetRuleContext<CharsetNameBaseContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode CHARSET_REVERSE_QOUTE_STRING() { return GetToken(MySqlParser.CHARSET_REVERSE_QOUTE_STRING, 0); }
		public CharsetNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_charsetName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCharsetName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCharsetName(this);
		}
	}

	[RuleVersion(0)]
	public CharsetNameContext charsetName() {
		CharsetNameContext _localctx = new CharsetNameContext(Context, State);
		EnterRule(_localctx, 498, RULE_charsetName);
		try {
			State = 5264;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BINARY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5260; Match(BINARY);
				}
				break;
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5261; charsetNameBase();
				}
				break;
			case STRING_LITERAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5262; Match(STRING_LITERAL);
				}
				break;
			case CHARSET_REVERSE_QOUTE_STRING:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5263; Match(CHARSET_REVERSE_QOUTE_STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollationNameContext : ParserRuleContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public CollationNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collationName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCollationName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCollationName(this);
		}
	}

	[RuleVersion(0)]
	public CollationNameContext collationName() {
		CollationNameContext _localctx = new CollationNameContext(Context, State);
		EnterRule(_localctx, 500, RULE_collationName);
		try {
			State = 5268;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,762,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5266; uid();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5267; Match(STRING_LITERAL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EngineNameContext : ParserRuleContext {
		public ITerminalNode ARCHIVE() { return GetToken(MySqlParser.ARCHIVE, 0); }
		public ITerminalNode BLACKHOLE() { return GetToken(MySqlParser.BLACKHOLE, 0); }
		public ITerminalNode CSV() { return GetToken(MySqlParser.CSV, 0); }
		public ITerminalNode FEDERATED() { return GetToken(MySqlParser.FEDERATED, 0); }
		public ITerminalNode INNODB() { return GetToken(MySqlParser.INNODB, 0); }
		public ITerminalNode MEMORY() { return GetToken(MySqlParser.MEMORY, 0); }
		public ITerminalNode MRG_MYISAM() { return GetToken(MySqlParser.MRG_MYISAM, 0); }
		public ITerminalNode MYISAM() { return GetToken(MySqlParser.MYISAM, 0); }
		public ITerminalNode NDB() { return GetToken(MySqlParser.NDB, 0); }
		public ITerminalNode NDBCLUSTER() { return GetToken(MySqlParser.NDBCLUSTER, 0); }
		public ITerminalNode PERFORMANCE_SCHEMA() { return GetToken(MySqlParser.PERFORMANCE_SCHEMA, 0); }
		public ITerminalNode TOKUDB() { return GetToken(MySqlParser.TOKUDB, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode REVERSE_QUOTE_ID() { return GetToken(MySqlParser.REVERSE_QUOTE_ID, 0); }
		public EngineNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_engineName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterEngineName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitEngineName(this);
		}
	}

	[RuleVersion(0)]
	public EngineNameContext engineName() {
		EngineNameContext _localctx = new EngineNameContext(Context, State);
		EnterRule(_localctx, 502, RULE_engineName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5270;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 618)) & ~0x3f) == 0 && ((1L << (_la - 618)) & ((1L << (ARCHIVE - 618)) | (1L << (BLACKHOLE - 618)) | (1L << (CSV - 618)) | (1L << (FEDERATED - 618)) | (1L << (INNODB - 618)) | (1L << (MEMORY - 618)) | (1L << (MRG_MYISAM - 618)) | (1L << (MYISAM - 618)) | (1L << (NDB - 618)) | (1L << (NDBCLUSTER - 618)) | (1L << (PERFORMANCE_SCHEMA - 618)) | (1L << (TOKUDB - 618)))) != 0) || _la==STRING_LITERAL || _la==REVERSE_QUOTE_ID) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UuidSetContext : ParserRuleContext {
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public UuidSetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uuidSet; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUuidSet(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUuidSet(this);
		}
	}

	[RuleVersion(0)]
	public UuidSetContext uuidSet() {
		UuidSetContext _localctx = new UuidSetContext(Context, State);
		EnterRule(_localctx, 504, RULE_uuidSet);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5272; decimalLiteral();
			State = 5273; Match(MINUS);
			State = 5274; decimalLiteral();
			State = 5275; Match(MINUS);
			State = 5276; decimalLiteral();
			State = 5277; Match(MINUS);
			State = 5278; decimalLiteral();
			State = 5279; Match(MINUS);
			State = 5280; decimalLiteral();
			State = 5286;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 5281; Match(COLON_SYMB);
				State = 5282; decimalLiteral();
				State = 5283; Match(MINUS);
				State = 5284; decimalLiteral();
				}
				}
				State = 5288;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COLON_SYMB );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XidContext : ParserRuleContext {
		public XuidStringIdContext globalTableUid;
		public XuidStringIdContext qualifier;
		public DecimalLiteralContext idFormat;
		public XuidStringIdContext[] xuidStringId() {
			return GetRuleContexts<XuidStringIdContext>();
		}
		public XuidStringIdContext xuidStringId(int i) {
			return GetRuleContext<XuidStringIdContext>(i);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public XidContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xid; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXid(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXid(this);
		}
	}

	[RuleVersion(0)]
	public XidContext xid() {
		XidContext _localctx = new XidContext(Context, State);
		EnterRule(_localctx, 506, RULE_xid);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5290; _localctx.globalTableUid = xuidStringId();
			State = 5297;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 5291; Match(COMMA);
				State = 5292; _localctx.qualifier = xuidStringId();
				State = 5295;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 5293; Match(COMMA);
					State = 5294; _localctx.idFormat = decimalLiteral();
					}
				}

				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XuidStringIdContext : ParserRuleContext {
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode BIT_STRING() { return GetToken(MySqlParser.BIT_STRING, 0); }
		public ITerminalNode[] HEXADECIMAL_LITERAL() { return GetTokens(MySqlParser.HEXADECIMAL_LITERAL); }
		public ITerminalNode HEXADECIMAL_LITERAL(int i) {
			return GetToken(MySqlParser.HEXADECIMAL_LITERAL, i);
		}
		public XuidStringIdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xuidStringId; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXuidStringId(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXuidStringId(this);
		}
	}

	[RuleVersion(0)]
	public XuidStringIdContext xuidStringId() {
		XuidStringIdContext _localctx = new XuidStringIdContext(Context, State);
		EnterRule(_localctx, 508, RULE_xuidStringId);
		int _la;
		try {
			State = 5306;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STRING_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5299; Match(STRING_LITERAL);
				}
				break;
			case BIT_STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5300; Match(BIT_STRING);
				}
				break;
			case HEXADECIMAL_LITERAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5302;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 5301; Match(HEXADECIMAL_LITERAL);
					}
					}
					State = 5304;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==HEXADECIMAL_LITERAL );
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AuthPluginContext : ParserRuleContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public AuthPluginContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_authPlugin; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAuthPlugin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAuthPlugin(this);
		}
	}

	[RuleVersion(0)]
	public AuthPluginContext authPlugin() {
		AuthPluginContext _localctx = new AuthPluginContext(Context, State);
		EnterRule(_localctx, 510, RULE_authPlugin);
		try {
			State = 5310;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,768,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5308; uid();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5309; Match(STRING_LITERAL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UidContext : ParserRuleContext {
		public SimpleIdContext simpleId() {
			return GetRuleContext<SimpleIdContext>(0);
		}
		public ITerminalNode REVERSE_QUOTE_ID() { return GetToken(MySqlParser.REVERSE_QUOTE_ID, 0); }
		public ITerminalNode CHARSET_REVERSE_QOUTE_STRING() { return GetToken(MySqlParser.CHARSET_REVERSE_QOUTE_STRING, 0); }
		public UidContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uid; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUid(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUid(this);
		}
	}

	[RuleVersion(0)]
	public UidContext uid() {
		UidContext _localctx = new UidContext(Context, State);
		EnterRule(_localctx, 512, RULE_uid);
		try {
			State = 5315;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,769,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5312; simpleId();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5313; Match(REVERSE_QUOTE_ID);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5314; Match(CHARSET_REVERSE_QOUTE_STRING);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleIdContext : ParserRuleContext {
		public ITerminalNode ID() { return GetToken(MySqlParser.ID, 0); }
		public CharsetNameBaseContext charsetNameBase() {
			return GetRuleContext<CharsetNameBaseContext>(0);
		}
		public TransactionLevelBaseContext transactionLevelBase() {
			return GetRuleContext<TransactionLevelBaseContext>(0);
		}
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public PrivilegesBaseContext privilegesBase() {
			return GetRuleContext<PrivilegesBaseContext>(0);
		}
		public IntervalTypeBaseContext intervalTypeBase() {
			return GetRuleContext<IntervalTypeBaseContext>(0);
		}
		public DataTypeBaseContext dataTypeBase() {
			return GetRuleContext<DataTypeBaseContext>(0);
		}
		public KeywordsCanBeIdContext keywordsCanBeId() {
			return GetRuleContext<KeywordsCanBeIdContext>(0);
		}
		public FunctionNameBaseContext functionNameBase() {
			return GetRuleContext<FunctionNameBaseContext>(0);
		}
		public SimpleIdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleId; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleId(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleId(this);
		}
	}

	[RuleVersion(0)]
	public SimpleIdContext simpleId() {
		SimpleIdContext _localctx = new SimpleIdContext(Context, State);
		EnterRule(_localctx, 514, RULE_simpleId);
		try {
			State = 5326;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,770,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5317; Match(ID);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5318; charsetNameBase();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5319; transactionLevelBase();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5320; engineName();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5321; privilegesBase();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5322; intervalTypeBase();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5323; dataTypeBase();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5324; keywordsCanBeId();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5325; functionNameBase();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DottedIdContext : ParserRuleContext {
		public ITerminalNode DOT_ID() { return GetToken(MySqlParser.DOT_ID, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DottedIdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dottedId; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDottedId(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDottedId(this);
		}
	}

	[RuleVersion(0)]
	public DottedIdContext dottedId() {
		DottedIdContext _localctx = new DottedIdContext(Context, State);
		EnterRule(_localctx, 516, RULE_dottedId);
		try {
			State = 5331;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DOT_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5328; Match(DOT_ID);
				}
				break;
			case DOT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5329; Match(DOT);
				State = 5330; uid();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DecimalLiteralContext : ParserRuleContext {
		public ITerminalNode DECIMAL_LITERAL() { return GetToken(MySqlParser.DECIMAL_LITERAL, 0); }
		public ITerminalNode ZERO_DECIMAL() { return GetToken(MySqlParser.ZERO_DECIMAL, 0); }
		public ITerminalNode ONE_DECIMAL() { return GetToken(MySqlParser.ONE_DECIMAL, 0); }
		public ITerminalNode TWO_DECIMAL() { return GetToken(MySqlParser.TWO_DECIMAL, 0); }
		public DecimalLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_decimalLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDecimalLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDecimalLiteral(this);
		}
	}

	[RuleVersion(0)]
	public DecimalLiteralContext decimalLiteral() {
		DecimalLiteralContext _localctx = new DecimalLiteralContext(Context, State);
		EnterRule(_localctx, 518, RULE_decimalLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5333;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 964)) & ~0x3f) == 0 && ((1L << (_la - 964)) & ((1L << (ZERO_DECIMAL - 964)) | (1L << (ONE_DECIMAL - 964)) | (1L << (TWO_DECIMAL - 964)) | (1L << (DECIMAL_LITERAL - 964)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FileSizeLiteralContext : ParserRuleContext {
		public ITerminalNode FILESIZE_LITERAL() { return GetToken(MySqlParser.FILESIZE_LITERAL, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public FileSizeLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fileSizeLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFileSizeLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFileSizeLiteral(this);
		}
	}

	[RuleVersion(0)]
	public FileSizeLiteralContext fileSizeLiteral() {
		FileSizeLiteralContext _localctx = new FileSizeLiteralContext(Context, State);
		EnterRule(_localctx, 520, RULE_fileSizeLiteral);
		try {
			State = 5337;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FILESIZE_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5335; Match(FILESIZE_LITERAL);
				}
				break;
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case DECIMAL_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5336; decimalLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringLiteralContext : ParserRuleContext {
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(MySqlParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(MySqlParser.STRING_LITERAL, i);
		}
		public ITerminalNode START_NATIONAL_STRING_LITERAL() { return GetToken(MySqlParser.START_NATIONAL_STRING_LITERAL, 0); }
		public ITerminalNode STRING_CHARSET_NAME() { return GetToken(MySqlParser.STRING_CHARSET_NAME, 0); }
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public StringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStringLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStringLiteral(this);
		}
	}

	[RuleVersion(0)]
	public StringLiteralContext stringLiteral() {
		StringLiteralContext _localctx = new StringLiteralContext(Context, State);
		EnterRule(_localctx, 522, RULE_stringLiteral);
		int _la;
		try {
			int _alt;
			State = 5362;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,779,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5344;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case STRING_LITERAL:
				case STRING_CHARSET_NAME:
					{
					State = 5340;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==STRING_CHARSET_NAME) {
						{
						State = 5339; Match(STRING_CHARSET_NAME);
						}
					}

					State = 5342; Match(STRING_LITERAL);
					}
					break;
				case START_NATIONAL_STRING_LITERAL:
					{
					State = 5343; Match(START_NATIONAL_STRING_LITERAL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5347;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 5346; Match(STRING_LITERAL);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5349;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,775,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5356;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case STRING_LITERAL:
				case STRING_CHARSET_NAME:
					{
					State = 5352;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==STRING_CHARSET_NAME) {
						{
						State = 5351; Match(STRING_CHARSET_NAME);
						}
					}

					State = 5354; Match(STRING_LITERAL);
					}
					break;
				case START_NATIONAL_STRING_LITERAL:
					{
					State = 5355; Match(START_NATIONAL_STRING_LITERAL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5360;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,778,Context) ) {
				case 1:
					{
					State = 5358; Match(COLLATE);
					State = 5359; collationName();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanLiteralContext : ParserRuleContext {
		public ITerminalNode TRUE() { return GetToken(MySqlParser.TRUE, 0); }
		public ITerminalNode FALSE() { return GetToken(MySqlParser.FALSE, 0); }
		public BooleanLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booleanLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBooleanLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBooleanLiteral(this);
		}
	}

	[RuleVersion(0)]
	public BooleanLiteralContext booleanLiteral() {
		BooleanLiteralContext _localctx = new BooleanLiteralContext(Context, State);
		EnterRule(_localctx, 524, RULE_booleanLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5364;
			_la = TokenStream.LA(1);
			if ( !(_la==FALSE || _la==TRUE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HexadecimalLiteralContext : ParserRuleContext {
		public ITerminalNode HEXADECIMAL_LITERAL() { return GetToken(MySqlParser.HEXADECIMAL_LITERAL, 0); }
		public ITerminalNode STRING_CHARSET_NAME() { return GetToken(MySqlParser.STRING_CHARSET_NAME, 0); }
		public HexadecimalLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hexadecimalLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHexadecimalLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHexadecimalLiteral(this);
		}
	}

	[RuleVersion(0)]
	public HexadecimalLiteralContext hexadecimalLiteral() {
		HexadecimalLiteralContext _localctx = new HexadecimalLiteralContext(Context, State);
		EnterRule(_localctx, 526, RULE_hexadecimalLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5367;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STRING_CHARSET_NAME) {
				{
				State = 5366; Match(STRING_CHARSET_NAME);
				}
			}

			State = 5369; Match(HEXADECIMAL_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NullNotnullContext : ParserRuleContext {
		public ITerminalNode NULL_LITERAL() { return GetToken(MySqlParser.NULL_LITERAL, 0); }
		public ITerminalNode NULL_SPEC_LITERAL() { return GetToken(MySqlParser.NULL_SPEC_LITERAL, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public NullNotnullContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nullNotnull; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNullNotnull(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNullNotnull(this);
		}
	}

	[RuleVersion(0)]
	public NullNotnullContext nullNotnull() {
		NullNotnullContext _localctx = new NullNotnullContext(Context, State);
		EnterRule(_localctx, 528, RULE_nullNotnull);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5372;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 5371; Match(NOT);
				}
			}

			State = 5374;
			_la = TokenStream.LA(1);
			if ( !(_la==NULL_LITERAL || _la==NULL_SPEC_LITERAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public IToken nullLiteral;
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public HexadecimalLiteralContext hexadecimalLiteral() {
			return GetRuleContext<HexadecimalLiteralContext>(0);
		}
		public BooleanLiteralContext booleanLiteral() {
			return GetRuleContext<BooleanLiteralContext>(0);
		}
		public ITerminalNode REAL_LITERAL() { return GetToken(MySqlParser.REAL_LITERAL, 0); }
		public ITerminalNode BIT_STRING() { return GetToken(MySqlParser.BIT_STRING, 0); }
		public ITerminalNode NULL_LITERAL() { return GetToken(MySqlParser.NULL_LITERAL, 0); }
		public ITerminalNode NULL_SPEC_LITERAL() { return GetToken(MySqlParser.NULL_SPEC_LITERAL, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(Context, State);
		EnterRule(_localctx, 530, RULE_constant);
		int _la;
		try {
			State = 5388;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,783,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5376; stringLiteral();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5377; decimalLiteral();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5378; Match(MINUS);
				State = 5379; decimalLiteral();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5380; hexadecimalLiteral();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5381; booleanLiteral();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5382; Match(REAL_LITERAL);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5383; Match(BIT_STRING);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5385;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 5384; Match(NOT);
					}
				}

				State = 5387;
				_localctx.nullLiteral = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==NULL_LITERAL || _la==NULL_SPEC_LITERAL) ) {
					_localctx.nullLiteral = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DataTypeContext : ParserRuleContext {
		public DataTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dataType; } }
	 
		public DataTypeContext() { }
		public virtual void CopyFrom(DataTypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SpatialDataTypeContext : DataTypeContext {
		public IToken typeName;
		public ITerminalNode GEOMETRYCOLLECTION() { return GetToken(MySqlParser.GEOMETRYCOLLECTION, 0); }
		public ITerminalNode GEOMCOLLECTION() { return GetToken(MySqlParser.GEOMCOLLECTION, 0); }
		public ITerminalNode LINESTRING() { return GetToken(MySqlParser.LINESTRING, 0); }
		public ITerminalNode MULTILINESTRING() { return GetToken(MySqlParser.MULTILINESTRING, 0); }
		public ITerminalNode MULTIPOINT() { return GetToken(MySqlParser.MULTIPOINT, 0); }
		public ITerminalNode MULTIPOLYGON() { return GetToken(MySqlParser.MULTIPOLYGON, 0); }
		public ITerminalNode POINT() { return GetToken(MySqlParser.POINT, 0); }
		public ITerminalNode POLYGON() { return GetToken(MySqlParser.POLYGON, 0); }
		public ITerminalNode JSON() { return GetToken(MySqlParser.JSON, 0); }
		public ITerminalNode GEOMETRY() { return GetToken(MySqlParser.GEOMETRY, 0); }
		public SpatialDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSpatialDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSpatialDataType(this);
		}
	}
	public partial class CollectionDataTypeContext : DataTypeContext {
		public IToken typeName;
		public CollectionOptionsContext collectionOptions() {
			return GetRuleContext<CollectionOptionsContext>(0);
		}
		public ITerminalNode ENUM() { return GetToken(MySqlParser.ENUM, 0); }
		public ITerminalNode[] SET() { return GetTokens(MySqlParser.SET); }
		public ITerminalNode SET(int i) {
			return GetToken(MySqlParser.SET, i);
		}
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public CollectionDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCollectionDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCollectionDataType(this);
		}
	}
	public partial class NationalVaryingStringDataTypeContext : DataTypeContext {
		public IToken typeName;
		public ITerminalNode NATIONAL() { return GetToken(MySqlParser.NATIONAL, 0); }
		public ITerminalNode VARYING() { return GetToken(MySqlParser.VARYING, 0); }
		public ITerminalNode CHAR() { return GetToken(MySqlParser.CHAR, 0); }
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public LengthOneDimensionContext lengthOneDimension() {
			return GetRuleContext<LengthOneDimensionContext>(0);
		}
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public NationalVaryingStringDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNationalVaryingStringDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNationalVaryingStringDataType(this);
		}
	}
	public partial class DimensionDataTypeContext : DataTypeContext {
		public IToken typeName;
		public ITerminalNode TINYINT() { return GetToken(MySqlParser.TINYINT, 0); }
		public ITerminalNode SMALLINT() { return GetToken(MySqlParser.SMALLINT, 0); }
		public ITerminalNode MEDIUMINT() { return GetToken(MySqlParser.MEDIUMINT, 0); }
		public ITerminalNode INT() { return GetToken(MySqlParser.INT, 0); }
		public ITerminalNode INTEGER() { return GetToken(MySqlParser.INTEGER, 0); }
		public ITerminalNode BIGINT() { return GetToken(MySqlParser.BIGINT, 0); }
		public LengthOneDimensionContext lengthOneDimension() {
			return GetRuleContext<LengthOneDimensionContext>(0);
		}
		public ITerminalNode ZEROFILL() { return GetToken(MySqlParser.ZEROFILL, 0); }
		public ITerminalNode SIGNED() { return GetToken(MySqlParser.SIGNED, 0); }
		public ITerminalNode UNSIGNED() { return GetToken(MySqlParser.UNSIGNED, 0); }
		public ITerminalNode REAL() { return GetToken(MySqlParser.REAL, 0); }
		public LengthTwoDimensionContext lengthTwoDimension() {
			return GetRuleContext<LengthTwoDimensionContext>(0);
		}
		public ITerminalNode DOUBLE() { return GetToken(MySqlParser.DOUBLE, 0); }
		public ITerminalNode PRECISION() { return GetToken(MySqlParser.PRECISION, 0); }
		public ITerminalNode DECIMAL() { return GetToken(MySqlParser.DECIMAL, 0); }
		public ITerminalNode DEC() { return GetToken(MySqlParser.DEC, 0); }
		public ITerminalNode FIXED() { return GetToken(MySqlParser.FIXED, 0); }
		public ITerminalNode NUMERIC() { return GetToken(MySqlParser.NUMERIC, 0); }
		public ITerminalNode FLOAT() { return GetToken(MySqlParser.FLOAT, 0); }
		public LengthTwoOptionalDimensionContext lengthTwoOptionalDimension() {
			return GetRuleContext<LengthTwoOptionalDimensionContext>(0);
		}
		public ITerminalNode BIT() { return GetToken(MySqlParser.BIT, 0); }
		public ITerminalNode TIME() { return GetToken(MySqlParser.TIME, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(MySqlParser.TIMESTAMP, 0); }
		public ITerminalNode DATETIME() { return GetToken(MySqlParser.DATETIME, 0); }
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ITerminalNode VARBINARY() { return GetToken(MySqlParser.VARBINARY, 0); }
		public ITerminalNode YEAR() { return GetToken(MySqlParser.YEAR, 0); }
		public DimensionDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDimensionDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDimensionDataType(this);
		}
	}
	public partial class StringDataTypeContext : DataTypeContext {
		public IToken typeName;
		public ITerminalNode CHAR() { return GetToken(MySqlParser.CHAR, 0); }
		public ITerminalNode VARCHAR() { return GetToken(MySqlParser.VARCHAR, 0); }
		public ITerminalNode TINYTEXT() { return GetToken(MySqlParser.TINYTEXT, 0); }
		public ITerminalNode TEXT() { return GetToken(MySqlParser.TEXT, 0); }
		public ITerminalNode MEDIUMTEXT() { return GetToken(MySqlParser.MEDIUMTEXT, 0); }
		public ITerminalNode LONGTEXT() { return GetToken(MySqlParser.LONGTEXT, 0); }
		public ITerminalNode NCHAR() { return GetToken(MySqlParser.NCHAR, 0); }
		public ITerminalNode NVARCHAR() { return GetToken(MySqlParser.NVARCHAR, 0); }
		public LengthOneDimensionContext lengthOneDimension() {
			return GetRuleContext<LengthOneDimensionContext>(0);
		}
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public StringDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStringDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStringDataType(this);
		}
	}
	public partial class NationalStringDataTypeContext : DataTypeContext {
		public IToken typeName;
		public ITerminalNode NATIONAL() { return GetToken(MySqlParser.NATIONAL, 0); }
		public ITerminalNode VARCHAR() { return GetToken(MySqlParser.VARCHAR, 0); }
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public LengthOneDimensionContext lengthOneDimension() {
			return GetRuleContext<LengthOneDimensionContext>(0);
		}
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ITerminalNode NCHAR() { return GetToken(MySqlParser.NCHAR, 0); }
		public NationalStringDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNationalStringDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNationalStringDataType(this);
		}
	}
	public partial class SimpleDataTypeContext : DataTypeContext {
		public IToken typeName;
		public ITerminalNode DATE() { return GetToken(MySqlParser.DATE, 0); }
		public ITerminalNode TINYBLOB() { return GetToken(MySqlParser.TINYBLOB, 0); }
		public ITerminalNode BLOB() { return GetToken(MySqlParser.BLOB, 0); }
		public ITerminalNode MEDIUMBLOB() { return GetToken(MySqlParser.MEDIUMBLOB, 0); }
		public ITerminalNode LONGBLOB() { return GetToken(MySqlParser.LONGBLOB, 0); }
		public ITerminalNode BOOL() { return GetToken(MySqlParser.BOOL, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(MySqlParser.BOOLEAN, 0); }
		public ITerminalNode SERIAL() { return GetToken(MySqlParser.SERIAL, 0); }
		public SimpleDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleDataType(this);
		}
	}

	[RuleVersion(0)]
	public DataTypeContext dataType() {
		DataTypeContext _localctx = new DataTypeContext(Context, State);
		EnterRule(_localctx, 532, RULE_dataType);
		int _la;
		try {
			State = 5496;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,812,Context) ) {
			case 1:
				_localctx = new StringDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 5390;
				((StringDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 189)) & ~0x3f) == 0 && ((1L << (_la - 189)) & ((1L << (CHAR - 189)) | (1L << (VARCHAR - 189)) | (1L << (NVARCHAR - 189)) | (1L << (TINYTEXT - 189)) | (1L << (TEXT - 189)) | (1L << (MEDIUMTEXT - 189)) | (1L << (LONGTEXT - 189)))) != 0) || _la==NCHAR) ) {
					((StringDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5392;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,784,Context) ) {
				case 1:
					{
					State = 5391; lengthOneDimension();
					}
					break;
				}
				State = 5395;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BINARY) {
					{
					State = 5394; Match(BINARY);
					}
				}

				State = 5403;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,787,Context) ) {
				case 1:
					{
					State = 5400;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case CHARACTER:
						{
						State = 5397; Match(CHARACTER);
						State = 5398; Match(SET);
						}
						break;
					case CHARSET:
						{
						State = 5399; Match(CHARSET);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5402; charsetName();
					}
					break;
				}
				State = 5407;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,788,Context) ) {
				case 1:
					{
					State = 5405; Match(COLLATE);
					State = 5406; collationName();
					}
					break;
				}
				}
				break;
			case 2:
				_localctx = new NationalStringDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 5409; Match(NATIONAL);
				State = 5410;
				((NationalStringDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==CHARACTER || _la==VARCHAR) ) {
					((NationalStringDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5412;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,789,Context) ) {
				case 1:
					{
					State = 5411; lengthOneDimension();
					}
					break;
				}
				State = 5415;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BINARY) {
					{
					State = 5414; Match(BINARY);
					}
				}

				}
				break;
			case 3:
				_localctx = new NationalStringDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 5417; Match(NCHAR);
				State = 5418; ((NationalStringDataTypeContext)_localctx).typeName = Match(VARCHAR);
				State = 5420;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,791,Context) ) {
				case 1:
					{
					State = 5419; lengthOneDimension();
					}
					break;
				}
				State = 5423;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BINARY) {
					{
					State = 5422; Match(BINARY);
					}
				}

				}
				break;
			case 4:
				_localctx = new NationalVaryingStringDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 5425; Match(NATIONAL);
				State = 5426;
				((NationalVaryingStringDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==CHARACTER || _la==CHAR) ) {
					((NationalVaryingStringDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5427; Match(VARYING);
				State = 5429;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,793,Context) ) {
				case 1:
					{
					State = 5428; lengthOneDimension();
					}
					break;
				}
				State = 5432;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BINARY) {
					{
					State = 5431; Match(BINARY);
					}
				}

				}
				break;
			case 5:
				_localctx = new DimensionDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 5434;
				((DimensionDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 171)) & ~0x3f) == 0 && ((1L << (_la - 171)) & ((1L << (TINYINT - 171)) | (1L << (SMALLINT - 171)) | (1L << (MEDIUMINT - 171)) | (1L << (INT - 171)) | (1L << (INTEGER - 171)) | (1L << (BIGINT - 171)))) != 0)) ) {
					((DimensionDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5436;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,795,Context) ) {
				case 1:
					{
					State = 5435; lengthOneDimension();
					}
					break;
				}
				State = 5439;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,796,Context) ) {
				case 1:
					{
					State = 5438;
					_la = TokenStream.LA(1);
					if ( !(_la==UNSIGNED || _la==SIGNED) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 5442;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ZEROFILL) {
					{
					State = 5441; Match(ZEROFILL);
					}
				}

				}
				break;
			case 6:
				_localctx = new DimensionDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 5444; ((DimensionDataTypeContext)_localctx).typeName = Match(REAL);
				State = 5446;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,798,Context) ) {
				case 1:
					{
					State = 5445; lengthTwoDimension();
					}
					break;
				}
				State = 5449;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,799,Context) ) {
				case 1:
					{
					State = 5448;
					_la = TokenStream.LA(1);
					if ( !(_la==UNSIGNED || _la==SIGNED) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 5452;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ZEROFILL) {
					{
					State = 5451; Match(ZEROFILL);
					}
				}

				}
				break;
			case 7:
				_localctx = new DimensionDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 5454; ((DimensionDataTypeContext)_localctx).typeName = Match(DOUBLE);
				State = 5456;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PRECISION) {
					{
					State = 5455; Match(PRECISION);
					}
				}

				State = 5459;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,802,Context) ) {
				case 1:
					{
					State = 5458; lengthTwoDimension();
					}
					break;
				}
				State = 5462;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,803,Context) ) {
				case 1:
					{
					State = 5461;
					_la = TokenStream.LA(1);
					if ( !(_la==UNSIGNED || _la==SIGNED) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 5465;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ZEROFILL) {
					{
					State = 5464; Match(ZEROFILL);
					}
				}

				}
				break;
			case 8:
				_localctx = new DimensionDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 5467;
				((DimensionDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 180)) & ~0x3f) == 0 && ((1L << (_la - 180)) & ((1L << (FLOAT - 180)) | (1L << (DECIMAL - 180)) | (1L << (DEC - 180)) | (1L << (NUMERIC - 180)))) != 0) || _la==FIXED) ) {
					((DimensionDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5469;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,805,Context) ) {
				case 1:
					{
					State = 5468; lengthTwoOptionalDimension();
					}
					break;
				}
				State = 5472;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,806,Context) ) {
				case 1:
					{
					State = 5471;
					_la = TokenStream.LA(1);
					if ( !(_la==UNSIGNED || _la==SIGNED) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 5475;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ZEROFILL) {
					{
					State = 5474; Match(ZEROFILL);
					}
				}

				}
				break;
			case 9:
				_localctx = new SimpleDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 5477;
				((SimpleDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TINYBLOB - 184)) | (1L << (BLOB - 184)) | (1L << (MEDIUMBLOB - 184)) | (1L << (LONGBLOB - 184)) | (1L << (SERIAL - 184)))) != 0) || _la==BOOL || _la==BOOLEAN) ) {
					((SimpleDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 10:
				_localctx = new DimensionDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 5478;
				((DimensionDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (BINARY - 185)) | (1L << (VARBINARY - 185)))) != 0) || _la==BIT) ) {
					((DimensionDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5480;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,808,Context) ) {
				case 1:
					{
					State = 5479; lengthOneDimension();
					}
					break;
				}
				}
				break;
			case 11:
				_localctx = new CollectionDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 5482;
				((CollectionDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==SET || _la==ENUM) ) {
					((CollectionDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5483; collectionOptions();
				State = 5485;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BINARY) {
					{
					State = 5484; Match(BINARY);
					}
				}

				State = 5493;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,811,Context) ) {
				case 1:
					{
					State = 5490;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case CHARACTER:
						{
						State = 5487; Match(CHARACTER);
						State = 5488; Match(SET);
						}
						break;
					case CHARSET:
						{
						State = 5489; Match(CHARSET);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5492; charsetName();
					}
					break;
				}
				}
				break;
			case 12:
				_localctx = new SpatialDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 5495;
				((SpatialDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==JSON || ((((_la - 634)) & ~0x3f) == 0 && ((1L << (_la - 634)) & ((1L << (GEOMETRYCOLLECTION - 634)) | (1L << (GEOMCOLLECTION - 634)) | (1L << (GEOMETRY - 634)) | (1L << (LINESTRING - 634)) | (1L << (MULTILINESTRING - 634)) | (1L << (MULTIPOINT - 634)) | (1L << (MULTIPOLYGON - 634)) | (1L << (POINT - 634)) | (1L << (POLYGON - 634)))) != 0)) ) {
					((SpatialDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionOptionsContext : ParserRuleContext {
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(MySqlParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(MySqlParser.STRING_LITERAL, i);
		}
		public CollectionOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionOptions; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCollectionOptions(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCollectionOptions(this);
		}
	}

	[RuleVersion(0)]
	public CollectionOptionsContext collectionOptions() {
		CollectionOptionsContext _localctx = new CollectionOptionsContext(Context, State);
		EnterRule(_localctx, 534, RULE_collectionOptions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5498; Match(LR_BRACKET);
			State = 5499; Match(STRING_LITERAL);
			State = 5504;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5500; Match(COMMA);
				State = 5501; Match(STRING_LITERAL);
				}
				}
				State = 5506;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5507; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConvertedDataTypeContext : ParserRuleContext {
		public IToken typeName;
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ITerminalNode NCHAR() { return GetToken(MySqlParser.NCHAR, 0); }
		public LengthOneDimensionContext lengthOneDimension() {
			return GetRuleContext<LengthOneDimensionContext>(0);
		}
		public ITerminalNode CHAR() { return GetToken(MySqlParser.CHAR, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public ITerminalNode DATE() { return GetToken(MySqlParser.DATE, 0); }
		public ITerminalNode DATETIME() { return GetToken(MySqlParser.DATETIME, 0); }
		public ITerminalNode TIME() { return GetToken(MySqlParser.TIME, 0); }
		public ITerminalNode DECIMAL() { return GetToken(MySqlParser.DECIMAL, 0); }
		public LengthTwoDimensionContext lengthTwoDimension() {
			return GetRuleContext<LengthTwoDimensionContext>(0);
		}
		public ITerminalNode SIGNED() { return GetToken(MySqlParser.SIGNED, 0); }
		public ITerminalNode UNSIGNED() { return GetToken(MySqlParser.UNSIGNED, 0); }
		public ITerminalNode INTEGER() { return GetToken(MySqlParser.INTEGER, 0); }
		public ConvertedDataTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_convertedDataType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterConvertedDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitConvertedDataType(this);
		}
	}

	[RuleVersion(0)]
	public ConvertedDataTypeContext convertedDataType() {
		ConvertedDataTypeContext _localctx = new ConvertedDataTypeContext(Context, State);
		EnterRule(_localctx, 536, RULE_convertedDataType);
		int _la;
		try {
			State = 5534;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BINARY:
			case NCHAR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5509;
				_localctx.typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==BINARY || _la==NCHAR) ) {
					_localctx.typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5511;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LR_BRACKET) {
					{
					State = 5510; lengthOneDimension();
					}
				}

				}
				break;
			case CHAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5513; _localctx.typeName = Match(CHAR);
				State = 5515;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LR_BRACKET) {
					{
					State = 5514; lengthOneDimension();
					}
				}

				State = 5523;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CHARACTER || _la==CHARSET) {
					{
					State = 5520;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case CHARACTER:
						{
						State = 5517; Match(CHARACTER);
						State = 5518; Match(SET);
						}
						break;
					case CHARSET:
						{
						State = 5519; Match(CHARSET);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5522; charsetName();
					}
				}

				}
				break;
			case DATE:
			case TIME:
			case DATETIME:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5525;
				_localctx.typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (DATETIME - 184)))) != 0)) ) {
					_localctx.typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case DECIMAL:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5526; _localctx.typeName = Match(DECIMAL);
				State = 5528;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LR_BRACKET) {
					{
					State = 5527; lengthTwoDimension();
					}
				}

				}
				break;
			case UNSIGNED:
			case SIGNED:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5530;
				_la = TokenStream.LA(1);
				if ( !(_la==UNSIGNED || _la==SIGNED) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5532;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INTEGER) {
					{
					State = 5531; Match(INTEGER);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LengthOneDimensionContext : ParserRuleContext {
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public LengthOneDimensionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lengthOneDimension; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLengthOneDimension(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLengthOneDimension(this);
		}
	}

	[RuleVersion(0)]
	public LengthOneDimensionContext lengthOneDimension() {
		LengthOneDimensionContext _localctx = new LengthOneDimensionContext(Context, State);
		EnterRule(_localctx, 538, RULE_lengthOneDimension);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5536; Match(LR_BRACKET);
			State = 5537; decimalLiteral();
			State = 5538; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LengthTwoDimensionContext : ParserRuleContext {
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public LengthTwoDimensionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lengthTwoDimension; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLengthTwoDimension(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLengthTwoDimension(this);
		}
	}

	[RuleVersion(0)]
	public LengthTwoDimensionContext lengthTwoDimension() {
		LengthTwoDimensionContext _localctx = new LengthTwoDimensionContext(Context, State);
		EnterRule(_localctx, 540, RULE_lengthTwoDimension);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5540; Match(LR_BRACKET);
			State = 5541; decimalLiteral();
			State = 5542; Match(COMMA);
			State = 5543; decimalLiteral();
			State = 5544; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LengthTwoOptionalDimensionContext : ParserRuleContext {
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public LengthTwoOptionalDimensionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lengthTwoOptionalDimension; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLengthTwoOptionalDimension(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLengthTwoOptionalDimension(this);
		}
	}

	[RuleVersion(0)]
	public LengthTwoOptionalDimensionContext lengthTwoOptionalDimension() {
		LengthTwoOptionalDimensionContext _localctx = new LengthTwoOptionalDimensionContext(Context, State);
		EnterRule(_localctx, 542, RULE_lengthTwoOptionalDimension);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5546; Match(LR_BRACKET);
			State = 5547; decimalLiteral();
			State = 5550;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 5548; Match(COMMA);
				State = 5549; decimalLiteral();
				}
			}

			State = 5552; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UidListContext : ParserRuleContext {
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public UidListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uidList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUidList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUidList(this);
		}
	}

	[RuleVersion(0)]
	public UidListContext uidList() {
		UidListContext _localctx = new UidListContext(Context, State);
		EnterRule(_localctx, 544, RULE_uidList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5554; uid();
			State = 5559;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,822,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 5555; Match(COMMA);
					State = 5556; uid();
					}
					} 
				}
				State = 5561;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,822,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablesContext : ParserRuleContext {
		public TableNameContext[] tableName() {
			return GetRuleContexts<TableNameContext>();
		}
		public TableNameContext tableName(int i) {
			return GetRuleContext<TableNameContext>(i);
		}
		public TablesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tables; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTables(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTables(this);
		}
	}

	[RuleVersion(0)]
	public TablesContext tables() {
		TablesContext _localctx = new TablesContext(Context, State);
		EnterRule(_localctx, 546, RULE_tables);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5562; tableName();
			State = 5567;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,823,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 5563; Match(COMMA);
					State = 5564; tableName();
					}
					} 
				}
				State = 5569;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,823,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexColumnNamesContext : ParserRuleContext {
		public IndexColumnNameContext[] indexColumnName() {
			return GetRuleContexts<IndexColumnNameContext>();
		}
		public IndexColumnNameContext indexColumnName(int i) {
			return GetRuleContext<IndexColumnNameContext>(i);
		}
		public IndexColumnNamesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexColumnNames; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexColumnNames(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexColumnNames(this);
		}
	}

	[RuleVersion(0)]
	public IndexColumnNamesContext indexColumnNames() {
		IndexColumnNamesContext _localctx = new IndexColumnNamesContext(Context, State);
		EnterRule(_localctx, 548, RULE_indexColumnNames);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5570; Match(LR_BRACKET);
			State = 5571; indexColumnName();
			State = 5576;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5572; Match(COMMA);
				State = 5573; indexColumnName();
				}
				}
				State = 5578;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5579; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionsContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ExpressionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressions; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExpressions(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExpressions(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionsContext expressions() {
		ExpressionsContext _localctx = new ExpressionsContext(Context, State);
		EnterRule(_localctx, 550, RULE_expressions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5581; expression(0);
			State = 5586;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5582; Match(COMMA);
				State = 5583; expression(0);
				}
				}
				State = 5588;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionsWithDefaultsContext : ParserRuleContext {
		public ExpressionOrDefaultContext[] expressionOrDefault() {
			return GetRuleContexts<ExpressionOrDefaultContext>();
		}
		public ExpressionOrDefaultContext expressionOrDefault(int i) {
			return GetRuleContext<ExpressionOrDefaultContext>(i);
		}
		public ExpressionsWithDefaultsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionsWithDefaults; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExpressionsWithDefaults(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExpressionsWithDefaults(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionsWithDefaultsContext expressionsWithDefaults() {
		ExpressionsWithDefaultsContext _localctx = new ExpressionsWithDefaultsContext(Context, State);
		EnterRule(_localctx, 552, RULE_expressionsWithDefaults);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5589; expressionOrDefault();
			State = 5594;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5590; Match(COMMA);
				State = 5591; expressionOrDefault();
				}
				}
				State = 5596;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantsContext : ParserRuleContext {
		public ConstantContext[] constant() {
			return GetRuleContexts<ConstantContext>();
		}
		public ConstantContext constant(int i) {
			return GetRuleContext<ConstantContext>(i);
		}
		public ConstantsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constants; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterConstants(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitConstants(this);
		}
	}

	[RuleVersion(0)]
	public ConstantsContext constants() {
		ConstantsContext _localctx = new ConstantsContext(Context, State);
		EnterRule(_localctx, 554, RULE_constants);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5597; constant();
			State = 5602;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5598; Match(COMMA);
				State = 5599; constant();
				}
				}
				State = 5604;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleStringsContext : ParserRuleContext {
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(MySqlParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(MySqlParser.STRING_LITERAL, i);
		}
		public SimpleStringsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleStrings; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleStrings(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleStrings(this);
		}
	}

	[RuleVersion(0)]
	public SimpleStringsContext simpleStrings() {
		SimpleStringsContext _localctx = new SimpleStringsContext(Context, State);
		EnterRule(_localctx, 556, RULE_simpleStrings);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5605; Match(STRING_LITERAL);
			State = 5610;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5606; Match(COMMA);
				State = 5607; Match(STRING_LITERAL);
				}
				}
				State = 5612;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserVariablesContext : ParserRuleContext {
		public ITerminalNode[] LOCAL_ID() { return GetTokens(MySqlParser.LOCAL_ID); }
		public ITerminalNode LOCAL_ID(int i) {
			return GetToken(MySqlParser.LOCAL_ID, i);
		}
		public UserVariablesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userVariables; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserVariables(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserVariables(this);
		}
	}

	[RuleVersion(0)]
	public UserVariablesContext userVariables() {
		UserVariablesContext _localctx = new UserVariablesContext(Context, State);
		EnterRule(_localctx, 558, RULE_userVariables);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5613; Match(LOCAL_ID);
			State = 5618;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5614; Match(COMMA);
				State = 5615; Match(LOCAL_ID);
				}
				}
				State = 5620;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefaultValueContext : ParserRuleContext {
		public ITerminalNode NULL_LITERAL() { return GetToken(MySqlParser.NULL_LITERAL, 0); }
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public UnaryOperatorContext unaryOperator() {
			return GetRuleContext<UnaryOperatorContext>(0);
		}
		public CurrentTimestampContext[] currentTimestamp() {
			return GetRuleContexts<CurrentTimestampContext>();
		}
		public CurrentTimestampContext currentTimestamp(int i) {
			return GetRuleContext<CurrentTimestampContext>(i);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public DefaultValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defaultValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDefaultValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDefaultValue(this);
		}
	}

	[RuleVersion(0)]
	public DefaultValueContext defaultValue() {
		DefaultValueContext _localctx = new DefaultValueContext(Context, State);
		EnterRule(_localctx, 560, RULE_defaultValue);
		try {
			State = 5632;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,832,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5621; Match(NULL_LITERAL);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5623;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,830,Context) ) {
				case 1:
					{
					State = 5622; unaryOperator();
					}
					break;
				}
				State = 5625; constant();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5626; currentTimestamp();
				State = 5630;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,831,Context) ) {
				case 1:
					{
					State = 5627; Match(ON);
					State = 5628; Match(UPDATE);
					State = 5629; currentTimestamp();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CurrentTimestampContext : ParserRuleContext {
		public ITerminalNode NOW() { return GetToken(MySqlParser.NOW, 0); }
		public ITerminalNode CURRENT_TIMESTAMP() { return GetToken(MySqlParser.CURRENT_TIMESTAMP, 0); }
		public ITerminalNode LOCALTIME() { return GetToken(MySqlParser.LOCALTIME, 0); }
		public ITerminalNode LOCALTIMESTAMP() { return GetToken(MySqlParser.LOCALTIMESTAMP, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public CurrentTimestampContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_currentTimestamp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCurrentTimestamp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCurrentTimestamp(this);
		}
	}

	[RuleVersion(0)]
	public CurrentTimestampContext currentTimestamp() {
		CurrentTimestampContext _localctx = new CurrentTimestampContext(Context, State);
		EnterRule(_localctx, 562, RULE_currentTimestamp);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5648;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT_TIMESTAMP:
			case LOCALTIME:
			case LOCALTIMESTAMP:
				{
				State = 5634;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 235)) & ~0x3f) == 0 && ((1L << (_la - 235)) & ((1L << (CURRENT_TIMESTAMP - 235)) | (1L << (LOCALTIME - 235)) | (1L << (LOCALTIMESTAMP - 235)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5640;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,834,Context) ) {
				case 1:
					{
					State = 5635; Match(LR_BRACKET);
					State = 5637;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (((((_la - 964)) & ~0x3f) == 0 && ((1L << (_la - 964)) & ((1L << (ZERO_DECIMAL - 964)) | (1L << (ONE_DECIMAL - 964)) | (1L << (TWO_DECIMAL - 964)) | (1L << (DECIMAL_LITERAL - 964)))) != 0)) {
						{
						State = 5636; decimalLiteral();
						}
					}

					State = 5639; Match(RR_BRACKET);
					}
					break;
				}
				}
				break;
			case NOW:
				{
				State = 5642; Match(NOW);
				State = 5643; Match(LR_BRACKET);
				State = 5645;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 964)) & ~0x3f) == 0 && ((1L << (_la - 964)) & ((1L << (ZERO_DECIMAL - 964)) | (1L << (ONE_DECIMAL - 964)) | (1L << (TWO_DECIMAL - 964)) | (1L << (DECIMAL_LITERAL - 964)))) != 0)) {
					{
					State = 5644; decimalLiteral();
					}
				}

				State = 5647; Match(RR_BRACKET);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionOrDefaultContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ExpressionOrDefaultContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionOrDefault; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExpressionOrDefault(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExpressionOrDefault(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionOrDefaultContext expressionOrDefault() {
		ExpressionOrDefaultContext _localctx = new ExpressionOrDefaultContext(Context, State);
		EnterRule(_localctx, 564, RULE_expressionOrDefault);
		try {
			State = 5652;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CASE:
			case CAST:
			case CONVERT:
			case CURRENT_USER:
			case DATABASE:
			case EXISTS:
			case FALSE:
			case IF:
			case INSERT:
			case INTERVAL:
			case LEFT:
			case NOT:
			case NULL_LITERAL:
			case REPLACE:
			case RIGHT:
			case TRUE:
			case VALUES:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case CHAR:
			case BINARY:
			case TEXT:
			case ENUM:
			case SERIAL:
			case AVG:
			case BIT_AND:
			case BIT_OR:
			case BIT_XOR:
			case COUNT:
			case GROUP_CONCAT:
			case MAX:
			case MIN:
			case STD:
			case STDDEV:
			case STDDEV_POP:
			case STDDEV_SAMP:
			case SUM:
			case VAR_POP:
			case VAR_SAMP:
			case VARIANCE:
			case CURRENT_DATE:
			case CURRENT_TIME:
			case CURRENT_TIMESTAMP:
			case LOCALTIME:
			case CURDATE:
			case CURTIME:
			case DATE_ADD:
			case DATE_SUB:
			case EXTRACT:
			case LOCALTIMESTAMP:
			case NOW:
			case POSITION:
			case SUBSTR:
			case SUBSTRING:
			case SYSDATE:
			case TRIM:
			case UTC_DATE:
			case UTC_TIME:
			case UTC_TIMESTAMP:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case PLUS:
			case MINUS:
			case EXCLAMATION_SYMBOL:
			case BIT_NOT_OP:
			case LR_BRACKET:
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case CHARSET_REVERSE_QOUTE_STRING:
			case START_NATIONAL_STRING_LITERAL:
			case STRING_LITERAL:
			case DECIMAL_LITERAL:
			case HEXADECIMAL_LITERAL:
			case REAL_LITERAL:
			case NULL_SPEC_LITERAL:
			case BIT_STRING:
			case STRING_CHARSET_NAME:
			case ID:
			case REVERSE_QUOTE_ID:
			case LOCAL_ID:
			case GLOBAL_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5650; expression(0);
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5651; Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfExistsContext : ParserRuleContext {
		public ITerminalNode IF() { return GetToken(MySqlParser.IF, 0); }
		public ITerminalNode EXISTS() { return GetToken(MySqlParser.EXISTS, 0); }
		public IfExistsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifExists; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIfExists(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIfExists(this);
		}
	}

	[RuleVersion(0)]
	public IfExistsContext ifExists() {
		IfExistsContext _localctx = new IfExistsContext(Context, State);
		EnterRule(_localctx, 566, RULE_ifExists);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5654; Match(IF);
			State = 5655; Match(EXISTS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfNotExistsContext : ParserRuleContext {
		public ITerminalNode IF() { return GetToken(MySqlParser.IF, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public ITerminalNode EXISTS() { return GetToken(MySqlParser.EXISTS, 0); }
		public IfNotExistsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifNotExists; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIfNotExists(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIfNotExists(this);
		}
	}

	[RuleVersion(0)]
	public IfNotExistsContext ifNotExists() {
		IfNotExistsContext _localctx = new IfNotExistsContext(Context, State);
		EnterRule(_localctx, 568, RULE_ifNotExists);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5657; Match(IF);
			State = 5658; Match(NOT);
			State = 5659; Match(EXISTS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
	 
		public FunctionCallContext() { }
		public virtual void CopyFrom(FunctionCallContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SpecificFunctionCallContext : FunctionCallContext {
		public SpecificFunctionContext specificFunction() {
			return GetRuleContext<SpecificFunctionContext>(0);
		}
		public SpecificFunctionCallContext(FunctionCallContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSpecificFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSpecificFunctionCall(this);
		}
	}
	public partial class PasswordFunctionCallContext : FunctionCallContext {
		public PasswordFunctionClauseContext passwordFunctionClause() {
			return GetRuleContext<PasswordFunctionClauseContext>(0);
		}
		public PasswordFunctionCallContext(FunctionCallContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPasswordFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPasswordFunctionCall(this);
		}
	}
	public partial class UdfFunctionCallContext : FunctionCallContext {
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public FunctionArgsContext functionArgs() {
			return GetRuleContext<FunctionArgsContext>(0);
		}
		public UdfFunctionCallContext(FunctionCallContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUdfFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUdfFunctionCall(this);
		}
	}
	public partial class AggregateFunctionCallContext : FunctionCallContext {
		public AggregateWindowedFunctionContext aggregateWindowedFunction() {
			return GetRuleContext<AggregateWindowedFunctionContext>(0);
		}
		public AggregateFunctionCallContext(FunctionCallContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAggregateFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAggregateFunctionCall(this);
		}
	}
	public partial class ScalarFunctionCallContext : FunctionCallContext {
		public ScalarFunctionNameContext scalarFunctionName() {
			return GetRuleContext<ScalarFunctionNameContext>(0);
		}
		public FunctionArgsContext functionArgs() {
			return GetRuleContext<FunctionArgsContext>(0);
		}
		public ScalarFunctionCallContext(FunctionCallContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterScalarFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitScalarFunctionCall(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 570, RULE_functionCall);
		int _la;
		try {
			State = 5678;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,840,Context) ) {
			case 1:
				_localctx = new SpecificFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 5661; specificFunction();
				}
				break;
			case 2:
				_localctx = new AggregateFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 5662; aggregateWindowedFunction();
				}
				break;
			case 3:
				_localctx = new ScalarFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 5663; scalarFunctionName();
				State = 5664; Match(LR_BRACKET);
				State = 5666;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << CASE) | (1L << CAST) | (1L << CONVERT) | (1L << CURRENT_USER) | (1L << DATABASE) | (1L << EXISTS) | (1L << FALSE))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (IF - 66)) | (1L << (INSERT - 66)) | (1L << (INTERVAL - 66)) | (1L << (LEFT - 66)) | (1L << (NOT - 66)) | (1L << (NULL_LITERAL - 66)) | (1L << (REPLACE - 66)) | (1L << (RIGHT - 66)))) != 0) || ((((_la - 153)) & ~0x3f) == 0 && ((1L << (_la - 153)) & ((1L << (TRUE - 153)) | (1L << (VALUES - 153)) | (1L << (DATE - 153)) | (1L << (TIME - 153)) | (1L << (TIMESTAMP - 153)) | (1L << (DATETIME - 153)) | (1L << (YEAR - 153)) | (1L << (CHAR - 153)) | (1L << (BINARY - 153)) | (1L << (TEXT - 153)) | (1L << (ENUM - 153)) | (1L << (SERIAL - 153)))) != 0) || ((((_la - 217)) & ~0x3f) == 0 && ((1L << (_la - 217)) & ((1L << (AVG - 217)) | (1L << (BIT_AND - 217)) | (1L << (BIT_OR - 217)) | (1L << (BIT_XOR - 217)) | (1L << (COUNT - 217)) | (1L << (GROUP_CONCAT - 217)) | (1L << (MAX - 217)) | (1L << (MIN - 217)) | (1L << (STD - 217)) | (1L << (STDDEV - 217)) | (1L << (STDDEV_POP - 217)) | (1L << (STDDEV_SAMP - 217)) | (1L << (SUM - 217)) | (1L << (VAR_POP - 217)) | (1L << (VAR_SAMP - 217)) | (1L << (VARIANCE - 217)) | (1L << (CURRENT_DATE - 217)) | (1L << (CURRENT_TIME - 217)) | (1L << (CURRENT_TIMESTAMP - 217)) | (1L << (LOCALTIME - 217)) | (1L << (CURDATE - 217)) | (1L << (CURTIME - 217)) | (1L << (DATE_ADD - 217)) | (1L << (DATE_SUB - 217)) | (1L << (EXTRACT - 217)) | (1L << (LOCALTIMESTAMP - 217)) | (1L << (NOW - 217)) | (1L << (POSITION - 217)) | (1L << (SUBSTR - 217)) | (1L << (SUBSTRING - 217)) | (1L << (SYSDATE - 217)) | (1L << (TRIM - 217)) | (1L << (UTC_DATE - 217)) | (1L << (UTC_TIME - 217)) | (1L << (UTC_TIMESTAMP - 217)) | (1L << (ACCOUNT - 217)) | (1L << (ACTION - 217)) | (1L << (AFTER - 217)) | (1L << (AGGREGATE - 217)) | (1L << (ALGORITHM - 217)) | (1L << (ANY - 217)) | (1L << (AT - 217)) | (1L << (AUTHORS - 217)) | (1L << (AUTOCOMMIT - 217)) | (1L << (AUTOEXTEND_SIZE - 217)) | (1L << (AUTO_INCREMENT - 217)) | (1L << (AVG_ROW_LENGTH - 217)) | (1L << (BEGIN - 217)) | (1L << (BINLOG - 217)) | (1L << (BIT - 217)) | (1L << (BLOCK - 217)) | (1L << (BOOL - 217)) | (1L << (BOOLEAN - 217)) | (1L << (BTREE - 217)) | (1L << (CACHE - 217)) | (1L << (CASCADED - 217)) | (1L << (CHAIN - 217)) | (1L << (CHANGED - 217)) | (1L << (CHANNEL - 217)) | (1L << (CHECKSUM - 217)) | (1L << (PAGE_CHECKSUM - 217)) | (1L << (CIPHER - 217)) | (1L << (CLIENT - 217)) | (1L << (CLOSE - 217)))) != 0) || ((((_la - 281)) & ~0x3f) == 0 && ((1L << (_la - 281)) & ((1L << (COALESCE - 281)) | (1L << (CODE - 281)) | (1L << (COLUMNS - 281)) | (1L << (COLUMN_FORMAT - 281)) | (1L << (COMMENT - 281)) | (1L << (COMMIT - 281)) | (1L << (COMPACT - 281)) | (1L << (COMPLETION - 281)) | (1L << (COMPRESSED - 281)) | (1L << (COMPRESSION - 281)) | (1L << (CONCURRENT - 281)) | (1L << (CONNECTION - 281)) | (1L << (CONSISTENT - 281)) | (1L << (CONTAINS - 281)) | (1L << (CONTEXT - 281)) | (1L << (CONTRIBUTORS - 281)) | (1L << (COPY - 281)) | (1L << (CPU - 281)) | (1L << (DATA - 281)) | (1L << (DATAFILE - 281)) | (1L << (DEALLOCATE - 281)) | (1L << (DEFAULT_AUTH - 281)) | (1L << (DEFINER - 281)) | (1L << (DELAY_KEY_WRITE - 281)) | (1L << (DES_KEY_FILE - 281)) | (1L << (DIRECTORY - 281)) | (1L << (DISABLE - 281)) | (1L << (DISCARD - 281)) | (1L << (DISK - 281)) | (1L << (DO - 281)) | (1L << (DUMPFILE - 281)) | (1L << (DUPLICATE - 281)) | (1L << (DYNAMIC - 281)) | (1L << (ENABLE - 281)) | (1L << (ENCRYPTION - 281)) | (1L << (END - 281)) | (1L << (ENDS - 281)) | (1L << (ENGINE - 281)) | (1L << (ENGINES - 281)) | (1L << (ERROR - 281)) | (1L << (ERRORS - 281)) | (1L << (ESCAPE - 281)) | (1L << (EVEN - 281)) | (1L << (EVENT - 281)) | (1L << (EVENTS - 281)) | (1L << (EVERY - 281)) | (1L << (EXCHANGE - 281)) | (1L << (EXCLUSIVE - 281)) | (1L << (EXPIRE - 281)) | (1L << (EXPORT - 281)) | (1L << (EXTENDED - 281)) | (1L << (EXTENT_SIZE - 281)) | (1L << (FAST - 281)) | (1L << (FAULTS - 281)) | (1L << (FIELDS - 281)) | (1L << (FILE_BLOCK_SIZE - 281)) | (1L << (FILTER - 281)) | (1L << (FIRST - 281)) | (1L << (FIXED - 281)) | (1L << (FLUSH - 281)) | (1L << (FOLLOWS - 281)) | (1L << (FOUND - 281)) | (1L << (FULL - 281)) | (1L << (FUNCTION - 281)))) != 0) || ((((_la - 345)) & ~0x3f) == 0 && ((1L << (_la - 345)) & ((1L << (GENERAL - 345)) | (1L << (GLOBAL - 345)) | (1L << (GRANTS - 345)) | (1L << (GROUP_REPLICATION - 345)) | (1L << (HANDLER - 345)) | (1L << (HASH - 345)) | (1L << (HELP - 345)) | (1L << (HOST - 345)) | (1L << (HOSTS - 345)) | (1L << (IDENTIFIED - 345)) | (1L << (IGNORE_SERVER_IDS - 345)) | (1L << (IMPORT - 345)) | (1L << (INDEXES - 345)) | (1L << (INITIAL_SIZE - 345)) | (1L << (INPLACE - 345)) | (1L << (INSERT_METHOD - 345)) | (1L << (INSTALL - 345)) | (1L << (INSTANCE - 345)) | (1L << (INVOKER - 345)) | (1L << (IO - 345)) | (1L << (IO_THREAD - 345)) | (1L << (IPC - 345)) | (1L << (ISOLATION - 345)) | (1L << (ISSUER - 345)) | (1L << (JSON - 345)) | (1L << (KEY_BLOCK_SIZE - 345)) | (1L << (LANGUAGE - 345)) | (1L << (LAST - 345)) | (1L << (LEAVES - 345)) | (1L << (LESS - 345)) | (1L << (LEVEL - 345)) | (1L << (LIST - 345)) | (1L << (LOCAL - 345)) | (1L << (LOGFILE - 345)) | (1L << (LOGS - 345)) | (1L << (MASTER - 345)) | (1L << (MASTER_AUTO_POSITION - 345)) | (1L << (MASTER_CONNECT_RETRY - 345)) | (1L << (MASTER_DELAY - 345)) | (1L << (MASTER_HEARTBEAT_PERIOD - 345)) | (1L << (MASTER_HOST - 345)) | (1L << (MASTER_LOG_FILE - 345)) | (1L << (MASTER_LOG_POS - 345)) | (1L << (MASTER_PASSWORD - 345)) | (1L << (MASTER_PORT - 345)) | (1L << (MASTER_RETRY_COUNT - 345)) | (1L << (MASTER_SSL - 345)) | (1L << (MASTER_SSL_CA - 345)) | (1L << (MASTER_SSL_CAPATH - 345)) | (1L << (MASTER_SSL_CERT - 345)) | (1L << (MASTER_SSL_CIPHER - 345)) | (1L << (MASTER_SSL_CRL - 345)) | (1L << (MASTER_SSL_CRLPATH - 345)) | (1L << (MASTER_SSL_KEY - 345)) | (1L << (MASTER_TLS_VERSION - 345)) | (1L << (MASTER_USER - 345)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 345)) | (1L << (MAX_QUERIES_PER_HOUR - 345)) | (1L << (MAX_ROWS - 345)) | (1L << (MAX_SIZE - 345)) | (1L << (MAX_UPDATES_PER_HOUR - 345)) | (1L << (MAX_USER_CONNECTIONS - 345)) | (1L << (MEDIUM - 345)) | (1L << (MERGE - 345)))) != 0) || ((((_la - 409)) & ~0x3f) == 0 && ((1L << (_la - 409)) & ((1L << (MID - 409)) | (1L << (MIGRATE - 409)) | (1L << (MIN_ROWS - 409)) | (1L << (MODE - 409)) | (1L << (MODIFY - 409)) | (1L << (MUTEX - 409)) | (1L << (MYSQL - 409)) | (1L << (NAME - 409)) | (1L << (NAMES - 409)) | (1L << (NCHAR - 409)) | (1L << (NEVER - 409)) | (1L << (NEXT - 409)) | (1L << (NO - 409)) | (1L << (NODEGROUP - 409)) | (1L << (NONE - 409)) | (1L << (OFFLINE - 409)) | (1L << (OFFSET - 409)) | (1L << (OJ - 409)) | (1L << (OLD_PASSWORD - 409)) | (1L << (ONE - 409)) | (1L << (ONLINE - 409)) | (1L << (ONLY - 409)) | (1L << (OPEN - 409)) | (1L << (OPTIMIZER_COSTS - 409)) | (1L << (OPTIONS - 409)) | (1L << (OWNER - 409)) | (1L << (PACK_KEYS - 409)) | (1L << (PAGE - 409)) | (1L << (PARSER - 409)) | (1L << (PARTIAL - 409)) | (1L << (PARTITIONING - 409)) | (1L << (PARTITIONS - 409)) | (1L << (PASSWORD - 409)) | (1L << (PHASE - 409)) | (1L << (PLUGIN - 409)) | (1L << (PLUGIN_DIR - 409)) | (1L << (PLUGINS - 409)) | (1L << (PORT - 409)) | (1L << (PRECEDES - 409)) | (1L << (PREPARE - 409)) | (1L << (PRESERVE - 409)) | (1L << (PREV - 409)) | (1L << (PROCESSLIST - 409)) | (1L << (PROFILE - 409)) | (1L << (PROFILES - 409)) | (1L << (PROXY - 409)) | (1L << (QUERY - 409)) | (1L << (QUICK - 409)) | (1L << (REBUILD - 409)) | (1L << (RECOVER - 409)) | (1L << (REDO_BUFFER_SIZE - 409)) | (1L << (REDUNDANT - 409)) | (1L << (RELAY - 409)) | (1L << (RELAY_LOG_FILE - 409)) | (1L << (RELAY_LOG_POS - 409)) | (1L << (RELAYLOG - 409)) | (1L << (REMOVE - 409)) | (1L << (REORGANIZE - 409)) | (1L << (REPAIR - 409)) | (1L << (REPLICATE_DO_DB - 409)) | (1L << (REPLICATE_DO_TABLE - 409)) | (1L << (REPLICATE_IGNORE_DB - 409)) | (1L << (REPLICATE_IGNORE_TABLE - 409)) | (1L << (REPLICATE_REWRITE_DB - 409)))) != 0) || ((((_la - 473)) & ~0x3f) == 0 && ((1L << (_la - 473)) & ((1L << (REPLICATE_WILD_DO_TABLE - 473)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 473)) | (1L << (REPLICATION - 473)) | (1L << (RESET - 473)) | (1L << (RESUME - 473)) | (1L << (RETURNS - 473)) | (1L << (ROLLBACK - 473)) | (1L << (ROLLUP - 473)) | (1L << (ROTATE - 473)) | (1L << (ROW - 473)) | (1L << (ROWS - 473)) | (1L << (ROW_FORMAT - 473)) | (1L << (SAVEPOINT - 473)) | (1L << (SCHEDULE - 473)) | (1L << (SECURITY - 473)) | (1L << (SERVER - 473)) | (1L << (SESSION - 473)) | (1L << (SHARE - 473)) | (1L << (SHARED - 473)) | (1L << (SIGNED - 473)) | (1L << (SIMPLE - 473)) | (1L << (SLAVE - 473)) | (1L << (SLOW - 473)) | (1L << (SNAPSHOT - 473)) | (1L << (SOCKET - 473)) | (1L << (SOME - 473)) | (1L << (SONAME - 473)) | (1L << (SOUNDS - 473)) | (1L << (SOURCE - 473)) | (1L << (SQL_AFTER_GTIDS - 473)) | (1L << (SQL_AFTER_MTS_GAPS - 473)) | (1L << (SQL_BEFORE_GTIDS - 473)) | (1L << (SQL_BUFFER_RESULT - 473)) | (1L << (SQL_CACHE - 473)) | (1L << (SQL_NO_CACHE - 473)) | (1L << (SQL_THREAD - 473)) | (1L << (START - 473)) | (1L << (STARTS - 473)) | (1L << (STATS_AUTO_RECALC - 473)) | (1L << (STATS_PERSISTENT - 473)) | (1L << (STATS_SAMPLE_PAGES - 473)) | (1L << (STATUS - 473)) | (1L << (STOP - 473)) | (1L << (STORAGE - 473)) | (1L << (STRING - 473)) | (1L << (SUBJECT - 473)) | (1L << (SUBPARTITION - 473)) | (1L << (SUBPARTITIONS - 473)) | (1L << (SUSPEND - 473)) | (1L << (SWAPS - 473)) | (1L << (SWITCHES - 473)) | (1L << (TABLESPACE - 473)) | (1L << (TEMPORARY - 473)) | (1L << (TEMPTABLE - 473)) | (1L << (THAN - 473)) | (1L << (TRADITIONAL - 473)) | (1L << (TRANSACTION - 473)) | (1L << (TRIGGERS - 473)) | (1L << (TRUNCATE - 473)) | (1L << (UNDEFINED - 473)) | (1L << (UNDOFILE - 473)) | (1L << (UNDO_BUFFER_SIZE - 473)) | (1L << (UNINSTALL - 473)))) != 0) || ((((_la - 537)) & ~0x3f) == 0 && ((1L << (_la - 537)) & ((1L << (UNKNOWN - 537)) | (1L << (UNTIL - 537)) | (1L << (UPGRADE - 537)) | (1L << (USER - 537)) | (1L << (USE_FRM - 537)) | (1L << (USER_RESOURCES - 537)) | (1L << (VALIDATION - 537)) | (1L << (VALUE - 537)) | (1L << (VARIABLES - 537)) | (1L << (VIEW - 537)) | (1L << (WAIT - 537)) | (1L << (WARNINGS - 537)) | (1L << (WITHOUT - 537)) | (1L << (WORK - 537)) | (1L << (WRAPPER - 537)) | (1L << (X509 - 537)) | (1L << (XA - 537)) | (1L << (XML - 537)) | (1L << (INTERNAL - 537)) | (1L << (QUARTER - 537)) | (1L << (MONTH - 537)) | (1L << (DAY - 537)) | (1L << (HOUR - 537)) | (1L << (MINUTE - 537)) | (1L << (WEEK - 537)) | (1L << (SECOND - 537)) | (1L << (MICROSECOND - 537)) | (1L << (TABLES - 537)) | (1L << (ROUTINE - 537)) | (1L << (EXECUTE - 537)) | (1L << (FILE - 537)) | (1L << (PROCESS - 537)) | (1L << (RELOAD - 537)) | (1L << (SHUTDOWN - 537)) | (1L << (SUPER - 537)) | (1L << (PRIVILEGES - 537)) | (1L << (ARMSCII8 - 537)) | (1L << (ASCII - 537)) | (1L << (BIG5 - 537)) | (1L << (CP1250 - 537)) | (1L << (CP1251 - 537)) | (1L << (CP1256 - 537)) | (1L << (CP1257 - 537)) | (1L << (CP850 - 537)) | (1L << (CP852 - 537)) | (1L << (CP866 - 537)) | (1L << (CP932 - 537)) | (1L << (DEC8 - 537)) | (1L << (EUCJPMS - 537)) | (1L << (EUCKR - 537)) | (1L << (GB2312 - 537)) | (1L << (GBK - 537)) | (1L << (GEOSTD8 - 537)) | (1L << (GREEK - 537)) | (1L << (HEBREW - 537)) | (1L << (HP8 - 537)) | (1L << (KEYBCS2 - 537)) | (1L << (KOI8R - 537)) | (1L << (KOI8U - 537)))) != 0) || ((((_la - 601)) & ~0x3f) == 0 && ((1L << (_la - 601)) & ((1L << (LATIN1 - 601)) | (1L << (LATIN2 - 601)) | (1L << (LATIN5 - 601)) | (1L << (LATIN7 - 601)) | (1L << (MACCE - 601)) | (1L << (MACROMAN - 601)) | (1L << (SJIS - 601)) | (1L << (SWE7 - 601)) | (1L << (TIS620 - 601)) | (1L << (UCS2 - 601)) | (1L << (UJIS - 601)) | (1L << (UTF16 - 601)) | (1L << (UTF16LE - 601)) | (1L << (UTF32 - 601)) | (1L << (UTF8 - 601)) | (1L << (UTF8MB3 - 601)) | (1L << (UTF8MB4 - 601)) | (1L << (ARCHIVE - 601)) | (1L << (BLACKHOLE - 601)) | (1L << (CSV - 601)) | (1L << (FEDERATED - 601)) | (1L << (INNODB - 601)) | (1L << (MEMORY - 601)) | (1L << (MRG_MYISAM - 601)) | (1L << (MYISAM - 601)) | (1L << (NDB - 601)) | (1L << (NDBCLUSTER - 601)) | (1L << (PERFORMANCE_SCHEMA - 601)) | (1L << (TOKUDB - 601)) | (1L << (REPEATABLE - 601)) | (1L << (COMMITTED - 601)) | (1L << (UNCOMMITTED - 601)) | (1L << (SERIALIZABLE - 601)) | (1L << (GEOMETRYCOLLECTION - 601)) | (1L << (LINESTRING - 601)) | (1L << (MULTILINESTRING - 601)) | (1L << (MULTIPOINT - 601)) | (1L << (MULTIPOLYGON - 601)) | (1L << (POINT - 601)) | (1L << (POLYGON - 601)) | (1L << (ABS - 601)) | (1L << (ACOS - 601)) | (1L << (ADDDATE - 601)) | (1L << (ADDTIME - 601)) | (1L << (AES_DECRYPT - 601)) | (1L << (AES_ENCRYPT - 601)) | (1L << (AREA - 601)) | (1L << (ASBINARY - 601)) | (1L << (ASIN - 601)) | (1L << (ASTEXT - 601)) | (1L << (ASWKB - 601)) | (1L << (ASWKT - 601)) | (1L << (ASYMMETRIC_DECRYPT - 601)) | (1L << (ASYMMETRIC_DERIVE - 601)) | (1L << (ASYMMETRIC_ENCRYPT - 601)) | (1L << (ASYMMETRIC_SIGN - 601)) | (1L << (ASYMMETRIC_VERIFY - 601)) | (1L << (ATAN - 601)) | (1L << (ATAN2 - 601)) | (1L << (BENCHMARK - 601)) | (1L << (BIN - 601)) | (1L << (BIT_COUNT - 601)))) != 0) || ((((_la - 665)) & ~0x3f) == 0 && ((1L << (_la - 665)) & ((1L << (BIT_LENGTH - 665)) | (1L << (BUFFER - 665)) | (1L << (CEIL - 665)) | (1L << (CEILING - 665)) | (1L << (CENTROID - 665)) | (1L << (CHARACTER_LENGTH - 665)) | (1L << (CHARSET - 665)) | (1L << (CHAR_LENGTH - 665)) | (1L << (COERCIBILITY - 665)) | (1L << (COLLATION - 665)) | (1L << (COMPRESS - 665)) | (1L << (CONCAT - 665)) | (1L << (CONCAT_WS - 665)) | (1L << (CONNECTION_ID - 665)) | (1L << (CONV - 665)) | (1L << (CONVERT_TZ - 665)) | (1L << (COS - 665)) | (1L << (COT - 665)) | (1L << (CRC32 - 665)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 665)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 665)) | (1L << (CREATE_DH_PARAMETERS - 665)) | (1L << (CREATE_DIGEST - 665)) | (1L << (CROSSES - 665)) | (1L << (DATEDIFF - 665)) | (1L << (DATE_FORMAT - 665)) | (1L << (DAYNAME - 665)) | (1L << (DAYOFMONTH - 665)) | (1L << (DAYOFWEEK - 665)) | (1L << (DAYOFYEAR - 665)) | (1L << (DECODE - 665)) | (1L << (DEGREES - 665)) | (1L << (DES_DECRYPT - 665)) | (1L << (DES_ENCRYPT - 665)) | (1L << (DIMENSION - 665)) | (1L << (DISJOINT - 665)) | (1L << (ELT - 665)) | (1L << (ENCODE - 665)) | (1L << (ENCRYPT - 665)) | (1L << (ENDPOINT - 665)) | (1L << (ENVELOPE - 665)) | (1L << (EQUALS - 665)) | (1L << (EXP - 665)) | (1L << (EXPORT_SET - 665)) | (1L << (EXTERIORRING - 665)) | (1L << (EXTRACTVALUE - 665)) | (1L << (FIELD - 665)) | (1L << (FIND_IN_SET - 665)) | (1L << (FLOOR - 665)) | (1L << (FORMAT - 665)) | (1L << (FOUND_ROWS - 665)) | (1L << (FROM_BASE64 - 665)) | (1L << (FROM_DAYS - 665)) | (1L << (FROM_UNIXTIME - 665)) | (1L << (GEOMCOLLFROMTEXT - 665)) | (1L << (GEOMCOLLFROMWKB - 665)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 665)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 665)) | (1L << (GEOMETRYFROMTEXT - 665)) | (1L << (GEOMETRYFROMWKB - 665)) | (1L << (GEOMETRYN - 665)) | (1L << (GEOMETRYTYPE - 665)) | (1L << (GEOMFROMTEXT - 665)) | (1L << (GEOMFROMWKB - 665)))) != 0) || ((((_la - 729)) & ~0x3f) == 0 && ((1L << (_la - 729)) & ((1L << (GET_FORMAT - 729)) | (1L << (GET_LOCK - 729)) | (1L << (GLENGTH - 729)) | (1L << (GREATEST - 729)) | (1L << (GTID_SUBSET - 729)) | (1L << (GTID_SUBTRACT - 729)) | (1L << (HEX - 729)) | (1L << (IFNULL - 729)) | (1L << (INET6_ATON - 729)) | (1L << (INET6_NTOA - 729)) | (1L << (INET_ATON - 729)) | (1L << (INET_NTOA - 729)) | (1L << (INSTR - 729)) | (1L << (INTERIORRINGN - 729)) | (1L << (INTERSECTS - 729)) | (1L << (ISCLOSED - 729)) | (1L << (ISEMPTY - 729)) | (1L << (ISNULL - 729)) | (1L << (ISSIMPLE - 729)) | (1L << (IS_FREE_LOCK - 729)) | (1L << (IS_IPV4 - 729)) | (1L << (IS_IPV4_COMPAT - 729)) | (1L << (IS_IPV4_MAPPED - 729)) | (1L << (IS_IPV6 - 729)) | (1L << (IS_USED_LOCK - 729)) | (1L << (LAST_INSERT_ID - 729)) | (1L << (LCASE - 729)) | (1L << (LEAST - 729)) | (1L << (LENGTH - 729)) | (1L << (LINEFROMTEXT - 729)) | (1L << (LINEFROMWKB - 729)) | (1L << (LINESTRINGFROMTEXT - 729)) | (1L << (LINESTRINGFROMWKB - 729)) | (1L << (LN - 729)) | (1L << (LOAD_FILE - 729)) | (1L << (LOCATE - 729)) | (1L << (LOG - 729)) | (1L << (LOG10 - 729)) | (1L << (LOG2 - 729)) | (1L << (LOWER - 729)) | (1L << (LPAD - 729)) | (1L << (LTRIM - 729)) | (1L << (MAKEDATE - 729)) | (1L << (MAKETIME - 729)) | (1L << (MAKE_SET - 729)) | (1L << (MASTER_POS_WAIT - 729)) | (1L << (MBRCONTAINS - 729)) | (1L << (MBRDISJOINT - 729)) | (1L << (MBREQUAL - 729)) | (1L << (MBRINTERSECTS - 729)) | (1L << (MBROVERLAPS - 729)) | (1L << (MBRTOUCHES - 729)) | (1L << (MBRWITHIN - 729)) | (1L << (MD5 - 729)) | (1L << (MLINEFROMTEXT - 729)) | (1L << (MLINEFROMWKB - 729)) | (1L << (MONTHNAME - 729)) | (1L << (MPOINTFROMTEXT - 729)) | (1L << (MPOINTFROMWKB - 729)) | (1L << (MPOLYFROMTEXT - 729)) | (1L << (MPOLYFROMWKB - 729)) | (1L << (MULTILINESTRINGFROMTEXT - 729)) | (1L << (MULTILINESTRINGFROMWKB - 729)) | (1L << (MULTIPOINTFROMTEXT - 729)))) != 0) || ((((_la - 793)) & ~0x3f) == 0 && ((1L << (_la - 793)) & ((1L << (MULTIPOINTFROMWKB - 793)) | (1L << (MULTIPOLYGONFROMTEXT - 793)) | (1L << (MULTIPOLYGONFROMWKB - 793)) | (1L << (NAME_CONST - 793)) | (1L << (NULLIF - 793)) | (1L << (NUMGEOMETRIES - 793)) | (1L << (NUMINTERIORRINGS - 793)) | (1L << (NUMPOINTS - 793)) | (1L << (OCT - 793)) | (1L << (OCTET_LENGTH - 793)) | (1L << (ORD - 793)) | (1L << (OVERLAPS - 793)) | (1L << (PERIOD_ADD - 793)) | (1L << (PERIOD_DIFF - 793)) | (1L << (PI - 793)) | (1L << (POINTFROMTEXT - 793)) | (1L << (POINTFROMWKB - 793)) | (1L << (POINTN - 793)) | (1L << (POLYFROMTEXT - 793)) | (1L << (POLYFROMWKB - 793)) | (1L << (POLYGONFROMTEXT - 793)) | (1L << (POLYGONFROMWKB - 793)) | (1L << (POW - 793)) | (1L << (POWER - 793)) | (1L << (QUOTE - 793)) | (1L << (RADIANS - 793)) | (1L << (RAND - 793)) | (1L << (RANDOM_BYTES - 793)) | (1L << (RELEASE_LOCK - 793)) | (1L << (REVERSE - 793)) | (1L << (ROUND - 793)) | (1L << (ROW_COUNT - 793)) | (1L << (RPAD - 793)) | (1L << (RTRIM - 793)) | (1L << (SEC_TO_TIME - 793)) | (1L << (SESSION_USER - 793)) | (1L << (SHA - 793)) | (1L << (SHA1 - 793)) | (1L << (SHA2 - 793)) | (1L << (SIGN - 793)) | (1L << (SIN - 793)) | (1L << (SLEEP - 793)) | (1L << (SOUNDEX - 793)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 793)) | (1L << (SQRT - 793)) | (1L << (SRID - 793)) | (1L << (STARTPOINT - 793)) | (1L << (STRCMP - 793)) | (1L << (STR_TO_DATE - 793)) | (1L << (ST_AREA - 793)) | (1L << (ST_ASBINARY - 793)) | (1L << (ST_ASTEXT - 793)) | (1L << (ST_ASWKB - 793)) | (1L << (ST_ASWKT - 793)) | (1L << (ST_BUFFER - 793)) | (1L << (ST_CENTROID - 793)) | (1L << (ST_CONTAINS - 793)) | (1L << (ST_CROSSES - 793)) | (1L << (ST_DIFFERENCE - 793)) | (1L << (ST_DIMENSION - 793)) | (1L << (ST_DISJOINT - 793)) | (1L << (ST_DISTANCE - 793)) | (1L << (ST_ENDPOINT - 793)) | (1L << (ST_ENVELOPE - 793)))) != 0) || ((((_la - 857)) & ~0x3f) == 0 && ((1L << (_la - 857)) & ((1L << (ST_EQUALS - 857)) | (1L << (ST_EXTERIORRING - 857)) | (1L << (ST_GEOMCOLLFROMTEXT - 857)) | (1L << (ST_GEOMCOLLFROMTXT - 857)) | (1L << (ST_GEOMCOLLFROMWKB - 857)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 857)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 857)) | (1L << (ST_GEOMETRYFROMTEXT - 857)) | (1L << (ST_GEOMETRYFROMWKB - 857)) | (1L << (ST_GEOMETRYN - 857)) | (1L << (ST_GEOMETRYTYPE - 857)) | (1L << (ST_GEOMFROMTEXT - 857)) | (1L << (ST_GEOMFROMWKB - 857)) | (1L << (ST_INTERIORRINGN - 857)) | (1L << (ST_INTERSECTION - 857)) | (1L << (ST_INTERSECTS - 857)) | (1L << (ST_ISCLOSED - 857)) | (1L << (ST_ISEMPTY - 857)) | (1L << (ST_ISSIMPLE - 857)) | (1L << (ST_LINEFROMTEXT - 857)) | (1L << (ST_LINEFROMWKB - 857)) | (1L << (ST_LINESTRINGFROMTEXT - 857)) | (1L << (ST_LINESTRINGFROMWKB - 857)) | (1L << (ST_NUMGEOMETRIES - 857)) | (1L << (ST_NUMINTERIORRING - 857)) | (1L << (ST_NUMINTERIORRINGS - 857)) | (1L << (ST_NUMPOINTS - 857)) | (1L << (ST_OVERLAPS - 857)) | (1L << (ST_POINTFROMTEXT - 857)) | (1L << (ST_POINTFROMWKB - 857)) | (1L << (ST_POINTN - 857)) | (1L << (ST_POLYFROMTEXT - 857)) | (1L << (ST_POLYFROMWKB - 857)) | (1L << (ST_POLYGONFROMTEXT - 857)) | (1L << (ST_POLYGONFROMWKB - 857)) | (1L << (ST_SRID - 857)) | (1L << (ST_STARTPOINT - 857)) | (1L << (ST_SYMDIFFERENCE - 857)) | (1L << (ST_TOUCHES - 857)) | (1L << (ST_UNION - 857)) | (1L << (ST_WITHIN - 857)) | (1L << (ST_X - 857)) | (1L << (ST_Y - 857)) | (1L << (SUBDATE - 857)) | (1L << (SUBSTRING_INDEX - 857)) | (1L << (SUBTIME - 857)) | (1L << (SYSTEM_USER - 857)) | (1L << (TAN - 857)) | (1L << (TIMEDIFF - 857)) | (1L << (TIMESTAMPADD - 857)) | (1L << (TIMESTAMPDIFF - 857)) | (1L << (TIME_FORMAT - 857)) | (1L << (TIME_TO_SEC - 857)) | (1L << (TOUCHES - 857)) | (1L << (TO_BASE64 - 857)) | (1L << (TO_DAYS - 857)) | (1L << (TO_SECONDS - 857)) | (1L << (UCASE - 857)) | (1L << (UNCOMPRESS - 857)) | (1L << (UNCOMPRESSED_LENGTH - 857)) | (1L << (UNHEX - 857)) | (1L << (UNIX_TIMESTAMP - 857)) | (1L << (UPDATEXML - 857)) | (1L << (UPPER - 857)))) != 0) || ((((_la - 921)) & ~0x3f) == 0 && ((1L << (_la - 921)) & ((1L << (UUID - 921)) | (1L << (UUID_SHORT - 921)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 921)) | (1L << (VERSION - 921)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 921)) | (1L << (WEEKDAY - 921)) | (1L << (WEEKOFYEAR - 921)) | (1L << (WEIGHT_STRING - 921)) | (1L << (WITHIN - 921)) | (1L << (YEARWEEK - 921)) | (1L << (Y_FUNCTION - 921)) | (1L << (X_FUNCTION - 921)) | (1L << (PLUS - 921)) | (1L << (MINUS - 921)) | (1L << (EXCLAMATION_SYMBOL - 921)) | (1L << (BIT_NOT_OP - 921)) | (1L << (LR_BRACKET - 921)) | (1L << (ZERO_DECIMAL - 921)) | (1L << (ONE_DECIMAL - 921)) | (1L << (TWO_DECIMAL - 921)) | (1L << (CHARSET_REVERSE_QOUTE_STRING - 921)) | (1L << (START_NATIONAL_STRING_LITERAL - 921)) | (1L << (STRING_LITERAL - 921)) | (1L << (DECIMAL_LITERAL - 921)) | (1L << (HEXADECIMAL_LITERAL - 921)) | (1L << (REAL_LITERAL - 921)) | (1L << (NULL_SPEC_LITERAL - 921)) | (1L << (BIT_STRING - 921)) | (1L << (STRING_CHARSET_NAME - 921)) | (1L << (ID - 921)) | (1L << (REVERSE_QUOTE_ID - 921)))) != 0) || _la==LOCAL_ID || _la==GLOBAL_ID) {
					{
					State = 5665; functionArgs();
					}
				}

				State = 5668; Match(RR_BRACKET);
				}
				break;
			case 4:
				_localctx = new UdfFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 5670; fullId();
				State = 5671; Match(LR_BRACKET);
				State = 5673;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << CASE) | (1L << CAST) | (1L << CONVERT) | (1L << CURRENT_USER) | (1L << DATABASE) | (1L << EXISTS) | (1L << FALSE))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (IF - 66)) | (1L << (INSERT - 66)) | (1L << (INTERVAL - 66)) | (1L << (LEFT - 66)) | (1L << (NOT - 66)) | (1L << (NULL_LITERAL - 66)) | (1L << (REPLACE - 66)) | (1L << (RIGHT - 66)))) != 0) || ((((_la - 153)) & ~0x3f) == 0 && ((1L << (_la - 153)) & ((1L << (TRUE - 153)) | (1L << (VALUES - 153)) | (1L << (DATE - 153)) | (1L << (TIME - 153)) | (1L << (TIMESTAMP - 153)) | (1L << (DATETIME - 153)) | (1L << (YEAR - 153)) | (1L << (CHAR - 153)) | (1L << (BINARY - 153)) | (1L << (TEXT - 153)) | (1L << (ENUM - 153)) | (1L << (SERIAL - 153)))) != 0) || ((((_la - 217)) & ~0x3f) == 0 && ((1L << (_la - 217)) & ((1L << (AVG - 217)) | (1L << (BIT_AND - 217)) | (1L << (BIT_OR - 217)) | (1L << (BIT_XOR - 217)) | (1L << (COUNT - 217)) | (1L << (GROUP_CONCAT - 217)) | (1L << (MAX - 217)) | (1L << (MIN - 217)) | (1L << (STD - 217)) | (1L << (STDDEV - 217)) | (1L << (STDDEV_POP - 217)) | (1L << (STDDEV_SAMP - 217)) | (1L << (SUM - 217)) | (1L << (VAR_POP - 217)) | (1L << (VAR_SAMP - 217)) | (1L << (VARIANCE - 217)) | (1L << (CURRENT_DATE - 217)) | (1L << (CURRENT_TIME - 217)) | (1L << (CURRENT_TIMESTAMP - 217)) | (1L << (LOCALTIME - 217)) | (1L << (CURDATE - 217)) | (1L << (CURTIME - 217)) | (1L << (DATE_ADD - 217)) | (1L << (DATE_SUB - 217)) | (1L << (EXTRACT - 217)) | (1L << (LOCALTIMESTAMP - 217)) | (1L << (NOW - 217)) | (1L << (POSITION - 217)) | (1L << (SUBSTR - 217)) | (1L << (SUBSTRING - 217)) | (1L << (SYSDATE - 217)) | (1L << (TRIM - 217)) | (1L << (UTC_DATE - 217)) | (1L << (UTC_TIME - 217)) | (1L << (UTC_TIMESTAMP - 217)) | (1L << (ACCOUNT - 217)) | (1L << (ACTION - 217)) | (1L << (AFTER - 217)) | (1L << (AGGREGATE - 217)) | (1L << (ALGORITHM - 217)) | (1L << (ANY - 217)) | (1L << (AT - 217)) | (1L << (AUTHORS - 217)) | (1L << (AUTOCOMMIT - 217)) | (1L << (AUTOEXTEND_SIZE - 217)) | (1L << (AUTO_INCREMENT - 217)) | (1L << (AVG_ROW_LENGTH - 217)) | (1L << (BEGIN - 217)) | (1L << (BINLOG - 217)) | (1L << (BIT - 217)) | (1L << (BLOCK - 217)) | (1L << (BOOL - 217)) | (1L << (BOOLEAN - 217)) | (1L << (BTREE - 217)) | (1L << (CACHE - 217)) | (1L << (CASCADED - 217)) | (1L << (CHAIN - 217)) | (1L << (CHANGED - 217)) | (1L << (CHANNEL - 217)) | (1L << (CHECKSUM - 217)) | (1L << (PAGE_CHECKSUM - 217)) | (1L << (CIPHER - 217)) | (1L << (CLIENT - 217)) | (1L << (CLOSE - 217)))) != 0) || ((((_la - 281)) & ~0x3f) == 0 && ((1L << (_la - 281)) & ((1L << (COALESCE - 281)) | (1L << (CODE - 281)) | (1L << (COLUMNS - 281)) | (1L << (COLUMN_FORMAT - 281)) | (1L << (COMMENT - 281)) | (1L << (COMMIT - 281)) | (1L << (COMPACT - 281)) | (1L << (COMPLETION - 281)) | (1L << (COMPRESSED - 281)) | (1L << (COMPRESSION - 281)) | (1L << (CONCURRENT - 281)) | (1L << (CONNECTION - 281)) | (1L << (CONSISTENT - 281)) | (1L << (CONTAINS - 281)) | (1L << (CONTEXT - 281)) | (1L << (CONTRIBUTORS - 281)) | (1L << (COPY - 281)) | (1L << (CPU - 281)) | (1L << (DATA - 281)) | (1L << (DATAFILE - 281)) | (1L << (DEALLOCATE - 281)) | (1L << (DEFAULT_AUTH - 281)) | (1L << (DEFINER - 281)) | (1L << (DELAY_KEY_WRITE - 281)) | (1L << (DES_KEY_FILE - 281)) | (1L << (DIRECTORY - 281)) | (1L << (DISABLE - 281)) | (1L << (DISCARD - 281)) | (1L << (DISK - 281)) | (1L << (DO - 281)) | (1L << (DUMPFILE - 281)) | (1L << (DUPLICATE - 281)) | (1L << (DYNAMIC - 281)) | (1L << (ENABLE - 281)) | (1L << (ENCRYPTION - 281)) | (1L << (END - 281)) | (1L << (ENDS - 281)) | (1L << (ENGINE - 281)) | (1L << (ENGINES - 281)) | (1L << (ERROR - 281)) | (1L << (ERRORS - 281)) | (1L << (ESCAPE - 281)) | (1L << (EVEN - 281)) | (1L << (EVENT - 281)) | (1L << (EVENTS - 281)) | (1L << (EVERY - 281)) | (1L << (EXCHANGE - 281)) | (1L << (EXCLUSIVE - 281)) | (1L << (EXPIRE - 281)) | (1L << (EXPORT - 281)) | (1L << (EXTENDED - 281)) | (1L << (EXTENT_SIZE - 281)) | (1L << (FAST - 281)) | (1L << (FAULTS - 281)) | (1L << (FIELDS - 281)) | (1L << (FILE_BLOCK_SIZE - 281)) | (1L << (FILTER - 281)) | (1L << (FIRST - 281)) | (1L << (FIXED - 281)) | (1L << (FLUSH - 281)) | (1L << (FOLLOWS - 281)) | (1L << (FOUND - 281)) | (1L << (FULL - 281)) | (1L << (FUNCTION - 281)))) != 0) || ((((_la - 345)) & ~0x3f) == 0 && ((1L << (_la - 345)) & ((1L << (GENERAL - 345)) | (1L << (GLOBAL - 345)) | (1L << (GRANTS - 345)) | (1L << (GROUP_REPLICATION - 345)) | (1L << (HANDLER - 345)) | (1L << (HASH - 345)) | (1L << (HELP - 345)) | (1L << (HOST - 345)) | (1L << (HOSTS - 345)) | (1L << (IDENTIFIED - 345)) | (1L << (IGNORE_SERVER_IDS - 345)) | (1L << (IMPORT - 345)) | (1L << (INDEXES - 345)) | (1L << (INITIAL_SIZE - 345)) | (1L << (INPLACE - 345)) | (1L << (INSERT_METHOD - 345)) | (1L << (INSTALL - 345)) | (1L << (INSTANCE - 345)) | (1L << (INVOKER - 345)) | (1L << (IO - 345)) | (1L << (IO_THREAD - 345)) | (1L << (IPC - 345)) | (1L << (ISOLATION - 345)) | (1L << (ISSUER - 345)) | (1L << (JSON - 345)) | (1L << (KEY_BLOCK_SIZE - 345)) | (1L << (LANGUAGE - 345)) | (1L << (LAST - 345)) | (1L << (LEAVES - 345)) | (1L << (LESS - 345)) | (1L << (LEVEL - 345)) | (1L << (LIST - 345)) | (1L << (LOCAL - 345)) | (1L << (LOGFILE - 345)) | (1L << (LOGS - 345)) | (1L << (MASTER - 345)) | (1L << (MASTER_AUTO_POSITION - 345)) | (1L << (MASTER_CONNECT_RETRY - 345)) | (1L << (MASTER_DELAY - 345)) | (1L << (MASTER_HEARTBEAT_PERIOD - 345)) | (1L << (MASTER_HOST - 345)) | (1L << (MASTER_LOG_FILE - 345)) | (1L << (MASTER_LOG_POS - 345)) | (1L << (MASTER_PASSWORD - 345)) | (1L << (MASTER_PORT - 345)) | (1L << (MASTER_RETRY_COUNT - 345)) | (1L << (MASTER_SSL - 345)) | (1L << (MASTER_SSL_CA - 345)) | (1L << (MASTER_SSL_CAPATH - 345)) | (1L << (MASTER_SSL_CERT - 345)) | (1L << (MASTER_SSL_CIPHER - 345)) | (1L << (MASTER_SSL_CRL - 345)) | (1L << (MASTER_SSL_CRLPATH - 345)) | (1L << (MASTER_SSL_KEY - 345)) | (1L << (MASTER_TLS_VERSION - 345)) | (1L << (MASTER_USER - 345)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 345)) | (1L << (MAX_QUERIES_PER_HOUR - 345)) | (1L << (MAX_ROWS - 345)) | (1L << (MAX_SIZE - 345)) | (1L << (MAX_UPDATES_PER_HOUR - 345)) | (1L << (MAX_USER_CONNECTIONS - 345)) | (1L << (MEDIUM - 345)) | (1L << (MERGE - 345)))) != 0) || ((((_la - 409)) & ~0x3f) == 0 && ((1L << (_la - 409)) & ((1L << (MID - 409)) | (1L << (MIGRATE - 409)) | (1L << (MIN_ROWS - 409)) | (1L << (MODE - 409)) | (1L << (MODIFY - 409)) | (1L << (MUTEX - 409)) | (1L << (MYSQL - 409)) | (1L << (NAME - 409)) | (1L << (NAMES - 409)) | (1L << (NCHAR - 409)) | (1L << (NEVER - 409)) | (1L << (NEXT - 409)) | (1L << (NO - 409)) | (1L << (NODEGROUP - 409)) | (1L << (NONE - 409)) | (1L << (OFFLINE - 409)) | (1L << (OFFSET - 409)) | (1L << (OJ - 409)) | (1L << (OLD_PASSWORD - 409)) | (1L << (ONE - 409)) | (1L << (ONLINE - 409)) | (1L << (ONLY - 409)) | (1L << (OPEN - 409)) | (1L << (OPTIMIZER_COSTS - 409)) | (1L << (OPTIONS - 409)) | (1L << (OWNER - 409)) | (1L << (PACK_KEYS - 409)) | (1L << (PAGE - 409)) | (1L << (PARSER - 409)) | (1L << (PARTIAL - 409)) | (1L << (PARTITIONING - 409)) | (1L << (PARTITIONS - 409)) | (1L << (PASSWORD - 409)) | (1L << (PHASE - 409)) | (1L << (PLUGIN - 409)) | (1L << (PLUGIN_DIR - 409)) | (1L << (PLUGINS - 409)) | (1L << (PORT - 409)) | (1L << (PRECEDES - 409)) | (1L << (PREPARE - 409)) | (1L << (PRESERVE - 409)) | (1L << (PREV - 409)) | (1L << (PROCESSLIST - 409)) | (1L << (PROFILE - 409)) | (1L << (PROFILES - 409)) | (1L << (PROXY - 409)) | (1L << (QUERY - 409)) | (1L << (QUICK - 409)) | (1L << (REBUILD - 409)) | (1L << (RECOVER - 409)) | (1L << (REDO_BUFFER_SIZE - 409)) | (1L << (REDUNDANT - 409)) | (1L << (RELAY - 409)) | (1L << (RELAY_LOG_FILE - 409)) | (1L << (RELAY_LOG_POS - 409)) | (1L << (RELAYLOG - 409)) | (1L << (REMOVE - 409)) | (1L << (REORGANIZE - 409)) | (1L << (REPAIR - 409)) | (1L << (REPLICATE_DO_DB - 409)) | (1L << (REPLICATE_DO_TABLE - 409)) | (1L << (REPLICATE_IGNORE_DB - 409)) | (1L << (REPLICATE_IGNORE_TABLE - 409)) | (1L << (REPLICATE_REWRITE_DB - 409)))) != 0) || ((((_la - 473)) & ~0x3f) == 0 && ((1L << (_la - 473)) & ((1L << (REPLICATE_WILD_DO_TABLE - 473)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 473)) | (1L << (REPLICATION - 473)) | (1L << (RESET - 473)) | (1L << (RESUME - 473)) | (1L << (RETURNS - 473)) | (1L << (ROLLBACK - 473)) | (1L << (ROLLUP - 473)) | (1L << (ROTATE - 473)) | (1L << (ROW - 473)) | (1L << (ROWS - 473)) | (1L << (ROW_FORMAT - 473)) | (1L << (SAVEPOINT - 473)) | (1L << (SCHEDULE - 473)) | (1L << (SECURITY - 473)) | (1L << (SERVER - 473)) | (1L << (SESSION - 473)) | (1L << (SHARE - 473)) | (1L << (SHARED - 473)) | (1L << (SIGNED - 473)) | (1L << (SIMPLE - 473)) | (1L << (SLAVE - 473)) | (1L << (SLOW - 473)) | (1L << (SNAPSHOT - 473)) | (1L << (SOCKET - 473)) | (1L << (SOME - 473)) | (1L << (SONAME - 473)) | (1L << (SOUNDS - 473)) | (1L << (SOURCE - 473)) | (1L << (SQL_AFTER_GTIDS - 473)) | (1L << (SQL_AFTER_MTS_GAPS - 473)) | (1L << (SQL_BEFORE_GTIDS - 473)) | (1L << (SQL_BUFFER_RESULT - 473)) | (1L << (SQL_CACHE - 473)) | (1L << (SQL_NO_CACHE - 473)) | (1L << (SQL_THREAD - 473)) | (1L << (START - 473)) | (1L << (STARTS - 473)) | (1L << (STATS_AUTO_RECALC - 473)) | (1L << (STATS_PERSISTENT - 473)) | (1L << (STATS_SAMPLE_PAGES - 473)) | (1L << (STATUS - 473)) | (1L << (STOP - 473)) | (1L << (STORAGE - 473)) | (1L << (STRING - 473)) | (1L << (SUBJECT - 473)) | (1L << (SUBPARTITION - 473)) | (1L << (SUBPARTITIONS - 473)) | (1L << (SUSPEND - 473)) | (1L << (SWAPS - 473)) | (1L << (SWITCHES - 473)) | (1L << (TABLESPACE - 473)) | (1L << (TEMPORARY - 473)) | (1L << (TEMPTABLE - 473)) | (1L << (THAN - 473)) | (1L << (TRADITIONAL - 473)) | (1L << (TRANSACTION - 473)) | (1L << (TRIGGERS - 473)) | (1L << (TRUNCATE - 473)) | (1L << (UNDEFINED - 473)) | (1L << (UNDOFILE - 473)) | (1L << (UNDO_BUFFER_SIZE - 473)) | (1L << (UNINSTALL - 473)))) != 0) || ((((_la - 537)) & ~0x3f) == 0 && ((1L << (_la - 537)) & ((1L << (UNKNOWN - 537)) | (1L << (UNTIL - 537)) | (1L << (UPGRADE - 537)) | (1L << (USER - 537)) | (1L << (USE_FRM - 537)) | (1L << (USER_RESOURCES - 537)) | (1L << (VALIDATION - 537)) | (1L << (VALUE - 537)) | (1L << (VARIABLES - 537)) | (1L << (VIEW - 537)) | (1L << (WAIT - 537)) | (1L << (WARNINGS - 537)) | (1L << (WITHOUT - 537)) | (1L << (WORK - 537)) | (1L << (WRAPPER - 537)) | (1L << (X509 - 537)) | (1L << (XA - 537)) | (1L << (XML - 537)) | (1L << (INTERNAL - 537)) | (1L << (QUARTER - 537)) | (1L << (MONTH - 537)) | (1L << (DAY - 537)) | (1L << (HOUR - 537)) | (1L << (MINUTE - 537)) | (1L << (WEEK - 537)) | (1L << (SECOND - 537)) | (1L << (MICROSECOND - 537)) | (1L << (TABLES - 537)) | (1L << (ROUTINE - 537)) | (1L << (EXECUTE - 537)) | (1L << (FILE - 537)) | (1L << (PROCESS - 537)) | (1L << (RELOAD - 537)) | (1L << (SHUTDOWN - 537)) | (1L << (SUPER - 537)) | (1L << (PRIVILEGES - 537)) | (1L << (ARMSCII8 - 537)) | (1L << (ASCII - 537)) | (1L << (BIG5 - 537)) | (1L << (CP1250 - 537)) | (1L << (CP1251 - 537)) | (1L << (CP1256 - 537)) | (1L << (CP1257 - 537)) | (1L << (CP850 - 537)) | (1L << (CP852 - 537)) | (1L << (CP866 - 537)) | (1L << (CP932 - 537)) | (1L << (DEC8 - 537)) | (1L << (EUCJPMS - 537)) | (1L << (EUCKR - 537)) | (1L << (GB2312 - 537)) | (1L << (GBK - 537)) | (1L << (GEOSTD8 - 537)) | (1L << (GREEK - 537)) | (1L << (HEBREW - 537)) | (1L << (HP8 - 537)) | (1L << (KEYBCS2 - 537)) | (1L << (KOI8R - 537)) | (1L << (KOI8U - 537)))) != 0) || ((((_la - 601)) & ~0x3f) == 0 && ((1L << (_la - 601)) & ((1L << (LATIN1 - 601)) | (1L << (LATIN2 - 601)) | (1L << (LATIN5 - 601)) | (1L << (LATIN7 - 601)) | (1L << (MACCE - 601)) | (1L << (MACROMAN - 601)) | (1L << (SJIS - 601)) | (1L << (SWE7 - 601)) | (1L << (TIS620 - 601)) | (1L << (UCS2 - 601)) | (1L << (UJIS - 601)) | (1L << (UTF16 - 601)) | (1L << (UTF16LE - 601)) | (1L << (UTF32 - 601)) | (1L << (UTF8 - 601)) | (1L << (UTF8MB3 - 601)) | (1L << (UTF8MB4 - 601)) | (1L << (ARCHIVE - 601)) | (1L << (BLACKHOLE - 601)) | (1L << (CSV - 601)) | (1L << (FEDERATED - 601)) | (1L << (INNODB - 601)) | (1L << (MEMORY - 601)) | (1L << (MRG_MYISAM - 601)) | (1L << (MYISAM - 601)) | (1L << (NDB - 601)) | (1L << (NDBCLUSTER - 601)) | (1L << (PERFORMANCE_SCHEMA - 601)) | (1L << (TOKUDB - 601)) | (1L << (REPEATABLE - 601)) | (1L << (COMMITTED - 601)) | (1L << (UNCOMMITTED - 601)) | (1L << (SERIALIZABLE - 601)) | (1L << (GEOMETRYCOLLECTION - 601)) | (1L << (LINESTRING - 601)) | (1L << (MULTILINESTRING - 601)) | (1L << (MULTIPOINT - 601)) | (1L << (MULTIPOLYGON - 601)) | (1L << (POINT - 601)) | (1L << (POLYGON - 601)) | (1L << (ABS - 601)) | (1L << (ACOS - 601)) | (1L << (ADDDATE - 601)) | (1L << (ADDTIME - 601)) | (1L << (AES_DECRYPT - 601)) | (1L << (AES_ENCRYPT - 601)) | (1L << (AREA - 601)) | (1L << (ASBINARY - 601)) | (1L << (ASIN - 601)) | (1L << (ASTEXT - 601)) | (1L << (ASWKB - 601)) | (1L << (ASWKT - 601)) | (1L << (ASYMMETRIC_DECRYPT - 601)) | (1L << (ASYMMETRIC_DERIVE - 601)) | (1L << (ASYMMETRIC_ENCRYPT - 601)) | (1L << (ASYMMETRIC_SIGN - 601)) | (1L << (ASYMMETRIC_VERIFY - 601)) | (1L << (ATAN - 601)) | (1L << (ATAN2 - 601)) | (1L << (BENCHMARK - 601)) | (1L << (BIN - 601)) | (1L << (BIT_COUNT - 601)))) != 0) || ((((_la - 665)) & ~0x3f) == 0 && ((1L << (_la - 665)) & ((1L << (BIT_LENGTH - 665)) | (1L << (BUFFER - 665)) | (1L << (CEIL - 665)) | (1L << (CEILING - 665)) | (1L << (CENTROID - 665)) | (1L << (CHARACTER_LENGTH - 665)) | (1L << (CHARSET - 665)) | (1L << (CHAR_LENGTH - 665)) | (1L << (COERCIBILITY - 665)) | (1L << (COLLATION - 665)) | (1L << (COMPRESS - 665)) | (1L << (CONCAT - 665)) | (1L << (CONCAT_WS - 665)) | (1L << (CONNECTION_ID - 665)) | (1L << (CONV - 665)) | (1L << (CONVERT_TZ - 665)) | (1L << (COS - 665)) | (1L << (COT - 665)) | (1L << (CRC32 - 665)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 665)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 665)) | (1L << (CREATE_DH_PARAMETERS - 665)) | (1L << (CREATE_DIGEST - 665)) | (1L << (CROSSES - 665)) | (1L << (DATEDIFF - 665)) | (1L << (DATE_FORMAT - 665)) | (1L << (DAYNAME - 665)) | (1L << (DAYOFMONTH - 665)) | (1L << (DAYOFWEEK - 665)) | (1L << (DAYOFYEAR - 665)) | (1L << (DECODE - 665)) | (1L << (DEGREES - 665)) | (1L << (DES_DECRYPT - 665)) | (1L << (DES_ENCRYPT - 665)) | (1L << (DIMENSION - 665)) | (1L << (DISJOINT - 665)) | (1L << (ELT - 665)) | (1L << (ENCODE - 665)) | (1L << (ENCRYPT - 665)) | (1L << (ENDPOINT - 665)) | (1L << (ENVELOPE - 665)) | (1L << (EQUALS - 665)) | (1L << (EXP - 665)) | (1L << (EXPORT_SET - 665)) | (1L << (EXTERIORRING - 665)) | (1L << (EXTRACTVALUE - 665)) | (1L << (FIELD - 665)) | (1L << (FIND_IN_SET - 665)) | (1L << (FLOOR - 665)) | (1L << (FORMAT - 665)) | (1L << (FOUND_ROWS - 665)) | (1L << (FROM_BASE64 - 665)) | (1L << (FROM_DAYS - 665)) | (1L << (FROM_UNIXTIME - 665)) | (1L << (GEOMCOLLFROMTEXT - 665)) | (1L << (GEOMCOLLFROMWKB - 665)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 665)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 665)) | (1L << (GEOMETRYFROMTEXT - 665)) | (1L << (GEOMETRYFROMWKB - 665)) | (1L << (GEOMETRYN - 665)) | (1L << (GEOMETRYTYPE - 665)) | (1L << (GEOMFROMTEXT - 665)) | (1L << (GEOMFROMWKB - 665)))) != 0) || ((((_la - 729)) & ~0x3f) == 0 && ((1L << (_la - 729)) & ((1L << (GET_FORMAT - 729)) | (1L << (GET_LOCK - 729)) | (1L << (GLENGTH - 729)) | (1L << (GREATEST - 729)) | (1L << (GTID_SUBSET - 729)) | (1L << (GTID_SUBTRACT - 729)) | (1L << (HEX - 729)) | (1L << (IFNULL - 729)) | (1L << (INET6_ATON - 729)) | (1L << (INET6_NTOA - 729)) | (1L << (INET_ATON - 729)) | (1L << (INET_NTOA - 729)) | (1L << (INSTR - 729)) | (1L << (INTERIORRINGN - 729)) | (1L << (INTERSECTS - 729)) | (1L << (ISCLOSED - 729)) | (1L << (ISEMPTY - 729)) | (1L << (ISNULL - 729)) | (1L << (ISSIMPLE - 729)) | (1L << (IS_FREE_LOCK - 729)) | (1L << (IS_IPV4 - 729)) | (1L << (IS_IPV4_COMPAT - 729)) | (1L << (IS_IPV4_MAPPED - 729)) | (1L << (IS_IPV6 - 729)) | (1L << (IS_USED_LOCK - 729)) | (1L << (LAST_INSERT_ID - 729)) | (1L << (LCASE - 729)) | (1L << (LEAST - 729)) | (1L << (LENGTH - 729)) | (1L << (LINEFROMTEXT - 729)) | (1L << (LINEFROMWKB - 729)) | (1L << (LINESTRINGFROMTEXT - 729)) | (1L << (LINESTRINGFROMWKB - 729)) | (1L << (LN - 729)) | (1L << (LOAD_FILE - 729)) | (1L << (LOCATE - 729)) | (1L << (LOG - 729)) | (1L << (LOG10 - 729)) | (1L << (LOG2 - 729)) | (1L << (LOWER - 729)) | (1L << (LPAD - 729)) | (1L << (LTRIM - 729)) | (1L << (MAKEDATE - 729)) | (1L << (MAKETIME - 729)) | (1L << (MAKE_SET - 729)) | (1L << (MASTER_POS_WAIT - 729)) | (1L << (MBRCONTAINS - 729)) | (1L << (MBRDISJOINT - 729)) | (1L << (MBREQUAL - 729)) | (1L << (MBRINTERSECTS - 729)) | (1L << (MBROVERLAPS - 729)) | (1L << (MBRTOUCHES - 729)) | (1L << (MBRWITHIN - 729)) | (1L << (MD5 - 729)) | (1L << (MLINEFROMTEXT - 729)) | (1L << (MLINEFROMWKB - 729)) | (1L << (MONTHNAME - 729)) | (1L << (MPOINTFROMTEXT - 729)) | (1L << (MPOINTFROMWKB - 729)) | (1L << (MPOLYFROMTEXT - 729)) | (1L << (MPOLYFROMWKB - 729)) | (1L << (MULTILINESTRINGFROMTEXT - 729)) | (1L << (MULTILINESTRINGFROMWKB - 729)) | (1L << (MULTIPOINTFROMTEXT - 729)))) != 0) || ((((_la - 793)) & ~0x3f) == 0 && ((1L << (_la - 793)) & ((1L << (MULTIPOINTFROMWKB - 793)) | (1L << (MULTIPOLYGONFROMTEXT - 793)) | (1L << (MULTIPOLYGONFROMWKB - 793)) | (1L << (NAME_CONST - 793)) | (1L << (NULLIF - 793)) | (1L << (NUMGEOMETRIES - 793)) | (1L << (NUMINTERIORRINGS - 793)) | (1L << (NUMPOINTS - 793)) | (1L << (OCT - 793)) | (1L << (OCTET_LENGTH - 793)) | (1L << (ORD - 793)) | (1L << (OVERLAPS - 793)) | (1L << (PERIOD_ADD - 793)) | (1L << (PERIOD_DIFF - 793)) | (1L << (PI - 793)) | (1L << (POINTFROMTEXT - 793)) | (1L << (POINTFROMWKB - 793)) | (1L << (POINTN - 793)) | (1L << (POLYFROMTEXT - 793)) | (1L << (POLYFROMWKB - 793)) | (1L << (POLYGONFROMTEXT - 793)) | (1L << (POLYGONFROMWKB - 793)) | (1L << (POW - 793)) | (1L << (POWER - 793)) | (1L << (QUOTE - 793)) | (1L << (RADIANS - 793)) | (1L << (RAND - 793)) | (1L << (RANDOM_BYTES - 793)) | (1L << (RELEASE_LOCK - 793)) | (1L << (REVERSE - 793)) | (1L << (ROUND - 793)) | (1L << (ROW_COUNT - 793)) | (1L << (RPAD - 793)) | (1L << (RTRIM - 793)) | (1L << (SEC_TO_TIME - 793)) | (1L << (SESSION_USER - 793)) | (1L << (SHA - 793)) | (1L << (SHA1 - 793)) | (1L << (SHA2 - 793)) | (1L << (SIGN - 793)) | (1L << (SIN - 793)) | (1L << (SLEEP - 793)) | (1L << (SOUNDEX - 793)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 793)) | (1L << (SQRT - 793)) | (1L << (SRID - 793)) | (1L << (STARTPOINT - 793)) | (1L << (STRCMP - 793)) | (1L << (STR_TO_DATE - 793)) | (1L << (ST_AREA - 793)) | (1L << (ST_ASBINARY - 793)) | (1L << (ST_ASTEXT - 793)) | (1L << (ST_ASWKB - 793)) | (1L << (ST_ASWKT - 793)) | (1L << (ST_BUFFER - 793)) | (1L << (ST_CENTROID - 793)) | (1L << (ST_CONTAINS - 793)) | (1L << (ST_CROSSES - 793)) | (1L << (ST_DIFFERENCE - 793)) | (1L << (ST_DIMENSION - 793)) | (1L << (ST_DISJOINT - 793)) | (1L << (ST_DISTANCE - 793)) | (1L << (ST_ENDPOINT - 793)) | (1L << (ST_ENVELOPE - 793)))) != 0) || ((((_la - 857)) & ~0x3f) == 0 && ((1L << (_la - 857)) & ((1L << (ST_EQUALS - 857)) | (1L << (ST_EXTERIORRING - 857)) | (1L << (ST_GEOMCOLLFROMTEXT - 857)) | (1L << (ST_GEOMCOLLFROMTXT - 857)) | (1L << (ST_GEOMCOLLFROMWKB - 857)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 857)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 857)) | (1L << (ST_GEOMETRYFROMTEXT - 857)) | (1L << (ST_GEOMETRYFROMWKB - 857)) | (1L << (ST_GEOMETRYN - 857)) | (1L << (ST_GEOMETRYTYPE - 857)) | (1L << (ST_GEOMFROMTEXT - 857)) | (1L << (ST_GEOMFROMWKB - 857)) | (1L << (ST_INTERIORRINGN - 857)) | (1L << (ST_INTERSECTION - 857)) | (1L << (ST_INTERSECTS - 857)) | (1L << (ST_ISCLOSED - 857)) | (1L << (ST_ISEMPTY - 857)) | (1L << (ST_ISSIMPLE - 857)) | (1L << (ST_LINEFROMTEXT - 857)) | (1L << (ST_LINEFROMWKB - 857)) | (1L << (ST_LINESTRINGFROMTEXT - 857)) | (1L << (ST_LINESTRINGFROMWKB - 857)) | (1L << (ST_NUMGEOMETRIES - 857)) | (1L << (ST_NUMINTERIORRING - 857)) | (1L << (ST_NUMINTERIORRINGS - 857)) | (1L << (ST_NUMPOINTS - 857)) | (1L << (ST_OVERLAPS - 857)) | (1L << (ST_POINTFROMTEXT - 857)) | (1L << (ST_POINTFROMWKB - 857)) | (1L << (ST_POINTN - 857)) | (1L << (ST_POLYFROMTEXT - 857)) | (1L << (ST_POLYFROMWKB - 857)) | (1L << (ST_POLYGONFROMTEXT - 857)) | (1L << (ST_POLYGONFROMWKB - 857)) | (1L << (ST_SRID - 857)) | (1L << (ST_STARTPOINT - 857)) | (1L << (ST_SYMDIFFERENCE - 857)) | (1L << (ST_TOUCHES - 857)) | (1L << (ST_UNION - 857)) | (1L << (ST_WITHIN - 857)) | (1L << (ST_X - 857)) | (1L << (ST_Y - 857)) | (1L << (SUBDATE - 857)) | (1L << (SUBSTRING_INDEX - 857)) | (1L << (SUBTIME - 857)) | (1L << (SYSTEM_USER - 857)) | (1L << (TAN - 857)) | (1L << (TIMEDIFF - 857)) | (1L << (TIMESTAMPADD - 857)) | (1L << (TIMESTAMPDIFF - 857)) | (1L << (TIME_FORMAT - 857)) | (1L << (TIME_TO_SEC - 857)) | (1L << (TOUCHES - 857)) | (1L << (TO_BASE64 - 857)) | (1L << (TO_DAYS - 857)) | (1L << (TO_SECONDS - 857)) | (1L << (UCASE - 857)) | (1L << (UNCOMPRESS - 857)) | (1L << (UNCOMPRESSED_LENGTH - 857)) | (1L << (UNHEX - 857)) | (1L << (UNIX_TIMESTAMP - 857)) | (1L << (UPDATEXML - 857)) | (1L << (UPPER - 857)))) != 0) || ((((_la - 921)) & ~0x3f) == 0 && ((1L << (_la - 921)) & ((1L << (UUID - 921)) | (1L << (UUID_SHORT - 921)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 921)) | (1L << (VERSION - 921)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 921)) | (1L << (WEEKDAY - 921)) | (1L << (WEEKOFYEAR - 921)) | (1L << (WEIGHT_STRING - 921)) | (1L << (WITHIN - 921)) | (1L << (YEARWEEK - 921)) | (1L << (Y_FUNCTION - 921)) | (1L << (X_FUNCTION - 921)) | (1L << (PLUS - 921)) | (1L << (MINUS - 921)) | (1L << (EXCLAMATION_SYMBOL - 921)) | (1L << (BIT_NOT_OP - 921)) | (1L << (LR_BRACKET - 921)) | (1L << (ZERO_DECIMAL - 921)) | (1L << (ONE_DECIMAL - 921)) | (1L << (TWO_DECIMAL - 921)) | (1L << (CHARSET_REVERSE_QOUTE_STRING - 921)) | (1L << (START_NATIONAL_STRING_LITERAL - 921)) | (1L << (STRING_LITERAL - 921)) | (1L << (DECIMAL_LITERAL - 921)) | (1L << (HEXADECIMAL_LITERAL - 921)) | (1L << (REAL_LITERAL - 921)) | (1L << (NULL_SPEC_LITERAL - 921)) | (1L << (BIT_STRING - 921)) | (1L << (STRING_CHARSET_NAME - 921)) | (1L << (ID - 921)) | (1L << (REVERSE_QUOTE_ID - 921)))) != 0) || _la==LOCAL_ID || _la==GLOBAL_ID) {
					{
					State = 5672; functionArgs();
					}
				}

				State = 5675; Match(RR_BRACKET);
				}
				break;
			case 5:
				_localctx = new PasswordFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 5677; passwordFunctionClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SpecificFunctionContext : ParserRuleContext {
		public SpecificFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_specificFunction; } }
	 
		public SpecificFunctionContext() { }
		public virtual void CopyFrom(SpecificFunctionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PositionFunctionCallContext : SpecificFunctionContext {
		public StringLiteralContext positionString;
		public ExpressionContext positionExpression;
		public StringLiteralContext inString;
		public ExpressionContext inExpression;
		public ITerminalNode POSITION() { return GetToken(MySqlParser.POSITION, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public StringLiteralContext[] stringLiteral() {
			return GetRuleContexts<StringLiteralContext>();
		}
		public StringLiteralContext stringLiteral(int i) {
			return GetRuleContext<StringLiteralContext>(i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public PositionFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPositionFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPositionFunctionCall(this);
		}
	}
	public partial class TrimFunctionCallContext : SpecificFunctionContext {
		public IToken positioinForm;
		public StringLiteralContext sourceString;
		public ExpressionContext sourceExpression;
		public StringLiteralContext fromString;
		public ExpressionContext fromExpression;
		public ITerminalNode TRIM() { return GetToken(MySqlParser.TRIM, 0); }
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode BOTH() { return GetToken(MySqlParser.BOTH, 0); }
		public ITerminalNode LEADING() { return GetToken(MySqlParser.LEADING, 0); }
		public ITerminalNode TRAILING() { return GetToken(MySqlParser.TRAILING, 0); }
		public StringLiteralContext[] stringLiteral() {
			return GetRuleContexts<StringLiteralContext>();
		}
		public StringLiteralContext stringLiteral(int i) {
			return GetRuleContext<StringLiteralContext>(i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public TrimFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTrimFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTrimFunctionCall(this);
		}
	}
	public partial class SimpleFunctionCallContext : SpecificFunctionContext {
		public ITerminalNode CURRENT_DATE() { return GetToken(MySqlParser.CURRENT_DATE, 0); }
		public ITerminalNode CURRENT_TIME() { return GetToken(MySqlParser.CURRENT_TIME, 0); }
		public ITerminalNode CURRENT_TIMESTAMP() { return GetToken(MySqlParser.CURRENT_TIMESTAMP, 0); }
		public ITerminalNode CURRENT_USER() { return GetToken(MySqlParser.CURRENT_USER, 0); }
		public ITerminalNode LOCALTIME() { return GetToken(MySqlParser.LOCALTIME, 0); }
		public SimpleFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleFunctionCall(this);
		}
	}
	public partial class CharFunctionCallContext : SpecificFunctionContext {
		public ITerminalNode CHAR() { return GetToken(MySqlParser.CHAR, 0); }
		public FunctionArgsContext functionArgs() {
			return GetRuleContext<FunctionArgsContext>(0);
		}
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public CharFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCharFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCharFunctionCall(this);
		}
	}
	public partial class WeightFunctionCallContext : SpecificFunctionContext {
		public IToken stringFormat;
		public ITerminalNode WEIGHT_STRING() { return GetToken(MySqlParser.WEIGHT_STRING, 0); }
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public LevelsInWeightStringContext levelsInWeightString() {
			return GetRuleContext<LevelsInWeightStringContext>(0);
		}
		public ITerminalNode CHAR() { return GetToken(MySqlParser.CHAR, 0); }
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public WeightFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterWeightFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitWeightFunctionCall(this);
		}
	}
	public partial class GetFormatFunctionCallContext : SpecificFunctionContext {
		public IToken datetimeFormat;
		public ITerminalNode GET_FORMAT() { return GetToken(MySqlParser.GET_FORMAT, 0); }
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public ITerminalNode DATE() { return GetToken(MySqlParser.DATE, 0); }
		public ITerminalNode TIME() { return GetToken(MySqlParser.TIME, 0); }
		public ITerminalNode DATETIME() { return GetToken(MySqlParser.DATETIME, 0); }
		public GetFormatFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGetFormatFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGetFormatFunctionCall(this);
		}
	}
	public partial class CaseFunctionCallContext : SpecificFunctionContext {
		public FunctionArgContext elseArg;
		public ITerminalNode CASE() { return GetToken(MySqlParser.CASE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public CaseFuncAlternativeContext[] caseFuncAlternative() {
			return GetRuleContexts<CaseFuncAlternativeContext>();
		}
		public CaseFuncAlternativeContext caseFuncAlternative(int i) {
			return GetRuleContext<CaseFuncAlternativeContext>(i);
		}
		public ITerminalNode ELSE() { return GetToken(MySqlParser.ELSE, 0); }
		public FunctionArgContext functionArg() {
			return GetRuleContext<FunctionArgContext>(0);
		}
		public CaseFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCaseFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCaseFunctionCall(this);
		}
	}
	public partial class ExtractFunctionCallContext : SpecificFunctionContext {
		public StringLiteralContext sourceString;
		public ExpressionContext sourceExpression;
		public ITerminalNode EXTRACT() { return GetToken(MySqlParser.EXTRACT, 0); }
		public IntervalTypeContext intervalType() {
			return GetRuleContext<IntervalTypeContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ExtractFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExtractFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExtractFunctionCall(this);
		}
	}
	public partial class DataTypeFunctionCallContext : SpecificFunctionContext {
		public IToken separator;
		public ITerminalNode CONVERT() { return GetToken(MySqlParser.CONVERT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ConvertedDataTypeContext convertedDataType() {
			return GetRuleContext<ConvertedDataTypeContext>(0);
		}
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode CAST() { return GetToken(MySqlParser.CAST, 0); }
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public DataTypeFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDataTypeFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDataTypeFunctionCall(this);
		}
	}
	public partial class ValuesFunctionCallContext : SpecificFunctionContext {
		public ITerminalNode VALUES() { return GetToken(MySqlParser.VALUES, 0); }
		public FullColumnNameContext fullColumnName() {
			return GetRuleContext<FullColumnNameContext>(0);
		}
		public ValuesFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterValuesFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitValuesFunctionCall(this);
		}
	}
	public partial class SubstrFunctionCallContext : SpecificFunctionContext {
		public StringLiteralContext sourceString;
		public ExpressionContext sourceExpression;
		public DecimalLiteralContext fromDecimal;
		public ExpressionContext fromExpression;
		public DecimalLiteralContext forDecimal;
		public ExpressionContext forExpression;
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode SUBSTR() { return GetToken(MySqlParser.SUBSTR, 0); }
		public ITerminalNode SUBSTRING() { return GetToken(MySqlParser.SUBSTRING, 0); }
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public SubstrFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubstrFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubstrFunctionCall(this);
		}
	}

	[RuleVersion(0)]
	public SpecificFunctionContext specificFunction() {
		SpecificFunctionContext _localctx = new SpecificFunctionContext(Context, State);
		EnterRule(_localctx, 572, RULE_specificFunction);
		int _la;
		try {
			State = 5837;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,860,Context) ) {
			case 1:
				_localctx = new SimpleFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 5680;
				_la = TokenStream.LA(1);
				if ( !(_la==CURRENT_USER || ((((_la - 233)) & ~0x3f) == 0 && ((1L << (_la - 233)) & ((1L << (CURRENT_DATE - 233)) | (1L << (CURRENT_TIME - 233)) | (1L << (CURRENT_TIMESTAMP - 233)) | (1L << (LOCALTIME - 233)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 2:
				_localctx = new DataTypeFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 5681; Match(CONVERT);
				State = 5682; Match(LR_BRACKET);
				State = 5683; expression(0);
				State = 5684; ((DataTypeFunctionCallContext)_localctx).separator = Match(COMMA);
				State = 5685; convertedDataType();
				State = 5686; Match(RR_BRACKET);
				}
				break;
			case 3:
				_localctx = new DataTypeFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 5688; Match(CONVERT);
				State = 5689; Match(LR_BRACKET);
				State = 5690; expression(0);
				State = 5691; Match(USING);
				State = 5692; charsetName();
				State = 5693; Match(RR_BRACKET);
				}
				break;
			case 4:
				_localctx = new DataTypeFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 5695; Match(CAST);
				State = 5696; Match(LR_BRACKET);
				State = 5697; expression(0);
				State = 5698; Match(AS);
				State = 5699; convertedDataType();
				State = 5700; Match(RR_BRACKET);
				}
				break;
			case 5:
				_localctx = new ValuesFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 5702; Match(VALUES);
				State = 5703; Match(LR_BRACKET);
				State = 5704; fullColumnName();
				State = 5705; Match(RR_BRACKET);
				}
				break;
			case 6:
				_localctx = new CaseFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 5707; Match(CASE);
				State = 5708; expression(0);
				State = 5710;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 5709; caseFuncAlternative();
					}
					}
					State = 5712;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==WHEN );
				State = 5716;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ELSE) {
					{
					State = 5714; Match(ELSE);
					State = 5715; ((CaseFunctionCallContext)_localctx).elseArg = functionArg();
					}
				}

				State = 5718; Match(END);
				}
				break;
			case 7:
				_localctx = new CaseFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 5720; Match(CASE);
				State = 5722;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 5721; caseFuncAlternative();
					}
					}
					State = 5724;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==WHEN );
				State = 5728;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ELSE) {
					{
					State = 5726; Match(ELSE);
					State = 5727; ((CaseFunctionCallContext)_localctx).elseArg = functionArg();
					}
				}

				State = 5730; Match(END);
				}
				break;
			case 8:
				_localctx = new CharFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 5732; Match(CHAR);
				State = 5733; Match(LR_BRACKET);
				State = 5734; functionArgs();
				State = 5737;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 5735; Match(USING);
					State = 5736; charsetName();
					}
				}

				State = 5739; Match(RR_BRACKET);
				}
				break;
			case 9:
				_localctx = new PositionFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 5741; Match(POSITION);
				State = 5742; Match(LR_BRACKET);
				State = 5745;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,846,Context) ) {
				case 1:
					{
					State = 5743; ((PositionFunctionCallContext)_localctx).positionString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5744; ((PositionFunctionCallContext)_localctx).positionExpression = expression(0);
					}
					break;
				}
				State = 5747; Match(IN);
				State = 5750;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,847,Context) ) {
				case 1:
					{
					State = 5748; ((PositionFunctionCallContext)_localctx).inString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5749; ((PositionFunctionCallContext)_localctx).inExpression = expression(0);
					}
					break;
				}
				State = 5752; Match(RR_BRACKET);
				}
				break;
			case 10:
				_localctx = new SubstrFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 5754;
				_la = TokenStream.LA(1);
				if ( !(_la==SUBSTR || _la==SUBSTRING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5755; Match(LR_BRACKET);
				State = 5758;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,848,Context) ) {
				case 1:
					{
					State = 5756; ((SubstrFunctionCallContext)_localctx).sourceString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5757; ((SubstrFunctionCallContext)_localctx).sourceExpression = expression(0);
					}
					break;
				}
				State = 5760; Match(FROM);
				State = 5763;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,849,Context) ) {
				case 1:
					{
					State = 5761; ((SubstrFunctionCallContext)_localctx).fromDecimal = decimalLiteral();
					}
					break;
				case 2:
					{
					State = 5762; ((SubstrFunctionCallContext)_localctx).fromExpression = expression(0);
					}
					break;
				}
				State = 5770;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 5765; Match(FOR);
					State = 5768;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,850,Context) ) {
					case 1:
						{
						State = 5766; ((SubstrFunctionCallContext)_localctx).forDecimal = decimalLiteral();
						}
						break;
					case 2:
						{
						State = 5767; ((SubstrFunctionCallContext)_localctx).forExpression = expression(0);
						}
						break;
					}
					}
				}

				State = 5772; Match(RR_BRACKET);
				}
				break;
			case 11:
				_localctx = new TrimFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 5774; Match(TRIM);
				State = 5775; Match(LR_BRACKET);
				State = 5776;
				((TrimFunctionCallContext)_localctx).positioinForm = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==BOTH || _la==LEADING || _la==TRAILING) ) {
					((TrimFunctionCallContext)_localctx).positioinForm = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5779;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,852,Context) ) {
				case 1:
					{
					State = 5777; ((TrimFunctionCallContext)_localctx).sourceString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5778; ((TrimFunctionCallContext)_localctx).sourceExpression = expression(0);
					}
					break;
				}
				State = 5781; Match(FROM);
				State = 5784;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,853,Context) ) {
				case 1:
					{
					State = 5782; ((TrimFunctionCallContext)_localctx).fromString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5783; ((TrimFunctionCallContext)_localctx).fromExpression = expression(0);
					}
					break;
				}
				State = 5786; Match(RR_BRACKET);
				}
				break;
			case 12:
				_localctx = new TrimFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 5788; Match(TRIM);
				State = 5789; Match(LR_BRACKET);
				State = 5792;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,854,Context) ) {
				case 1:
					{
					State = 5790; ((TrimFunctionCallContext)_localctx).sourceString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5791; ((TrimFunctionCallContext)_localctx).sourceExpression = expression(0);
					}
					break;
				}
				State = 5794; Match(FROM);
				State = 5797;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,855,Context) ) {
				case 1:
					{
					State = 5795; ((TrimFunctionCallContext)_localctx).fromString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5796; ((TrimFunctionCallContext)_localctx).fromExpression = expression(0);
					}
					break;
				}
				State = 5799; Match(RR_BRACKET);
				}
				break;
			case 13:
				_localctx = new WeightFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 5801; Match(WEIGHT_STRING);
				State = 5802; Match(LR_BRACKET);
				State = 5805;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,856,Context) ) {
				case 1:
					{
					State = 5803; stringLiteral();
					}
					break;
				case 2:
					{
					State = 5804; expression(0);
					}
					break;
				}
				State = 5813;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 5807; Match(AS);
					State = 5808;
					((WeightFunctionCallContext)_localctx).stringFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==CHAR || _la==BINARY) ) {
						((WeightFunctionCallContext)_localctx).stringFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 5809; Match(LR_BRACKET);
					State = 5810; decimalLiteral();
					State = 5811; Match(RR_BRACKET);
					}
				}

				State = 5816;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LEVEL) {
					{
					State = 5815; levelsInWeightString();
					}
				}

				State = 5818; Match(RR_BRACKET);
				}
				break;
			case 14:
				_localctx = new ExtractFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 5820; Match(EXTRACT);
				State = 5821; Match(LR_BRACKET);
				State = 5822; intervalType();
				State = 5823; Match(FROM);
				State = 5826;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,859,Context) ) {
				case 1:
					{
					State = 5824; ((ExtractFunctionCallContext)_localctx).sourceString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5825; ((ExtractFunctionCallContext)_localctx).sourceExpression = expression(0);
					}
					break;
				}
				State = 5828; Match(RR_BRACKET);
				}
				break;
			case 15:
				_localctx = new GetFormatFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 5830; Match(GET_FORMAT);
				State = 5831; Match(LR_BRACKET);
				State = 5832;
				((GetFormatFunctionCallContext)_localctx).datetimeFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (DATETIME - 184)))) != 0)) ) {
					((GetFormatFunctionCallContext)_localctx).datetimeFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5833; Match(COMMA);
				State = 5834; stringLiteral();
				State = 5835; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseFuncAlternativeContext : ParserRuleContext {
		public FunctionArgContext condition;
		public FunctionArgContext consequent;
		public ITerminalNode WHEN() { return GetToken(MySqlParser.WHEN, 0); }
		public ITerminalNode THEN() { return GetToken(MySqlParser.THEN, 0); }
		public FunctionArgContext[] functionArg() {
			return GetRuleContexts<FunctionArgContext>();
		}
		public FunctionArgContext functionArg(int i) {
			return GetRuleContext<FunctionArgContext>(i);
		}
		public CaseFuncAlternativeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseFuncAlternative; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCaseFuncAlternative(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCaseFuncAlternative(this);
		}
	}

	[RuleVersion(0)]
	public CaseFuncAlternativeContext caseFuncAlternative() {
		CaseFuncAlternativeContext _localctx = new CaseFuncAlternativeContext(Context, State);
		EnterRule(_localctx, 574, RULE_caseFuncAlternative);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5839; Match(WHEN);
			State = 5840; _localctx.condition = functionArg();
			State = 5841; Match(THEN);
			State = 5842; _localctx.consequent = functionArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LevelsInWeightStringContext : ParserRuleContext {
		public LevelsInWeightStringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_levelsInWeightString; } }
	 
		public LevelsInWeightStringContext() { }
		public virtual void CopyFrom(LevelsInWeightStringContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class LevelWeightRangeContext : LevelsInWeightStringContext {
		public DecimalLiteralContext firstLevel;
		public DecimalLiteralContext lastLevel;
		public ITerminalNode LEVEL() { return GetToken(MySqlParser.LEVEL, 0); }
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public LevelWeightRangeContext(LevelsInWeightStringContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLevelWeightRange(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLevelWeightRange(this);
		}
	}
	public partial class LevelWeightListContext : LevelsInWeightStringContext {
		public ITerminalNode LEVEL() { return GetToken(MySqlParser.LEVEL, 0); }
		public LevelInWeightListElementContext[] levelInWeightListElement() {
			return GetRuleContexts<LevelInWeightListElementContext>();
		}
		public LevelInWeightListElementContext levelInWeightListElement(int i) {
			return GetRuleContext<LevelInWeightListElementContext>(i);
		}
		public LevelWeightListContext(LevelsInWeightStringContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLevelWeightList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLevelWeightList(this);
		}
	}

	[RuleVersion(0)]
	public LevelsInWeightStringContext levelsInWeightString() {
		LevelsInWeightStringContext _localctx = new LevelsInWeightStringContext(Context, State);
		EnterRule(_localctx, 576, RULE_levelsInWeightString);
		int _la;
		try {
			State = 5858;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,862,Context) ) {
			case 1:
				_localctx = new LevelWeightListContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 5844; Match(LEVEL);
				State = 5845; levelInWeightListElement();
				State = 5850;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 5846; Match(COMMA);
					State = 5847; levelInWeightListElement();
					}
					}
					State = 5852;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new LevelWeightRangeContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 5853; Match(LEVEL);
				State = 5854; ((LevelWeightRangeContext)_localctx).firstLevel = decimalLiteral();
				State = 5855; Match(MINUS);
				State = 5856; ((LevelWeightRangeContext)_localctx).lastLevel = decimalLiteral();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LevelInWeightListElementContext : ParserRuleContext {
		public IToken orderType;
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode ASC() { return GetToken(MySqlParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(MySqlParser.DESC, 0); }
		public ITerminalNode REVERSE() { return GetToken(MySqlParser.REVERSE, 0); }
		public LevelInWeightListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_levelInWeightListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLevelInWeightListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLevelInWeightListElement(this);
		}
	}

	[RuleVersion(0)]
	public LevelInWeightListElementContext levelInWeightListElement() {
		LevelInWeightListElementContext _localctx = new LevelInWeightListElementContext(Context, State);
		EnterRule(_localctx, 578, RULE_levelInWeightListElement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5860; decimalLiteral();
			State = 5862;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASC || _la==DESC || _la==REVERSE) {
				{
				State = 5861;
				_localctx.orderType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ASC || _la==DESC || _la==REVERSE) ) {
					_localctx.orderType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AggregateWindowedFunctionContext : ParserRuleContext {
		public IToken aggregator;
		public IToken starArg;
		public IToken separator;
		public FunctionArgContext functionArg() {
			return GetRuleContext<FunctionArgContext>(0);
		}
		public ITerminalNode AVG() { return GetToken(MySqlParser.AVG, 0); }
		public ITerminalNode MAX() { return GetToken(MySqlParser.MAX, 0); }
		public ITerminalNode MIN() { return GetToken(MySqlParser.MIN, 0); }
		public ITerminalNode SUM() { return GetToken(MySqlParser.SUM, 0); }
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(MySqlParser.DISTINCT, 0); }
		public ITerminalNode COUNT() { return GetToken(MySqlParser.COUNT, 0); }
		public FunctionArgsContext functionArgs() {
			return GetRuleContext<FunctionArgsContext>(0);
		}
		public ITerminalNode BIT_AND() { return GetToken(MySqlParser.BIT_AND, 0); }
		public ITerminalNode BIT_OR() { return GetToken(MySqlParser.BIT_OR, 0); }
		public ITerminalNode BIT_XOR() { return GetToken(MySqlParser.BIT_XOR, 0); }
		public ITerminalNode STD() { return GetToken(MySqlParser.STD, 0); }
		public ITerminalNode STDDEV() { return GetToken(MySqlParser.STDDEV, 0); }
		public ITerminalNode STDDEV_POP() { return GetToken(MySqlParser.STDDEV_POP, 0); }
		public ITerminalNode STDDEV_SAMP() { return GetToken(MySqlParser.STDDEV_SAMP, 0); }
		public ITerminalNode VAR_POP() { return GetToken(MySqlParser.VAR_POP, 0); }
		public ITerminalNode VAR_SAMP() { return GetToken(MySqlParser.VAR_SAMP, 0); }
		public ITerminalNode VARIANCE() { return GetToken(MySqlParser.VARIANCE, 0); }
		public ITerminalNode GROUP_CONCAT() { return GetToken(MySqlParser.GROUP_CONCAT, 0); }
		public ITerminalNode ORDER() { return GetToken(MySqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public OrderByExpressionContext[] orderByExpression() {
			return GetRuleContexts<OrderByExpressionContext>();
		}
		public OrderByExpressionContext orderByExpression(int i) {
			return GetRuleContext<OrderByExpressionContext>(i);
		}
		public ITerminalNode SEPARATOR() { return GetToken(MySqlParser.SEPARATOR, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public AggregateWindowedFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aggregateWindowedFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAggregateWindowedFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAggregateWindowedFunction(this);
		}
	}

	[RuleVersion(0)]
	public AggregateWindowedFunctionContext aggregateWindowedFunction() {
		AggregateWindowedFunctionContext _localctx = new AggregateWindowedFunctionContext(Context, State);
		EnterRule(_localctx, 580, RULE_aggregateWindowedFunction);
		int _la;
		try {
			State = 5920;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,872,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5864;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 217)) & ~0x3f) == 0 && ((1L << (_la - 217)) & ((1L << (AVG - 217)) | (1L << (MAX - 217)) | (1L << (MIN - 217)) | (1L << (SUM - 217)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5865; Match(LR_BRACKET);
				State = 5867;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALL || _la==DISTINCT) {
					{
					State = 5866;
					_localctx.aggregator = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==ALL || _la==DISTINCT) ) {
						_localctx.aggregator = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 5869; functionArg();
				State = 5870; Match(RR_BRACKET);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5872; Match(COUNT);
				State = 5873; Match(LR_BRACKET);
				State = 5879;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case STAR:
					{
					State = 5874; _localctx.starArg = Match(STAR);
					}
					break;
				case ALL:
				case CASE:
				case CAST:
				case CONVERT:
				case CURRENT_USER:
				case DATABASE:
				case EXISTS:
				case FALSE:
				case IF:
				case INSERT:
				case INTERVAL:
				case LEFT:
				case NOT:
				case NULL_LITERAL:
				case REPLACE:
				case RIGHT:
				case TRUE:
				case VALUES:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case CHAR:
				case BINARY:
				case TEXT:
				case ENUM:
				case SERIAL:
				case AVG:
				case BIT_AND:
				case BIT_OR:
				case BIT_XOR:
				case COUNT:
				case GROUP_CONCAT:
				case MAX:
				case MIN:
				case STD:
				case STDDEV:
				case STDDEV_POP:
				case STDDEV_SAMP:
				case SUM:
				case VAR_POP:
				case VAR_SAMP:
				case VARIANCE:
				case CURRENT_DATE:
				case CURRENT_TIME:
				case CURRENT_TIMESTAMP:
				case LOCALTIME:
				case CURDATE:
				case CURTIME:
				case DATE_ADD:
				case DATE_SUB:
				case EXTRACT:
				case LOCALTIMESTAMP:
				case NOW:
				case POSITION:
				case SUBSTR:
				case SUBSTRING:
				case SYSDATE:
				case TRIM:
				case UTC_DATE:
				case UTC_TIME:
				case UTC_TIMESTAMP:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case PLUS:
				case MINUS:
				case EXCLAMATION_SYMBOL:
				case BIT_NOT_OP:
				case LR_BRACKET:
				case ZERO_DECIMAL:
				case ONE_DECIMAL:
				case TWO_DECIMAL:
				case CHARSET_REVERSE_QOUTE_STRING:
				case START_NATIONAL_STRING_LITERAL:
				case STRING_LITERAL:
				case DECIMAL_LITERAL:
				case HEXADECIMAL_LITERAL:
				case REAL_LITERAL:
				case NULL_SPEC_LITERAL:
				case BIT_STRING:
				case STRING_CHARSET_NAME:
				case ID:
				case REVERSE_QUOTE_ID:
				case LOCAL_ID:
				case GLOBAL_ID:
					{
					State = 5876;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==ALL) {
						{
						State = 5875; _localctx.aggregator = Match(ALL);
						}
					}

					State = 5878; functionArg();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5881; Match(RR_BRACKET);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5882; Match(COUNT);
				State = 5883; Match(LR_BRACKET);
				State = 5884; _localctx.aggregator = Match(DISTINCT);
				State = 5885; functionArgs();
				State = 5886; Match(RR_BRACKET);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5888;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 218)) & ~0x3f) == 0 && ((1L << (_la - 218)) & ((1L << (BIT_AND - 218)) | (1L << (BIT_OR - 218)) | (1L << (BIT_XOR - 218)) | (1L << (STD - 218)) | (1L << (STDDEV - 218)) | (1L << (STDDEV_POP - 218)) | (1L << (STDDEV_SAMP - 218)) | (1L << (VAR_POP - 218)) | (1L << (VAR_SAMP - 218)) | (1L << (VARIANCE - 218)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5889; Match(LR_BRACKET);
				State = 5891;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALL) {
					{
					State = 5890; _localctx.aggregator = Match(ALL);
					}
				}

				State = 5893; functionArg();
				State = 5894; Match(RR_BRACKET);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5896; Match(GROUP_CONCAT);
				State = 5897; Match(LR_BRACKET);
				State = 5899;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DISTINCT) {
					{
					State = 5898; _localctx.aggregator = Match(DISTINCT);
					}
				}

				State = 5901; functionArgs();
				State = 5912;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ORDER) {
					{
					State = 5902; Match(ORDER);
					State = 5903; Match(BY);
					State = 5904; orderByExpression();
					State = 5909;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 5905; Match(COMMA);
						State = 5906; orderByExpression();
						}
						}
						State = 5911;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 5916;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SEPARATOR) {
					{
					State = 5914; Match(SEPARATOR);
					State = 5915; _localctx.separator = Match(STRING_LITERAL);
					}
				}

				State = 5918; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScalarFunctionNameContext : ParserRuleContext {
		public FunctionNameBaseContext functionNameBase() {
			return GetRuleContext<FunctionNameBaseContext>(0);
		}
		public ITerminalNode ASCII() { return GetToken(MySqlParser.ASCII, 0); }
		public ITerminalNode CURDATE() { return GetToken(MySqlParser.CURDATE, 0); }
		public ITerminalNode CURRENT_DATE() { return GetToken(MySqlParser.CURRENT_DATE, 0); }
		public ITerminalNode CURRENT_TIME() { return GetToken(MySqlParser.CURRENT_TIME, 0); }
		public ITerminalNode CURRENT_TIMESTAMP() { return GetToken(MySqlParser.CURRENT_TIMESTAMP, 0); }
		public ITerminalNode CURTIME() { return GetToken(MySqlParser.CURTIME, 0); }
		public ITerminalNode DATE_ADD() { return GetToken(MySqlParser.DATE_ADD, 0); }
		public ITerminalNode DATE_SUB() { return GetToken(MySqlParser.DATE_SUB, 0); }
		public ITerminalNode IF() { return GetToken(MySqlParser.IF, 0); }
		public ITerminalNode INSERT() { return GetToken(MySqlParser.INSERT, 0); }
		public ITerminalNode LOCALTIME() { return GetToken(MySqlParser.LOCALTIME, 0); }
		public ITerminalNode LOCALTIMESTAMP() { return GetToken(MySqlParser.LOCALTIMESTAMP, 0); }
		public ITerminalNode MID() { return GetToken(MySqlParser.MID, 0); }
		public ITerminalNode NOW() { return GetToken(MySqlParser.NOW, 0); }
		public ITerminalNode REPLACE() { return GetToken(MySqlParser.REPLACE, 0); }
		public ITerminalNode SUBSTR() { return GetToken(MySqlParser.SUBSTR, 0); }
		public ITerminalNode SUBSTRING() { return GetToken(MySqlParser.SUBSTRING, 0); }
		public ITerminalNode SYSDATE() { return GetToken(MySqlParser.SYSDATE, 0); }
		public ITerminalNode TRIM() { return GetToken(MySqlParser.TRIM, 0); }
		public ITerminalNode UTC_DATE() { return GetToken(MySqlParser.UTC_DATE, 0); }
		public ITerminalNode UTC_TIME() { return GetToken(MySqlParser.UTC_TIME, 0); }
		public ITerminalNode UTC_TIMESTAMP() { return GetToken(MySqlParser.UTC_TIMESTAMP, 0); }
		public ScalarFunctionNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scalarFunctionName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterScalarFunctionName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitScalarFunctionName(this);
		}
	}

	[RuleVersion(0)]
	public ScalarFunctionNameContext scalarFunctionName() {
		ScalarFunctionNameContext _localctx = new ScalarFunctionNameContext(Context, State);
		EnterRule(_localctx, 582, RULE_scalarFunctionName);
		try {
			State = 5945;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DATABASE:
			case LEFT:
			case RIGHT:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case YEAR:
			case COUNT:
			case POSITION:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5922; functionNameBase();
				}
				break;
			case ASCII:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5923; Match(ASCII);
				}
				break;
			case CURDATE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5924; Match(CURDATE);
				}
				break;
			case CURRENT_DATE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5925; Match(CURRENT_DATE);
				}
				break;
			case CURRENT_TIME:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5926; Match(CURRENT_TIME);
				}
				break;
			case CURRENT_TIMESTAMP:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5927; Match(CURRENT_TIMESTAMP);
				}
				break;
			case CURTIME:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5928; Match(CURTIME);
				}
				break;
			case DATE_ADD:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5929; Match(DATE_ADD);
				}
				break;
			case DATE_SUB:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5930; Match(DATE_SUB);
				}
				break;
			case IF:
				EnterOuterAlt(_localctx, 10);
				{
				State = 5931; Match(IF);
				}
				break;
			case INSERT:
				EnterOuterAlt(_localctx, 11);
				{
				State = 5932; Match(INSERT);
				}
				break;
			case LOCALTIME:
				EnterOuterAlt(_localctx, 12);
				{
				State = 5933; Match(LOCALTIME);
				}
				break;
			case LOCALTIMESTAMP:
				EnterOuterAlt(_localctx, 13);
				{
				State = 5934; Match(LOCALTIMESTAMP);
				}
				break;
			case MID:
				EnterOuterAlt(_localctx, 14);
				{
				State = 5935; Match(MID);
				}
				break;
			case NOW:
				EnterOuterAlt(_localctx, 15);
				{
				State = 5936; Match(NOW);
				}
				break;
			case REPLACE:
				EnterOuterAlt(_localctx, 16);
				{
				State = 5937; Match(REPLACE);
				}
				break;
			case SUBSTR:
				EnterOuterAlt(_localctx, 17);
				{
				State = 5938; Match(SUBSTR);
				}
				break;
			case SUBSTRING:
				EnterOuterAlt(_localctx, 18);
				{
				State = 5939; Match(SUBSTRING);
				}
				break;
			case SYSDATE:
				EnterOuterAlt(_localctx, 19);
				{
				State = 5940; Match(SYSDATE);
				}
				break;
			case TRIM:
				EnterOuterAlt(_localctx, 20);
				{
				State = 5941; Match(TRIM);
				}
				break;
			case UTC_DATE:
				EnterOuterAlt(_localctx, 21);
				{
				State = 5942; Match(UTC_DATE);
				}
				break;
			case UTC_TIME:
				EnterOuterAlt(_localctx, 22);
				{
				State = 5943; Match(UTC_TIME);
				}
				break;
			case UTC_TIMESTAMP:
				EnterOuterAlt(_localctx, 23);
				{
				State = 5944; Match(UTC_TIMESTAMP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PasswordFunctionClauseContext : ParserRuleContext {
		public IToken functionName;
		public FunctionArgContext functionArg() {
			return GetRuleContext<FunctionArgContext>(0);
		}
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode OLD_PASSWORD() { return GetToken(MySqlParser.OLD_PASSWORD, 0); }
		public PasswordFunctionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_passwordFunctionClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPasswordFunctionClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPasswordFunctionClause(this);
		}
	}

	[RuleVersion(0)]
	public PasswordFunctionClauseContext passwordFunctionClause() {
		PasswordFunctionClauseContext _localctx = new PasswordFunctionClauseContext(Context, State);
		EnterRule(_localctx, 584, RULE_passwordFunctionClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5947;
			_localctx.functionName = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==OLD_PASSWORD || _la==PASSWORD) ) {
				_localctx.functionName = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5948; Match(LR_BRACKET);
			State = 5949; functionArg();
			State = 5950; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionArgsContext : ParserRuleContext {
		public ConstantContext[] constant() {
			return GetRuleContexts<ConstantContext>();
		}
		public ConstantContext constant(int i) {
			return GetRuleContext<ConstantContext>(i);
		}
		public FullColumnNameContext[] fullColumnName() {
			return GetRuleContexts<FullColumnNameContext>();
		}
		public FullColumnNameContext fullColumnName(int i) {
			return GetRuleContext<FullColumnNameContext>(i);
		}
		public FunctionCallContext[] functionCall() {
			return GetRuleContexts<FunctionCallContext>();
		}
		public FunctionCallContext functionCall(int i) {
			return GetRuleContext<FunctionCallContext>(i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public FunctionArgsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionArgs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFunctionArgs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFunctionArgs(this);
		}
	}

	[RuleVersion(0)]
	public FunctionArgsContext functionArgs() {
		FunctionArgsContext _localctx = new FunctionArgsContext(Context, State);
		EnterRule(_localctx, 586, RULE_functionArgs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5956;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,874,Context) ) {
			case 1:
				{
				State = 5952; constant();
				}
				break;
			case 2:
				{
				State = 5953; fullColumnName();
				}
				break;
			case 3:
				{
				State = 5954; functionCall();
				}
				break;
			case 4:
				{
				State = 5955; expression(0);
				}
				break;
			}
			State = 5967;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5958; Match(COMMA);
				State = 5963;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,875,Context) ) {
				case 1:
					{
					State = 5959; constant();
					}
					break;
				case 2:
					{
					State = 5960; fullColumnName();
					}
					break;
				case 3:
					{
					State = 5961; functionCall();
					}
					break;
				case 4:
					{
					State = 5962; expression(0);
					}
					break;
				}
				}
				}
				State = 5969;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionArgContext : ParserRuleContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public FullColumnNameContext fullColumnName() {
			return GetRuleContext<FullColumnNameContext>(0);
		}
		public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public FunctionArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionArg; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFunctionArg(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFunctionArg(this);
		}
	}

	[RuleVersion(0)]
	public FunctionArgContext functionArg() {
		FunctionArgContext _localctx = new FunctionArgContext(Context, State);
		EnterRule(_localctx, 588, RULE_functionArg);
		try {
			State = 5974;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,877,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5970; constant();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5971; fullColumnName();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5972; functionCall();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5973; expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IsExpressionContext : ExpressionContext {
		public IToken testValue;
		public PredicateContext predicate() {
			return GetRuleContext<PredicateContext>(0);
		}
		public ITerminalNode IS() { return GetToken(MySqlParser.IS, 0); }
		public ITerminalNode TRUE() { return GetToken(MySqlParser.TRUE, 0); }
		public ITerminalNode FALSE() { return GetToken(MySqlParser.FALSE, 0); }
		public ITerminalNode UNKNOWN() { return GetToken(MySqlParser.UNKNOWN, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public IsExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIsExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIsExpression(this);
		}
	}
	public partial class NotExpressionContext : ExpressionContext {
		public IToken notOperator;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public NotExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNotExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNotExpression(this);
		}
	}
	public partial class LogicalExpressionContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public LogicalOperatorContext logicalOperator() {
			return GetRuleContext<LogicalOperatorContext>(0);
		}
		public LogicalExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLogicalExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLogicalExpression(this);
		}
	}
	public partial class PredicateExpressionContext : ExpressionContext {
		public PredicateContext predicate() {
			return GetRuleContext<PredicateContext>(0);
		}
		public PredicateExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPredicateExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPredicateExpression(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(Context, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 590;
		EnterRecursionRule(_localctx, 590, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5987;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,879,Context) ) {
			case 1:
				{
				_localctx = new NotExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 5977;
				((NotExpressionContext)_localctx).notOperator = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==NOT || _la==EXCLAMATION_SYMBOL) ) {
					((NotExpressionContext)_localctx).notOperator = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5978; expression(4);
				}
				break;
			case 2:
				{
				_localctx = new IsExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 5979; predicate(0);
				State = 5980; Match(IS);
				State = 5982;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 5981; Match(NOT);
					}
				}

				State = 5984;
				((IsExpressionContext)_localctx).testValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FALSE || _la==TRUE || _la==UNKNOWN) ) {
					((IsExpressionContext)_localctx).testValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 3:
				{
				_localctx = new PredicateExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 5986; predicate(0);
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 5995;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,880,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new LogicalExpressionContext(new ExpressionContext(_parentctx, _parentState));
					PushNewRecursionContext(_localctx, _startState, RULE_expression);
					State = 5989;
					if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
					State = 5990; logicalOperator();
					State = 5991; expression(4);
					}
					} 
				}
				State = 5997;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,880,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class PredicateContext : ParserRuleContext {
		public PredicateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predicate; } }
	 
		public PredicateContext() { }
		public virtual void CopyFrom(PredicateContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SoundsLikePredicateContext : PredicateContext {
		public PredicateContext[] predicate() {
			return GetRuleContexts<PredicateContext>();
		}
		public PredicateContext predicate(int i) {
			return GetRuleContext<PredicateContext>(i);
		}
		public ITerminalNode SOUNDS() { return GetToken(MySqlParser.SOUNDS, 0); }
		public ITerminalNode LIKE() { return GetToken(MySqlParser.LIKE, 0); }
		public SoundsLikePredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSoundsLikePredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSoundsLikePredicate(this);
		}
	}
	public partial class ExpressionAtomPredicateContext : PredicateContext {
		public ExpressionAtomContext expressionAtom() {
			return GetRuleContext<ExpressionAtomContext>(0);
		}
		public ITerminalNode LOCAL_ID() { return GetToken(MySqlParser.LOCAL_ID, 0); }
		public ITerminalNode VAR_ASSIGN() { return GetToken(MySqlParser.VAR_ASSIGN, 0); }
		public ExpressionAtomPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExpressionAtomPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExpressionAtomPredicate(this);
		}
	}
	public partial class InPredicateContext : PredicateContext {
		public PredicateContext predicate() {
			return GetRuleContext<PredicateContext>(0);
		}
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public InPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterInPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitInPredicate(this);
		}
	}
	public partial class SubqueryComparasionPredicateContext : PredicateContext {
		public IToken quantifier;
		public PredicateContext predicate() {
			return GetRuleContext<PredicateContext>(0);
		}
		public ComparisonOperatorContext comparisonOperator() {
			return GetRuleContext<ComparisonOperatorContext>(0);
		}
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode ANY() { return GetToken(MySqlParser.ANY, 0); }
		public ITerminalNode SOME() { return GetToken(MySqlParser.SOME, 0); }
		public SubqueryComparasionPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubqueryComparasionPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubqueryComparasionPredicate(this);
		}
	}
	public partial class BetweenPredicateContext : PredicateContext {
		public PredicateContext[] predicate() {
			return GetRuleContexts<PredicateContext>();
		}
		public PredicateContext predicate(int i) {
			return GetRuleContext<PredicateContext>(i);
		}
		public ITerminalNode BETWEEN() { return GetToken(MySqlParser.BETWEEN, 0); }
		public ITerminalNode AND() { return GetToken(MySqlParser.AND, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public BetweenPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBetweenPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBetweenPredicate(this);
		}
	}
	public partial class BinaryComparasionPredicateContext : PredicateContext {
		public PredicateContext left;
		public PredicateContext right;
		public ComparisonOperatorContext comparisonOperator() {
			return GetRuleContext<ComparisonOperatorContext>(0);
		}
		public PredicateContext[] predicate() {
			return GetRuleContexts<PredicateContext>();
		}
		public PredicateContext predicate(int i) {
			return GetRuleContext<PredicateContext>(i);
		}
		public BinaryComparasionPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBinaryComparasionPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBinaryComparasionPredicate(this);
		}
	}
	public partial class IsNullPredicateContext : PredicateContext {
		public PredicateContext predicate() {
			return GetRuleContext<PredicateContext>(0);
		}
		public ITerminalNode IS() { return GetToken(MySqlParser.IS, 0); }
		public NullNotnullContext nullNotnull() {
			return GetRuleContext<NullNotnullContext>(0);
		}
		public IsNullPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIsNullPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIsNullPredicate(this);
		}
	}
	public partial class LikePredicateContext : PredicateContext {
		public PredicateContext[] predicate() {
			return GetRuleContexts<PredicateContext>();
		}
		public PredicateContext predicate(int i) {
			return GetRuleContext<PredicateContext>(i);
		}
		public ITerminalNode LIKE() { return GetToken(MySqlParser.LIKE, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public ITerminalNode ESCAPE() { return GetToken(MySqlParser.ESCAPE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public LikePredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLikePredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLikePredicate(this);
		}
	}
	public partial class RegexpPredicateContext : PredicateContext {
		public IToken regex;
		public PredicateContext[] predicate() {
			return GetRuleContexts<PredicateContext>();
		}
		public PredicateContext predicate(int i) {
			return GetRuleContext<PredicateContext>(i);
		}
		public ITerminalNode REGEXP() { return GetToken(MySqlParser.REGEXP, 0); }
		public ITerminalNode RLIKE() { return GetToken(MySqlParser.RLIKE, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public RegexpPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRegexpPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRegexpPredicate(this);
		}
	}

	[RuleVersion(0)]
	public PredicateContext predicate() {
		return predicate(0);
	}

	private PredicateContext predicate(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		PredicateContext _localctx = new PredicateContext(Context, _parentState);
		PredicateContext _prevctx = _localctx;
		int _startState = 592;
		EnterRecursionRule(_localctx, 592, RULE_predicate, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new ExpressionAtomPredicateContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 6001;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,881,Context) ) {
			case 1:
				{
				State = 5999; Match(LOCAL_ID);
				State = 6000; Match(VAR_ASSIGN);
				}
				break;
			}
			State = 6003; expressionAtom(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 6062;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,889,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 6060;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,888,Context) ) {
					case 1:
						{
						_localctx = new BinaryComparasionPredicateContext(new PredicateContext(_parentctx, _parentState));
						((BinaryComparasionPredicateContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6005;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 6006; comparisonOperator();
						State = 6007; ((BinaryComparasionPredicateContext)_localctx).right = predicate(8);
						}
						break;
					case 2:
						{
						_localctx = new BetweenPredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6009;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 6011;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 6010; Match(NOT);
							}
						}

						State = 6013; Match(BETWEEN);
						State = 6014; predicate(0);
						State = 6015; Match(AND);
						State = 6016; predicate(6);
						}
						break;
					case 3:
						{
						_localctx = new SoundsLikePredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6018;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 6019; Match(SOUNDS);
						State = 6020; Match(LIKE);
						State = 6021; predicate(5);
						}
						break;
					case 4:
						{
						_localctx = new RegexpPredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6022;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 6024;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 6023; Match(NOT);
							}
						}

						State = 6026;
						((RegexpPredicateContext)_localctx).regex = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==REGEXP || _la==RLIKE) ) {
							((RegexpPredicateContext)_localctx).regex = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 6027; predicate(3);
						}
						break;
					case 5:
						{
						_localctx = new InPredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6028;
						if (!(Precpred(Context, 9))) throw new FailedPredicateException(this, "Precpred(Context, 9)");
						State = 6030;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 6029; Match(NOT);
							}
						}

						State = 6032; Match(IN);
						State = 6033; Match(LR_BRACKET);
						State = 6036;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,885,Context) ) {
						case 1:
							{
							State = 6034; selectStatement();
							}
							break;
						case 2:
							{
							State = 6035; expressions();
							}
							break;
						}
						State = 6038; Match(RR_BRACKET);
						}
						break;
					case 6:
						{
						_localctx = new IsNullPredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6040;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 6041; Match(IS);
						State = 6042; nullNotnull();
						}
						break;
					case 7:
						{
						_localctx = new SubqueryComparasionPredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6043;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 6044; comparisonOperator();
						State = 6045;
						((SubqueryComparasionPredicateContext)_localctx).quantifier = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==ALL || _la==ANY || _la==SOME) ) {
							((SubqueryComparasionPredicateContext)_localctx).quantifier = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 6046; Match(LR_BRACKET);
						State = 6047; selectStatement();
						State = 6048; Match(RR_BRACKET);
						}
						break;
					case 8:
						{
						_localctx = new LikePredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6050;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 6052;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 6051; Match(NOT);
							}
						}

						State = 6054; Match(LIKE);
						State = 6055; predicate(0);
						State = 6058;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,887,Context) ) {
						case 1:
							{
							State = 6056; Match(ESCAPE);
							State = 6057; Match(STRING_LITERAL);
							}
							break;
						}
						}
						break;
					}
					} 
				}
				State = 6064;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,889,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ExpressionAtomContext : ParserRuleContext {
		public ExpressionAtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionAtom; } }
	 
		public ExpressionAtomContext() { }
		public virtual void CopyFrom(ExpressionAtomContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class UnaryExpressionAtomContext : ExpressionAtomContext {
		public UnaryOperatorContext unaryOperator() {
			return GetRuleContext<UnaryOperatorContext>(0);
		}
		public ExpressionAtomContext expressionAtom() {
			return GetRuleContext<ExpressionAtomContext>(0);
		}
		public UnaryExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnaryExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnaryExpressionAtom(this);
		}
	}
	public partial class CollateExpressionAtomContext : ExpressionAtomContext {
		public ExpressionAtomContext expressionAtom() {
			return GetRuleContext<ExpressionAtomContext>(0);
		}
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public CollateExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCollateExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCollateExpressionAtom(this);
		}
	}
	public partial class SubqueryExpessionAtomContext : ExpressionAtomContext {
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public SubqueryExpessionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubqueryExpessionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubqueryExpessionAtom(this);
		}
	}
	public partial class MysqlVariableExpressionAtomContext : ExpressionAtomContext {
		public MysqlVariableContext mysqlVariable() {
			return GetRuleContext<MysqlVariableContext>(0);
		}
		public MysqlVariableExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMysqlVariableExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMysqlVariableExpressionAtom(this);
		}
	}
	public partial class NestedExpressionAtomContext : ExpressionAtomContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public NestedExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNestedExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNestedExpressionAtom(this);
		}
	}
	public partial class NestedRowExpressionAtomContext : ExpressionAtomContext {
		public ITerminalNode ROW() { return GetToken(MySqlParser.ROW, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public NestedRowExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNestedRowExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNestedRowExpressionAtom(this);
		}
	}
	public partial class MathExpressionAtomContext : ExpressionAtomContext {
		public ExpressionAtomContext left;
		public ExpressionAtomContext right;
		public MathOperatorContext mathOperator() {
			return GetRuleContext<MathOperatorContext>(0);
		}
		public ExpressionAtomContext[] expressionAtom() {
			return GetRuleContexts<ExpressionAtomContext>();
		}
		public ExpressionAtomContext expressionAtom(int i) {
			return GetRuleContext<ExpressionAtomContext>(i);
		}
		public MathExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMathExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMathExpressionAtom(this);
		}
	}
	public partial class IntervalExpressionAtomContext : ExpressionAtomContext {
		public ITerminalNode INTERVAL() { return GetToken(MySqlParser.INTERVAL, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public IntervalTypeContext intervalType() {
			return GetRuleContext<IntervalTypeContext>(0);
		}
		public IntervalExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIntervalExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIntervalExpressionAtom(this);
		}
	}
	public partial class ExistsExpessionAtomContext : ExpressionAtomContext {
		public ITerminalNode EXISTS() { return GetToken(MySqlParser.EXISTS, 0); }
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ExistsExpessionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExistsExpessionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExistsExpessionAtom(this);
		}
	}
	public partial class ConstantExpressionAtomContext : ExpressionAtomContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ConstantExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterConstantExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitConstantExpressionAtom(this);
		}
	}
	public partial class FunctionCallExpressionAtomContext : ExpressionAtomContext {
		public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public FunctionCallExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFunctionCallExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFunctionCallExpressionAtom(this);
		}
	}
	public partial class BinaryExpressionAtomContext : ExpressionAtomContext {
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ExpressionAtomContext expressionAtom() {
			return GetRuleContext<ExpressionAtomContext>(0);
		}
		public BinaryExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBinaryExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBinaryExpressionAtom(this);
		}
	}
	public partial class FullColumnNameExpressionAtomContext : ExpressionAtomContext {
		public FullColumnNameContext fullColumnName() {
			return GetRuleContext<FullColumnNameContext>(0);
		}
		public FullColumnNameExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFullColumnNameExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFullColumnNameExpressionAtom(this);
		}
	}
	public partial class BitExpressionAtomContext : ExpressionAtomContext {
		public ExpressionAtomContext left;
		public ExpressionAtomContext right;
		public BitOperatorContext bitOperator() {
			return GetRuleContext<BitOperatorContext>(0);
		}
		public ExpressionAtomContext[] expressionAtom() {
			return GetRuleContexts<ExpressionAtomContext>();
		}
		public ExpressionAtomContext expressionAtom(int i) {
			return GetRuleContext<ExpressionAtomContext>(i);
		}
		public BitExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBitExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBitExpressionAtom(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionAtomContext expressionAtom() {
		return expressionAtom(0);
	}

	private ExpressionAtomContext expressionAtom(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionAtomContext _localctx = new ExpressionAtomContext(Context, _parentState);
		ExpressionAtomContext _prevctx = _localctx;
		int _startState = 594;
		EnterRecursionRule(_localctx, 594, RULE_expressionAtom, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 6110;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,892,Context) ) {
			case 1:
				{
				_localctx = new ConstantExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 6066; constant();
				}
				break;
			case 2:
				{
				_localctx = new FullColumnNameExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6067; fullColumnName();
				}
				break;
			case 3:
				{
				_localctx = new FunctionCallExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6068; functionCall();
				}
				break;
			case 4:
				{
				_localctx = new MysqlVariableExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6069; mysqlVariable();
				}
				break;
			case 5:
				{
				_localctx = new UnaryExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6070; unaryOperator();
				State = 6071; expressionAtom(9);
				}
				break;
			case 6:
				{
				_localctx = new BinaryExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6073; Match(BINARY);
				State = 6074; expressionAtom(8);
				}
				break;
			case 7:
				{
				_localctx = new NestedExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6075; Match(LR_BRACKET);
				State = 6076; expression(0);
				State = 6081;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 6077; Match(COMMA);
					State = 6078; expression(0);
					}
					}
					State = 6083;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 6084; Match(RR_BRACKET);
				}
				break;
			case 8:
				{
				_localctx = new NestedRowExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6086; Match(ROW);
				State = 6087; Match(LR_BRACKET);
				State = 6088; expression(0);
				State = 6091;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 6089; Match(COMMA);
					State = 6090; expression(0);
					}
					}
					State = 6093;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==COMMA );
				State = 6095; Match(RR_BRACKET);
				}
				break;
			case 9:
				{
				_localctx = new ExistsExpessionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6097; Match(EXISTS);
				State = 6098; Match(LR_BRACKET);
				State = 6099; selectStatement();
				State = 6100; Match(RR_BRACKET);
				}
				break;
			case 10:
				{
				_localctx = new SubqueryExpessionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6102; Match(LR_BRACKET);
				State = 6103; selectStatement();
				State = 6104; Match(RR_BRACKET);
				}
				break;
			case 11:
				{
				_localctx = new IntervalExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6106; Match(INTERVAL);
				State = 6107; expression(0);
				State = 6108; intervalType();
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 6125;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,894,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 6123;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,893,Context) ) {
					case 1:
						{
						_localctx = new BitExpressionAtomContext(new ExpressionAtomContext(_parentctx, _parentState));
						((BitExpressionAtomContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expressionAtom);
						State = 6112;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 6113; bitOperator();
						State = 6114; ((BitExpressionAtomContext)_localctx).right = expressionAtom(3);
						}
						break;
					case 2:
						{
						_localctx = new MathExpressionAtomContext(new ExpressionAtomContext(_parentctx, _parentState));
						((MathExpressionAtomContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expressionAtom);
						State = 6116;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 6117; mathOperator();
						State = 6118; ((MathExpressionAtomContext)_localctx).right = expressionAtom(2);
						}
						break;
					case 3:
						{
						_localctx = new CollateExpressionAtomContext(new ExpressionAtomContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expressionAtom);
						State = 6120;
						if (!(Precpred(Context, 11))) throw new FailedPredicateException(this, "Precpred(Context, 11)");
						State = 6121; Match(COLLATE);
						State = 6122; collationName();
						}
						break;
					}
					} 
				}
				State = 6127;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,894,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class UnaryOperatorContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public UnaryOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnaryOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnaryOperator(this);
		}
	}

	[RuleVersion(0)]
	public UnaryOperatorContext unaryOperator() {
		UnaryOperatorContext _localctx = new UnaryOperatorContext(Context, State);
		EnterRule(_localctx, 596, RULE_unaryOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6128;
			_la = TokenStream.LA(1);
			if ( !(_la==NOT || ((((_la - 945)) & ~0x3f) == 0 && ((1L << (_la - 945)) & ((1L << (PLUS - 945)) | (1L << (MINUS - 945)) | (1L << (EXCLAMATION_SYMBOL - 945)) | (1L << (BIT_NOT_OP - 945)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComparisonOperatorContext : ParserRuleContext {
		public ComparisonOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comparisonOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterComparisonOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitComparisonOperator(this);
		}
	}

	[RuleVersion(0)]
	public ComparisonOperatorContext comparisonOperator() {
		ComparisonOperatorContext _localctx = new ComparisonOperatorContext(Context, State);
		EnterRule(_localctx, 598, RULE_comparisonOperator);
		try {
			State = 6144;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,895,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6130; Match(EQUAL_SYMBOL);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6131; Match(GREATER_SYMBOL);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6132; Match(LESS_SYMBOL);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 6133; Match(LESS_SYMBOL);
				State = 6134; Match(EQUAL_SYMBOL);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 6135; Match(GREATER_SYMBOL);
				State = 6136; Match(EQUAL_SYMBOL);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 6137; Match(LESS_SYMBOL);
				State = 6138; Match(GREATER_SYMBOL);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 6139; Match(EXCLAMATION_SYMBOL);
				State = 6140; Match(EQUAL_SYMBOL);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 6141; Match(LESS_SYMBOL);
				State = 6142; Match(EQUAL_SYMBOL);
				State = 6143; Match(GREATER_SYMBOL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicalOperatorContext : ParserRuleContext {
		public ITerminalNode AND() { return GetToken(MySqlParser.AND, 0); }
		public ITerminalNode XOR() { return GetToken(MySqlParser.XOR, 0); }
		public ITerminalNode OR() { return GetToken(MySqlParser.OR, 0); }
		public LogicalOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicalOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLogicalOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLogicalOperator(this);
		}
	}

	[RuleVersion(0)]
	public LogicalOperatorContext logicalOperator() {
		LogicalOperatorContext _localctx = new LogicalOperatorContext(Context, State);
		EnterRule(_localctx, 600, RULE_logicalOperator);
		try {
			State = 6153;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AND:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6146; Match(AND);
				}
				break;
			case BIT_AND_OP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6147; Match(BIT_AND_OP);
				State = 6148; Match(BIT_AND_OP);
				}
				break;
			case XOR:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6149; Match(XOR);
				}
				break;
			case OR:
				EnterOuterAlt(_localctx, 4);
				{
				State = 6150; Match(OR);
				}
				break;
			case BIT_OR_OP:
				EnterOuterAlt(_localctx, 5);
				{
				State = 6151; Match(BIT_OR_OP);
				State = 6152; Match(BIT_OR_OP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitOperatorContext : ParserRuleContext {
		public BitOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBitOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBitOperator(this);
		}
	}

	[RuleVersion(0)]
	public BitOperatorContext bitOperator() {
		BitOperatorContext _localctx = new BitOperatorContext(Context, State);
		EnterRule(_localctx, 602, RULE_bitOperator);
		try {
			State = 6162;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LESS_SYMBOL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6155; Match(LESS_SYMBOL);
				State = 6156; Match(LESS_SYMBOL);
				}
				break;
			case GREATER_SYMBOL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6157; Match(GREATER_SYMBOL);
				State = 6158; Match(GREATER_SYMBOL);
				}
				break;
			case BIT_AND_OP:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6159; Match(BIT_AND_OP);
				}
				break;
			case BIT_XOR_OP:
				EnterOuterAlt(_localctx, 4);
				{
				State = 6160; Match(BIT_XOR_OP);
				}
				break;
			case BIT_OR_OP:
				EnterOuterAlt(_localctx, 5);
				{
				State = 6161; Match(BIT_OR_OP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MathOperatorContext : ParserRuleContext {
		public ITerminalNode DIV() { return GetToken(MySqlParser.DIV, 0); }
		public ITerminalNode MOD() { return GetToken(MySqlParser.MOD, 0); }
		public MathOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mathOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMathOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMathOperator(this);
		}
	}

	[RuleVersion(0)]
	public MathOperatorContext mathOperator() {
		MathOperatorContext _localctx = new MathOperatorContext(Context, State);
		EnterRule(_localctx, 604, RULE_mathOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6164;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 942)) & ~0x3f) == 0 && ((1L << (_la - 942)) & ((1L << (STAR - 942)) | (1L << (DIVIDE - 942)) | (1L << (MODULE - 942)) | (1L << (PLUS - 942)) | (1L << (MINUSMINUS - 942)) | (1L << (MINUS - 942)) | (1L << (DIV - 942)) | (1L << (MOD - 942)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CharsetNameBaseContext : ParserRuleContext {
		public ITerminalNode ARMSCII8() { return GetToken(MySqlParser.ARMSCII8, 0); }
		public ITerminalNode ASCII() { return GetToken(MySqlParser.ASCII, 0); }
		public ITerminalNode BIG5() { return GetToken(MySqlParser.BIG5, 0); }
		public ITerminalNode CP1250() { return GetToken(MySqlParser.CP1250, 0); }
		public ITerminalNode CP1251() { return GetToken(MySqlParser.CP1251, 0); }
		public ITerminalNode CP1256() { return GetToken(MySqlParser.CP1256, 0); }
		public ITerminalNode CP1257() { return GetToken(MySqlParser.CP1257, 0); }
		public ITerminalNode CP850() { return GetToken(MySqlParser.CP850, 0); }
		public ITerminalNode CP852() { return GetToken(MySqlParser.CP852, 0); }
		public ITerminalNode CP866() { return GetToken(MySqlParser.CP866, 0); }
		public ITerminalNode CP932() { return GetToken(MySqlParser.CP932, 0); }
		public ITerminalNode DEC8() { return GetToken(MySqlParser.DEC8, 0); }
		public ITerminalNode EUCJPMS() { return GetToken(MySqlParser.EUCJPMS, 0); }
		public ITerminalNode EUCKR() { return GetToken(MySqlParser.EUCKR, 0); }
		public ITerminalNode GB2312() { return GetToken(MySqlParser.GB2312, 0); }
		public ITerminalNode GBK() { return GetToken(MySqlParser.GBK, 0); }
		public ITerminalNode GEOSTD8() { return GetToken(MySqlParser.GEOSTD8, 0); }
		public ITerminalNode GREEK() { return GetToken(MySqlParser.GREEK, 0); }
		public ITerminalNode HEBREW() { return GetToken(MySqlParser.HEBREW, 0); }
		public ITerminalNode HP8() { return GetToken(MySqlParser.HP8, 0); }
		public ITerminalNode KEYBCS2() { return GetToken(MySqlParser.KEYBCS2, 0); }
		public ITerminalNode KOI8R() { return GetToken(MySqlParser.KOI8R, 0); }
		public ITerminalNode KOI8U() { return GetToken(MySqlParser.KOI8U, 0); }
		public ITerminalNode LATIN1() { return GetToken(MySqlParser.LATIN1, 0); }
		public ITerminalNode LATIN2() { return GetToken(MySqlParser.LATIN2, 0); }
		public ITerminalNode LATIN5() { return GetToken(MySqlParser.LATIN5, 0); }
		public ITerminalNode LATIN7() { return GetToken(MySqlParser.LATIN7, 0); }
		public ITerminalNode MACCE() { return GetToken(MySqlParser.MACCE, 0); }
		public ITerminalNode MACROMAN() { return GetToken(MySqlParser.MACROMAN, 0); }
		public ITerminalNode SJIS() { return GetToken(MySqlParser.SJIS, 0); }
		public ITerminalNode SWE7() { return GetToken(MySqlParser.SWE7, 0); }
		public ITerminalNode TIS620() { return GetToken(MySqlParser.TIS620, 0); }
		public ITerminalNode UCS2() { return GetToken(MySqlParser.UCS2, 0); }
		public ITerminalNode UJIS() { return GetToken(MySqlParser.UJIS, 0); }
		public ITerminalNode UTF16() { return GetToken(MySqlParser.UTF16, 0); }
		public ITerminalNode UTF16LE() { return GetToken(MySqlParser.UTF16LE, 0); }
		public ITerminalNode UTF32() { return GetToken(MySqlParser.UTF32, 0); }
		public ITerminalNode UTF8() { return GetToken(MySqlParser.UTF8, 0); }
		public ITerminalNode UTF8MB3() { return GetToken(MySqlParser.UTF8MB3, 0); }
		public ITerminalNode UTF8MB4() { return GetToken(MySqlParser.UTF8MB4, 0); }
		public CharsetNameBaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_charsetNameBase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCharsetNameBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCharsetNameBase(this);
		}
	}

	[RuleVersion(0)]
	public CharsetNameBaseContext charsetNameBase() {
		CharsetNameBaseContext _localctx = new CharsetNameBaseContext(Context, State);
		EnterRule(_localctx, 606, RULE_charsetNameBase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6166;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 578)) & ~0x3f) == 0 && ((1L << (_la - 578)) & ((1L << (ARMSCII8 - 578)) | (1L << (ASCII - 578)) | (1L << (BIG5 - 578)) | (1L << (CP1250 - 578)) | (1L << (CP1251 - 578)) | (1L << (CP1256 - 578)) | (1L << (CP1257 - 578)) | (1L << (CP850 - 578)) | (1L << (CP852 - 578)) | (1L << (CP866 - 578)) | (1L << (CP932 - 578)) | (1L << (DEC8 - 578)) | (1L << (EUCJPMS - 578)) | (1L << (EUCKR - 578)) | (1L << (GB2312 - 578)) | (1L << (GBK - 578)) | (1L << (GEOSTD8 - 578)) | (1L << (GREEK - 578)) | (1L << (HEBREW - 578)) | (1L << (HP8 - 578)) | (1L << (KEYBCS2 - 578)) | (1L << (KOI8R - 578)) | (1L << (KOI8U - 578)) | (1L << (LATIN1 - 578)) | (1L << (LATIN2 - 578)) | (1L << (LATIN5 - 578)) | (1L << (LATIN7 - 578)) | (1L << (MACCE - 578)) | (1L << (MACROMAN - 578)) | (1L << (SJIS - 578)) | (1L << (SWE7 - 578)) | (1L << (TIS620 - 578)) | (1L << (UCS2 - 578)) | (1L << (UJIS - 578)) | (1L << (UTF16 - 578)) | (1L << (UTF16LE - 578)) | (1L << (UTF32 - 578)) | (1L << (UTF8 - 578)) | (1L << (UTF8MB3 - 578)) | (1L << (UTF8MB4 - 578)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TransactionLevelBaseContext : ParserRuleContext {
		public ITerminalNode REPEATABLE() { return GetToken(MySqlParser.REPEATABLE, 0); }
		public ITerminalNode COMMITTED() { return GetToken(MySqlParser.COMMITTED, 0); }
		public ITerminalNode UNCOMMITTED() { return GetToken(MySqlParser.UNCOMMITTED, 0); }
		public ITerminalNode SERIALIZABLE() { return GetToken(MySqlParser.SERIALIZABLE, 0); }
		public TransactionLevelBaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transactionLevelBase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTransactionLevelBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTransactionLevelBase(this);
		}
	}

	[RuleVersion(0)]
	public TransactionLevelBaseContext transactionLevelBase() {
		TransactionLevelBaseContext _localctx = new TransactionLevelBaseContext(Context, State);
		EnterRule(_localctx, 608, RULE_transactionLevelBase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6168;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 630)) & ~0x3f) == 0 && ((1L << (_la - 630)) & ((1L << (REPEATABLE - 630)) | (1L << (COMMITTED - 630)) | (1L << (UNCOMMITTED - 630)) | (1L << (SERIALIZABLE - 630)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrivilegesBaseContext : ParserRuleContext {
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public ITerminalNode ROUTINE() { return GetToken(MySqlParser.ROUTINE, 0); }
		public ITerminalNode EXECUTE() { return GetToken(MySqlParser.EXECUTE, 0); }
		public ITerminalNode FILE() { return GetToken(MySqlParser.FILE, 0); }
		public ITerminalNode PROCESS() { return GetToken(MySqlParser.PROCESS, 0); }
		public ITerminalNode RELOAD() { return GetToken(MySqlParser.RELOAD, 0); }
		public ITerminalNode SHUTDOWN() { return GetToken(MySqlParser.SHUTDOWN, 0); }
		public ITerminalNode SUPER() { return GetToken(MySqlParser.SUPER, 0); }
		public ITerminalNode PRIVILEGES() { return GetToken(MySqlParser.PRIVILEGES, 0); }
		public PrivilegesBaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_privilegesBase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPrivilegesBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPrivilegesBase(this);
		}
	}

	[RuleVersion(0)]
	public PrivilegesBaseContext privilegesBase() {
		PrivilegesBaseContext _localctx = new PrivilegesBaseContext(Context, State);
		EnterRule(_localctx, 610, RULE_privilegesBase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6170;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 569)) & ~0x3f) == 0 && ((1L << (_la - 569)) & ((1L << (TABLES - 569)) | (1L << (ROUTINE - 569)) | (1L << (EXECUTE - 569)) | (1L << (FILE - 569)) | (1L << (PROCESS - 569)) | (1L << (RELOAD - 569)) | (1L << (SHUTDOWN - 569)) | (1L << (SUPER - 569)) | (1L << (PRIVILEGES - 569)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalTypeBaseContext : ParserRuleContext {
		public ITerminalNode QUARTER() { return GetToken(MySqlParser.QUARTER, 0); }
		public ITerminalNode MONTH() { return GetToken(MySqlParser.MONTH, 0); }
		public ITerminalNode DAY() { return GetToken(MySqlParser.DAY, 0); }
		public ITerminalNode HOUR() { return GetToken(MySqlParser.HOUR, 0); }
		public ITerminalNode MINUTE() { return GetToken(MySqlParser.MINUTE, 0); }
		public ITerminalNode WEEK() { return GetToken(MySqlParser.WEEK, 0); }
		public ITerminalNode SECOND() { return GetToken(MySqlParser.SECOND, 0); }
		public ITerminalNode MICROSECOND() { return GetToken(MySqlParser.MICROSECOND, 0); }
		public IntervalTypeBaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalTypeBase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIntervalTypeBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIntervalTypeBase(this);
		}
	}

	[RuleVersion(0)]
	public IntervalTypeBaseContext intervalTypeBase() {
		IntervalTypeBaseContext _localctx = new IntervalTypeBaseContext(Context, State);
		EnterRule(_localctx, 612, RULE_intervalTypeBase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6172;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 561)) & ~0x3f) == 0 && ((1L << (_la - 561)) & ((1L << (QUARTER - 561)) | (1L << (MONTH - 561)) | (1L << (DAY - 561)) | (1L << (HOUR - 561)) | (1L << (MINUTE - 561)) | (1L << (WEEK - 561)) | (1L << (SECOND - 561)) | (1L << (MICROSECOND - 561)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DataTypeBaseContext : ParserRuleContext {
		public ITerminalNode DATE() { return GetToken(MySqlParser.DATE, 0); }
		public ITerminalNode TIME() { return GetToken(MySqlParser.TIME, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(MySqlParser.TIMESTAMP, 0); }
		public ITerminalNode DATETIME() { return GetToken(MySqlParser.DATETIME, 0); }
		public ITerminalNode YEAR() { return GetToken(MySqlParser.YEAR, 0); }
		public ITerminalNode ENUM() { return GetToken(MySqlParser.ENUM, 0); }
		public ITerminalNode TEXT() { return GetToken(MySqlParser.TEXT, 0); }
		public DataTypeBaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dataTypeBase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDataTypeBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDataTypeBase(this);
		}
	}

	[RuleVersion(0)]
	public DataTypeBaseContext dataTypeBase() {
		DataTypeBaseContext _localctx = new DataTypeBaseContext(Context, State);
		EnterRule(_localctx, 614, RULE_dataTypeBase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6174;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (DATETIME - 184)) | (1L << (YEAR - 184)) | (1L << (TEXT - 184)) | (1L << (ENUM - 184)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordsCanBeIdContext : ParserRuleContext {
		public ITerminalNode ACCOUNT() { return GetToken(MySqlParser.ACCOUNT, 0); }
		public ITerminalNode ACTION() { return GetToken(MySqlParser.ACTION, 0); }
		public ITerminalNode AFTER() { return GetToken(MySqlParser.AFTER, 0); }
		public ITerminalNode AGGREGATE() { return GetToken(MySqlParser.AGGREGATE, 0); }
		public ITerminalNode ALGORITHM() { return GetToken(MySqlParser.ALGORITHM, 0); }
		public ITerminalNode ANY() { return GetToken(MySqlParser.ANY, 0); }
		public ITerminalNode AT() { return GetToken(MySqlParser.AT, 0); }
		public ITerminalNode AUTHORS() { return GetToken(MySqlParser.AUTHORS, 0); }
		public ITerminalNode AUTOCOMMIT() { return GetToken(MySqlParser.AUTOCOMMIT, 0); }
		public ITerminalNode AUTOEXTEND_SIZE() { return GetToken(MySqlParser.AUTOEXTEND_SIZE, 0); }
		public ITerminalNode AUTO_INCREMENT() { return GetToken(MySqlParser.AUTO_INCREMENT, 0); }
		public ITerminalNode AVG_ROW_LENGTH() { return GetToken(MySqlParser.AVG_ROW_LENGTH, 0); }
		public ITerminalNode BEGIN() { return GetToken(MySqlParser.BEGIN, 0); }
		public ITerminalNode BINLOG() { return GetToken(MySqlParser.BINLOG, 0); }
		public ITerminalNode BIT() { return GetToken(MySqlParser.BIT, 0); }
		public ITerminalNode BLOCK() { return GetToken(MySqlParser.BLOCK, 0); }
		public ITerminalNode BOOL() { return GetToken(MySqlParser.BOOL, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(MySqlParser.BOOLEAN, 0); }
		public ITerminalNode BTREE() { return GetToken(MySqlParser.BTREE, 0); }
		public ITerminalNode CACHE() { return GetToken(MySqlParser.CACHE, 0); }
		public ITerminalNode CASCADED() { return GetToken(MySqlParser.CASCADED, 0); }
		public ITerminalNode CHAIN() { return GetToken(MySqlParser.CHAIN, 0); }
		public ITerminalNode CHANGED() { return GetToken(MySqlParser.CHANGED, 0); }
		public ITerminalNode CHANNEL() { return GetToken(MySqlParser.CHANNEL, 0); }
		public ITerminalNode CHECKSUM() { return GetToken(MySqlParser.CHECKSUM, 0); }
		public ITerminalNode PAGE_CHECKSUM() { return GetToken(MySqlParser.PAGE_CHECKSUM, 0); }
		public ITerminalNode CIPHER() { return GetToken(MySqlParser.CIPHER, 0); }
		public ITerminalNode CLIENT() { return GetToken(MySqlParser.CLIENT, 0); }
		public ITerminalNode CLOSE() { return GetToken(MySqlParser.CLOSE, 0); }
		public ITerminalNode COALESCE() { return GetToken(MySqlParser.COALESCE, 0); }
		public ITerminalNode CODE() { return GetToken(MySqlParser.CODE, 0); }
		public ITerminalNode COLUMNS() { return GetToken(MySqlParser.COLUMNS, 0); }
		public ITerminalNode COLUMN_FORMAT() { return GetToken(MySqlParser.COLUMN_FORMAT, 0); }
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode COMMIT() { return GetToken(MySqlParser.COMMIT, 0); }
		public ITerminalNode COMPACT() { return GetToken(MySqlParser.COMPACT, 0); }
		public ITerminalNode COMPLETION() { return GetToken(MySqlParser.COMPLETION, 0); }
		public ITerminalNode COMPRESSED() { return GetToken(MySqlParser.COMPRESSED, 0); }
		public ITerminalNode COMPRESSION() { return GetToken(MySqlParser.COMPRESSION, 0); }
		public ITerminalNode CONCURRENT() { return GetToken(MySqlParser.CONCURRENT, 0); }
		public ITerminalNode CONNECTION() { return GetToken(MySqlParser.CONNECTION, 0); }
		public ITerminalNode CONSISTENT() { return GetToken(MySqlParser.CONSISTENT, 0); }
		public ITerminalNode CONTAINS() { return GetToken(MySqlParser.CONTAINS, 0); }
		public ITerminalNode CONTEXT() { return GetToken(MySqlParser.CONTEXT, 0); }
		public ITerminalNode CONTRIBUTORS() { return GetToken(MySqlParser.CONTRIBUTORS, 0); }
		public ITerminalNode COPY() { return GetToken(MySqlParser.COPY, 0); }
		public ITerminalNode CPU() { return GetToken(MySqlParser.CPU, 0); }
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode DATAFILE() { return GetToken(MySqlParser.DATAFILE, 0); }
		public ITerminalNode DEALLOCATE() { return GetToken(MySqlParser.DEALLOCATE, 0); }
		public ITerminalNode DEFAULT_AUTH() { return GetToken(MySqlParser.DEFAULT_AUTH, 0); }
		public ITerminalNode DEFINER() { return GetToken(MySqlParser.DEFINER, 0); }
		public ITerminalNode DELAY_KEY_WRITE() { return GetToken(MySqlParser.DELAY_KEY_WRITE, 0); }
		public ITerminalNode DES_KEY_FILE() { return GetToken(MySqlParser.DES_KEY_FILE, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(MySqlParser.DIRECTORY, 0); }
		public ITerminalNode DISABLE() { return GetToken(MySqlParser.DISABLE, 0); }
		public ITerminalNode DISCARD() { return GetToken(MySqlParser.DISCARD, 0); }
		public ITerminalNode DISK() { return GetToken(MySqlParser.DISK, 0); }
		public ITerminalNode DO() { return GetToken(MySqlParser.DO, 0); }
		public ITerminalNode DUMPFILE() { return GetToken(MySqlParser.DUMPFILE, 0); }
		public ITerminalNode DUPLICATE() { return GetToken(MySqlParser.DUPLICATE, 0); }
		public ITerminalNode DYNAMIC() { return GetToken(MySqlParser.DYNAMIC, 0); }
		public ITerminalNode ENABLE() { return GetToken(MySqlParser.ENABLE, 0); }
		public ITerminalNode ENCRYPTION() { return GetToken(MySqlParser.ENCRYPTION, 0); }
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public ITerminalNode ENDS() { return GetToken(MySqlParser.ENDS, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public ITerminalNode ENGINES() { return GetToken(MySqlParser.ENGINES, 0); }
		public ITerminalNode ERROR() { return GetToken(MySqlParser.ERROR, 0); }
		public ITerminalNode ERRORS() { return GetToken(MySqlParser.ERRORS, 0); }
		public ITerminalNode ESCAPE() { return GetToken(MySqlParser.ESCAPE, 0); }
		public ITerminalNode EVEN() { return GetToken(MySqlParser.EVEN, 0); }
		public ITerminalNode EVENT() { return GetToken(MySqlParser.EVENT, 0); }
		public ITerminalNode EVENTS() { return GetToken(MySqlParser.EVENTS, 0); }
		public ITerminalNode EVERY() { return GetToken(MySqlParser.EVERY, 0); }
		public ITerminalNode EXCHANGE() { return GetToken(MySqlParser.EXCHANGE, 0); }
		public ITerminalNode EXCLUSIVE() { return GetToken(MySqlParser.EXCLUSIVE, 0); }
		public ITerminalNode EXPIRE() { return GetToken(MySqlParser.EXPIRE, 0); }
		public ITerminalNode EXPORT() { return GetToken(MySqlParser.EXPORT, 0); }
		public ITerminalNode EXTENDED() { return GetToken(MySqlParser.EXTENDED, 0); }
		public ITerminalNode EXTENT_SIZE() { return GetToken(MySqlParser.EXTENT_SIZE, 0); }
		public ITerminalNode FAST() { return GetToken(MySqlParser.FAST, 0); }
		public ITerminalNode FAULTS() { return GetToken(MySqlParser.FAULTS, 0); }
		public ITerminalNode FIELDS() { return GetToken(MySqlParser.FIELDS, 0); }
		public ITerminalNode FILE_BLOCK_SIZE() { return GetToken(MySqlParser.FILE_BLOCK_SIZE, 0); }
		public ITerminalNode FILTER() { return GetToken(MySqlParser.FILTER, 0); }
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode FIXED() { return GetToken(MySqlParser.FIXED, 0); }
		public ITerminalNode FLUSH() { return GetToken(MySqlParser.FLUSH, 0); }
		public ITerminalNode FOLLOWS() { return GetToken(MySqlParser.FOLLOWS, 0); }
		public ITerminalNode FOUND() { return GetToken(MySqlParser.FOUND, 0); }
		public ITerminalNode FULL() { return GetToken(MySqlParser.FULL, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public ITerminalNode GENERAL() { return GetToken(MySqlParser.GENERAL, 0); }
		public ITerminalNode GLOBAL() { return GetToken(MySqlParser.GLOBAL, 0); }
		public ITerminalNode GRANTS() { return GetToken(MySqlParser.GRANTS, 0); }
		public ITerminalNode GROUP_REPLICATION() { return GetToken(MySqlParser.GROUP_REPLICATION, 0); }
		public ITerminalNode HANDLER() { return GetToken(MySqlParser.HANDLER, 0); }
		public ITerminalNode HASH() { return GetToken(MySqlParser.HASH, 0); }
		public ITerminalNode HELP() { return GetToken(MySqlParser.HELP, 0); }
		public ITerminalNode HOST() { return GetToken(MySqlParser.HOST, 0); }
		public ITerminalNode HOSTS() { return GetToken(MySqlParser.HOSTS, 0); }
		public ITerminalNode IDENTIFIED() { return GetToken(MySqlParser.IDENTIFIED, 0); }
		public ITerminalNode IGNORE_SERVER_IDS() { return GetToken(MySqlParser.IGNORE_SERVER_IDS, 0); }
		public ITerminalNode IMPORT() { return GetToken(MySqlParser.IMPORT, 0); }
		public ITerminalNode INDEXES() { return GetToken(MySqlParser.INDEXES, 0); }
		public ITerminalNode INITIAL_SIZE() { return GetToken(MySqlParser.INITIAL_SIZE, 0); }
		public ITerminalNode INPLACE() { return GetToken(MySqlParser.INPLACE, 0); }
		public ITerminalNode INSERT_METHOD() { return GetToken(MySqlParser.INSERT_METHOD, 0); }
		public ITerminalNode INSTALL() { return GetToken(MySqlParser.INSTALL, 0); }
		public ITerminalNode INSTANCE() { return GetToken(MySqlParser.INSTANCE, 0); }
		public ITerminalNode INTERNAL() { return GetToken(MySqlParser.INTERNAL, 0); }
		public ITerminalNode INVOKER() { return GetToken(MySqlParser.INVOKER, 0); }
		public ITerminalNode IO() { return GetToken(MySqlParser.IO, 0); }
		public ITerminalNode IO_THREAD() { return GetToken(MySqlParser.IO_THREAD, 0); }
		public ITerminalNode IPC() { return GetToken(MySqlParser.IPC, 0); }
		public ITerminalNode ISOLATION() { return GetToken(MySqlParser.ISOLATION, 0); }
		public ITerminalNode ISSUER() { return GetToken(MySqlParser.ISSUER, 0); }
		public ITerminalNode JSON() { return GetToken(MySqlParser.JSON, 0); }
		public ITerminalNode KEY_BLOCK_SIZE() { return GetToken(MySqlParser.KEY_BLOCK_SIZE, 0); }
		public ITerminalNode LANGUAGE() { return GetToken(MySqlParser.LANGUAGE, 0); }
		public ITerminalNode LAST() { return GetToken(MySqlParser.LAST, 0); }
		public ITerminalNode LEAVES() { return GetToken(MySqlParser.LEAVES, 0); }
		public ITerminalNode LESS() { return GetToken(MySqlParser.LESS, 0); }
		public ITerminalNode LEVEL() { return GetToken(MySqlParser.LEVEL, 0); }
		public ITerminalNode LIST() { return GetToken(MySqlParser.LIST, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public ITerminalNode LOGFILE() { return GetToken(MySqlParser.LOGFILE, 0); }
		public ITerminalNode LOGS() { return GetToken(MySqlParser.LOGS, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ITerminalNode MASTER_AUTO_POSITION() { return GetToken(MySqlParser.MASTER_AUTO_POSITION, 0); }
		public ITerminalNode MASTER_CONNECT_RETRY() { return GetToken(MySqlParser.MASTER_CONNECT_RETRY, 0); }
		public ITerminalNode MASTER_DELAY() { return GetToken(MySqlParser.MASTER_DELAY, 0); }
		public ITerminalNode MASTER_HEARTBEAT_PERIOD() { return GetToken(MySqlParser.MASTER_HEARTBEAT_PERIOD, 0); }
		public ITerminalNode MASTER_HOST() { return GetToken(MySqlParser.MASTER_HOST, 0); }
		public ITerminalNode MASTER_LOG_FILE() { return GetToken(MySqlParser.MASTER_LOG_FILE, 0); }
		public ITerminalNode MASTER_LOG_POS() { return GetToken(MySqlParser.MASTER_LOG_POS, 0); }
		public ITerminalNode MASTER_PASSWORD() { return GetToken(MySqlParser.MASTER_PASSWORD, 0); }
		public ITerminalNode MASTER_PORT() { return GetToken(MySqlParser.MASTER_PORT, 0); }
		public ITerminalNode MASTER_RETRY_COUNT() { return GetToken(MySqlParser.MASTER_RETRY_COUNT, 0); }
		public ITerminalNode MASTER_SSL() { return GetToken(MySqlParser.MASTER_SSL, 0); }
		public ITerminalNode MASTER_SSL_CA() { return GetToken(MySqlParser.MASTER_SSL_CA, 0); }
		public ITerminalNode MASTER_SSL_CAPATH() { return GetToken(MySqlParser.MASTER_SSL_CAPATH, 0); }
		public ITerminalNode MASTER_SSL_CERT() { return GetToken(MySqlParser.MASTER_SSL_CERT, 0); }
		public ITerminalNode MASTER_SSL_CIPHER() { return GetToken(MySqlParser.MASTER_SSL_CIPHER, 0); }
		public ITerminalNode MASTER_SSL_CRL() { return GetToken(MySqlParser.MASTER_SSL_CRL, 0); }
		public ITerminalNode MASTER_SSL_CRLPATH() { return GetToken(MySqlParser.MASTER_SSL_CRLPATH, 0); }
		public ITerminalNode MASTER_SSL_KEY() { return GetToken(MySqlParser.MASTER_SSL_KEY, 0); }
		public ITerminalNode MASTER_TLS_VERSION() { return GetToken(MySqlParser.MASTER_TLS_VERSION, 0); }
		public ITerminalNode MASTER_USER() { return GetToken(MySqlParser.MASTER_USER, 0); }
		public ITerminalNode MAX_CONNECTIONS_PER_HOUR() { return GetToken(MySqlParser.MAX_CONNECTIONS_PER_HOUR, 0); }
		public ITerminalNode MAX_QUERIES_PER_HOUR() { return GetToken(MySqlParser.MAX_QUERIES_PER_HOUR, 0); }
		public ITerminalNode MAX_ROWS() { return GetToken(MySqlParser.MAX_ROWS, 0); }
		public ITerminalNode MAX_SIZE() { return GetToken(MySqlParser.MAX_SIZE, 0); }
		public ITerminalNode MAX_UPDATES_PER_HOUR() { return GetToken(MySqlParser.MAX_UPDATES_PER_HOUR, 0); }
		public ITerminalNode MAX_USER_CONNECTIONS() { return GetToken(MySqlParser.MAX_USER_CONNECTIONS, 0); }
		public ITerminalNode MEDIUM() { return GetToken(MySqlParser.MEDIUM, 0); }
		public ITerminalNode MEMORY() { return GetToken(MySqlParser.MEMORY, 0); }
		public ITerminalNode MERGE() { return GetToken(MySqlParser.MERGE, 0); }
		public ITerminalNode MID() { return GetToken(MySqlParser.MID, 0); }
		public ITerminalNode MIGRATE() { return GetToken(MySqlParser.MIGRATE, 0); }
		public ITerminalNode MIN_ROWS() { return GetToken(MySqlParser.MIN_ROWS, 0); }
		public ITerminalNode MODE() { return GetToken(MySqlParser.MODE, 0); }
		public ITerminalNode MODIFY() { return GetToken(MySqlParser.MODIFY, 0); }
		public ITerminalNode MUTEX() { return GetToken(MySqlParser.MUTEX, 0); }
		public ITerminalNode MYSQL() { return GetToken(MySqlParser.MYSQL, 0); }
		public ITerminalNode NAME() { return GetToken(MySqlParser.NAME, 0); }
		public ITerminalNode NAMES() { return GetToken(MySqlParser.NAMES, 0); }
		public ITerminalNode NCHAR() { return GetToken(MySqlParser.NCHAR, 0); }
		public ITerminalNode NEVER() { return GetToken(MySqlParser.NEVER, 0); }
		public ITerminalNode NEXT() { return GetToken(MySqlParser.NEXT, 0); }
		public ITerminalNode NO() { return GetToken(MySqlParser.NO, 0); }
		public ITerminalNode NODEGROUP() { return GetToken(MySqlParser.NODEGROUP, 0); }
		public ITerminalNode NONE() { return GetToken(MySqlParser.NONE, 0); }
		public ITerminalNode OFFLINE() { return GetToken(MySqlParser.OFFLINE, 0); }
		public ITerminalNode OFFSET() { return GetToken(MySqlParser.OFFSET, 0); }
		public ITerminalNode OJ() { return GetToken(MySqlParser.OJ, 0); }
		public ITerminalNode OLD_PASSWORD() { return GetToken(MySqlParser.OLD_PASSWORD, 0); }
		public ITerminalNode ONE() { return GetToken(MySqlParser.ONE, 0); }
		public ITerminalNode ONLINE() { return GetToken(MySqlParser.ONLINE, 0); }
		public ITerminalNode ONLY() { return GetToken(MySqlParser.ONLY, 0); }
		public ITerminalNode OPEN() { return GetToken(MySqlParser.OPEN, 0); }
		public ITerminalNode OPTIMIZER_COSTS() { return GetToken(MySqlParser.OPTIMIZER_COSTS, 0); }
		public ITerminalNode OPTIONS() { return GetToken(MySqlParser.OPTIONS, 0); }
		public ITerminalNode OWNER() { return GetToken(MySqlParser.OWNER, 0); }
		public ITerminalNode PACK_KEYS() { return GetToken(MySqlParser.PACK_KEYS, 0); }
		public ITerminalNode PAGE() { return GetToken(MySqlParser.PAGE, 0); }
		public ITerminalNode PARSER() { return GetToken(MySqlParser.PARSER, 0); }
		public ITerminalNode PARTIAL() { return GetToken(MySqlParser.PARTIAL, 0); }
		public ITerminalNode PARTITIONING() { return GetToken(MySqlParser.PARTITIONING, 0); }
		public ITerminalNode PARTITIONS() { return GetToken(MySqlParser.PARTITIONS, 0); }
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode PHASE() { return GetToken(MySqlParser.PHASE, 0); }
		public ITerminalNode PLUGINS() { return GetToken(MySqlParser.PLUGINS, 0); }
		public ITerminalNode PLUGIN_DIR() { return GetToken(MySqlParser.PLUGIN_DIR, 0); }
		public ITerminalNode PLUGIN() { return GetToken(MySqlParser.PLUGIN, 0); }
		public ITerminalNode PORT() { return GetToken(MySqlParser.PORT, 0); }
		public ITerminalNode PRECEDES() { return GetToken(MySqlParser.PRECEDES, 0); }
		public ITerminalNode PREPARE() { return GetToken(MySqlParser.PREPARE, 0); }
		public ITerminalNode PRESERVE() { return GetToken(MySqlParser.PRESERVE, 0); }
		public ITerminalNode PREV() { return GetToken(MySqlParser.PREV, 0); }
		public ITerminalNode PROCESSLIST() { return GetToken(MySqlParser.PROCESSLIST, 0); }
		public ITerminalNode PROFILE() { return GetToken(MySqlParser.PROFILE, 0); }
		public ITerminalNode PROFILES() { return GetToken(MySqlParser.PROFILES, 0); }
		public ITerminalNode PROXY() { return GetToken(MySqlParser.PROXY, 0); }
		public ITerminalNode QUERY() { return GetToken(MySqlParser.QUERY, 0); }
		public ITerminalNode QUICK() { return GetToken(MySqlParser.QUICK, 0); }
		public ITerminalNode REBUILD() { return GetToken(MySqlParser.REBUILD, 0); }
		public ITerminalNode RECOVER() { return GetToken(MySqlParser.RECOVER, 0); }
		public ITerminalNode REDO_BUFFER_SIZE() { return GetToken(MySqlParser.REDO_BUFFER_SIZE, 0); }
		public ITerminalNode REDUNDANT() { return GetToken(MySqlParser.REDUNDANT, 0); }
		public ITerminalNode RELAY() { return GetToken(MySqlParser.RELAY, 0); }
		public ITerminalNode RELAYLOG() { return GetToken(MySqlParser.RELAYLOG, 0); }
		public ITerminalNode RELAY_LOG_FILE() { return GetToken(MySqlParser.RELAY_LOG_FILE, 0); }
		public ITerminalNode RELAY_LOG_POS() { return GetToken(MySqlParser.RELAY_LOG_POS, 0); }
		public ITerminalNode REMOVE() { return GetToken(MySqlParser.REMOVE, 0); }
		public ITerminalNode REORGANIZE() { return GetToken(MySqlParser.REORGANIZE, 0); }
		public ITerminalNode REPAIR() { return GetToken(MySqlParser.REPAIR, 0); }
		public ITerminalNode REPLICATE_DO_DB() { return GetToken(MySqlParser.REPLICATE_DO_DB, 0); }
		public ITerminalNode REPLICATE_DO_TABLE() { return GetToken(MySqlParser.REPLICATE_DO_TABLE, 0); }
		public ITerminalNode REPLICATE_IGNORE_DB() { return GetToken(MySqlParser.REPLICATE_IGNORE_DB, 0); }
		public ITerminalNode REPLICATE_IGNORE_TABLE() { return GetToken(MySqlParser.REPLICATE_IGNORE_TABLE, 0); }
		public ITerminalNode REPLICATE_REWRITE_DB() { return GetToken(MySqlParser.REPLICATE_REWRITE_DB, 0); }
		public ITerminalNode REPLICATE_WILD_DO_TABLE() { return GetToken(MySqlParser.REPLICATE_WILD_DO_TABLE, 0); }
		public ITerminalNode REPLICATE_WILD_IGNORE_TABLE() { return GetToken(MySqlParser.REPLICATE_WILD_IGNORE_TABLE, 0); }
		public ITerminalNode REPLICATION() { return GetToken(MySqlParser.REPLICATION, 0); }
		public ITerminalNode RESET() { return GetToken(MySqlParser.RESET, 0); }
		public ITerminalNode RESUME() { return GetToken(MySqlParser.RESUME, 0); }
		public ITerminalNode RETURNS() { return GetToken(MySqlParser.RETURNS, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(MySqlParser.ROLLBACK, 0); }
		public ITerminalNode ROLLUP() { return GetToken(MySqlParser.ROLLUP, 0); }
		public ITerminalNode ROTATE() { return GetToken(MySqlParser.ROTATE, 0); }
		public ITerminalNode ROW() { return GetToken(MySqlParser.ROW, 0); }
		public ITerminalNode ROWS() { return GetToken(MySqlParser.ROWS, 0); }
		public ITerminalNode ROW_FORMAT() { return GetToken(MySqlParser.ROW_FORMAT, 0); }
		public ITerminalNode SAVEPOINT() { return GetToken(MySqlParser.SAVEPOINT, 0); }
		public ITerminalNode SCHEDULE() { return GetToken(MySqlParser.SCHEDULE, 0); }
		public ITerminalNode SECURITY() { return GetToken(MySqlParser.SECURITY, 0); }
		public ITerminalNode SERIAL() { return GetToken(MySqlParser.SERIAL, 0); }
		public ITerminalNode SERVER() { return GetToken(MySqlParser.SERVER, 0); }
		public ITerminalNode SESSION() { return GetToken(MySqlParser.SESSION, 0); }
		public ITerminalNode SHARE() { return GetToken(MySqlParser.SHARE, 0); }
		public ITerminalNode SHARED() { return GetToken(MySqlParser.SHARED, 0); }
		public ITerminalNode SIGNED() { return GetToken(MySqlParser.SIGNED, 0); }
		public ITerminalNode SIMPLE() { return GetToken(MySqlParser.SIMPLE, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ITerminalNode SLOW() { return GetToken(MySqlParser.SLOW, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(MySqlParser.SNAPSHOT, 0); }
		public ITerminalNode SOCKET() { return GetToken(MySqlParser.SOCKET, 0); }
		public ITerminalNode SOME() { return GetToken(MySqlParser.SOME, 0); }
		public ITerminalNode SONAME() { return GetToken(MySqlParser.SONAME, 0); }
		public ITerminalNode SOUNDS() { return GetToken(MySqlParser.SOUNDS, 0); }
		public ITerminalNode SOURCE() { return GetToken(MySqlParser.SOURCE, 0); }
		public ITerminalNode SQL_AFTER_GTIDS() { return GetToken(MySqlParser.SQL_AFTER_GTIDS, 0); }
		public ITerminalNode SQL_AFTER_MTS_GAPS() { return GetToken(MySqlParser.SQL_AFTER_MTS_GAPS, 0); }
		public ITerminalNode SQL_BEFORE_GTIDS() { return GetToken(MySqlParser.SQL_BEFORE_GTIDS, 0); }
		public ITerminalNode SQL_BUFFER_RESULT() { return GetToken(MySqlParser.SQL_BUFFER_RESULT, 0); }
		public ITerminalNode SQL_CACHE() { return GetToken(MySqlParser.SQL_CACHE, 0); }
		public ITerminalNode SQL_NO_CACHE() { return GetToken(MySqlParser.SQL_NO_CACHE, 0); }
		public ITerminalNode SQL_THREAD() { return GetToken(MySqlParser.SQL_THREAD, 0); }
		public ITerminalNode START() { return GetToken(MySqlParser.START, 0); }
		public ITerminalNode STARTS() { return GetToken(MySqlParser.STARTS, 0); }
		public ITerminalNode STATS_AUTO_RECALC() { return GetToken(MySqlParser.STATS_AUTO_RECALC, 0); }
		public ITerminalNode STATS_PERSISTENT() { return GetToken(MySqlParser.STATS_PERSISTENT, 0); }
		public ITerminalNode STATS_SAMPLE_PAGES() { return GetToken(MySqlParser.STATS_SAMPLE_PAGES, 0); }
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode STOP() { return GetToken(MySqlParser.STOP, 0); }
		public ITerminalNode STORAGE() { return GetToken(MySqlParser.STORAGE, 0); }
		public ITerminalNode STRING() { return GetToken(MySqlParser.STRING, 0); }
		public ITerminalNode SUBJECT() { return GetToken(MySqlParser.SUBJECT, 0); }
		public ITerminalNode SUBPARTITION() { return GetToken(MySqlParser.SUBPARTITION, 0); }
		public ITerminalNode SUBPARTITIONS() { return GetToken(MySqlParser.SUBPARTITIONS, 0); }
		public ITerminalNode SUSPEND() { return GetToken(MySqlParser.SUSPEND, 0); }
		public ITerminalNode SWAPS() { return GetToken(MySqlParser.SWAPS, 0); }
		public ITerminalNode SWITCHES() { return GetToken(MySqlParser.SWITCHES, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public ITerminalNode TEMPORARY() { return GetToken(MySqlParser.TEMPORARY, 0); }
		public ITerminalNode TEMPTABLE() { return GetToken(MySqlParser.TEMPTABLE, 0); }
		public ITerminalNode THAN() { return GetToken(MySqlParser.THAN, 0); }
		public ITerminalNode TRADITIONAL() { return GetToken(MySqlParser.TRADITIONAL, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(MySqlParser.TRANSACTION, 0); }
		public ITerminalNode TRIGGERS() { return GetToken(MySqlParser.TRIGGERS, 0); }
		public ITerminalNode TRUNCATE() { return GetToken(MySqlParser.TRUNCATE, 0); }
		public ITerminalNode UNDEFINED() { return GetToken(MySqlParser.UNDEFINED, 0); }
		public ITerminalNode UNDOFILE() { return GetToken(MySqlParser.UNDOFILE, 0); }
		public ITerminalNode UNDO_BUFFER_SIZE() { return GetToken(MySqlParser.UNDO_BUFFER_SIZE, 0); }
		public ITerminalNode UNINSTALL() { return GetToken(MySqlParser.UNINSTALL, 0); }
		public ITerminalNode UNKNOWN() { return GetToken(MySqlParser.UNKNOWN, 0); }
		public ITerminalNode UNTIL() { return GetToken(MySqlParser.UNTIL, 0); }
		public ITerminalNode UPGRADE() { return GetToken(MySqlParser.UPGRADE, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public ITerminalNode USE_FRM() { return GetToken(MySqlParser.USE_FRM, 0); }
		public ITerminalNode USER_RESOURCES() { return GetToken(MySqlParser.USER_RESOURCES, 0); }
		public ITerminalNode VALIDATION() { return GetToken(MySqlParser.VALIDATION, 0); }
		public ITerminalNode VALUE() { return GetToken(MySqlParser.VALUE, 0); }
		public ITerminalNode VARIABLES() { return GetToken(MySqlParser.VARIABLES, 0); }
		public ITerminalNode VIEW() { return GetToken(MySqlParser.VIEW, 0); }
		public ITerminalNode WAIT() { return GetToken(MySqlParser.WAIT, 0); }
		public ITerminalNode WARNINGS() { return GetToken(MySqlParser.WARNINGS, 0); }
		public ITerminalNode WITHOUT() { return GetToken(MySqlParser.WITHOUT, 0); }
		public ITerminalNode WORK() { return GetToken(MySqlParser.WORK, 0); }
		public ITerminalNode WRAPPER() { return GetToken(MySqlParser.WRAPPER, 0); }
		public ITerminalNode X509() { return GetToken(MySqlParser.X509, 0); }
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public ITerminalNode XML() { return GetToken(MySqlParser.XML, 0); }
		public KeywordsCanBeIdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keywordsCanBeId; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterKeywordsCanBeId(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitKeywordsCanBeId(this);
		}
	}

	[RuleVersion(0)]
	public KeywordsCanBeIdContext keywordsCanBeId() {
		KeywordsCanBeIdContext _localctx = new KeywordsCanBeIdContext(Context, State);
		EnterRule(_localctx, 616, RULE_keywordsCanBeId);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6176;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 205)) & ~0x3f) == 0 && ((1L << (_la - 205)) & ((1L << (SERIAL - 205)) | (1L << (ACCOUNT - 205)) | (1L << (ACTION - 205)) | (1L << (AFTER - 205)) | (1L << (AGGREGATE - 205)) | (1L << (ALGORITHM - 205)) | (1L << (ANY - 205)) | (1L << (AT - 205)) | (1L << (AUTHORS - 205)) | (1L << (AUTOCOMMIT - 205)) | (1L << (AUTOEXTEND_SIZE - 205)) | (1L << (AUTO_INCREMENT - 205)) | (1L << (AVG_ROW_LENGTH - 205)) | (1L << (BEGIN - 205)) | (1L << (BINLOG - 205)) | (1L << (BIT - 205)) | (1L << (BLOCK - 205)) | (1L << (BOOL - 205)))) != 0) || ((((_la - 269)) & ~0x3f) == 0 && ((1L << (_la - 269)) & ((1L << (BOOLEAN - 269)) | (1L << (BTREE - 269)) | (1L << (CACHE - 269)) | (1L << (CASCADED - 269)) | (1L << (CHAIN - 269)) | (1L << (CHANGED - 269)) | (1L << (CHANNEL - 269)) | (1L << (CHECKSUM - 269)) | (1L << (PAGE_CHECKSUM - 269)) | (1L << (CIPHER - 269)) | (1L << (CLIENT - 269)) | (1L << (CLOSE - 269)) | (1L << (COALESCE - 269)) | (1L << (CODE - 269)) | (1L << (COLUMNS - 269)) | (1L << (COLUMN_FORMAT - 269)) | (1L << (COMMENT - 269)) | (1L << (COMMIT - 269)) | (1L << (COMPACT - 269)) | (1L << (COMPLETION - 269)) | (1L << (COMPRESSED - 269)) | (1L << (COMPRESSION - 269)) | (1L << (CONCURRENT - 269)) | (1L << (CONNECTION - 269)) | (1L << (CONSISTENT - 269)) | (1L << (CONTAINS - 269)) | (1L << (CONTEXT - 269)) | (1L << (CONTRIBUTORS - 269)) | (1L << (COPY - 269)) | (1L << (CPU - 269)) | (1L << (DATA - 269)) | (1L << (DATAFILE - 269)) | (1L << (DEALLOCATE - 269)) | (1L << (DEFAULT_AUTH - 269)) | (1L << (DEFINER - 269)) | (1L << (DELAY_KEY_WRITE - 269)) | (1L << (DES_KEY_FILE - 269)) | (1L << (DIRECTORY - 269)) | (1L << (DISABLE - 269)) | (1L << (DISCARD - 269)) | (1L << (DISK - 269)) | (1L << (DO - 269)) | (1L << (DUMPFILE - 269)) | (1L << (DUPLICATE - 269)) | (1L << (DYNAMIC - 269)) | (1L << (ENABLE - 269)) | (1L << (ENCRYPTION - 269)) | (1L << (END - 269)) | (1L << (ENDS - 269)) | (1L << (ENGINE - 269)) | (1L << (ENGINES - 269)) | (1L << (ERROR - 269)) | (1L << (ERRORS - 269)) | (1L << (ESCAPE - 269)) | (1L << (EVEN - 269)) | (1L << (EVENT - 269)) | (1L << (EVENTS - 269)) | (1L << (EVERY - 269)) | (1L << (EXCHANGE - 269)) | (1L << (EXCLUSIVE - 269)) | (1L << (EXPIRE - 269)) | (1L << (EXPORT - 269)) | (1L << (EXTENDED - 269)) | (1L << (EXTENT_SIZE - 269)))) != 0) || ((((_la - 333)) & ~0x3f) == 0 && ((1L << (_la - 333)) & ((1L << (FAST - 333)) | (1L << (FAULTS - 333)) | (1L << (FIELDS - 333)) | (1L << (FILE_BLOCK_SIZE - 333)) | (1L << (FILTER - 333)) | (1L << (FIRST - 333)) | (1L << (FIXED - 333)) | (1L << (FLUSH - 333)) | (1L << (FOLLOWS - 333)) | (1L << (FOUND - 333)) | (1L << (FULL - 333)) | (1L << (FUNCTION - 333)) | (1L << (GENERAL - 333)) | (1L << (GLOBAL - 333)) | (1L << (GRANTS - 333)) | (1L << (GROUP_REPLICATION - 333)) | (1L << (HANDLER - 333)) | (1L << (HASH - 333)) | (1L << (HELP - 333)) | (1L << (HOST - 333)) | (1L << (HOSTS - 333)) | (1L << (IDENTIFIED - 333)) | (1L << (IGNORE_SERVER_IDS - 333)) | (1L << (IMPORT - 333)) | (1L << (INDEXES - 333)) | (1L << (INITIAL_SIZE - 333)) | (1L << (INPLACE - 333)) | (1L << (INSERT_METHOD - 333)) | (1L << (INSTALL - 333)) | (1L << (INSTANCE - 333)) | (1L << (INVOKER - 333)) | (1L << (IO - 333)) | (1L << (IO_THREAD - 333)) | (1L << (IPC - 333)) | (1L << (ISOLATION - 333)) | (1L << (ISSUER - 333)) | (1L << (JSON - 333)) | (1L << (KEY_BLOCK_SIZE - 333)) | (1L << (LANGUAGE - 333)) | (1L << (LAST - 333)) | (1L << (LEAVES - 333)) | (1L << (LESS - 333)) | (1L << (LEVEL - 333)) | (1L << (LIST - 333)) | (1L << (LOCAL - 333)) | (1L << (LOGFILE - 333)) | (1L << (LOGS - 333)) | (1L << (MASTER - 333)) | (1L << (MASTER_AUTO_POSITION - 333)) | (1L << (MASTER_CONNECT_RETRY - 333)) | (1L << (MASTER_DELAY - 333)) | (1L << (MASTER_HEARTBEAT_PERIOD - 333)) | (1L << (MASTER_HOST - 333)) | (1L << (MASTER_LOG_FILE - 333)) | (1L << (MASTER_LOG_POS - 333)) | (1L << (MASTER_PASSWORD - 333)) | (1L << (MASTER_PORT - 333)) | (1L << (MASTER_RETRY_COUNT - 333)) | (1L << (MASTER_SSL - 333)) | (1L << (MASTER_SSL_CA - 333)) | (1L << (MASTER_SSL_CAPATH - 333)) | (1L << (MASTER_SSL_CERT - 333)) | (1L << (MASTER_SSL_CIPHER - 333)) | (1L << (MASTER_SSL_CRL - 333)))) != 0) || ((((_la - 397)) & ~0x3f) == 0 && ((1L << (_la - 397)) & ((1L << (MASTER_SSL_CRLPATH - 397)) | (1L << (MASTER_SSL_KEY - 397)) | (1L << (MASTER_TLS_VERSION - 397)) | (1L << (MASTER_USER - 397)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 397)) | (1L << (MAX_QUERIES_PER_HOUR - 397)) | (1L << (MAX_ROWS - 397)) | (1L << (MAX_SIZE - 397)) | (1L << (MAX_UPDATES_PER_HOUR - 397)) | (1L << (MAX_USER_CONNECTIONS - 397)) | (1L << (MEDIUM - 397)) | (1L << (MERGE - 397)) | (1L << (MID - 397)) | (1L << (MIGRATE - 397)) | (1L << (MIN_ROWS - 397)) | (1L << (MODE - 397)) | (1L << (MODIFY - 397)) | (1L << (MUTEX - 397)) | (1L << (MYSQL - 397)) | (1L << (NAME - 397)) | (1L << (NAMES - 397)) | (1L << (NCHAR - 397)) | (1L << (NEVER - 397)) | (1L << (NEXT - 397)) | (1L << (NO - 397)) | (1L << (NODEGROUP - 397)) | (1L << (NONE - 397)) | (1L << (OFFLINE - 397)) | (1L << (OFFSET - 397)) | (1L << (OJ - 397)) | (1L << (OLD_PASSWORD - 397)) | (1L << (ONE - 397)) | (1L << (ONLINE - 397)) | (1L << (ONLY - 397)) | (1L << (OPEN - 397)) | (1L << (OPTIMIZER_COSTS - 397)) | (1L << (OPTIONS - 397)) | (1L << (OWNER - 397)) | (1L << (PACK_KEYS - 397)) | (1L << (PAGE - 397)) | (1L << (PARSER - 397)) | (1L << (PARTIAL - 397)) | (1L << (PARTITIONING - 397)) | (1L << (PARTITIONS - 397)) | (1L << (PASSWORD - 397)) | (1L << (PHASE - 397)) | (1L << (PLUGIN - 397)) | (1L << (PLUGIN_DIR - 397)) | (1L << (PLUGINS - 397)) | (1L << (PORT - 397)) | (1L << (PRECEDES - 397)) | (1L << (PREPARE - 397)) | (1L << (PRESERVE - 397)) | (1L << (PREV - 397)) | (1L << (PROCESSLIST - 397)) | (1L << (PROFILE - 397)) | (1L << (PROFILES - 397)) | (1L << (PROXY - 397)) | (1L << (QUERY - 397)) | (1L << (QUICK - 397)) | (1L << (REBUILD - 397)) | (1L << (RECOVER - 397)) | (1L << (REDO_BUFFER_SIZE - 397)) | (1L << (REDUNDANT - 397)))) != 0) || ((((_la - 461)) & ~0x3f) == 0 && ((1L << (_la - 461)) & ((1L << (RELAY - 461)) | (1L << (RELAY_LOG_FILE - 461)) | (1L << (RELAY_LOG_POS - 461)) | (1L << (RELAYLOG - 461)) | (1L << (REMOVE - 461)) | (1L << (REORGANIZE - 461)) | (1L << (REPAIR - 461)) | (1L << (REPLICATE_DO_DB - 461)) | (1L << (REPLICATE_DO_TABLE - 461)) | (1L << (REPLICATE_IGNORE_DB - 461)) | (1L << (REPLICATE_IGNORE_TABLE - 461)) | (1L << (REPLICATE_REWRITE_DB - 461)) | (1L << (REPLICATE_WILD_DO_TABLE - 461)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 461)) | (1L << (REPLICATION - 461)) | (1L << (RESET - 461)) | (1L << (RESUME - 461)) | (1L << (RETURNS - 461)) | (1L << (ROLLBACK - 461)) | (1L << (ROLLUP - 461)) | (1L << (ROTATE - 461)) | (1L << (ROW - 461)) | (1L << (ROWS - 461)) | (1L << (ROW_FORMAT - 461)) | (1L << (SAVEPOINT - 461)) | (1L << (SCHEDULE - 461)) | (1L << (SECURITY - 461)) | (1L << (SERVER - 461)) | (1L << (SESSION - 461)) | (1L << (SHARE - 461)) | (1L << (SHARED - 461)) | (1L << (SIGNED - 461)) | (1L << (SIMPLE - 461)) | (1L << (SLAVE - 461)) | (1L << (SLOW - 461)) | (1L << (SNAPSHOT - 461)) | (1L << (SOCKET - 461)) | (1L << (SOME - 461)) | (1L << (SONAME - 461)) | (1L << (SOUNDS - 461)) | (1L << (SOURCE - 461)) | (1L << (SQL_AFTER_GTIDS - 461)) | (1L << (SQL_AFTER_MTS_GAPS - 461)) | (1L << (SQL_BEFORE_GTIDS - 461)) | (1L << (SQL_BUFFER_RESULT - 461)) | (1L << (SQL_CACHE - 461)) | (1L << (SQL_NO_CACHE - 461)) | (1L << (SQL_THREAD - 461)) | (1L << (START - 461)) | (1L << (STARTS - 461)) | (1L << (STATS_AUTO_RECALC - 461)) | (1L << (STATS_PERSISTENT - 461)) | (1L << (STATS_SAMPLE_PAGES - 461)) | (1L << (STATUS - 461)) | (1L << (STOP - 461)) | (1L << (STORAGE - 461)) | (1L << (STRING - 461)) | (1L << (SUBJECT - 461)) | (1L << (SUBPARTITION - 461)) | (1L << (SUBPARTITIONS - 461)) | (1L << (SUSPEND - 461)) | (1L << (SWAPS - 461)) | (1L << (SWITCHES - 461)))) != 0) || ((((_la - 525)) & ~0x3f) == 0 && ((1L << (_la - 525)) & ((1L << (TABLESPACE - 525)) | (1L << (TEMPORARY - 525)) | (1L << (TEMPTABLE - 525)) | (1L << (THAN - 525)) | (1L << (TRADITIONAL - 525)) | (1L << (TRANSACTION - 525)) | (1L << (TRIGGERS - 525)) | (1L << (TRUNCATE - 525)) | (1L << (UNDEFINED - 525)) | (1L << (UNDOFILE - 525)) | (1L << (UNDO_BUFFER_SIZE - 525)) | (1L << (UNINSTALL - 525)) | (1L << (UNKNOWN - 525)) | (1L << (UNTIL - 525)) | (1L << (UPGRADE - 525)) | (1L << (USER - 525)) | (1L << (USE_FRM - 525)) | (1L << (USER_RESOURCES - 525)) | (1L << (VALIDATION - 525)) | (1L << (VALUE - 525)) | (1L << (VARIABLES - 525)) | (1L << (VIEW - 525)) | (1L << (WAIT - 525)) | (1L << (WARNINGS - 525)) | (1L << (WITHOUT - 525)) | (1L << (WORK - 525)) | (1L << (WRAPPER - 525)) | (1L << (X509 - 525)) | (1L << (XA - 525)) | (1L << (XML - 525)) | (1L << (INTERNAL - 525)))) != 0) || _la==MEMORY) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionNameBaseContext : ParserRuleContext {
		public ITerminalNode ABS() { return GetToken(MySqlParser.ABS, 0); }
		public ITerminalNode ACOS() { return GetToken(MySqlParser.ACOS, 0); }
		public ITerminalNode ADDDATE() { return GetToken(MySqlParser.ADDDATE, 0); }
		public ITerminalNode ADDTIME() { return GetToken(MySqlParser.ADDTIME, 0); }
		public ITerminalNode AES_DECRYPT() { return GetToken(MySqlParser.AES_DECRYPT, 0); }
		public ITerminalNode AES_ENCRYPT() { return GetToken(MySqlParser.AES_ENCRYPT, 0); }
		public ITerminalNode AREA() { return GetToken(MySqlParser.AREA, 0); }
		public ITerminalNode ASBINARY() { return GetToken(MySqlParser.ASBINARY, 0); }
		public ITerminalNode ASIN() { return GetToken(MySqlParser.ASIN, 0); }
		public ITerminalNode ASTEXT() { return GetToken(MySqlParser.ASTEXT, 0); }
		public ITerminalNode ASWKB() { return GetToken(MySqlParser.ASWKB, 0); }
		public ITerminalNode ASWKT() { return GetToken(MySqlParser.ASWKT, 0); }
		public ITerminalNode ASYMMETRIC_DECRYPT() { return GetToken(MySqlParser.ASYMMETRIC_DECRYPT, 0); }
		public ITerminalNode ASYMMETRIC_DERIVE() { return GetToken(MySqlParser.ASYMMETRIC_DERIVE, 0); }
		public ITerminalNode ASYMMETRIC_ENCRYPT() { return GetToken(MySqlParser.ASYMMETRIC_ENCRYPT, 0); }
		public ITerminalNode ASYMMETRIC_SIGN() { return GetToken(MySqlParser.ASYMMETRIC_SIGN, 0); }
		public ITerminalNode ASYMMETRIC_VERIFY() { return GetToken(MySqlParser.ASYMMETRIC_VERIFY, 0); }
		public ITerminalNode ATAN() { return GetToken(MySqlParser.ATAN, 0); }
		public ITerminalNode ATAN2() { return GetToken(MySqlParser.ATAN2, 0); }
		public ITerminalNode BENCHMARK() { return GetToken(MySqlParser.BENCHMARK, 0); }
		public ITerminalNode BIN() { return GetToken(MySqlParser.BIN, 0); }
		public ITerminalNode BIT_COUNT() { return GetToken(MySqlParser.BIT_COUNT, 0); }
		public ITerminalNode BIT_LENGTH() { return GetToken(MySqlParser.BIT_LENGTH, 0); }
		public ITerminalNode BUFFER() { return GetToken(MySqlParser.BUFFER, 0); }
		public ITerminalNode CEIL() { return GetToken(MySqlParser.CEIL, 0); }
		public ITerminalNode CEILING() { return GetToken(MySqlParser.CEILING, 0); }
		public ITerminalNode CENTROID() { return GetToken(MySqlParser.CENTROID, 0); }
		public ITerminalNode CHARACTER_LENGTH() { return GetToken(MySqlParser.CHARACTER_LENGTH, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public ITerminalNode CHAR_LENGTH() { return GetToken(MySqlParser.CHAR_LENGTH, 0); }
		public ITerminalNode COERCIBILITY() { return GetToken(MySqlParser.COERCIBILITY, 0); }
		public ITerminalNode COLLATION() { return GetToken(MySqlParser.COLLATION, 0); }
		public ITerminalNode COMPRESS() { return GetToken(MySqlParser.COMPRESS, 0); }
		public ITerminalNode CONCAT() { return GetToken(MySqlParser.CONCAT, 0); }
		public ITerminalNode CONCAT_WS() { return GetToken(MySqlParser.CONCAT_WS, 0); }
		public ITerminalNode CONNECTION_ID() { return GetToken(MySqlParser.CONNECTION_ID, 0); }
		public ITerminalNode CONV() { return GetToken(MySqlParser.CONV, 0); }
		public ITerminalNode CONVERT_TZ() { return GetToken(MySqlParser.CONVERT_TZ, 0); }
		public ITerminalNode COS() { return GetToken(MySqlParser.COS, 0); }
		public ITerminalNode COT() { return GetToken(MySqlParser.COT, 0); }
		public ITerminalNode COUNT() { return GetToken(MySqlParser.COUNT, 0); }
		public ITerminalNode CRC32() { return GetToken(MySqlParser.CRC32, 0); }
		public ITerminalNode CREATE_ASYMMETRIC_PRIV_KEY() { return GetToken(MySqlParser.CREATE_ASYMMETRIC_PRIV_KEY, 0); }
		public ITerminalNode CREATE_ASYMMETRIC_PUB_KEY() { return GetToken(MySqlParser.CREATE_ASYMMETRIC_PUB_KEY, 0); }
		public ITerminalNode CREATE_DH_PARAMETERS() { return GetToken(MySqlParser.CREATE_DH_PARAMETERS, 0); }
		public ITerminalNode CREATE_DIGEST() { return GetToken(MySqlParser.CREATE_DIGEST, 0); }
		public ITerminalNode CROSSES() { return GetToken(MySqlParser.CROSSES, 0); }
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode DATE() { return GetToken(MySqlParser.DATE, 0); }
		public ITerminalNode DATEDIFF() { return GetToken(MySqlParser.DATEDIFF, 0); }
		public ITerminalNode DATE_FORMAT() { return GetToken(MySqlParser.DATE_FORMAT, 0); }
		public ITerminalNode DAY() { return GetToken(MySqlParser.DAY, 0); }
		public ITerminalNode DAYNAME() { return GetToken(MySqlParser.DAYNAME, 0); }
		public ITerminalNode DAYOFMONTH() { return GetToken(MySqlParser.DAYOFMONTH, 0); }
		public ITerminalNode DAYOFWEEK() { return GetToken(MySqlParser.DAYOFWEEK, 0); }
		public ITerminalNode DAYOFYEAR() { return GetToken(MySqlParser.DAYOFYEAR, 0); }
		public ITerminalNode DECODE() { return GetToken(MySqlParser.DECODE, 0); }
		public ITerminalNode DEGREES() { return GetToken(MySqlParser.DEGREES, 0); }
		public ITerminalNode DES_DECRYPT() { return GetToken(MySqlParser.DES_DECRYPT, 0); }
		public ITerminalNode DES_ENCRYPT() { return GetToken(MySqlParser.DES_ENCRYPT, 0); }
		public ITerminalNode DIMENSION() { return GetToken(MySqlParser.DIMENSION, 0); }
		public ITerminalNode DISJOINT() { return GetToken(MySqlParser.DISJOINT, 0); }
		public ITerminalNode ELT() { return GetToken(MySqlParser.ELT, 0); }
		public ITerminalNode ENCODE() { return GetToken(MySqlParser.ENCODE, 0); }
		public ITerminalNode ENCRYPT() { return GetToken(MySqlParser.ENCRYPT, 0); }
		public ITerminalNode ENDPOINT() { return GetToken(MySqlParser.ENDPOINT, 0); }
		public ITerminalNode ENVELOPE() { return GetToken(MySqlParser.ENVELOPE, 0); }
		public ITerminalNode EQUALS() { return GetToken(MySqlParser.EQUALS, 0); }
		public ITerminalNode EXP() { return GetToken(MySqlParser.EXP, 0); }
		public ITerminalNode EXPORT_SET() { return GetToken(MySqlParser.EXPORT_SET, 0); }
		public ITerminalNode EXTERIORRING() { return GetToken(MySqlParser.EXTERIORRING, 0); }
		public ITerminalNode EXTRACTVALUE() { return GetToken(MySqlParser.EXTRACTVALUE, 0); }
		public ITerminalNode FIELD() { return GetToken(MySqlParser.FIELD, 0); }
		public ITerminalNode FIND_IN_SET() { return GetToken(MySqlParser.FIND_IN_SET, 0); }
		public ITerminalNode FLOOR() { return GetToken(MySqlParser.FLOOR, 0); }
		public ITerminalNode FORMAT() { return GetToken(MySqlParser.FORMAT, 0); }
		public ITerminalNode FOUND_ROWS() { return GetToken(MySqlParser.FOUND_ROWS, 0); }
		public ITerminalNode FROM_BASE64() { return GetToken(MySqlParser.FROM_BASE64, 0); }
		public ITerminalNode FROM_DAYS() { return GetToken(MySqlParser.FROM_DAYS, 0); }
		public ITerminalNode FROM_UNIXTIME() { return GetToken(MySqlParser.FROM_UNIXTIME, 0); }
		public ITerminalNode GEOMCOLLFROMTEXT() { return GetToken(MySqlParser.GEOMCOLLFROMTEXT, 0); }
		public ITerminalNode GEOMCOLLFROMWKB() { return GetToken(MySqlParser.GEOMCOLLFROMWKB, 0); }
		public ITerminalNode GEOMETRYCOLLECTION() { return GetToken(MySqlParser.GEOMETRYCOLLECTION, 0); }
		public ITerminalNode GEOMETRYCOLLECTIONFROMTEXT() { return GetToken(MySqlParser.GEOMETRYCOLLECTIONFROMTEXT, 0); }
		public ITerminalNode GEOMETRYCOLLECTIONFROMWKB() { return GetToken(MySqlParser.GEOMETRYCOLLECTIONFROMWKB, 0); }
		public ITerminalNode GEOMETRYFROMTEXT() { return GetToken(MySqlParser.GEOMETRYFROMTEXT, 0); }
		public ITerminalNode GEOMETRYFROMWKB() { return GetToken(MySqlParser.GEOMETRYFROMWKB, 0); }
		public ITerminalNode GEOMETRYN() { return GetToken(MySqlParser.GEOMETRYN, 0); }
		public ITerminalNode GEOMETRYTYPE() { return GetToken(MySqlParser.GEOMETRYTYPE, 0); }
		public ITerminalNode GEOMFROMTEXT() { return GetToken(MySqlParser.GEOMFROMTEXT, 0); }
		public ITerminalNode GEOMFROMWKB() { return GetToken(MySqlParser.GEOMFROMWKB, 0); }
		public ITerminalNode GET_FORMAT() { return GetToken(MySqlParser.GET_FORMAT, 0); }
		public ITerminalNode GET_LOCK() { return GetToken(MySqlParser.GET_LOCK, 0); }
		public ITerminalNode GLENGTH() { return GetToken(MySqlParser.GLENGTH, 0); }
		public ITerminalNode GREATEST() { return GetToken(MySqlParser.GREATEST, 0); }
		public ITerminalNode GTID_SUBSET() { return GetToken(MySqlParser.GTID_SUBSET, 0); }
		public ITerminalNode GTID_SUBTRACT() { return GetToken(MySqlParser.GTID_SUBTRACT, 0); }
		public ITerminalNode HEX() { return GetToken(MySqlParser.HEX, 0); }
		public ITerminalNode HOUR() { return GetToken(MySqlParser.HOUR, 0); }
		public ITerminalNode IFNULL() { return GetToken(MySqlParser.IFNULL, 0); }
		public ITerminalNode INET6_ATON() { return GetToken(MySqlParser.INET6_ATON, 0); }
		public ITerminalNode INET6_NTOA() { return GetToken(MySqlParser.INET6_NTOA, 0); }
		public ITerminalNode INET_ATON() { return GetToken(MySqlParser.INET_ATON, 0); }
		public ITerminalNode INET_NTOA() { return GetToken(MySqlParser.INET_NTOA, 0); }
		public ITerminalNode INSTR() { return GetToken(MySqlParser.INSTR, 0); }
		public ITerminalNode INTERIORRINGN() { return GetToken(MySqlParser.INTERIORRINGN, 0); }
		public ITerminalNode INTERSECTS() { return GetToken(MySqlParser.INTERSECTS, 0); }
		public ITerminalNode ISCLOSED() { return GetToken(MySqlParser.ISCLOSED, 0); }
		public ITerminalNode ISEMPTY() { return GetToken(MySqlParser.ISEMPTY, 0); }
		public ITerminalNode ISNULL() { return GetToken(MySqlParser.ISNULL, 0); }
		public ITerminalNode ISSIMPLE() { return GetToken(MySqlParser.ISSIMPLE, 0); }
		public ITerminalNode IS_FREE_LOCK() { return GetToken(MySqlParser.IS_FREE_LOCK, 0); }
		public ITerminalNode IS_IPV4() { return GetToken(MySqlParser.IS_IPV4, 0); }
		public ITerminalNode IS_IPV4_COMPAT() { return GetToken(MySqlParser.IS_IPV4_COMPAT, 0); }
		public ITerminalNode IS_IPV4_MAPPED() { return GetToken(MySqlParser.IS_IPV4_MAPPED, 0); }
		public ITerminalNode IS_IPV6() { return GetToken(MySqlParser.IS_IPV6, 0); }
		public ITerminalNode IS_USED_LOCK() { return GetToken(MySqlParser.IS_USED_LOCK, 0); }
		public ITerminalNode LAST_INSERT_ID() { return GetToken(MySqlParser.LAST_INSERT_ID, 0); }
		public ITerminalNode LCASE() { return GetToken(MySqlParser.LCASE, 0); }
		public ITerminalNode LEAST() { return GetToken(MySqlParser.LEAST, 0); }
		public ITerminalNode LEFT() { return GetToken(MySqlParser.LEFT, 0); }
		public ITerminalNode LENGTH() { return GetToken(MySqlParser.LENGTH, 0); }
		public ITerminalNode LINEFROMTEXT() { return GetToken(MySqlParser.LINEFROMTEXT, 0); }
		public ITerminalNode LINEFROMWKB() { return GetToken(MySqlParser.LINEFROMWKB, 0); }
		public ITerminalNode LINESTRING() { return GetToken(MySqlParser.LINESTRING, 0); }
		public ITerminalNode LINESTRINGFROMTEXT() { return GetToken(MySqlParser.LINESTRINGFROMTEXT, 0); }
		public ITerminalNode LINESTRINGFROMWKB() { return GetToken(MySqlParser.LINESTRINGFROMWKB, 0); }
		public ITerminalNode LN() { return GetToken(MySqlParser.LN, 0); }
		public ITerminalNode LOAD_FILE() { return GetToken(MySqlParser.LOAD_FILE, 0); }
		public ITerminalNode LOCATE() { return GetToken(MySqlParser.LOCATE, 0); }
		public ITerminalNode LOG() { return GetToken(MySqlParser.LOG, 0); }
		public ITerminalNode LOG10() { return GetToken(MySqlParser.LOG10, 0); }
		public ITerminalNode LOG2() { return GetToken(MySqlParser.LOG2, 0); }
		public ITerminalNode LOWER() { return GetToken(MySqlParser.LOWER, 0); }
		public ITerminalNode LPAD() { return GetToken(MySqlParser.LPAD, 0); }
		public ITerminalNode LTRIM() { return GetToken(MySqlParser.LTRIM, 0); }
		public ITerminalNode MAKEDATE() { return GetToken(MySqlParser.MAKEDATE, 0); }
		public ITerminalNode MAKETIME() { return GetToken(MySqlParser.MAKETIME, 0); }
		public ITerminalNode MAKE_SET() { return GetToken(MySqlParser.MAKE_SET, 0); }
		public ITerminalNode MASTER_POS_WAIT() { return GetToken(MySqlParser.MASTER_POS_WAIT, 0); }
		public ITerminalNode MBRCONTAINS() { return GetToken(MySqlParser.MBRCONTAINS, 0); }
		public ITerminalNode MBRDISJOINT() { return GetToken(MySqlParser.MBRDISJOINT, 0); }
		public ITerminalNode MBREQUAL() { return GetToken(MySqlParser.MBREQUAL, 0); }
		public ITerminalNode MBRINTERSECTS() { return GetToken(MySqlParser.MBRINTERSECTS, 0); }
		public ITerminalNode MBROVERLAPS() { return GetToken(MySqlParser.MBROVERLAPS, 0); }
		public ITerminalNode MBRTOUCHES() { return GetToken(MySqlParser.MBRTOUCHES, 0); }
		public ITerminalNode MBRWITHIN() { return GetToken(MySqlParser.MBRWITHIN, 0); }
		public ITerminalNode MD5() { return GetToken(MySqlParser.MD5, 0); }
		public ITerminalNode MICROSECOND() { return GetToken(MySqlParser.MICROSECOND, 0); }
		public ITerminalNode MINUTE() { return GetToken(MySqlParser.MINUTE, 0); }
		public ITerminalNode MLINEFROMTEXT() { return GetToken(MySqlParser.MLINEFROMTEXT, 0); }
		public ITerminalNode MLINEFROMWKB() { return GetToken(MySqlParser.MLINEFROMWKB, 0); }
		public ITerminalNode MONTH() { return GetToken(MySqlParser.MONTH, 0); }
		public ITerminalNode MONTHNAME() { return GetToken(MySqlParser.MONTHNAME, 0); }
		public ITerminalNode MPOINTFROMTEXT() { return GetToken(MySqlParser.MPOINTFROMTEXT, 0); }
		public ITerminalNode MPOINTFROMWKB() { return GetToken(MySqlParser.MPOINTFROMWKB, 0); }
		public ITerminalNode MPOLYFROMTEXT() { return GetToken(MySqlParser.MPOLYFROMTEXT, 0); }
		public ITerminalNode MPOLYFROMWKB() { return GetToken(MySqlParser.MPOLYFROMWKB, 0); }
		public ITerminalNode MULTILINESTRING() { return GetToken(MySqlParser.MULTILINESTRING, 0); }
		public ITerminalNode MULTILINESTRINGFROMTEXT() { return GetToken(MySqlParser.MULTILINESTRINGFROMTEXT, 0); }
		public ITerminalNode MULTILINESTRINGFROMWKB() { return GetToken(MySqlParser.MULTILINESTRINGFROMWKB, 0); }
		public ITerminalNode MULTIPOINT() { return GetToken(MySqlParser.MULTIPOINT, 0); }
		public ITerminalNode MULTIPOINTFROMTEXT() { return GetToken(MySqlParser.MULTIPOINTFROMTEXT, 0); }
		public ITerminalNode MULTIPOINTFROMWKB() { return GetToken(MySqlParser.MULTIPOINTFROMWKB, 0); }
		public ITerminalNode MULTIPOLYGON() { return GetToken(MySqlParser.MULTIPOLYGON, 0); }
		public ITerminalNode MULTIPOLYGONFROMTEXT() { return GetToken(MySqlParser.MULTIPOLYGONFROMTEXT, 0); }
		public ITerminalNode MULTIPOLYGONFROMWKB() { return GetToken(MySqlParser.MULTIPOLYGONFROMWKB, 0); }
		public ITerminalNode NAME_CONST() { return GetToken(MySqlParser.NAME_CONST, 0); }
		public ITerminalNode NULLIF() { return GetToken(MySqlParser.NULLIF, 0); }
		public ITerminalNode NUMGEOMETRIES() { return GetToken(MySqlParser.NUMGEOMETRIES, 0); }
		public ITerminalNode NUMINTERIORRINGS() { return GetToken(MySqlParser.NUMINTERIORRINGS, 0); }
		public ITerminalNode NUMPOINTS() { return GetToken(MySqlParser.NUMPOINTS, 0); }
		public ITerminalNode OCT() { return GetToken(MySqlParser.OCT, 0); }
		public ITerminalNode OCTET_LENGTH() { return GetToken(MySqlParser.OCTET_LENGTH, 0); }
		public ITerminalNode ORD() { return GetToken(MySqlParser.ORD, 0); }
		public ITerminalNode OVERLAPS() { return GetToken(MySqlParser.OVERLAPS, 0); }
		public ITerminalNode PERIOD_ADD() { return GetToken(MySqlParser.PERIOD_ADD, 0); }
		public ITerminalNode PERIOD_DIFF() { return GetToken(MySqlParser.PERIOD_DIFF, 0); }
		public ITerminalNode PI() { return GetToken(MySqlParser.PI, 0); }
		public ITerminalNode POINT() { return GetToken(MySqlParser.POINT, 0); }
		public ITerminalNode POINTFROMTEXT() { return GetToken(MySqlParser.POINTFROMTEXT, 0); }
		public ITerminalNode POINTFROMWKB() { return GetToken(MySqlParser.POINTFROMWKB, 0); }
		public ITerminalNode POINTN() { return GetToken(MySqlParser.POINTN, 0); }
		public ITerminalNode POLYFROMTEXT() { return GetToken(MySqlParser.POLYFROMTEXT, 0); }
		public ITerminalNode POLYFROMWKB() { return GetToken(MySqlParser.POLYFROMWKB, 0); }
		public ITerminalNode POLYGON() { return GetToken(MySqlParser.POLYGON, 0); }
		public ITerminalNode POLYGONFROMTEXT() { return GetToken(MySqlParser.POLYGONFROMTEXT, 0); }
		public ITerminalNode POLYGONFROMWKB() { return GetToken(MySqlParser.POLYGONFROMWKB, 0); }
		public ITerminalNode POSITION() { return GetToken(MySqlParser.POSITION, 0); }
		public ITerminalNode POW() { return GetToken(MySqlParser.POW, 0); }
		public ITerminalNode POWER() { return GetToken(MySqlParser.POWER, 0); }
		public ITerminalNode QUARTER() { return GetToken(MySqlParser.QUARTER, 0); }
		public ITerminalNode QUOTE() { return GetToken(MySqlParser.QUOTE, 0); }
		public ITerminalNode RADIANS() { return GetToken(MySqlParser.RADIANS, 0); }
		public ITerminalNode RAND() { return GetToken(MySqlParser.RAND, 0); }
		public ITerminalNode RANDOM_BYTES() { return GetToken(MySqlParser.RANDOM_BYTES, 0); }
		public ITerminalNode RELEASE_LOCK() { return GetToken(MySqlParser.RELEASE_LOCK, 0); }
		public ITerminalNode REVERSE() { return GetToken(MySqlParser.REVERSE, 0); }
		public ITerminalNode RIGHT() { return GetToken(MySqlParser.RIGHT, 0); }
		public ITerminalNode ROUND() { return GetToken(MySqlParser.ROUND, 0); }
		public ITerminalNode ROW_COUNT() { return GetToken(MySqlParser.ROW_COUNT, 0); }
		public ITerminalNode RPAD() { return GetToken(MySqlParser.RPAD, 0); }
		public ITerminalNode RTRIM() { return GetToken(MySqlParser.RTRIM, 0); }
		public ITerminalNode SECOND() { return GetToken(MySqlParser.SECOND, 0); }
		public ITerminalNode SEC_TO_TIME() { return GetToken(MySqlParser.SEC_TO_TIME, 0); }
		public ITerminalNode SESSION_USER() { return GetToken(MySqlParser.SESSION_USER, 0); }
		public ITerminalNode SHA() { return GetToken(MySqlParser.SHA, 0); }
		public ITerminalNode SHA1() { return GetToken(MySqlParser.SHA1, 0); }
		public ITerminalNode SHA2() { return GetToken(MySqlParser.SHA2, 0); }
		public ITerminalNode SIGN() { return GetToken(MySqlParser.SIGN, 0); }
		public ITerminalNode SIN() { return GetToken(MySqlParser.SIN, 0); }
		public ITerminalNode SLEEP() { return GetToken(MySqlParser.SLEEP, 0); }
		public ITerminalNode SOUNDEX() { return GetToken(MySqlParser.SOUNDEX, 0); }
		public ITerminalNode SQL_THREAD_WAIT_AFTER_GTIDS() { return GetToken(MySqlParser.SQL_THREAD_WAIT_AFTER_GTIDS, 0); }
		public ITerminalNode SQRT() { return GetToken(MySqlParser.SQRT, 0); }
		public ITerminalNode SRID() { return GetToken(MySqlParser.SRID, 0); }
		public ITerminalNode STARTPOINT() { return GetToken(MySqlParser.STARTPOINT, 0); }
		public ITerminalNode STRCMP() { return GetToken(MySqlParser.STRCMP, 0); }
		public ITerminalNode STR_TO_DATE() { return GetToken(MySqlParser.STR_TO_DATE, 0); }
		public ITerminalNode ST_AREA() { return GetToken(MySqlParser.ST_AREA, 0); }
		public ITerminalNode ST_ASBINARY() { return GetToken(MySqlParser.ST_ASBINARY, 0); }
		public ITerminalNode ST_ASTEXT() { return GetToken(MySqlParser.ST_ASTEXT, 0); }
		public ITerminalNode ST_ASWKB() { return GetToken(MySqlParser.ST_ASWKB, 0); }
		public ITerminalNode ST_ASWKT() { return GetToken(MySqlParser.ST_ASWKT, 0); }
		public ITerminalNode ST_BUFFER() { return GetToken(MySqlParser.ST_BUFFER, 0); }
		public ITerminalNode ST_CENTROID() { return GetToken(MySqlParser.ST_CENTROID, 0); }
		public ITerminalNode ST_CONTAINS() { return GetToken(MySqlParser.ST_CONTAINS, 0); }
		public ITerminalNode ST_CROSSES() { return GetToken(MySqlParser.ST_CROSSES, 0); }
		public ITerminalNode ST_DIFFERENCE() { return GetToken(MySqlParser.ST_DIFFERENCE, 0); }
		public ITerminalNode ST_DIMENSION() { return GetToken(MySqlParser.ST_DIMENSION, 0); }
		public ITerminalNode ST_DISJOINT() { return GetToken(MySqlParser.ST_DISJOINT, 0); }
		public ITerminalNode ST_DISTANCE() { return GetToken(MySqlParser.ST_DISTANCE, 0); }
		public ITerminalNode ST_ENDPOINT() { return GetToken(MySqlParser.ST_ENDPOINT, 0); }
		public ITerminalNode ST_ENVELOPE() { return GetToken(MySqlParser.ST_ENVELOPE, 0); }
		public ITerminalNode ST_EQUALS() { return GetToken(MySqlParser.ST_EQUALS, 0); }
		public ITerminalNode ST_EXTERIORRING() { return GetToken(MySqlParser.ST_EXTERIORRING, 0); }
		public ITerminalNode ST_GEOMCOLLFROMTEXT() { return GetToken(MySqlParser.ST_GEOMCOLLFROMTEXT, 0); }
		public ITerminalNode ST_GEOMCOLLFROMTXT() { return GetToken(MySqlParser.ST_GEOMCOLLFROMTXT, 0); }
		public ITerminalNode ST_GEOMCOLLFROMWKB() { return GetToken(MySqlParser.ST_GEOMCOLLFROMWKB, 0); }
		public ITerminalNode ST_GEOMETRYCOLLECTIONFROMTEXT() { return GetToken(MySqlParser.ST_GEOMETRYCOLLECTIONFROMTEXT, 0); }
		public ITerminalNode ST_GEOMETRYCOLLECTIONFROMWKB() { return GetToken(MySqlParser.ST_GEOMETRYCOLLECTIONFROMWKB, 0); }
		public ITerminalNode ST_GEOMETRYFROMTEXT() { return GetToken(MySqlParser.ST_GEOMETRYFROMTEXT, 0); }
		public ITerminalNode ST_GEOMETRYFROMWKB() { return GetToken(MySqlParser.ST_GEOMETRYFROMWKB, 0); }
		public ITerminalNode ST_GEOMETRYN() { return GetToken(MySqlParser.ST_GEOMETRYN, 0); }
		public ITerminalNode ST_GEOMETRYTYPE() { return GetToken(MySqlParser.ST_GEOMETRYTYPE, 0); }
		public ITerminalNode ST_GEOMFROMTEXT() { return GetToken(MySqlParser.ST_GEOMFROMTEXT, 0); }
		public ITerminalNode ST_GEOMFROMWKB() { return GetToken(MySqlParser.ST_GEOMFROMWKB, 0); }
		public ITerminalNode ST_INTERIORRINGN() { return GetToken(MySqlParser.ST_INTERIORRINGN, 0); }
		public ITerminalNode ST_INTERSECTION() { return GetToken(MySqlParser.ST_INTERSECTION, 0); }
		public ITerminalNode ST_INTERSECTS() { return GetToken(MySqlParser.ST_INTERSECTS, 0); }
		public ITerminalNode ST_ISCLOSED() { return GetToken(MySqlParser.ST_ISCLOSED, 0); }
		public ITerminalNode ST_ISEMPTY() { return GetToken(MySqlParser.ST_ISEMPTY, 0); }
		public ITerminalNode ST_ISSIMPLE() { return GetToken(MySqlParser.ST_ISSIMPLE, 0); }
		public ITerminalNode ST_LINEFROMTEXT() { return GetToken(MySqlParser.ST_LINEFROMTEXT, 0); }
		public ITerminalNode ST_LINEFROMWKB() { return GetToken(MySqlParser.ST_LINEFROMWKB, 0); }
		public ITerminalNode ST_LINESTRINGFROMTEXT() { return GetToken(MySqlParser.ST_LINESTRINGFROMTEXT, 0); }
		public ITerminalNode ST_LINESTRINGFROMWKB() { return GetToken(MySqlParser.ST_LINESTRINGFROMWKB, 0); }
		public ITerminalNode ST_NUMGEOMETRIES() { return GetToken(MySqlParser.ST_NUMGEOMETRIES, 0); }
		public ITerminalNode ST_NUMINTERIORRING() { return GetToken(MySqlParser.ST_NUMINTERIORRING, 0); }
		public ITerminalNode ST_NUMINTERIORRINGS() { return GetToken(MySqlParser.ST_NUMINTERIORRINGS, 0); }
		public ITerminalNode ST_NUMPOINTS() { return GetToken(MySqlParser.ST_NUMPOINTS, 0); }
		public ITerminalNode ST_OVERLAPS() { return GetToken(MySqlParser.ST_OVERLAPS, 0); }
		public ITerminalNode ST_POINTFROMTEXT() { return GetToken(MySqlParser.ST_POINTFROMTEXT, 0); }
		public ITerminalNode ST_POINTFROMWKB() { return GetToken(MySqlParser.ST_POINTFROMWKB, 0); }
		public ITerminalNode ST_POINTN() { return GetToken(MySqlParser.ST_POINTN, 0); }
		public ITerminalNode ST_POLYFROMTEXT() { return GetToken(MySqlParser.ST_POLYFROMTEXT, 0); }
		public ITerminalNode ST_POLYFROMWKB() { return GetToken(MySqlParser.ST_POLYFROMWKB, 0); }
		public ITerminalNode ST_POLYGONFROMTEXT() { return GetToken(MySqlParser.ST_POLYGONFROMTEXT, 0); }
		public ITerminalNode ST_POLYGONFROMWKB() { return GetToken(MySqlParser.ST_POLYGONFROMWKB, 0); }
		public ITerminalNode ST_SRID() { return GetToken(MySqlParser.ST_SRID, 0); }
		public ITerminalNode ST_STARTPOINT() { return GetToken(MySqlParser.ST_STARTPOINT, 0); }
		public ITerminalNode ST_SYMDIFFERENCE() { return GetToken(MySqlParser.ST_SYMDIFFERENCE, 0); }
		public ITerminalNode ST_TOUCHES() { return GetToken(MySqlParser.ST_TOUCHES, 0); }
		public ITerminalNode ST_UNION() { return GetToken(MySqlParser.ST_UNION, 0); }
		public ITerminalNode ST_WITHIN() { return GetToken(MySqlParser.ST_WITHIN, 0); }
		public ITerminalNode ST_X() { return GetToken(MySqlParser.ST_X, 0); }
		public ITerminalNode ST_Y() { return GetToken(MySqlParser.ST_Y, 0); }
		public ITerminalNode SUBDATE() { return GetToken(MySqlParser.SUBDATE, 0); }
		public ITerminalNode SUBSTRING_INDEX() { return GetToken(MySqlParser.SUBSTRING_INDEX, 0); }
		public ITerminalNode SUBTIME() { return GetToken(MySqlParser.SUBTIME, 0); }
		public ITerminalNode SYSTEM_USER() { return GetToken(MySqlParser.SYSTEM_USER, 0); }
		public ITerminalNode TAN() { return GetToken(MySqlParser.TAN, 0); }
		public ITerminalNode TIME() { return GetToken(MySqlParser.TIME, 0); }
		public ITerminalNode TIMEDIFF() { return GetToken(MySqlParser.TIMEDIFF, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(MySqlParser.TIMESTAMP, 0); }
		public ITerminalNode TIMESTAMPADD() { return GetToken(MySqlParser.TIMESTAMPADD, 0); }
		public ITerminalNode TIMESTAMPDIFF() { return GetToken(MySqlParser.TIMESTAMPDIFF, 0); }
		public ITerminalNode TIME_FORMAT() { return GetToken(MySqlParser.TIME_FORMAT, 0); }
		public ITerminalNode TIME_TO_SEC() { return GetToken(MySqlParser.TIME_TO_SEC, 0); }
		public ITerminalNode TOUCHES() { return GetToken(MySqlParser.TOUCHES, 0); }
		public ITerminalNode TO_BASE64() { return GetToken(MySqlParser.TO_BASE64, 0); }
		public ITerminalNode TO_DAYS() { return GetToken(MySqlParser.TO_DAYS, 0); }
		public ITerminalNode TO_SECONDS() { return GetToken(MySqlParser.TO_SECONDS, 0); }
		public ITerminalNode UCASE() { return GetToken(MySqlParser.UCASE, 0); }
		public ITerminalNode UNCOMPRESS() { return GetToken(MySqlParser.UNCOMPRESS, 0); }
		public ITerminalNode UNCOMPRESSED_LENGTH() { return GetToken(MySqlParser.UNCOMPRESSED_LENGTH, 0); }
		public ITerminalNode UNHEX() { return GetToken(MySqlParser.UNHEX, 0); }
		public ITerminalNode UNIX_TIMESTAMP() { return GetToken(MySqlParser.UNIX_TIMESTAMP, 0); }
		public ITerminalNode UPDATEXML() { return GetToken(MySqlParser.UPDATEXML, 0); }
		public ITerminalNode UPPER() { return GetToken(MySqlParser.UPPER, 0); }
		public ITerminalNode UUID() { return GetToken(MySqlParser.UUID, 0); }
		public ITerminalNode UUID_SHORT() { return GetToken(MySqlParser.UUID_SHORT, 0); }
		public ITerminalNode VALIDATE_PASSWORD_STRENGTH() { return GetToken(MySqlParser.VALIDATE_PASSWORD_STRENGTH, 0); }
		public ITerminalNode VERSION() { return GetToken(MySqlParser.VERSION, 0); }
		public ITerminalNode WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() { return GetToken(MySqlParser.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, 0); }
		public ITerminalNode WEEK() { return GetToken(MySqlParser.WEEK, 0); }
		public ITerminalNode WEEKDAY() { return GetToken(MySqlParser.WEEKDAY, 0); }
		public ITerminalNode WEEKOFYEAR() { return GetToken(MySqlParser.WEEKOFYEAR, 0); }
		public ITerminalNode WEIGHT_STRING() { return GetToken(MySqlParser.WEIGHT_STRING, 0); }
		public ITerminalNode WITHIN() { return GetToken(MySqlParser.WITHIN, 0); }
		public ITerminalNode YEAR() { return GetToken(MySqlParser.YEAR, 0); }
		public ITerminalNode YEARWEEK() { return GetToken(MySqlParser.YEARWEEK, 0); }
		public ITerminalNode Y_FUNCTION() { return GetToken(MySqlParser.Y_FUNCTION, 0); }
		public ITerminalNode X_FUNCTION() { return GetToken(MySqlParser.X_FUNCTION, 0); }
		public FunctionNameBaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionNameBase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFunctionNameBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFunctionNameBase(this);
		}
	}

	[RuleVersion(0)]
	public FunctionNameBaseContext functionNameBase() {
		FunctionNameBaseContext _localctx = new FunctionNameBaseContext(Context, State);
		EnterRule(_localctx, 618, RULE_functionNameBase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6178;
			_la = TokenStream.LA(1);
			if ( !(_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 184)) & ~0x3f) == 0 && ((1L << (_la - 184)) & ((1L << (DATE - 184)) | (1L << (TIME - 184)) | (1L << (TIMESTAMP - 184)) | (1L << (YEAR - 184)) | (1L << (COUNT - 184)) | (1L << (POSITION - 184)))) != 0) || ((((_la - 561)) & ~0x3f) == 0 && ((1L << (_la - 561)) & ((1L << (QUARTER - 561)) | (1L << (MONTH - 561)) | (1L << (DAY - 561)) | (1L << (HOUR - 561)) | (1L << (MINUTE - 561)) | (1L << (WEEK - 561)) | (1L << (SECOND - 561)) | (1L << (MICROSECOND - 561)))) != 0) || ((((_la - 634)) & ~0x3f) == 0 && ((1L << (_la - 634)) & ((1L << (GEOMETRYCOLLECTION - 634)) | (1L << (LINESTRING - 634)) | (1L << (MULTILINESTRING - 634)) | (1L << (MULTIPOINT - 634)) | (1L << (MULTIPOLYGON - 634)) | (1L << (POINT - 634)) | (1L << (POLYGON - 634)) | (1L << (ABS - 634)) | (1L << (ACOS - 634)) | (1L << (ADDDATE - 634)) | (1L << (ADDTIME - 634)) | (1L << (AES_DECRYPT - 634)) | (1L << (AES_ENCRYPT - 634)) | (1L << (AREA - 634)) | (1L << (ASBINARY - 634)) | (1L << (ASIN - 634)) | (1L << (ASTEXT - 634)) | (1L << (ASWKB - 634)) | (1L << (ASWKT - 634)) | (1L << (ASYMMETRIC_DECRYPT - 634)) | (1L << (ASYMMETRIC_DERIVE - 634)) | (1L << (ASYMMETRIC_ENCRYPT - 634)) | (1L << (ASYMMETRIC_SIGN - 634)) | (1L << (ASYMMETRIC_VERIFY - 634)) | (1L << (ATAN - 634)) | (1L << (ATAN2 - 634)) | (1L << (BENCHMARK - 634)) | (1L << (BIN - 634)) | (1L << (BIT_COUNT - 634)) | (1L << (BIT_LENGTH - 634)) | (1L << (BUFFER - 634)) | (1L << (CEIL - 634)) | (1L << (CEILING - 634)) | (1L << (CENTROID - 634)) | (1L << (CHARACTER_LENGTH - 634)) | (1L << (CHARSET - 634)) | (1L << (CHAR_LENGTH - 634)) | (1L << (COERCIBILITY - 634)) | (1L << (COLLATION - 634)) | (1L << (COMPRESS - 634)) | (1L << (CONCAT - 634)) | (1L << (CONCAT_WS - 634)) | (1L << (CONNECTION_ID - 634)) | (1L << (CONV - 634)) | (1L << (CONVERT_TZ - 634)) | (1L << (COS - 634)) | (1L << (COT - 634)) | (1L << (CRC32 - 634)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 634)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 634)) | (1L << (CREATE_DH_PARAMETERS - 634)) | (1L << (CREATE_DIGEST - 634)) | (1L << (CROSSES - 634)) | (1L << (DATEDIFF - 634)) | (1L << (DATE_FORMAT - 634)) | (1L << (DAYNAME - 634)) | (1L << (DAYOFMONTH - 634)) | (1L << (DAYOFWEEK - 634)) | (1L << (DAYOFYEAR - 634)) | (1L << (DECODE - 634)) | (1L << (DEGREES - 634)) | (1L << (DES_DECRYPT - 634)))) != 0) || ((((_la - 698)) & ~0x3f) == 0 && ((1L << (_la - 698)) & ((1L << (DES_ENCRYPT - 698)) | (1L << (DIMENSION - 698)) | (1L << (DISJOINT - 698)) | (1L << (ELT - 698)) | (1L << (ENCODE - 698)) | (1L << (ENCRYPT - 698)) | (1L << (ENDPOINT - 698)) | (1L << (ENVELOPE - 698)) | (1L << (EQUALS - 698)) | (1L << (EXP - 698)) | (1L << (EXPORT_SET - 698)) | (1L << (EXTERIORRING - 698)) | (1L << (EXTRACTVALUE - 698)) | (1L << (FIELD - 698)) | (1L << (FIND_IN_SET - 698)) | (1L << (FLOOR - 698)) | (1L << (FORMAT - 698)) | (1L << (FOUND_ROWS - 698)) | (1L << (FROM_BASE64 - 698)) | (1L << (FROM_DAYS - 698)) | (1L << (FROM_UNIXTIME - 698)) | (1L << (GEOMCOLLFROMTEXT - 698)) | (1L << (GEOMCOLLFROMWKB - 698)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 698)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 698)) | (1L << (GEOMETRYFROMTEXT - 698)) | (1L << (GEOMETRYFROMWKB - 698)) | (1L << (GEOMETRYN - 698)) | (1L << (GEOMETRYTYPE - 698)) | (1L << (GEOMFROMTEXT - 698)) | (1L << (GEOMFROMWKB - 698)) | (1L << (GET_FORMAT - 698)) | (1L << (GET_LOCK - 698)) | (1L << (GLENGTH - 698)) | (1L << (GREATEST - 698)) | (1L << (GTID_SUBSET - 698)) | (1L << (GTID_SUBTRACT - 698)) | (1L << (HEX - 698)) | (1L << (IFNULL - 698)) | (1L << (INET6_ATON - 698)) | (1L << (INET6_NTOA - 698)) | (1L << (INET_ATON - 698)) | (1L << (INET_NTOA - 698)) | (1L << (INSTR - 698)) | (1L << (INTERIORRINGN - 698)) | (1L << (INTERSECTS - 698)) | (1L << (ISCLOSED - 698)) | (1L << (ISEMPTY - 698)) | (1L << (ISNULL - 698)) | (1L << (ISSIMPLE - 698)) | (1L << (IS_FREE_LOCK - 698)) | (1L << (IS_IPV4 - 698)) | (1L << (IS_IPV4_COMPAT - 698)) | (1L << (IS_IPV4_MAPPED - 698)) | (1L << (IS_IPV6 - 698)) | (1L << (IS_USED_LOCK - 698)) | (1L << (LAST_INSERT_ID - 698)) | (1L << (LCASE - 698)) | (1L << (LEAST - 698)) | (1L << (LENGTH - 698)) | (1L << (LINEFROMTEXT - 698)) | (1L << (LINEFROMWKB - 698)) | (1L << (LINESTRINGFROMTEXT - 698)) | (1L << (LINESTRINGFROMWKB - 698)))) != 0) || ((((_la - 762)) & ~0x3f) == 0 && ((1L << (_la - 762)) & ((1L << (LN - 762)) | (1L << (LOAD_FILE - 762)) | (1L << (LOCATE - 762)) | (1L << (LOG - 762)) | (1L << (LOG10 - 762)) | (1L << (LOG2 - 762)) | (1L << (LOWER - 762)) | (1L << (LPAD - 762)) | (1L << (LTRIM - 762)) | (1L << (MAKEDATE - 762)) | (1L << (MAKETIME - 762)) | (1L << (MAKE_SET - 762)) | (1L << (MASTER_POS_WAIT - 762)) | (1L << (MBRCONTAINS - 762)) | (1L << (MBRDISJOINT - 762)) | (1L << (MBREQUAL - 762)) | (1L << (MBRINTERSECTS - 762)) | (1L << (MBROVERLAPS - 762)) | (1L << (MBRTOUCHES - 762)) | (1L << (MBRWITHIN - 762)) | (1L << (MD5 - 762)) | (1L << (MLINEFROMTEXT - 762)) | (1L << (MLINEFROMWKB - 762)) | (1L << (MONTHNAME - 762)) | (1L << (MPOINTFROMTEXT - 762)) | (1L << (MPOINTFROMWKB - 762)) | (1L << (MPOLYFROMTEXT - 762)) | (1L << (MPOLYFROMWKB - 762)) | (1L << (MULTILINESTRINGFROMTEXT - 762)) | (1L << (MULTILINESTRINGFROMWKB - 762)) | (1L << (MULTIPOINTFROMTEXT - 762)) | (1L << (MULTIPOINTFROMWKB - 762)) | (1L << (MULTIPOLYGONFROMTEXT - 762)) | (1L << (MULTIPOLYGONFROMWKB - 762)) | (1L << (NAME_CONST - 762)) | (1L << (NULLIF - 762)) | (1L << (NUMGEOMETRIES - 762)) | (1L << (NUMINTERIORRINGS - 762)) | (1L << (NUMPOINTS - 762)) | (1L << (OCT - 762)) | (1L << (OCTET_LENGTH - 762)) | (1L << (ORD - 762)) | (1L << (OVERLAPS - 762)) | (1L << (PERIOD_ADD - 762)) | (1L << (PERIOD_DIFF - 762)) | (1L << (PI - 762)) | (1L << (POINTFROMTEXT - 762)) | (1L << (POINTFROMWKB - 762)) | (1L << (POINTN - 762)) | (1L << (POLYFROMTEXT - 762)) | (1L << (POLYFROMWKB - 762)) | (1L << (POLYGONFROMTEXT - 762)) | (1L << (POLYGONFROMWKB - 762)) | (1L << (POW - 762)) | (1L << (POWER - 762)) | (1L << (QUOTE - 762)) | (1L << (RADIANS - 762)) | (1L << (RAND - 762)) | (1L << (RANDOM_BYTES - 762)) | (1L << (RELEASE_LOCK - 762)) | (1L << (REVERSE - 762)) | (1L << (ROUND - 762)) | (1L << (ROW_COUNT - 762)) | (1L << (RPAD - 762)))) != 0) || ((((_la - 826)) & ~0x3f) == 0 && ((1L << (_la - 826)) & ((1L << (RTRIM - 826)) | (1L << (SEC_TO_TIME - 826)) | (1L << (SESSION_USER - 826)) | (1L << (SHA - 826)) | (1L << (SHA1 - 826)) | (1L << (SHA2 - 826)) | (1L << (SIGN - 826)) | (1L << (SIN - 826)) | (1L << (SLEEP - 826)) | (1L << (SOUNDEX - 826)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 826)) | (1L << (SQRT - 826)) | (1L << (SRID - 826)) | (1L << (STARTPOINT - 826)) | (1L << (STRCMP - 826)) | (1L << (STR_TO_DATE - 826)) | (1L << (ST_AREA - 826)) | (1L << (ST_ASBINARY - 826)) | (1L << (ST_ASTEXT - 826)) | (1L << (ST_ASWKB - 826)) | (1L << (ST_ASWKT - 826)) | (1L << (ST_BUFFER - 826)) | (1L << (ST_CENTROID - 826)) | (1L << (ST_CONTAINS - 826)) | (1L << (ST_CROSSES - 826)) | (1L << (ST_DIFFERENCE - 826)) | (1L << (ST_DIMENSION - 826)) | (1L << (ST_DISJOINT - 826)) | (1L << (ST_DISTANCE - 826)) | (1L << (ST_ENDPOINT - 826)) | (1L << (ST_ENVELOPE - 826)) | (1L << (ST_EQUALS - 826)) | (1L << (ST_EXTERIORRING - 826)) | (1L << (ST_GEOMCOLLFROMTEXT - 826)) | (1L << (ST_GEOMCOLLFROMTXT - 826)) | (1L << (ST_GEOMCOLLFROMWKB - 826)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 826)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 826)) | (1L << (ST_GEOMETRYFROMTEXT - 826)) | (1L << (ST_GEOMETRYFROMWKB - 826)) | (1L << (ST_GEOMETRYN - 826)) | (1L << (ST_GEOMETRYTYPE - 826)) | (1L << (ST_GEOMFROMTEXT - 826)) | (1L << (ST_GEOMFROMWKB - 826)) | (1L << (ST_INTERIORRINGN - 826)) | (1L << (ST_INTERSECTION - 826)) | (1L << (ST_INTERSECTS - 826)) | (1L << (ST_ISCLOSED - 826)) | (1L << (ST_ISEMPTY - 826)) | (1L << (ST_ISSIMPLE - 826)) | (1L << (ST_LINEFROMTEXT - 826)) | (1L << (ST_LINEFROMWKB - 826)) | (1L << (ST_LINESTRINGFROMTEXT - 826)) | (1L << (ST_LINESTRINGFROMWKB - 826)) | (1L << (ST_NUMGEOMETRIES - 826)) | (1L << (ST_NUMINTERIORRING - 826)) | (1L << (ST_NUMINTERIORRINGS - 826)) | (1L << (ST_NUMPOINTS - 826)) | (1L << (ST_OVERLAPS - 826)) | (1L << (ST_POINTFROMTEXT - 826)) | (1L << (ST_POINTFROMWKB - 826)) | (1L << (ST_POINTN - 826)) | (1L << (ST_POLYFROMTEXT - 826)) | (1L << (ST_POLYFROMWKB - 826)))) != 0) || ((((_la - 890)) & ~0x3f) == 0 && ((1L << (_la - 890)) & ((1L << (ST_POLYGONFROMTEXT - 890)) | (1L << (ST_POLYGONFROMWKB - 890)) | (1L << (ST_SRID - 890)) | (1L << (ST_STARTPOINT - 890)) | (1L << (ST_SYMDIFFERENCE - 890)) | (1L << (ST_TOUCHES - 890)) | (1L << (ST_UNION - 890)) | (1L << (ST_WITHIN - 890)) | (1L << (ST_X - 890)) | (1L << (ST_Y - 890)) | (1L << (SUBDATE - 890)) | (1L << (SUBSTRING_INDEX - 890)) | (1L << (SUBTIME - 890)) | (1L << (SYSTEM_USER - 890)) | (1L << (TAN - 890)) | (1L << (TIMEDIFF - 890)) | (1L << (TIMESTAMPADD - 890)) | (1L << (TIMESTAMPDIFF - 890)) | (1L << (TIME_FORMAT - 890)) | (1L << (TIME_TO_SEC - 890)) | (1L << (TOUCHES - 890)) | (1L << (TO_BASE64 - 890)) | (1L << (TO_DAYS - 890)) | (1L << (TO_SECONDS - 890)) | (1L << (UCASE - 890)) | (1L << (UNCOMPRESS - 890)) | (1L << (UNCOMPRESSED_LENGTH - 890)) | (1L << (UNHEX - 890)) | (1L << (UNIX_TIMESTAMP - 890)) | (1L << (UPDATEXML - 890)) | (1L << (UPPER - 890)) | (1L << (UUID - 890)) | (1L << (UUID_SHORT - 890)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 890)) | (1L << (VERSION - 890)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 890)) | (1L << (WEEKDAY - 890)) | (1L << (WEEKOFYEAR - 890)) | (1L << (WEIGHT_STRING - 890)) | (1L << (WITHIN - 890)) | (1L << (YEARWEEK - 890)) | (1L << (Y_FUNCTION - 890)) | (1L << (X_FUNCTION - 890)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 295: return expression_sempred((ExpressionContext)_localctx, predIndex);
		case 296: return predicate_sempred((PredicateContext)_localctx, predIndex);
		case 297: return expressionAtom_sempred((ExpressionAtomContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 3);
		}
		return true;
	}
	private bool predicate_sempred(PredicateContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return Precpred(Context, 7);
		case 2: return Precpred(Context, 5);
		case 3: return Precpred(Context, 4);
		case 4: return Precpred(Context, 2);
		case 5: return Precpred(Context, 9);
		case 6: return Precpred(Context, 8);
		case 7: return Precpred(Context, 6);
		case 8: return Precpred(Context, 3);
		}
		return true;
	}
	private bool expressionAtom_sempred(ExpressionAtomContext _localctx, int predIndex) {
		switch (predIndex) {
		case 9: return Precpred(Context, 2);
		case 10: return Precpred(Context, 1);
		case 11: return Precpred(Context, 11);
		}
		return true;
	}

	private static string _serializedATN = _serializeATN();
	private static string _serializeATN()
	{
	    StringBuilder sb = new StringBuilder();
	    sb.Append("\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\x3DD");
		sb.Append("\x1827\x4\x2\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6");
		sb.Append("\x4\a\t\a\x4\b\t\b\x4\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r");
		sb.Append("\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t\x10\x4\x11\t\x11\x4\x12");
		sb.Append("\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15\x4\x16\t\x16\x4");
		sb.Append("\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B\t\x1B");
		sb.Append("\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t ");
		sb.Append("\x4!\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t");
		sb.Append("(\x4)\t)\x4*\t*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t");
		sb.Append("\x30\x4\x31\t\x31\x4\x32\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4");
		sb.Append("\x35\t\x35\x4\x36\t\x36\x4\x37\t\x37\x4\x38\t\x38\x4\x39\t\x39");
		sb.Append("\x4:\t:\x4;\t;\x4<\t<\x4=\t=\x4>\t>\x4?\t?\x4@\t@\x4\x41\t\x41");
		sb.Append("\x4\x42\t\x42\x4\x43\t\x43\x4\x44\t\x44\x4\x45\t\x45\x4\x46");
		sb.Append("\t\x46\x4G\tG\x4H\tH\x4I\tI\x4J\tJ\x4K\tK\x4L\tL\x4M\tM\x4N");
		sb.Append("\tN\x4O\tO\x4P\tP\x4Q\tQ\x4R\tR\x4S\tS\x4T\tT\x4U\tU\x4V\tV");
		sb.Append("\x4W\tW\x4X\tX\x4Y\tY\x4Z\tZ\x4[\t[\x4\\\t\\\x4]\t]\x4^\t^\x4");
		sb.Append("_\t_\x4`\t`\x4\x61\t\x61\x4\x62\t\x62\x4\x63\t\x63\x4\x64\t");
		sb.Append("\x64\x4\x65\t\x65\x4\x66\t\x66\x4g\tg\x4h\th\x4i\ti\x4j\tj\x4");
		sb.Append("k\tk\x4l\tl\x4m\tm\x4n\tn\x4o\to\x4p\tp\x4q\tq\x4r\tr\x4s\t");
		sb.Append("s\x4t\tt\x4u\tu\x4v\tv\x4w\tw\x4x\tx\x4y\ty\x4z\tz\x4{\t{\x4");
		sb.Append("|\t|\x4}\t}\x4~\t~\x4\x7F\t\x7F\x4\x80\t\x80\x4\x81\t\x81\x4");
		sb.Append("\x82\t\x82\x4\x83\t\x83\x4\x84\t\x84\x4\x85\t\x85\x4\x86\t\x86");
		sb.Append("\x4\x87\t\x87\x4\x88\t\x88\x4\x89\t\x89\x4\x8A\t\x8A\x4\x8B");
		sb.Append("\t\x8B\x4\x8C\t\x8C\x4\x8D\t\x8D\x4\x8E\t\x8E\x4\x8F\t\x8F\x4");
		sb.Append("\x90\t\x90\x4\x91\t\x91\x4\x92\t\x92\x4\x93\t\x93\x4\x94\t\x94");
		sb.Append("\x4\x95\t\x95\x4\x96\t\x96\x4\x97\t\x97\x4\x98\t\x98\x4\x99");
		sb.Append("\t\x99\x4\x9A\t\x9A\x4\x9B\t\x9B\x4\x9C\t\x9C\x4\x9D\t\x9D\x4");
		sb.Append("\x9E\t\x9E\x4\x9F\t\x9F\x4\xA0\t\xA0\x4\xA1\t\xA1\x4\xA2\t\xA2");
		sb.Append("\x4\xA3\t\xA3\x4\xA4\t\xA4\x4\xA5\t\xA5\x4\xA6\t\xA6\x4\xA7");
		sb.Append("\t\xA7\x4\xA8\t\xA8\x4\xA9\t\xA9\x4\xAA\t\xAA\x4\xAB\t\xAB\x4");
		sb.Append("\xAC\t\xAC\x4\xAD\t\xAD\x4\xAE\t\xAE\x4\xAF\t\xAF\x4\xB0\t\xB0");
		sb.Append("\x4\xB1\t\xB1\x4\xB2\t\xB2\x4\xB3\t\xB3\x4\xB4\t\xB4\x4\xB5");
		sb.Append("\t\xB5\x4\xB6\t\xB6\x4\xB7\t\xB7\x4\xB8\t\xB8\x4\xB9\t\xB9\x4");
		sb.Append("\xBA\t\xBA\x4\xBB\t\xBB\x4\xBC\t\xBC\x4\xBD\t\xBD\x4\xBE\t\xBE");
		sb.Append("\x4\xBF\t\xBF\x4\xC0\t\xC0\x4\xC1\t\xC1\x4\xC2\t\xC2\x4\xC3");
		sb.Append("\t\xC3\x4\xC4\t\xC4\x4\xC5\t\xC5\x4\xC6\t\xC6\x4\xC7\t\xC7\x4");
		sb.Append("\xC8\t\xC8\x4\xC9\t\xC9\x4\xCA\t\xCA\x4\xCB\t\xCB\x4\xCC\t\xCC");
		sb.Append("\x4\xCD\t\xCD\x4\xCE\t\xCE\x4\xCF\t\xCF\x4\xD0\t\xD0\x4\xD1");
		sb.Append("\t\xD1\x4\xD2\t\xD2\x4\xD3\t\xD3\x4\xD4\t\xD4\x4\xD5\t\xD5\x4");
		sb.Append("\xD6\t\xD6\x4\xD7\t\xD7\x4\xD8\t\xD8\x4\xD9\t\xD9\x4\xDA\t\xDA");
		sb.Append("\x4\xDB\t\xDB\x4\xDC\t\xDC\x4\xDD\t\xDD\x4\xDE\t\xDE\x4\xDF");
		sb.Append("\t\xDF\x4\xE0\t\xE0\x4\xE1\t\xE1\x4\xE2\t\xE2\x4\xE3\t\xE3\x4");
		sb.Append("\xE4\t\xE4\x4\xE5\t\xE5\x4\xE6\t\xE6\x4\xE7\t\xE7\x4\xE8\t\xE8");
		sb.Append("\x4\xE9\t\xE9\x4\xEA\t\xEA\x4\xEB\t\xEB\x4\xEC\t\xEC\x4\xED");
		sb.Append("\t\xED\x4\xEE\t\xEE\x4\xEF\t\xEF\x4\xF0\t\xF0\x4\xF1\t\xF1\x4");
		sb.Append("\xF2\t\xF2\x4\xF3\t\xF3\x4\xF4\t\xF4\x4\xF5\t\xF5\x4\xF6\t\xF6");
		sb.Append("\x4\xF7\t\xF7\x4\xF8\t\xF8\x4\xF9\t\xF9\x4\xFA\t\xFA\x4\xFB");
		sb.Append("\t\xFB\x4\xFC\t\xFC\x4\xFD\t\xFD\x4\xFE\t\xFE\x4\xFF\t\xFF\x4");
		sb.Append("\x100\t\x100\x4\x101\t\x101\x4\x102\t\x102\x4\x103\t\x103\x4");
		sb.Append("\x104\t\x104\x4\x105\t\x105\x4\x106\t\x106\x4\x107\t\x107\x4");
		sb.Append("\x108\t\x108\x4\x109\t\x109\x4\x10A\t\x10A\x4\x10B\t\x10B\x4");
		sb.Append("\x10C\t\x10C\x4\x10D\t\x10D\x4\x10E\t\x10E\x4\x10F\t\x10F\x4");
		sb.Append("\x110\t\x110\x4\x111\t\x111\x4\x112\t\x112\x4\x113\t\x113\x4");
		sb.Append("\x114\t\x114\x4\x115\t\x115\x4\x116\t\x116\x4\x117\t\x117\x4");
		sb.Append("\x118\t\x118\x4\x119\t\x119\x4\x11A\t\x11A\x4\x11B\t\x11B\x4");
		sb.Append("\x11C\t\x11C\x4\x11D\t\x11D\x4\x11E\t\x11E\x4\x11F\t\x11F\x4");
		sb.Append("\x120\t\x120\x4\x121\t\x121\x4\x122\t\x122\x4\x123\t\x123\x4");
		sb.Append("\x124\t\x124\x4\x125\t\x125\x4\x126\t\x126\x4\x127\t\x127\x4");
		sb.Append("\x128\t\x128\x4\x129\t\x129\x4\x12A\t\x12A\x4\x12B\t\x12B\x4");
		sb.Append("\x12C\t\x12C\x4\x12D\t\x12D\x4\x12E\t\x12E\x4\x12F\t\x12F\x4");
		sb.Append("\x130\t\x130\x4\x131\t\x131\x4\x132\t\x132\x4\x133\t\x133\x4");
		sb.Append("\x134\t\x134\x4\x135\t\x135\x4\x136\t\x136\x4\x137\t\x137\x3");
		sb.Append("\x2\x5\x2\x270\n\x2\x3\x2\x5\x2\x273\n\x2\x3\x2\x3\x2\x3\x3");
		sb.Append("\x3\x3\x5\x3\x279\n\x3\x3\x3\x5\x3\x27C\n\x3\x3\x3\a\x3\x27F");
		sb.Append("\n\x3\f\x3\xE\x3\x282\v\x3\x3\x3\x3\x3\x5\x3\x286\n\x3\x3\x3");
		sb.Append("\x5\x3\x289\n\x3\x3\x3\x5\x3\x28C\n\x3\x3\x4\x3\x4\x3\x4\x3");
		sb.Append("\x4\x3\x4\x3\x4\x3\x4\x5\x4\x295\n\x4\x3\x5\x3\x5\x3\x6\x3\x6");
		sb.Append("\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6");
		sb.Append("\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6");
		sb.Append("\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6");
		sb.Append("\x3\x6\x3\x6\x3\x6\x5\x6\x2BC\n\x6\x3\a\x3\a\x3\a\x3\a\x3\a");
		sb.Append("\x3\a\x3\a\x3\a\x3\a\x3\a\x5\a\x2C8\n\a\x3\b\x3\b\x3\b\x3\b");
		sb.Append("\x3\b\x3\b\x3\b\x3\b\x3\b\x5\b\x2D3\n\b\x3\t\x3\t\x3\t\x3\t");
		sb.Append("\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x5\t");
		sb.Append("\x2E4\n\t\x3\n\x3\n\x3\n\x5\n\x2E9\n\n\x3\v\x3\v\x3\v\x3\v\x3");
		sb.Append("\v\x3\v\x3\v\x3\v\x3\v\x3\v\x5\v\x2F5\n\v\x3\f\x3\f\x3\f\x3");
		sb.Append("\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3");
		sb.Append("\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x5\f\x310\n");
		sb.Append("\f\x3\r\x3\r\x3\r\x3\r\x5\r\x316\n\r\x3\xE\x3\xE\x3\xE\x5\xE");
		sb.Append("\x31B\n\xE\x3\xE\x3\xE\a\xE\x31F\n\xE\f\xE\xE\xE\x322\v\xE\x3");
		sb.Append("\xF\x3\xF\x5\xF\x326\n\xF\x3\xF\x3\xF\x5\xF\x32A\n\xF\x3\xF");
		sb.Append("\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x5\xF\x333\n\xF\x3\xF\x5");
		sb.Append("\xF\x336\n\xF\x3\xF\x5\xF\x339\n\xF\x3\xF\x3\xF\x5\xF\x33D\n");
		sb.Append("\xF\x3\xF\x3\xF\x3\xF\x3\x10\x3\x10\x5\x10\x344\n\x10\x3\x10");
		sb.Append("\x5\x10\x347\n\x10\x3\x10\x3\x10\x3\x10\x5\x10\x34C\n\x10\x3");
		sb.Append("\x10\x3\x10\x3\x10\x3\x10\a\x10\x352\n\x10\f\x10\xE\x10\x355");
		sb.Append("\v\x10\x3\x10\x3\x10\x5\x10\x359\n\x10\x3\x10\x3\x10\x3\x10");
		sb.Append("\x5\x10\x35E\n\x10\x3\x10\a\x10\x361\n\x10\f\x10\xE\x10\x364");
		sb.Append("\v\x10\x3\x11\x3\x11\x3\x11\x3\x11\x3\x11\x3\x11\x3\x11\x3\x11");
		sb.Append("\x3\x11\x5\x11\x36F\n\x11\x3\x11\x5\x11\x372\n\x11\x3\x11\x3");
		sb.Append("\x11\x5\x11\x376\n\x11\x3\x11\x5\x11\x379\n\x11\x3\x11\x3\x11");
		sb.Append("\x5\x11\x37D\n\x11\x3\x11\x5\x11\x380\n\x11\x3\x11\x3\x11\x5");
		sb.Append("\x11\x384\n\x11\x3\x11\x5\x11\x387\n\x11\x3\x11\x5\x11\x38A");
		sb.Append("\n\x11\x3\x11\x3\x11\x5\x11\x38E\n\x11\x3\x11\x5\x11\x391\n");
		sb.Append("\x11\x3\x11\x3\x11\x5\x11\x395\n\x11\x3\x11\x3\x11\x3\x12\x3");
		sb.Append("\x12\x5\x12\x39B\n\x12\x3\x12\x3\x12\x3\x12\x3\x12\x5\x12\x3A1");
		sb.Append("\n\x12\x3\x12\x3\x12\a\x12\x3A5\n\x12\f\x12\xE\x12\x3A8\v\x12");
		sb.Append("\x3\x12\x3\x12\a\x12\x3AC\n\x12\f\x12\xE\x12\x3AF\v\x12\x3\x12");
		sb.Append("\x3\x12\x3\x13\x3\x13\x5\x13\x3B5\n\x13\x3\x13\x3\x13\x3\x13");
		sb.Append("\x3\x13\x5\x13\x3BB\n\x13\x3\x13\x3\x13\a\x13\x3BF\n\x13\f\x13");
		sb.Append("\xE\x13\x3C2\v\x13\x3\x13\x3\x13\x3\x13\x3\x13\a\x13\x3C8\n");
		sb.Append("\x13\f\x13\xE\x13\x3CB\v\x13\x3\x13\x3\x13\x3\x14\x3\x14\x3");
		sb.Append("\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14");
		sb.Append("\x3\x14\a\x14\x3DB\n\x14\f\x14\xE\x14\x3DE\v\x14\x3\x14\x3\x14");
		sb.Append("\x3\x15\x3\x15\x5\x15\x3E4\n\x15\x3\x15\x3\x15\x5\x15\x3E8\n");
		sb.Append("\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15");
		sb.Append("\x5\x15\x3F2\n\x15\x3\x15\x3\x15\x5\x15\x3F6\n\x15\x3\x15\x3");
		sb.Append("\x15\x5\x15\x3FA\n\x15\x3\x15\x3\x15\x5\x15\x3FE\n\x15\x3\x15");
		sb.Append("\x3\x15\x5\x15\x402\n\x15\x3\x15\a\x15\x405\n\x15\f\x15\xE\x15");
		sb.Append("\x408\v\x15\x5\x15\x40A\n\x15\x3\x15\x5\x15\x40D\n\x15\x3\x15");
		sb.Append("\x5\x15\x410\n\x15\x3\x15\x5\x15\x413\n\x15\x3\x15\x3\x15\x3");
		sb.Append("\x15\x3\x15\x5\x15\x419\n\x15\x3\x15\x3\x15\x5\x15\x41D\n\x15");
		sb.Append("\x3\x15\x3\x15\x3\x15\x3\x15\x5\x15\x423\n\x15\x3\x15\a\x15");
		sb.Append("\x426\n\x15\f\x15\xE\x15\x429\v\x15\x5\x15\x42B\n\x15\x3\x15");
		sb.Append("\x5\x15\x42E\n\x15\x5\x15\x430\n\x15\x3\x16\x3\x16\x3\x16\x3");
		sb.Append("\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x5\x16\x43B\n\x16\x3");
		sb.Append("\x16\x3\x16\x5\x16\x43F\n\x16\x3\x16\x5\x16\x442\n\x16\x3\x17");
		sb.Append("\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3");
		sb.Append("\x17\x3\x17\x3\x17\x5\x17\x450\n\x17\x3\x17\x5\x17\x453\n\x17");
		sb.Append("\x3\x17\x3\x17\x5\x17\x457\n\x17\x3\x17\x5\x17\x45A\n\x17\x3");
		sb.Append("\x17\x3\x17\x5\x17\x45E\n\x17\x3\x17\x5\x17\x461\n\x17\x3\x17");
		sb.Append("\x3\x17\x5\x17\x465\n\x17\x3\x17\x5\x17\x468\n\x17\x3\x17\x3");
		sb.Append("\x17\x5\x17\x46C\n\x17\x3\x17\x5\x17\x46F\n\x17\x3\x17\x5\x17");
		sb.Append("\x472\n\x17\x3\x17\x3\x17\x5\x17\x476\n\x17\x3\x17\x5\x17\x479");
		sb.Append("\n\x17\x3\x17\x3\x17\x5\x17\x47D\n\x17\x3\x17\x3\x17\x3\x18");
		sb.Append("\x3\x18\x5\x18\x483\n\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18");
		sb.Append("\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\x490\n\x18");
		sb.Append("\x3\x18\x3\x18\x3\x19\x3\x19\x3\x19\x5\x19\x497\n\x19\x3\x19");
		sb.Append("\x3\x19\x3\x19\x5\x19\x49C\n\x19\x3\x19\x5\x19\x49F\n\x19\x3");
		sb.Append("\x19\x3\x19\x3\x19\x5\x19\x4A4\n\x19\x3\x19\x3\x19\x3\x19\x3");
		sb.Append("\x19\x3\x19\x3\x19\x5\x19\x4AC\n\x19\x3\x19\x3\x19\x3\x19\x3");
		sb.Append("\x19\x5\x19\x4B2\n\x19\x3\x19\x3\x19\x5\x19\x4B6\n\x19\x3\x1A");
		sb.Append("\x5\x1A\x4B9\n\x1A\x3\x1A\x3\x1A\x3\x1A\x5\x1A\x4BE\n\x1A\x3");
		sb.Append("\x1A\x5\x1A\x4C1\n\x1A\x3\x1A\x3\x1A\x5\x1A\x4C5\n\x1A\x3\x1A");
		sb.Append("\x3\x1A\x5\x1A\x4C9\n\x1A\x3\x1A\x5\x1A\x4CC\n\x1A\x3\x1B\x3");
		sb.Append("\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x5\x1B\x4D4\n\x1B\x5\x1B\x4D6");
		sb.Append("\n\x1B\x3\x1C\x3\x1C\x3\x1C\a\x1C\x4DB\n\x1C\f\x1C\xE\x1C\x4DE");
		sb.Append("\v\x1C\x3\x1C\x3\x1C\x3\x1C\x5\x1C\x4E3\n\x1C\x3\x1C\x3\x1C");
		sb.Append("\x3\x1C\x3\x1C\a\x1C\x4E9\n\x1C\f\x1C\xE\x1C\x4EC\v\x1C\x5\x1C");
		sb.Append("\x4EE\n\x1C\x3\x1C\x3\x1C\x3\x1C\a\x1C\x4F3\n\x1C\f\x1C\xE\x1C");
		sb.Append("\x4F6\v\x1C\x5\x1C\x4F8\n\x1C\x5\x1C\x4FA\n\x1C\x3\x1D\x3\x1D");
		sb.Append("\x3\x1D\x3\x1D\x5\x1D\x500\n\x1D\x3\x1E\x3\x1E\x3\x1E\x3\x1E");
		sb.Append("\x5\x1E\x506\n\x1E\x3\x1E\x3\x1E\x3\x1F\x3\x1F\x3\x1F\x3\x1F");
		sb.Append("\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3");
		sb.Append("\x1F\x5\x1F\x517\n\x1F\x3 \x3 \x3 \x3 \x3 \x5 \x51E\n \x3!\x3");
		sb.Append("!\x3!\x3\"\x3\"\x5\"\x525\n\"\x3\"\x3\"\x3\"\x3\"\x3\"\x3\"");
		sb.Append("\x3\"\x5\"\x52E\n\"\x3#\x5#\x531\n#\x3#\x3#\x3#\x3$\x3$\x3$");
		sb.Append("\x3%\x3%\x3%\x3%\x3%\x5%\x53E\n%\x3%\x3%\x3%\x3%\x3%\x3%\x3");
		sb.Append("%\x3%\x3%\x3%\x3%\x5%\x54B\n%\x3%\x3%\x3%\x5%\x550\n%\x3&\x3");
		sb.Append("&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x5&\x560\n");
		sb.Append("&\x3\'\x3\'\x3\'\x3\'\a\'\x566\n\'\f\'\xE\'\x569\v\'\x3\'\x3");
		sb.Append("\'\x3(\x3(\x3(\x3(\x3(\x5(\x572\n(\x3)\x3)\a)\x576\n)\f)\xE");
		sb.Append(")\x579\v)\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x5*\x582\n*\x3*\x5*\x585");
		sb.Append("\n*\x3*\x3*\x3*\x5*\x58A\n*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3*");
		sb.Append("\x3*\x3*\x3*\x5*\x597\n*\x3*\x3*\x3*\x3*\x3*\x5*\x59E\n*\x3");
		sb.Append("*\x3*\x3*\x5*\x5A3\n*\x3+\x3+\x5+\x5A7\n+\x5+\x5A9\n+\x3+\x3");
		sb.Append("+\x3+\x5+\x5AE\n+\x3+\x5+\x5B1\n+\x3+\x3+\a+\x5B5\n+\f+\xE+");
		sb.Append("\x5B8\v+\x3+\x3+\x5+\x5BC\n+\x5+\x5BE\n+\x3+\x3+\x5+\x5C2\n");
		sb.Append("+\x3+\x5+\x5C5\n+\x3+\x5+\x5C8\n+\x3+\x3+\a+\x5CC\n+\f+\xE+");
		sb.Append("\x5CF\v+\x3+\x3+\x5+\x5D3\n+\x5+\x5D5\n+\x3+\x3+\x3+\x5+\x5DA");
		sb.Append("\n+\x3+\x3+\x3+\x3+\x3+\x5+\x5E1\n+\x5+\x5E3\n+\x3+\x3+\x3+");
		sb.Append("\x3+\x3+\x5+\x5EA\n+\x3,\x3,\x3,\x5,\x5EF\n,\x3,\x3,\x5,\x5F3");
		sb.Append("\n,\x3,\x5,\x5F6\n,\x3-\x3-\x3-\x3-\x3-\x3-\x5-\x5FE\n-\x3-");
		sb.Append("\x3-\x3-\x3-\x3-\x3-\x5-\x606\n-\x5-\x608\n-\x3.\x3.\x3.\x3");
		sb.Append(".\x3.\x3.\x5.\x610\n.\x3/\x3/\x5/\x614\n/\x3/\x5/\x617\n/\x3");
		sb.Append("/\x3/\a/\x61B\n/\f/\xE/\x61E\v/\x3/\x3/\x5/\x622\n/\x3/\x5/");
		sb.Append("\x625\n/\x3/\x3/\a/\x629\n/\f/\xE/\x62C\v/\x5/\x62E\n/\x3\x30");
		sb.Append("\x3\x30\x5\x30\x632\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x637\n");
		sb.Append("\x30\x3\x30\x3\x30\x3\x30\x5\x30\x63C\n\x30\x3\x30\x3\x30\x5");
		sb.Append("\x30\x640\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x645\n\x30\x3\x30");
		sb.Append("\x5\x30\x648\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x64D\n\x30\x3");
		sb.Append("\x30\x3\x30\x5\x30\x651\n\x30\x3\x30\x3\x30\x5\x30\x655\n\x30");
		sb.Append("\x3\x30\x3\x30\x3\x30\x5\x30\x65A\n\x30\x3\x30\x3\x30\x3\x30");
		sb.Append("\x5\x30\x65F\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x664\n\x30\x3");
		sb.Append("\x30\x3\x30\x3\x30\x3\x30\x5\x30\x66A\n\x30\x3\x30\x3\x30\x3");
		sb.Append("\x30\x5\x30\x66F\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x674\n\x30");
		sb.Append("\x3\x30\x3\x30\x3\x30\x3\x30\x5\x30\x67A\n\x30\x3\x30\x3\x30");
		sb.Append("\x3\x30\x5\x30\x67F\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x684\n");
		sb.Append("\x30\x3\x30\x3\x30\x3\x30\x5\x30\x689\n\x30\x3\x30\x3\x30\x3");
		sb.Append("\x30\x5\x30\x68E\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x693\n\x30");
		sb.Append("\x3\x30\x3\x30\x3\x30\x5\x30\x698\n\x30\x3\x30\x3\x30\x3\x30");
		sb.Append("\x5\x30\x69D\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x6A2\n\x30\x3");
		sb.Append("\x30\x3\x30\x3\x30\x5\x30\x6A7\n\x30\x3\x30\x3\x30\x3\x30\x5");
		sb.Append("\x30\x6AC\n\x30\x3\x30\x3\x30\x3\x30\x3\x30\x5\x30\x6B2\n\x30");
		sb.Append("\x3\x30\x3\x30\x3\x30\x5\x30\x6B7\n\x30\x3\x30\x3\x30\x3\x30");
		sb.Append("\x3\x30\x5\x30\x6BD\n\x30\x3\x31\x3\x31\x3\x31\x3\x32\x3\x32");
		sb.Append("\x3\x32\x3\x32\x3\x32\x5\x32\x6C7\n\x32\x3\x32\x3\x32\x3\x32");
		sb.Append("\x3\x32\x3\x32\x5\x32\x6CE\n\x32\x5\x32\x6D0\n\x32\x3\x32\x3");
		sb.Append("\x32\x3\x32\x3\x32\a\x32\x6D6\n\x32\f\x32\xE\x32\x6D9\v\x32");
		sb.Append("\x3\x32\x3\x32\x5\x32\x6DD\n\x32\x3\x33\x5\x33\x6E0\n\x33\x3");
		sb.Append("\x33\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33\x5\x33\x6E8\n\x33\x3");
		sb.Append("\x33\x3\x33\x3\x33\x3\x33\x5\x33\x6EE\n\x33\x3\x33\x3\x33\x3");
		sb.Append("\x33\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33");
		sb.Append("\x3\x33\x3\x33\x3\x33\x5\x33\x6FE\n\x33\x3\x33\x3\x33\x3\x33");
		sb.Append("\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33\x5\x33\x70A");
		sb.Append("\n\x33\x5\x33\x70C\n\x33\x3\x34\x5\x34\x70F\n\x34\x3\x34\x3");
		sb.Append("\x34\x3\x34\x3\x34\x3\x34\x3\x34\x5\x34\x717\n\x34\x3\x34\x3");
		sb.Append("\x34\x3\x34\x3\x34\x5\x34\x71D\n\x34\x3\x34\x3\x34\x3\x34\x3");
		sb.Append("\x34\x5\x34\x723\n\x34\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3");
		sb.Append("\x35\x3\x35\x3\x35\x3\x35\a\x35\x72E\n\x35\f\x35\xE\x35\x731");
		sb.Append("\v\x35\x3\x35\x3\x35\a\x35\x735\n\x35\f\x35\xE\x35\x738\v\x35");
		sb.Append("\x3\x35\x3\x35\x3\x35\a\x35\x73D\n\x35\f\x35\xE\x35\x740\v\x35");
		sb.Append("\x5\x35\x742\n\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35");
		sb.Append("\x3\x35\a\x35\x74B\n\x35\f\x35\xE\x35\x74E\v\x35\x3\x35\x3\x35");
		sb.Append("\x3\x35\a\x35\x753\n\x35\f\x35\xE\x35\x756\v\x35\x5\x35\x758");
		sb.Append("\n\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35");
		sb.Append("\a\x35\x762\n\x35\f\x35\xE\x35\x765\v\x35\x3\x35\x3\x35\a\x35");
		sb.Append("\x769\n\x35\f\x35\xE\x35\x76C\v\x35\x3\x35\x3\x35\x3\x35\a\x35");
		sb.Append("\x771\n\x35\f\x35\xE\x35\x774\v\x35\x5\x35\x776\n\x35\x3\x35");
		sb.Append("\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\a\x35\x780");
		sb.Append("\n\x35\f\x35\xE\x35\x783\v\x35\x3\x35\x3\x35\a\x35\x787\n\x35");
		sb.Append("\f\x35\xE\x35\x78A\v\x35\x3\x35\x3\x35\x3\x35\a\x35\x78F\n\x35");
		sb.Append("\f\x35\xE\x35\x792\v\x35\x5\x35\x794\n\x35\x3\x35\x3\x35\x3");
		sb.Append("\x35\a\x35\x799\n\x35\f\x35\xE\x35\x79C\v\x35\x3\x35\x3\x35");
		sb.Append("\x3\x35\a\x35\x7A1\n\x35\f\x35\xE\x35\x7A4\v\x35\x5\x35\x7A6");
		sb.Append("\n\x35\x5\x35\x7A8\n\x35\x3\x36\x3\x36\x3\x36\x5\x36\x7AD\n");
		sb.Append("\x36\x3\x37\x3\x37\x3\x37\x3\x37\x6\x37\x7B3\n\x37\r\x37\xE");
		sb.Append("\x37\x7B4\x3\x37\x3\x37\x3\x38\x3\x38\x3\x38\a\x38\x7BC\n\x38");
		sb.Append("\f\x38\xE\x38\x7BF\v\x38\x3\x39\x5\x39\x7C2\n\x39\x3\x39\x3");
		sb.Append("\x39\x5\x39\x7C6\n\x39\x3\x39\x3\x39\x3\x39\x5\x39\x7CB\n\x39");
		sb.Append("\x3\x39\x3\x39\x3\x39\x3\x39\x5\x39\x7D1\n\x39\x3\x39\x3\x39");
		sb.Append("\x3\x39\x3\x39\x5\x39\x7D7\n\x39\x3\x39\x3\x39\x3\x39\x5\x39");
		sb.Append("\x7DC\n\x39\x3\x39\x3\x39\x3\x39\x5\x39\x7E1\n\x39\x3\x39\x3");
		sb.Append("\x39\x3\x39\x5\x39\x7E6\n\x39\x3\x39\x3\x39\x3\x39\x5\x39\x7EB");
		sb.Append("\n\x39\x3\x39\x5\x39\x7EE\n\x39\x3:\x3:\x3:\x5:\x7F3\n:\x3:");
		sb.Append("\x6:\x7F6\n:\r:\xE:\x7F7\x3:\x3:\x3:\x3:\x3:\x3:\x3:\x3:\x5");
		sb.Append(":\x802\n:\x3;\x3;\x5;\x806\n;\x3;\x3;\x3;\x3;\x3;\x5;\x80D\n");
		sb.Append(";\x3;\x3;\x3;\x5;\x812\n;\x3;\x5;\x815\n;\x3;\x3;\x3;\x5;\x81A");
		sb.Append("\n;\x3;\x5;\x81D\n;\x3;\x3;\x5;\x821\n;\x3;\x3;\x5;\x825\n;");
		sb.Append("\x3<\x3<\x3<\x3<\a<\x82B\n<\f<\xE<\x82E\v<\x3=\x3=\x3=\x3=\x3");
		sb.Append("=\x3=\x3=\x3>\x3>\x3>\x3>\x3>\x3>\x3>\x3>\x3>\x5>\x840\n>\x3");
		sb.Append(">\x5>\x843\n>\x3>\x5>\x846\n>\x3>\x3>\x5>\x84A\n>\x3>\x3>\x3");
		sb.Append("?\x3?\x3?\x3?\a?\x852\n?\f?\xE?\x855\v?\x3@\x3@\x3@\x3@\x3@");
		sb.Append("\x3@\x3@\x3@\a@\x85F\n@\f@\xE@\x862\v@\x3@\x3@\x3\x41\x3\x41");
		sb.Append("\x5\x41\x868\n\x41\x3\x41\x5\x41\x86B\n\x41\x3\x41\x3\x41\x3");
		sb.Append("\x41\x3\x41\x3\x41\a\x41\x872\n\x41\f\x41\xE\x41\x875\v\x41");
		sb.Append("\x5\x41\x877\n\x41\x3\x41\x5\x41\x87A\n\x41\x3\x42\x3\x42\x3");
		sb.Append("\x42\x3\x42\x3\x42\x3\x42\x3\x42\x3\x42\x3\x42\x5\x42\x885\n");
		sb.Append("\x42\x3\x42\x5\x42\x888\n\x42\x3\x42\x3\x42\x5\x42\x88C\n\x42");
		sb.Append("\x3\x42\x3\x42\x3\x43\x3\x43\x3\x43\x3\x43\x5\x43\x894\n\x43");
		sb.Append("\x3\x43\x5\x43\x897\n\x43\x3\x43\x3\x43\x3\x43\x5\x43\x89C\n");
		sb.Append("\x43\x3\x43\x3\x43\x3\x43\x3\x43\x3\x43\x3\x43\x5\x43\x8A4\n");
		sb.Append("\x43\x3\x43\x3\x43\x3\x43\x3\x43\x5\x43\x8AA\n\x43\x3\x43\x3");
		sb.Append("\x43\x5\x43\x8AE\n\x43\x3\x44\x3\x44\x5\x44\x8B2\n\x44\x3\x44");
		sb.Append("\a\x44\x8B5\n\x44\f\x44\xE\x44\x8B8\v\x44\x3\x44\x3\x44\x5\x44");
		sb.Append("\x8BC\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x8C3\n");
		sb.Append("\x44\x3\x44\x3\x44\x5\x44\x8C7\n\x44\x3\x44\x3\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\a\x44\x8D0\n\x44\f\x44\xE\x44\x8D3");
		sb.Append("\v\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x8DA\n\x44");
		sb.Append("\x3\x44\x5\x44\x8DD\n\x44\x3\x44\x3\x44\a\x44\x8E1\n\x44\f\x44");
		sb.Append("\xE\x44\x8E4\v\x44\x3\x44\x3\x44\x3\x44\x5\x44\x8E9\n\x44\x5");
		sb.Append("\x44\x8EB\n\x44\x3\x44\x3\x44\x3\x44\x5\x44\x8F0\n\x44\x3\x44");
		sb.Append("\x3\x44\a\x44\x8F4\n\x44\f\x44\xE\x44\x8F7\v\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x5\x44\x8FC\n\x44\x5\x44\x8FE\n\x44\x3\x44\x3\x44\x5");
		sb.Append("\x44\x902\n\x44\x3\x44\x5\x44\x905\n\x44\x3\x44\x5\x44\x908");
		sb.Append("\n\x44\x3\x44\x3\x44\a\x44\x90C\n\x44\f\x44\xE\x44\x90F\v\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x5\x44\x914\n\x44\x3\x44\x5\x44\x917\n");
		sb.Append("\x44\x3\x44\x3\x44\a\x44\x91B\n\x44\f\x44\xE\x44\x91E\v\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x5\x44\x923\n\x44\x5\x44\x925\n\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x5\x44\x92A\n\x44\x3\x44\x3\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x5\x44\x932\n\x44\x5\x44\x934\n\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x93D\n\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x5\x44\x942\n\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x5\x44\x94A\n\x44\x3\x44\x3\x44\x5\x44");
		sb.Append("\x94E\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44");
		sb.Append("\x956\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x5\x44\x960\n\x44\x3\x44\x3\x44\x3\x44\x5\x44\x965\n");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x96C\n\x44\x3");
		sb.Append("\x44\x3\x44\x5\x44\x970\n\x44\x3\x44\x3\x44\x5\x44\x974\n\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x98C\n\x44\x3\x44");
		sb.Append("\x3\x44\x5\x44\x990\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x99C\n\x44\x3\x44");
		sb.Append("\x5\x44\x99F\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x5\x44\x9A8\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\a\x44");
		sb.Append("\x9B7\n\x44\f\x44\xE\x44\x9BA\v\x44\x3\x44\x3\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x9C5\n\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x9CC\n\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x5\x44\x9D3\n\x44\x3\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\a\x44\x9E0\n\x44\f\x44\xE\x44\x9E3\v\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x9EF");
		sb.Append("\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x9F5\n\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x5\x44\x9FB\n\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x5\x44\xA01\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44");
		sb.Append("\xA07\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\xA0D\n\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x5\x44\xA13\n\x44\x3\x45\x3\x45\x3");
		sb.Append("\x45\x5\x45\xA18\n\x45\x3\x45\x3\x45\x3\x46\x3\x46\x3\x46\x5");
		sb.Append("\x46\xA1F\n\x46\x3\x46\x3\x46\x3G\x3G\x3G\x5G\xA26\nG\x3G\x3");
		sb.Append("G\x3G\x3G\x3G\x5G\xA2D\nG\x3G\x3G\x3G\x5G\xA32\nG\x3G\aG\xA35");
		sb.Append("\nG\fG\xEG\xA38\vG\x3H\x3H\x3H\x3H\x3H\x3H\x3H\x3H\x3I\x3I\x3");
		sb.Append("I\x5I\xA45\nI\x3I\x3I\x3J\x3J\x3J\x5J\xA4C\nJ\x3J\x3J\x3K\x3");
		sb.Append("K\x3K\x5K\xA53\nK\x3K\x3K\x3L\x3L\x5L\xA59\nL\x3L\x3L\x5L\xA5D");
		sb.Append("\nL\x3L\x3L\x5L\xA61\nL\x3M\x3M\x3M\x3M\x3M\x5M\xA68\nM\x3M");
		sb.Append("\x5M\xA6B\nM\x3N\x3N\x3N\x5N\xA70\nN\x3N\x3N\x3O\x3O\x3O\x5");
		sb.Append("O\xA77\nO\x3O\x3O\x3O\aO\xA7C\nO\fO\xEO\xA7F\vO\x3O\x5O\xA82");
		sb.Append("\nO\x3P\x3P\x3P\x3P\x3P\aP\xA89\nP\fP\xEP\xA8C\vP\x3Q\x3Q\x3");
		sb.Append("Q\x3Q\x3R\x3R\x5R\xA94\nR\x3R\x3R\x3S\x3S\x3S\x3S\x3S\x5S\xA9D");
		sb.Append("\nS\x3S\x5S\xAA0\nS\x3T\x3T\x5T\xAA4\nT\x3U\x3U\x3U\x3V\x3V");
		sb.Append("\x3V\x3V\x5V\xAAD\nV\x3W\x3W\x5W\xAB1\nW\x3W\x5W\xAB4\nW\x3");
		sb.Append("W\x5W\xAB7\nW\x3W\x3W\x3W\x3W\x3W\x3W\x5W\xABF\nW\x3W\x3W\x3");
		sb.Append("W\x3W\x5W\xAC5\nW\x3W\x3W\x3W\x3W\x3W\aW\xACC\nW\fW\xEW\xACF");
		sb.Append("\vW\x5W\xAD1\nW\x3W\x3W\x3W\x3W\x3W\x3W\x3W\aW\xADA\nW\fW\xE");
		sb.Append("W\xADD\vW\x5W\xADF\nW\x3X\x3X\x3X\x5X\xAE4\nX\x3X\x5X\xAE7\n");
		sb.Append("X\x3X\x3X\x3X\x5X\xAEC\nX\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x5");
		sb.Append("X\xAF6\nX\x3X\x3X\x3X\x5X\xAFB\nX\x3X\x3X\x6X\xAFF\nX\rX\xE");
		sb.Append("X\xB00\x5X\xB03\nX\x3X\x3X\x6X\xB07\nX\rX\xEX\xB08\x5X\xB0B");
		sb.Append("\nX\x3X\x3X\x3X\x3X\x5X\xB11\nX\x3X\x3X\x3X\x3X\aX\xB17\nX\f");
		sb.Append("X\xEX\xB1A\vX\x3X\x3X\x5X\xB1E\nX\x3X\x3X\x3X\x3X\aX\xB24\n");
		sb.Append("X\fX\xEX\xB27\vX\x5X\xB29\nX\x3Y\x3Y\x3Y\x5Y\xB2E\nY\x3Y\x5");
		sb.Append("Y\xB31\nY\x3Y\x3Y\x3Y\x5Y\xB36\nY\x3Y\x3Y\x3Y\x3Y\x3Y\x3Y\x5");
		sb.Append("Y\xB3E\nY\x3Y\x3Y\x3Y\x3Y\x3Y\x3Y\x5Y\xB46\nY\x3Y\x3Y\x3Y\x3");
		sb.Append("Y\x5Y\xB4C\nY\x3Y\x3Y\x3Y\x3Y\aY\xB52\nY\fY\xEY\xB55\vY\x3Y");
		sb.Append("\x3Y\x5Y\xB59\nY\x3Y\x3Y\x3Y\x3Y\aY\xB5F\nY\fY\xEY\xB62\vY\x5");
		sb.Append("Y\xB64\nY\x3Z\x3Z\x5Z\xB68\nZ\x3Z\x5Z\xB6B\nZ\x3Z\x3Z\x3Z\x3");
		sb.Append("Z\x3Z\x3Z\x5Z\xB73\nZ\x3Z\x3Z\x3Z\x3Z\x5Z\xB79\nZ\x3Z\x3Z\x3");
		sb.Append("Z\x3Z\x3Z\aZ\xB80\nZ\fZ\xEZ\xB83\vZ\x5Z\xB85\nZ\x3[\x3[\x5[");
		sb.Append("\xB89\n[\x3[\x3[\x5[\xB8D\n[\x3[\x3[\x6[\xB91\n[\r[\xE[\xB92");
		sb.Append("\x3[\x3[\x5[\xB97\n[\x3[\x3[\x5[\xB9B\n[\x5[\xB9D\n[\x3[\x5");
		sb.Append("[\xBA0\n[\x3[\x5[\xBA3\n[\x3[\x5[\xBA6\n[\x3[\x3[\x6[\xBAA\n");
		sb.Append("[\r[\xE[\xBAB\x3[\x3[\x5[\xBB0\n[\x3[\x5[\xBB3\n[\x3[\x5[\xBB6");
		sb.Append("\n[\x3[\x5[\xBB9\n[\x3[\x5[\xBBC\n[\x5[\xBBE\n[\x3\\\x3\\\x5");
		sb.Append("\\\xBC2\n\\\x3]\x3]\x3]\x3]\x3]\x3]\x3]\x3]\x3]\x3]\a]\xBCE");
		sb.Append("\n]\f]\xE]\xBD1\v]\x5]\xBD3\n]\x3^\x3^\x3^\x3^\x5^\xBD9\n^\x3");
		sb.Append("_\x3_\x5_\xBDD\n_\x3`\x3`\x3`\x3`\x3`\x3`\x5`\xBE5\n`\x3\x61");
		sb.Append("\x3\x61\x5\x61\xBE9\n\x61\x3\x61\x5\x61\xBEC\n\x61\x3\x61\x5");
		sb.Append("\x61\xBEF\n\x61\x3\x61\x3\x61\x3\x61\x3\x61\x3\x61\x3\x61\x3");
		sb.Append("\x61\x5\x61\xBF8\n\x61\x3\x61\x3\x61\x5\x61\xBFC\n\x61\x3\x61");
		sb.Append("\x5\x61\xBFF\n\x61\x3\x61\x3\x61\x5\x61\xC03\n\x61\x3\x62\x3");
		sb.Append("\x62\x5\x62\xC07\n\x62\x3\x62\x5\x62\xC0A\n\x62\x3\x62\x5\x62");
		sb.Append("\xC0D\n\x62\x3\x62\x3\x62\x3\x62\x5\x62\xC12\n\x62\x3\x62\x3");
		sb.Append("\x62\x3\x62\x3\x62\x5\x62\xC18\n\x62\a\x62\xC1A\n\x62\f\x62");
		sb.Append("\xE\x62\xC1D\v\x62\x3\x62\x3\x62\x3\x62\x3\x62\x3\x62\x3\x62");
		sb.Append("\x3\x62\x5\x62\xC26\n\x62\x3\x62\x3\x62\x3\x62\x3\x62\x5\x62");
		sb.Append("\xC2C\n\x62\a\x62\xC2E\n\x62\f\x62\xE\x62\xC31\v\x62\x3\x62");
		sb.Append("\x3\x62\x3\x62\x5\x62\xC36\n\x62\x3\x62\x3\x62\x5\x62\xC3A\n");
		sb.Append("\x62\x3\x63\x3\x63\x3\x63\x3\x63\x5\x63\xC40\n\x63\x3\x63\x5");
		sb.Append("\x63\xC43\n\x63\x3\x64\x3\x64\x3\x64\x3\x64\x3\x64\x3\x64\x3");
		sb.Append("\x64\x3\x64\x3\x64\x3\x64\x5\x64\xC4F\n\x64\x3\x64\x3\x64\x5");
		sb.Append("\x64\xC53\n\x64\x3\x64\x3\x64\x5\x64\xC57\n\x64\x3\x65\x3\x65");
		sb.Append("\x3\x65\x3\x65\x3\x65\x3\x65\x5\x65\xC5F\n\x65\x3\x65\x3\x65");
		sb.Append("\x5\x65\xC63\n\x65\x3\x66\x3\x66\x3\x66\x3\x66\x3g\x3g\x5g\xC6B");
		sb.Append("\ng\x3g\x5g\xC6E\ng\x3g\x3g\x5g\xC72\ng\x3g\x5g\xC75\ng\x3g");
		sb.Append("\x3g\x3g\x3g\ag\xC7B\ng\fg\xEg\xC7E\vg\x3g\x3g\x5g\xC82\ng\x3");
		sb.Append("g\x5g\xC85\ng\x3g\x5g\xC88\ng\x3h\x3h\x5h\xC8C\nh\x3h\x5h\xC8F");
		sb.Append("\nh\x3h\x3h\x3h\x3h\x3h\ah\xC96\nh\fh\xEh\xC99\vh\x3h\x3h\x5");
		sb.Append("h\xC9D\nh\x3i\x3i\x3i\x3i\x3i\ai\xCA4\ni\fi\xEi\xCA7\vi\x3j");
		sb.Append("\x3j\x5j\xCAB\nj\x3k\x3k\x3k\ak\xCB0\nk\fk\xEk\xCB3\vk\x3l\x3");
		sb.Append("l\al\xCB7\nl\fl\xEl\xCBA\vl\x3l\x3l\x3l\al\xCBF\nl\fl\xEl\xCC2");
		sb.Append("\vl\x3l\x3l\x5l\xCC6\nl\x3m\x3m\x3m\x3m\x3m\x3m\x5m\xCCE\nm");
		sb.Append("\x3m\x5m\xCD1\nm\x3m\x5m\xCD4\nm\x3m\x3m\x3m\am\xCD9\nm\fm\xE");
		sb.Append("m\xCDC\vm\x5m\xCDE\nm\x3m\x3m\x3m\x3m\x3m\x5m\xCE5\nm\x3m\x5");
		sb.Append("m\xCE8\nm\x3m\x3m\x3m\x3m\x3m\x3m\x5m\xCF0\nm\x3n\x3n\x3n\x3");
		sb.Append("n\x5n\xCF6\nn\x3n\x3n\x3n\x3n\x3o\x3o\x3o\x3o\x3o\x5o\xD01\n");
		sb.Append("o\x3p\x5p\xD04\np\x3p\x3p\x3p\x3p\x3p\x3p\x3p\x3p\x3p\x5p\xD0F");
		sb.Append("\np\x3p\x3p\x3p\x3p\x5p\xD15\np\x3p\x3p\x5p\xD19\np\x3p\x3p");
		sb.Append("\x3p\x3p\x3p\x3p\x3p\x3p\x3p\x5p\xD24\np\x3p\x3p\x3p\x5p\xD29");
		sb.Append("\np\x5p\xD2B\np\x3p\x3p\x5p\xD2F\np\x3q\x3q\x3q\x3q\x3q\x3q");
		sb.Append("\x3q\x3q\x5q\xD39\nq\x3r\x3r\x3r\x3r\x3r\x3r\x3r\x3r\x5r\xD43");
		sb.Append("\nr\x3s\x3s\as\xD47\ns\fs\xEs\xD4A\vs\x3s\x3s\x5s\xD4E\ns\x3");
		sb.Append("s\x5s\xD51\ns\x3s\x5s\xD54\ns\x3s\x5s\xD57\ns\x3s\x3s\as\xD5B");
		sb.Append("\ns\fs\xEs\xD5E\vs\x3s\x3s\x5s\xD62\ns\x3s\x5s\xD65\ns\x3s\x5");
		sb.Append("s\xD68\ns\x3s\x5s\xD6B\ns\x5s\xD6D\ns\x3t\x3t\at\xD71\nt\ft");
		sb.Append("\xEt\xD74\vt\x3t\x3t\x5t\xD78\nt\x3t\x5t\xD7B\nt\x3t\x5t\xD7E");
		sb.Append("\nt\x3u\x3u\x5u\xD82\nu\x3u\x3u\x3v\x3v\x5v\xD88\nv\x3v\x3v");
		sb.Append("\x5v\xD8C\nv\x3w\x3w\x3w\x3w\x3w\x3w\x3w\x3w\x5w\xD96\nw\x3");
		sb.Append("x\x3x\x5x\xD9A\nx\x3x\x3x\ax\xD9E\nx\fx\xEx\xDA1\vx\x3y\x3y");
		sb.Append("\x3y\x3y\x3y\x3y\x5y\xDA9\ny\x3y\x5y\xDAC\ny\x3y\x3y\x5y\xDB0");
		sb.Append("\ny\x3y\x5y\xDB3\ny\x3y\x3y\x5y\xDB7\ny\x3y\x3y\x5y\xDBB\ny");
		sb.Append("\x3y\x5y\xDBE\ny\x5y\xDC0\ny\x3z\x3z\x3z\x3z\az\xDC6\nz\fz\xE");
		sb.Append("z\xDC9\vz\x3z\x3z\x3z\x3z\x3z\x3z\x3z\x3z\x3z\x5z\xDD4\nz\x3");
		sb.Append("z\x3z\x6z\xDD8\nz\rz\xEz\xDD9\x5z\xDDC\nz\x3z\x3z\x6z\xDE0\n");
		sb.Append("z\rz\xEz\xDE1\x5z\xDE4\nz\x5z\xDE6\nz\x3{\x3{\x3{\x3{\x5{\xDEC");
		sb.Append("\n{\x3{\x3{\x3{\x3{\x3{\x3{\x5{\xDF4\n{\x3|\x3|\x3|\x3|\x3|");
		sb.Append("\x3|\x5|\xDFC\n|\x3}\x3}\x3}\x3}\x5}\xE02\n}\x3}\x3}\x3}\x3");
		sb.Append("}\x3}\a}\xE09\n}\f}\xE}\xE0C\v}\x3}\x3}\x5}\xE10\n}\x5}\xE12");
		sb.Append("\n}\x3}\x3}\x5}\xE16\n}\x3~\x3~\x5~\xE1A\n~\x3\x7F\x3\x7F\x3");
		sb.Append("\x7F\x3\x7F\x5\x7F\xE20\n\x7F\x3\x7F\x3\x7F\x3\x7F\x3\x7F\x3");
		sb.Append("\x7F\x5\x7F\xE27\n\x7F\x3\x80\x3\x80\x5\x80\xE2B\n\x80\x3\x81");
		sb.Append("\x3\x81\x3\x81\x3\x81\x3\x81\a\x81\xE32\n\x81\f\x81\xE\x81\xE35");
		sb.Append("\v\x81\x5\x81\xE37\n\x81\x3\x82\x3\x82\x5\x82\xE3B\n\x82\x3");
		sb.Append("\x83\x3\x83\x5\x83\xE3F\n\x83\x3\x83\x3\x83\x5\x83\xE43\n\x83");
		sb.Append("\x3\x83\x5\x83\xE46\n\x83\x3\x83\x5\x83\xE49\n\x83\x3\x83\x5");
		sb.Append("\x83\xE4C\n\x83\x3\x84\x3\x84\x5\x84\xE50\n\x84\x3\x84\x3\x84");
		sb.Append("\x5\x84\xE54\n\x84\x3\x84\x5\x84\xE57\n\x84\x3\x84\x5\x84\xE5A");
		sb.Append("\n\x84\x3\x84\x5\x84\xE5D\n\x84\x3\x85\x3\x85\x3\x85\x3\x86");
		sb.Append("\x3\x86\x5\x86\xE64\n\x86\x3\x86\x3\x86\x5\x86\xE68\n\x86\x3");
		sb.Append("\x86\x3\x86\x3\x87\x3\x87\x3\x87\x3\x87\x3\x88\x3\x88\x3\x88");
		sb.Append("\x3\x88\x3\x88\a\x88\xE75\n\x88\f\x88\xE\x88\xE78\v\x88\x3\x89");
		sb.Append("\x3\x89\x3\x89\x3\x8A\x3\x8A\x3\x8A\x3\x8A\x3\x8A\x3\x8B\x3");
		sb.Append("\x8B\x5\x8B\xE84\n\x8B\x3\x8B\x3\x8B\x3\x8B\x3\x8B\a\x8B\xE8A");
		sb.Append("\n\x8B\f\x8B\xE\x8B\xE8D\v\x8B\x3\x8C\x3\x8C\x3\x8C\x3\x8C\x3");
		sb.Append("\x8C\x3\x8C\x3\x8C\x5\x8C\xE96\n\x8C\x3\x8D\x3\x8D\x5\x8D\xE9A");
		sb.Append("\n\x8D\x3\x8D\x5\x8D\xE9D\n\x8D\x3\x8D\x3\x8D\x3\x8E\x3\x8E");
		sb.Append("\x5\x8E\xEA3\n\x8E\x3\x8E\x5\x8E\xEA6\n\x8E\x3\x8E\x5\x8E\xEA9");
		sb.Append("\n\x8E\x3\x8F\x3\x8F\x3\x8F\x3\x8F\x3\x8F\x3\x8F\x3\x8F\x5\x8F");
		sb.Append("\xEB2\n\x8F\x3\x90\x3\x90\x3\x90\x3\x90\x3\x90\x3\x90\x3\x90");
		sb.Append("\x5\x90\xEBB\n\x90\x3\x91\x3\x91\x3\x91\x3\x91\x3\x91\x3\x91");
		sb.Append("\a\x91\xEC3\n\x91\f\x91\xE\x91\xEC6\v\x91\x3\x91\x5\x91\xEC9");
		sb.Append("\n\x91\x3\x92\x3\x92\x3\x92\x3\x92\x3\x92\x3\x92\a\x92\xED1");
		sb.Append("\n\x92\f\x92\xE\x92\xED4\v\x92\x3\x93\x3\x93\x3\x93\x3\x93\x3");
		sb.Append("\x93\x3\x93\x3\x93\x5\x93\xEDD\n\x93\x3\x94\x3\x94\x3\x94\x3");
		sb.Append("\x95\x3\x95\x3\x95\x5\x95\xEE5\n\x95\x3\x95\x5\x95\xEE8\n\x95");
		sb.Append("\x3\x96\x3\x96\x3\x96\x3\x96\x3\x96\a\x96\xEEF\n\x96\f\x96\xE");
		sb.Append("\x96\xEF2\v\x96\x5\x96\xEF4\n\x96\x3\x96\x3\x96\x5\x96\xEF8");
		sb.Append("\n\x96\x3\x96\a\x96\xEFB\n\x96\f\x96\xE\x96\xEFE\v\x96\x3\x96");
		sb.Append("\x5\x96\xF01\n\x96\x3\x97\x3\x97\x3\x97\x3\x97\x3\x97\a\x97");
		sb.Append("\xF08\n\x97\f\x97\xE\x97\xF0B\v\x97\x5\x97\xF0D\n\x97\x3\x98");
		sb.Append("\x3\x98\x3\x98\x3\x99\x3\x99\x3\x99\x3\x9A\x3\x9A\x3\x9A\x3");
		sb.Append("\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A");
		sb.Append("\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3");
		sb.Append("\x9A\a\x9A\xF2A\n\x9A\f\x9A\xE\x9A\xF2D\v\x9A\x5\x9A\xF2F\n");
		sb.Append("\x9A\x3\x9A\x5\x9A\xF32\n\x9A\x3\x9B\x3\x9B\x3\x9C\x3\x9C\x3");
		sb.Append("\x9D\x3\x9D\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9F\x3\x9F\x3\x9F");
		sb.Append("\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3");
		sb.Append("\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F");
		sb.Append("\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3");
		sb.Append("\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F");
		sb.Append("\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\a\x9F\xF68\n\x9F\f\x9F\xE");
		sb.Append("\x9F\xF6B\v\x9F\x3\x9F\x3\x9F\x5\x9F\xF6F\n\x9F\x3\xA0\x3\xA0");
		sb.Append("\x3\xA0\x3\xA0\x3\xA0\x3\xA0\x3\xA1\x3\xA1\x3\xA2\x3\xA2\x3");
		sb.Append("\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2");
		sb.Append("\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x5\xA2\xF8B");
		sb.Append("\n\xA2\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3");
		sb.Append("\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x5\xA3\xF99\n\xA3\x3\xA4\x3\xA4");
		sb.Append("\x3\xA4\a\xA4\xF9E\n\xA4\f\xA4\xE\xA4\xFA1\v\xA4\x3\xA4\x5\xA4");
		sb.Append("\xFA4\n\xA4\x3\xA5\x3\xA5\x3\xA5\x3\xA5\x5\xA5\xFAA\n\xA5\x3");
		sb.Append("\xA6\x3\xA6\x3\xA6\x3\xA6\x3\xA6\x3\xA6\x5\xA6\xFB2\n\xA6\x5");
		sb.Append("\xA6\xFB4\n\xA6\x3\xA7\x3\xA7\x3\xA7\x3\xA7\x3\xA8\x3\xA8\x3");
		sb.Append("\xA8\x3\xA8\x3\xA8\x5\xA8\xFBF\n\xA8\x3\xA9\x3\xA9\x3\xA9\x3");
		sb.Append("\xA9\x3\xAA\x3\xAA\x3\xAA\x3\xAA\x5\xAA\xFC9\n\xAA\x3\xAB\x3");
		sb.Append("\xAB\x3\xAB\x3\xAB\x3\xAB\x5\xAB\xFD0\n\xAB\x3\xAC\x3\xAC\x3");
		sb.Append("\xAC\x3\xAC\x5\xAC\xFD6\n\xAC\x3\xAD\x3\xAD\x3\xAD\x3\xAD\x3");
		sb.Append("\xAE\x3\xAE\x5\xAE\xFDE\n\xAE\x3\xAF\x3\xAF\x3\xAF\x5\xAF\xFE3");
		sb.Append("\n\xAF\x3\xAF\x3\xAF\x3\xAF\x3\xAF\a\xAF\xFE9\n\xAF\f\xAF\xE");
		sb.Append("\xAF\xFEC\v\xAF\x3\xAF\x3\xAF\x3\xAF\a\xAF\xFF1\n\xAF\f\xAF");
		sb.Append("\xE\xAF\xFF4\v\xAF\x3\xAF\x3\xAF\x3\xAF\a\xAF\xFF9\n\xAF\f\xAF");
		sb.Append("\xE\xAF\xFFC\v\xAF\x3\xAF\x3\xAF\x3\xAF\a\xAF\x1001\n\xAF\f");
		sb.Append("\xAF\xE\xAF\x1004\v\xAF\x3\xAF\a\xAF\x1007\n\xAF\f\xAF\xE\xAF");
		sb.Append("\x100A\v\xAF\x5\xAF\x100C\n\xAF\x3\xAF\x3\xAF\x5\xAF\x1010\n");
		sb.Append("\xAF\x3\xB0\x3\xB0\x3\xB0\x5\xB0\x1015\n\xB0\x3\xB0\x6\xB0\x1018");
		sb.Append("\n\xB0\r\xB0\xE\xB0\x1019\x3\xB0\x3\xB0\x6\xB0\x101E\n\xB0\r");
		sb.Append("\xB0\xE\xB0\x101F\x5\xB0\x1022\n\xB0\x3\xB0\x3\xB0\x3\xB0\x3");
		sb.Append("\xB1\x3\xB1\x3\xB1\x3\xB1\x6\xB1\x102B\n\xB1\r\xB1\xE\xB1\x102C");
		sb.Append("\x3\xB1\a\xB1\x1030\n\xB1\f\xB1\xE\xB1\x1033\v\xB1\x3\xB1\x3");
		sb.Append("\xB1\x6\xB1\x1037\n\xB1\r\xB1\xE\xB1\x1038\x5\xB1\x103B\n\xB1");
		sb.Append("\x3\xB1\x3\xB1\x3\xB1\x3\xB2\x3\xB2\x3\xB2\x3\xB3\x3\xB3\x3");
		sb.Append("\xB3\x3\xB4\x3\xB4\x3\xB4\x5\xB4\x1049\n\xB4\x3\xB4\x3\xB4\x6");
		sb.Append("\xB4\x104D\n\xB4\r\xB4\xE\xB4\x104E\x3\xB4\x3\xB4\x3\xB4\x5");
		sb.Append("\xB4\x1054\n\xB4\x3\xB5\x3\xB5\x3\xB5\x5\xB5\x1059\n\xB5\x3");
		sb.Append("\xB5\x3\xB5\x6\xB5\x105D\n\xB5\r\xB5\xE\xB5\x105E\x3\xB5\x3");
		sb.Append("\xB5\x3\xB5\x3\xB5\x3\xB5\x5\xB5\x1066\n\xB5\x3\xB6\x3\xB6\x3");
		sb.Append("\xB6\x3\xB7\x3\xB7\x3\xB7\x5\xB7\x106E\n\xB7\x3\xB7\x3\xB7\x3");
		sb.Append("\xB7\x3\xB7\x6\xB7\x1074\n\xB7\r\xB7\xE\xB7\x1075\x3\xB7\x3");
		sb.Append("\xB7\x3\xB7\x5\xB7\x107B\n\xB7\x3\xB8\x3\xB8\x3\xB8\x3\xB8\x5");
		sb.Append("\xB8\x1081\n\xB8\x3\xB8\x5\xB8\x1084\n\xB8\x3\xB8\x3\xB8\x3");
		sb.Append("\xB8\x3\xB8\x3\xB8\x3\xB8\x5\xB8\x108C\n\xB8\x3\xB9\x3\xB9\x3");
		sb.Append("\xB9\x3\xB9\x3\xB9\x5\xB9\x1093\n\xB9\x3\xBA\x3\xBA\x3\xBA\x3");
		sb.Append("\xBA\x3\xBA\x3\xBA\x3\xBA\x5\xBA\x109C\n\xBA\x3\xBA\x5\xBA\x109F");
		sb.Append("\n\xBA\x3\xBB\x3\xBB\x3\xBB\x3\xBB\x3\xBB\x3\xBB\x3\xBC\x3\xBC");
		sb.Append("\x3\xBC\x3\xBC\x3\xBC\x3\xBC\x3\xBC\a\xBC\x10AE\n\xBC\f\xBC");
		sb.Append("\xE\xBC\x10B1\v\xBC\x3\xBC\x3\xBC\x3\xBD\x3\xBD\x3\xBD\x5\xBD");
		sb.Append("\x10B8\n\xBD\x3\xBD\x3\xBD\x3\xBD\x3\xBD\x3\xBD\x3\xBD\x5\xBD");
		sb.Append("\x10C0\n\xBD\x3\xBE\x3\xBE\x5\xBE\x10C4\n\xBE\x3\xBE\x3\xBE");
		sb.Append("\x3\xBF\x3\xBF\x3\xBF\x5\xBF\x10CB\n\xBF\x3\xBF\x3\xBF\x6\xBF");
		sb.Append("\x10CF\n\xBF\r\xBF\xE\xBF\x10D0\x3\xC0\x3\xC0\x3\xC0\x3\xC0");
		sb.Append("\x6\xC0\x10D7\n\xC0\r\xC0\xE\xC0\x10D8\x3\xC1\x3\xC1\x3\xC1");
		sb.Append("\x3\xC1\x3\xC1\a\xC1\x10E0\n\xC1\f\xC1\xE\xC1\x10E3\v\xC1\x3");
		sb.Append("\xC1\x3\xC1\x3\xC1\x5\xC1\x10E8\n\xC1\x3\xC1\x3\xC1\x3\xC1\a");
		sb.Append("\xC1\x10ED\n\xC1\f\xC1\xE\xC1\x10F0\v\xC1\x3\xC1\x3\xC1\x3\xC1");
		sb.Append("\x3\xC1\x5\xC1\x10F6\n\xC1\x3\xC1\a\xC1\x10F9\n\xC1\f\xC1\xE");
		sb.Append("\xC1\x10FC\v\xC1\x5\xC1\x10FE\n\xC1\x5\xC1\x1100\n\xC1\x3\xC1");
		sb.Append("\x3\xC1\x6\xC1\x1104\n\xC1\r\xC1\xE\xC1\x1105\x5\xC1\x1108\n");
		sb.Append("\xC1\x3\xC1\x3\xC1\a\xC1\x110C\n\xC1\f\xC1\xE\xC1\x110F\v\xC1");
		sb.Append("\x5\xC1\x1111\n\xC1\x3\xC2\x3\xC2\x3\xC2\x3\xC2\x3\xC2\a\xC2");
		sb.Append("\x1118\n\xC2\f\xC2\xE\xC2\x111B\v\xC2\x3\xC2\x3\xC2\x3\xC2\x5");
		sb.Append("\xC2\x1120\n\xC2\x3\xC2\x3\xC2\x3\xC2\a\xC2\x1125\n\xC2\f\xC2");
		sb.Append("\xE\xC2\x1128\v\xC2\x3\xC2\x3\xC2\x3\xC2\x3\xC2\x5\xC2\x112E");
		sb.Append("\n\xC2\x3\xC2\a\xC2\x1131\n\xC2\f\xC2\xE\xC2\x1134\v\xC2\x5");
		sb.Append("\xC2\x1136\n\xC2\x5\xC2\x1138\n\xC2\x3\xC2\x3\xC2\x6\xC2\x113C");
		sb.Append("\n\xC2\r\xC2\xE\xC2\x113D\x5\xC2\x1140\n\xC2\x3\xC2\x3\xC2\a");
		sb.Append("\xC2\x1144\n\xC2\f\xC2\xE\xC2\x1147\v\xC2\x5\xC2\x1149\n\xC2");
		sb.Append("\x3\xC3\x3\xC3\x3\xC3\x5\xC3\x114E\n\xC3\x3\xC3\x3\xC3\x3\xC3");
		sb.Append("\a\xC3\x1153\n\xC3\f\xC3\xE\xC3\x1156\v\xC3\x3\xC4\x3\xC4\x3");
		sb.Append("\xC4\x3\xC4\a\xC4\x115C\n\xC4\f\xC4\xE\xC4\x115F\v\xC4\x3\xC4");
		sb.Append("\x3\xC4\x5\xC4\x1163\n\xC4\x3\xC4\x3\xC4\x3\xC4\x3\xC4\x3\xC4");
		sb.Append("\a\xC4\x116A\n\xC4\f\xC4\xE\xC4\x116D\v\xC4\x3\xC4\x3\xC4\x3");
		sb.Append("\xC4\x3\xC4\x5\xC4\x1173\n\xC4\x3\xC4\a\xC4\x1176\n\xC4\f\xC4");
		sb.Append("\xE\xC4\x1179\v\xC4\x5\xC4\x117B\n\xC4\x5\xC4\x117D\n\xC4\x3");
		sb.Append("\xC4\x3\xC4\x3\xC4\x3\xC4\a\xC4\x1183\n\xC4\f\xC4\xE\xC4\x1186");
		sb.Append("\v\xC4\x5\xC4\x1188\n\xC4\x3\xC5\x3\xC5\x3\xC5\x3\xC5\x3\xC5");
		sb.Append("\x3\xC5\x3\xC5\x3\xC5\a\xC5\x1192\n\xC5\f\xC5\xE\xC5\x1195\v");
		sb.Append("\xC5\x3\xC5\x3\xC5\x3\xC5\x5\xC5\x119A\n\xC5\x3\xC6\x3\xC6\x3");
		sb.Append("\xC6\x3\xC6\x3\xC6\a\xC6\x11A1\n\xC6\f\xC6\xE\xC6\x11A4\v\xC6");
		sb.Append("\x3\xC7\x3\xC7\x3\xC7\x3\xC7\a\xC7\x11AA\n\xC7\f\xC7\xE\xC7");
		sb.Append("\x11AD\v\xC7\x3\xC7\x3\xC7\x5\xC7\x11B1\n\xC7\x3\xC7\x3\xC7");
		sb.Append("\x3\xC7\x3\xC7\x3\xC7\a\xC7\x11B8\n\xC7\f\xC7\xE\xC7\x11BB\v");
		sb.Append("\xC7\x3\xC7\x3\xC7\x3\xC7\x5\xC7\x11C0\n\xC7\x3\xC7\x3\xC7\x3");
		sb.Append("\xC7\x3\xC7\x3\xC7\x3\xC7\x3\xC7\a\xC7\x11C9\n\xC7\f\xC7\xE");
		sb.Append("\xC7\x11CC\v\xC7\x5\xC7\x11CE\n\xC7\x3\xC8\x3\xC8\x3\xC8\x3");
		sb.Append("\xC8\x3\xC8\x3\xC8\x3\xC8\x3\xC8\a\xC8\x11D8\n\xC8\f\xC8\xE");
		sb.Append("\xC8\x11DB\v\xC8\x3\xC9\x3\xC9\x3\xC9\x3\xC9\x5\xC9\x11E1\n");
		sb.Append("\xC9\x3\xC9\x3\xC9\x3\xC9\x5\xC9\x11E6\n\xC9\x3\xCA\x3\xCA\x3");
		sb.Append("\xCA\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB");
		sb.Append("\x3\xCB\x3\xCB\x5\xCB\x11F5\n\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB");
		sb.Append("\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x5\xCB\x1200\n\xCB\x3\xCB");
		sb.Append("\x5\xCB\x1203\n\xCB\x3\xCC\x3\xCC\x3\xCC\x3\xCC\x3\xCC\x3\xCC");
		sb.Append("\x3\xCC\x3\xCC\x5\xCC\x120D\n\xCC\x3\xCD\x3\xCD\x3\xCD\x3\xCD");
		sb.Append("\x3\xCD\x3\xCD\x3\xCD\x3\xCD\x5\xCD\x1217\n\xCD\x3\xCE\x3\xCE");
		sb.Append("\x3\xCE\x3\xCE\x3\xCE\x3\xCE\x3\xCE\x3\xCE\x5\xCE\x1221\n\xCE");
		sb.Append("\x3\xCF\x3\xCF\x3\xCF\x3\xD0\x3\xD0\x3\xD0\x3\xD0\x3\xD0\x5");
		sb.Append("\xD0\x122B\n\xD0\x3\xD1\x3\xD1\x5\xD1\x122F\n\xD1\x3\xD1\x3");
		sb.Append("\xD1\x5\xD1\x1233\n\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3");
		sb.Append("\xD1\x3\xD1\x5\xD1\x123C\n\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3");
		sb.Append("\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1");
		sb.Append("\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3");
		sb.Append("\xD1\x3\xD1\x3\xD1\x3\xD1\x5\xD1\x1257\n\xD1\x3\xD2\x3\xD2\x3");
		sb.Append("\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2");
		sb.Append("\x3\xD2\x3\xD2\x5\xD2\x1266\n\xD2\x3\xD3\x3\xD3\x3\xD3\x3\xD3");
		sb.Append("\x3\xD4\x3\xD4\x5\xD4\x126E\n\xD4\x3\xD4\x3\xD4\x3\xD4\x3\xD5");
		sb.Append("\x3\xD5\x3\xD5\x3\xD5\a\xD5\x1277\n\xD5\f\xD5\xE\xD5\x127A\v");
		sb.Append("\xD5\x3\xD6\x3\xD6\x3\xD6\x3\xD6\x5\xD6\x1280\n\xD6\x3\xD7\x3");
		sb.Append("\xD7\x5\xD7\x1284\n\xD7\x3\xD7\x3\xD7\x3\xD7\x3\xD8\x3\xD8\x5");
		sb.Append("\xD8\x128B\n\xD8\x3\xD8\x3\xD8\x3\xD8\x5\xD8\x1290\n\xD8\x3");
		sb.Append("\xD8\x5\xD8\x1293\n\xD8\x3\xD8\x5\xD8\x1296\n\xD8\x3\xD9\x3");
		sb.Append("\xD9\x3\xD9\x3\xD9\x3\xD9\x3\xD9\x3\xD9\x5\xD9\x129F\n\xD9\x3");
		sb.Append("\xDA\x3\xDA\x5\xDA\x12A3\n\xDA\x3\xDA\x3\xDA\x3\xDA\x3\xDA\x3");
		sb.Append("\xDA\x3\xDA\x3\xDA\x3\xDB\x3\xDB\x3\xDB\x3\xDB\x3\xDB\x3\xDB");
		sb.Append("\x3\xDC\x3\xDC\x3\xDC\x3\xDC\x3\xDD\x3\xDD\x3\xDD\x3\xDD\x3");
		sb.Append("\xDD\x3\xDD\x3\xDD\x3\xDD\x3\xDD\a\xDD\x12BF\n\xDD\f\xDD\xE");
		sb.Append("\xDD\x12C2\v\xDD\x3\xDD\x3\xDD\x3\xDD\x3\xDD\x5\xDD\x12C8\n");
		sb.Append("\xDD\x3\xDD\x3\xDD\x5\xDD\x12CC\n\xDD\x3\xDD\x3\xDD\x3\xDD\x3");
		sb.Append("\xDD\x3\xDD\x5\xDD\x12D3\n\xDD\x3\xDD\x5\xDD\x12D6\n\xDD\x3");
		sb.Append("\xDD\x3\xDD\x3\xDD\x3\xDD\x3\xDD\x3\xDD\x3\xDD\x3\xDD\x5\xDD");
		sb.Append("\x12E0\n\xDD\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE");
		sb.Append("\x3\xDE\x5\xDE\x12EA\n\xDE\x3\xDE\x3\xDE\x5\xDE\x12EE\n\xDE");
		sb.Append("\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x12F4\n\xDE\x3\xDE\x5\xDE");
		sb.Append("\x12F7\n\xDE\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x12FC\n\xDE\x3\xDE");
		sb.Append("\x3\xDE\x5\xDE\x1300\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE");
		sb.Append("\x5\xDE\x1307\n\xDE\x3\xDE\x5\xDE\x130A\n\xDE\x3\xDE\x3\xDE");
		sb.Append("\x3\xDE\x3\xDE\x5\xDE\x1310\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE");
		sb.Append("\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3");
		sb.Append("\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE");
		sb.Append("\x3\xDE\x5\xDE\x1328\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE");
		sb.Append("\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x1335\n\xDE");
		sb.Append("\x3\xDE\x5\xDE\x1338\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE");
		sb.Append("\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x1342\n\xDE\x3\xDE\x3\xDE\x3\xDE");
		sb.Append("\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x134A\n\xDE\x3\xDE\x3\xDE\x5\xDE");
		sb.Append("\x134E\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x1355");
		sb.Append("\n\xDE\x3\xDE\x5\xDE\x1358\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE");
		sb.Append("\x3\xDE\a\xDE\x135F\n\xDE\f\xDE\xE\xDE\x1362\v\xDE\x3\xDE\x3");
		sb.Append("\xDE\x3\xDE\x5\xDE\x1367\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x5");
		sb.Append("\xDE\x136D\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3");
		sb.Append("\xDE\x3\xDE\x5\xDE\x1377\n\xDE\x5\xDE\x1379\n\xDE\x3\xDF\x3");
		sb.Append("\xDF\x3\xDF\x3\xDF\x5\xDF\x137F\n\xDF\x3\xDF\x5\xDF\x1382\n");
		sb.Append("\xDF\x3\xDF\x5\xDF\x1385\n\xDF\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3");
		sb.Append("\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x5\xE0\x1391\n\xE0\x3");
		sb.Append("\xE0\x5\xE0\x1394\n\xE0\x3\xE1\x3\xE1\x3\xE1\x3\xE1\x5\xE1\x139A");
		sb.Append("\n\xE1\x3\xE2\x5\xE2\x139D\n\xE2\x3\xE2\x3\xE2\x3\xE2\x3\xE2");
		sb.Append("\x3\xE2\x3\xE2\x5\xE2\x13A5\n\xE2\x3\xE2\x3\xE2\x3\xE2\x3\xE2");
		sb.Append("\x3\xE2\x3\xE2\x5\xE2\x13AD\n\xE2\x3\xE3\x3\xE3\x3\xE3\x3\xE3");
		sb.Append("\x5\xE3\x13B3\n\xE3\x3\xE3\x3\xE3\x5\xE3\x13B7\n\xE3\x3\xE4");
		sb.Append("\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3");
		sb.Append("\xE4\x3\xE4\x3\xE4\x5\xE4\x13C5\n\xE4\x3\xE5\x3\xE5\x3\xE5\x3");
		sb.Append("\xE6\x3\xE6\x3\xE6\x3\xE6\x3\xE6\a\xE6\x13CF\n\xE6\f\xE6\xE");
		sb.Append("\xE6\x13D2\v\xE6\x3\xE6\x3\xE6\x3\xE6\x3\xE6\x5\xE6\x13D8\n");
		sb.Append("\xE6\x3\xE6\x5\xE6\x13DB\n\xE6\x3\xE6\x3\xE6\x3\xE6\x3\xE7\x3");
		sb.Append("\xE7\x5\xE7\x13E2\n\xE7\x3\xE7\x3\xE7\x3\xE7\a\xE7\x13E7\n\xE7");
		sb.Append("\f\xE7\xE\xE7\x13EA\v\xE7\x3\xE8\x3\xE8\x5\xE8\x13EE\n\xE8\x3");
		sb.Append("\xE8\x6\xE8\x13F1\n\xE8\r\xE8\xE\xE8\x13F2\x3\xE9\x3\xE9\x3");
		sb.Append("\xE9\x3\xE9\x3\xE9\x3\xE9\x3\xE9\a\xE9\x13FC\n\xE9\f\xE9\xE");
		sb.Append("\xE9\x13FF\v\xE9\x3\xEA\x3\xEA\x3\xEA\x3\xEA\x3\xEB\x3\xEB\x3");
		sb.Append("\xEC\x3\xEC\x5\xEC\x1409\n\xEC\x3\xEC\x3\xEC\x3\xEC\x3\xEC\x5");
		sb.Append("\xEC\x140F\n\xEC\x3\xED\x3\xED\x3\xED\x5\xED\x1414\n\xED\x3");
		sb.Append("\xED\x3\xED\x3\xED\x3\xED\x3\xED\x3\xED\x3\xED\x3\xED\x3\xED");
		sb.Append("\x3\xED\x3\xED\x5\xED\x1421\n\xED\x5\xED\x1423\n\xED\x3\xED");
		sb.Append("\x3\xED\x3\xED\x5\xED\x1428\n\xED\x3\xED\x3\xED\x3\xED\x5\xED");
		sb.Append("\x142D\n\xED\x5\xED\x142F\n\xED\x3\xEE\x3\xEE\x3\xEE\x3\xEE");
		sb.Append("\x3\xEE\x5\xEE\x1436\n\xEE\x3\xEF\x3\xEF\x3\xEF\x3\xEF\x3\xEF");
		sb.Append("\x5\xEF\x143D\n\xEF\x3\xEF\x5\xEF\x1440\n\xEF\x3\xEF\x5\xEF");
		sb.Append("\x1443\n\xEF\x3\xEF\x3\xEF\x3\xEF\x3\xEF\x5\xEF\x1449\n\xEF");
		sb.Append("\x3\xEF\x3\xEF\x5\xEF\x144D\n\xEF\x3\xF0\x3\xF0\x3\xF0\x3\xF0");
		sb.Append("\x5\xF0\x1453\n\xF0\x3\xF1\x3\xF1\x3\xF1\x3\xF1\x5\xF1\x1459");
		sb.Append("\n\xF1\x3\xF1\x3\xF1\x3\xF2\x3\xF2\x3\xF2\x3\xF3\x3\xF3\x3\xF3");
		sb.Append("\x3\xF4\x3\xF4\x3\xF4\x3\xF4\x3\xF4\x5\xF4\x1468\n\xF4\x3\xF4");
		sb.Append("\x3\xF4\x3\xF4\x5\xF4\x146D\n\xF4\x3\xF5\x3\xF5\x3\xF5\x3\xF5");
		sb.Append("\x5\xF5\x1473\n\xF5\x3\xF6\x3\xF6\x3\xF7\x3\xF7\x3\xF7\x5\xF7");
		sb.Append("\x147A\n\xF7\x5\xF7\x147C\n\xF7\x3\xF8\x3\xF8\x5\xF8\x1480\n");
		sb.Append("\xF8\x3\xF8\x3\xF8\x3\xF8\x3\xF8\x5\xF8\x1486\n\xF8\x3\xF8\x5");
		sb.Append("\xF8\x1489\n\xF8\x3\xF9\x3\xF9\x3\xFA\x3\xFA\x3\xFB\x3\xFB\x3");
		sb.Append("\xFB\x3\xFB\x5\xFB\x1493\n\xFB\x3\xFC\x3\xFC\x5\xFC\x1497\n");
		sb.Append("\xFC\x3\xFD\x3\xFD\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE");
		sb.Append("\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x6");
		sb.Append("\xFE\x14A9\n\xFE\r\xFE\xE\xFE\x14AA\x3\xFF\x3\xFF\x3\xFF\x3");
		sb.Append("\xFF\x3\xFF\x5\xFF\x14B2\n\xFF\x5\xFF\x14B4\n\xFF\x3\x100\x3");
		sb.Append("\x100\x3\x100\x6\x100\x14B9\n\x100\r\x100\xE\x100\x14BA\x5\x100");
		sb.Append("\x14BD\n\x100\x3\x101\x3\x101\x5\x101\x14C1\n\x101\x3\x102\x3");
		sb.Append("\x102\x3\x102\x5\x102\x14C6\n\x102\x3\x103\x3\x103\x3\x103\x3");
		sb.Append("\x103\x3\x103\x3\x103\x3\x103\x3\x103\x3\x103\x5\x103\x14D1");
		sb.Append("\n\x103\x3\x104\x3\x104\x3\x104\x5\x104\x14D6\n\x104\x3\x105");
		sb.Append("\x3\x105\x3\x106\x3\x106\x5\x106\x14DC\n\x106\x3\x107\x5\x107");
		sb.Append("\x14DF\n\x107\x3\x107\x3\x107\x5\x107\x14E3\n\x107\x3\x107\x6");
		sb.Append("\x107\x14E6\n\x107\r\x107\xE\x107\x14E7\x3\x107\x5\x107\x14EB");
		sb.Append("\n\x107\x3\x107\x3\x107\x5\x107\x14EF\n\x107\x3\x107\x3\x107");
		sb.Append("\x5\x107\x14F3\n\x107\x5\x107\x14F5\n\x107\x3\x108\x3\x108\x3");
		sb.Append("\x109\x5\x109\x14FA\n\x109\x3\x109\x3\x109\x3\x10A\x5\x10A\x14FF");
		sb.Append("\n\x10A\x3\x10A\x3\x10A\x3\x10B\x3\x10B\x3\x10B\x3\x10B\x3\x10B");
		sb.Append("\x3\x10B\x3\x10B\x3\x10B\x3\x10B\x5\x10B\x150C\n\x10B\x3\x10B");
		sb.Append("\x5\x10B\x150F\n\x10B\x3\x10C\x3\x10C\x5\x10C\x1513\n\x10C\x3");
		sb.Append("\x10C\x5\x10C\x1516\n\x10C\x3\x10C\x3\x10C\x3\x10C\x5\x10C\x151B");
		sb.Append("\n\x10C\x3\x10C\x5\x10C\x151E\n\x10C\x3\x10C\x3\x10C\x5\x10C");
		sb.Append("\x1522\n\x10C\x3\x10C\x3\x10C\x3\x10C\x5\x10C\x1527\n\x10C\x3");
		sb.Append("\x10C\x5\x10C\x152A\n\x10C\x3\x10C\x3\x10C\x3\x10C\x5\x10C\x152F");
		sb.Append("\n\x10C\x3\x10C\x5\x10C\x1532\n\x10C\x3\x10C\x3\x10C\x3\x10C");
		sb.Append("\x3\x10C\x5\x10C\x1538\n\x10C\x3\x10C\x5\x10C\x153B\n\x10C\x3");
		sb.Append("\x10C\x3\x10C\x5\x10C\x153F\n\x10C\x3\x10C\x5\x10C\x1542\n\x10C");
		sb.Append("\x3\x10C\x5\x10C\x1545\n\x10C\x3\x10C\x3\x10C\x5\x10C\x1549");
		sb.Append("\n\x10C\x3\x10C\x5\x10C\x154C\n\x10C\x3\x10C\x5\x10C\x154F\n");
		sb.Append("\x10C\x3\x10C\x3\x10C\x5\x10C\x1553\n\x10C\x3\x10C\x5\x10C\x1556");
		sb.Append("\n\x10C\x3\x10C\x5\x10C\x1559\n\x10C\x3\x10C\x5\x10C\x155C\n");
		sb.Append("\x10C\x3\x10C\x3\x10C\x5\x10C\x1560\n\x10C\x3\x10C\x5\x10C\x1563");
		sb.Append("\n\x10C\x3\x10C\x5\x10C\x1566\n\x10C\x3\x10C\x3\x10C\x3\x10C");
		sb.Append("\x5\x10C\x156B\n\x10C\x3\x10C\x3\x10C\x3\x10C\x5\x10C\x1570");
		sb.Append("\n\x10C\x3\x10C\x3\x10C\x3\x10C\x5\x10C\x1575\n\x10C\x3\x10C");
		sb.Append("\x5\x10C\x1578\n\x10C\x3\x10C\x5\x10C\x157B\n\x10C\x3\x10D\x3");
		sb.Append("\x10D\x3\x10D\x3\x10D\a\x10D\x1581\n\x10D\f\x10D\xE\x10D\x1584");
		sb.Append("\v\x10D\x3\x10D\x3\x10D\x3\x10E\x3\x10E\x5\x10E\x158A\n\x10E");
		sb.Append("\x3\x10E\x3\x10E\x5\x10E\x158E\n\x10E\x3\x10E\x3\x10E\x3\x10E");
		sb.Append("\x5\x10E\x1593\n\x10E\x3\x10E\x5\x10E\x1596\n\x10E\x3\x10E\x3");
		sb.Append("\x10E\x3\x10E\x5\x10E\x159B\n\x10E\x3\x10E\x3\x10E\x5\x10E\x159F");
		sb.Append("\n\x10E\x5\x10E\x15A1\n\x10E\x3\x10F\x3\x10F\x3\x10F\x3\x10F");
		sb.Append("\x3\x110\x3\x110\x3\x110\x3\x110\x3\x110\x3\x110\x3\x111\x3");
		sb.Append("\x111\x3\x111\x3\x111\x5\x111\x15B1\n\x111\x3\x111\x3\x111\x3");
		sb.Append("\x112\x3\x112\x3\x112\a\x112\x15B8\n\x112\f\x112\xE\x112\x15BB");
		sb.Append("\v\x112\x3\x113\x3\x113\x3\x113\a\x113\x15C0\n\x113\f\x113\xE");
		sb.Append("\x113\x15C3\v\x113\x3\x114\x3\x114\x3\x114\x3\x114\a\x114\x15C9");
		sb.Append("\n\x114\f\x114\xE\x114\x15CC\v\x114\x3\x114\x3\x114\x3\x115");
		sb.Append("\x3\x115\x3\x115\a\x115\x15D3\n\x115\f\x115\xE\x115\x15D6\v");
		sb.Append("\x115\x3\x116\x3\x116\x3\x116\a\x116\x15DB\n\x116\f\x116\xE");
		sb.Append("\x116\x15DE\v\x116\x3\x117\x3\x117\x3\x117\a\x117\x15E3\n\x117");
		sb.Append("\f\x117\xE\x117\x15E6\v\x117\x3\x118\x3\x118\x3\x118\a\x118");
		sb.Append("\x15EB\n\x118\f\x118\xE\x118\x15EE\v\x118\x3\x119\x3\x119\x3");
		sb.Append("\x119\a\x119\x15F3\n\x119\f\x119\xE\x119\x15F6\v\x119\x3\x11A");
		sb.Append("\x3\x11A\x5\x11A\x15FA\n\x11A\x3\x11A\x3\x11A\x3\x11A\x3\x11A");
		sb.Append("\x3\x11A\x5\x11A\x1601\n\x11A\x5\x11A\x1603\n\x11A\x3\x11B\x3");
		sb.Append("\x11B\x3\x11B\x5\x11B\x1608\n\x11B\x3\x11B\x5\x11B\x160B\n\x11B");
		sb.Append("\x3\x11B\x3\x11B\x3\x11B\x5\x11B\x1610\n\x11B\x3\x11B\x5\x11B");
		sb.Append("\x1613\n\x11B\x3\x11C\x3\x11C\x5\x11C\x1617\n\x11C\x3\x11D\x3");
		sb.Append("\x11D\x3\x11D\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11F\x3\x11F");
		sb.Append("\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x1625\n\x11F\x3\x11F\x3\x11F");
		sb.Append("\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x162C\n\x11F\x3\x11F\x3\x11F");
		sb.Append("\x3\x11F\x5\x11F\x1631\n\x11F\x3\x120\x3\x120\x3\x120\x3\x120");
		sb.Append("\x3\x120\x3\x120\x3\x120\x3\x120\x3\x120\x3\x120\x3\x120\x3");
		sb.Append("\x120\x3\x120\x3\x120\x3\x120\x3\x120\x3\x120\x3\x120\x3\x120");
		sb.Append("\x3\x120\x3\x120\x3\x120\x3\x120\x3\x120\x3\x120\x3\x120\x3");
		sb.Append("\x120\x3\x120\x3\x120\x3\x120\x6\x120\x1651\n\x120\r\x120\xE");
		sb.Append("\x120\x1652\x3\x120\x3\x120\x5\x120\x1657\n\x120\x3\x120\x3");
		sb.Append("\x120\x3\x120\x3\x120\x6\x120\x165D\n\x120\r\x120\xE\x120\x165E");
		sb.Append("\x3\x120\x3\x120\x5\x120\x1663\n\x120\x3\x120\x3\x120\x3\x120");
		sb.Append("\x3\x120\x3\x120\x3\x120\x3\x120\x5\x120\x166C\n\x120\x3\x120");
		sb.Append("\x3\x120\x3\x120\x3\x120\x3\x120\x3\x120\x5\x120\x1674\n\x120");
		sb.Append("\x3\x120\x3\x120\x3\x120\x5\x120\x1679\n\x120\x3\x120\x3\x120");
		sb.Append("\x3\x120\x3\x120\x3\x120\x3\x120\x5\x120\x1681\n\x120\x3\x120");
		sb.Append("\x3\x120\x3\x120\x5\x120\x1686\n\x120\x3\x120\x3\x120\x3\x120");
		sb.Append("\x5\x120\x168B\n\x120\x5\x120\x168D\n\x120\x3\x120\x3\x120\x3");
		sb.Append("\x120\x3\x120\x3\x120\x3\x120\x3\x120\x5\x120\x1696\n\x120\x3");
		sb.Append("\x120\x3\x120\x3\x120\x5\x120\x169B\n\x120\x3\x120\x3\x120\x3");
		sb.Append("\x120\x3\x120\x3\x120\x3\x120\x5\x120\x16A3\n\x120\x3\x120\x3");
		sb.Append("\x120\x3\x120\x5\x120\x16A8\n\x120\x3\x120\x3\x120\x3\x120\x3");
		sb.Append("\x120\x3\x120\x3\x120\x5\x120\x16B0\n\x120\x3\x120\x3\x120\x3");
		sb.Append("\x120\x3\x120\x3\x120\x3\x120\x5\x120\x16B8\n\x120\x3\x120\x5");
		sb.Append("\x120\x16BB\n\x120\x3\x120\x3\x120\x3\x120\x3\x120\x3\x120\x3");
		sb.Append("\x120\x3\x120\x3\x120\x5\x120\x16C5\n\x120\x3\x120\x3\x120\x3");
		sb.Append("\x120\x3\x120\x3\x120\x3\x120\x3\x120\x3\x120\x3\x120\x5\x120");
		sb.Append("\x16D0\n\x120\x3\x121\x3\x121\x3\x121\x3\x121\x3\x121\x3\x122");
		sb.Append("\x3\x122\x3\x122\x3\x122\a\x122\x16DB\n\x122\f\x122\xE\x122");
		sb.Append("\x16DE\v\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x5\x122");
		sb.Append("\x16E5\n\x122\x3\x123\x3\x123\x5\x123\x16E9\n\x123\x3\x124\x3");
		sb.Append("\x124\x3\x124\x5\x124\x16EE\n\x124\x3\x124\x3\x124\x3\x124\x3");
		sb.Append("\x124\x3\x124\x3\x124\x3\x124\x5\x124\x16F7\n\x124\x3\x124\x5");
		sb.Append("\x124\x16FA\n\x124\x3\x124\x3\x124\x3\x124\x3\x124\x3\x124\x3");
		sb.Append("\x124\x3\x124\x3\x124\x3\x124\x3\x124\x5\x124\x1706\n\x124\x3");
		sb.Append("\x124\x3\x124\x3\x124\x3\x124\x3\x124\x3\x124\x5\x124\x170E");
		sb.Append("\n\x124\x3\x124\x3\x124\x3\x124\x3\x124\x3\x124\x3\x124\a\x124");
		sb.Append("\x1716\n\x124\f\x124\xE\x124\x1719\v\x124\x5\x124\x171B\n\x124");
		sb.Append("\x3\x124\x3\x124\x5\x124\x171F\n\x124\x3\x124\x3\x124\x5\x124");
		sb.Append("\x1723\n\x124\x3\x125\x3\x125\x3\x125\x3\x125\x3\x125\x3\x125");
		sb.Append("\x3\x125\x3\x125\x3\x125\x3\x125\x3\x125\x3\x125\x3\x125\x3");
		sb.Append("\x125\x3\x125\x3\x125\x3\x125\x3\x125\x3\x125\x3\x125\x3\x125");
		sb.Append("\x3\x125\x3\x125\x5\x125\x173C\n\x125\x3\x126\x3\x126\x3\x126");
		sb.Append("\x3\x126\x3\x126\x3\x127\x3\x127\x3\x127\x3\x127\x5\x127\x1747");
		sb.Append("\n\x127\x3\x127\x3\x127\x3\x127\x3\x127\x3\x127\x5\x127\x174E");
		sb.Append("\n\x127\a\x127\x1750\n\x127\f\x127\xE\x127\x1753\v\x127\x3\x128");
		sb.Append("\x3\x128\x3\x128\x3\x128\x5\x128\x1759\n\x128\x3\x129\x3\x129");
		sb.Append("\x3\x129\x3\x129\x3\x129\x3\x129\x5\x129\x1761\n\x129\x3\x129");
		sb.Append("\x3\x129\x3\x129\x5\x129\x1766\n\x129\x3\x129\x3\x129\x3\x129");
		sb.Append("\x3\x129\a\x129\x176C\n\x129\f\x129\xE\x129\x176F\v\x129\x3");
		sb.Append("\x12A\x3\x12A\x3\x12A\x5\x12A\x1774\n\x12A\x3\x12A\x3\x12A\x3");
		sb.Append("\x12A\x3\x12A\x3\x12A\x3\x12A\x3\x12A\x3\x12A\x5\x12A\x177E");
		sb.Append("\n\x12A\x3\x12A\x3\x12A\x3\x12A\x3\x12A\x3\x12A\x3\x12A\x3\x12A");
		sb.Append("\x3\x12A\x3\x12A\x3\x12A\x3\x12A\x5\x12A\x178B\n\x12A\x3\x12A");
		sb.Append("\x3\x12A\x3\x12A\x3\x12A\x5\x12A\x1791\n\x12A\x3\x12A\x3\x12A");
		sb.Append("\x3\x12A\x3\x12A\x5\x12A\x1797\n\x12A\x3\x12A\x3\x12A\x3\x12A");
		sb.Append("\x3\x12A\x3\x12A\x3\x12A\x3\x12A\x3\x12A\x3\x12A\x3\x12A\x3");
		sb.Append("\x12A\x3\x12A\x3\x12A\x3\x12A\x5\x12A\x17A7\n\x12A\x3\x12A\x3");
		sb.Append("\x12A\x3\x12A\x3\x12A\x5\x12A\x17AD\n\x12A\a\x12A\x17AF\n\x12A");
		sb.Append("\f\x12A\xE\x12A\x17B2\v\x12A\x3\x12B\x3\x12B\x3\x12B\x3\x12B");
		sb.Append("\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3");
		sb.Append("\x12B\x3\x12B\x3\x12B\a\x12B\x17C2\n\x12B\f\x12B\xE\x12B\x17C5");
		sb.Append("\v\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B");
		sb.Append("\x6\x12B\x17CE\n\x12B\r\x12B\xE\x12B\x17CF\x3\x12B\x3\x12B\x3");
		sb.Append("\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B");
		sb.Append("\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x17E1\n\x12B");
		sb.Append("\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3");
		sb.Append("\x12B\x3\x12B\x3\x12B\x3\x12B\a\x12B\x17EE\n\x12B\f\x12B\xE");
		sb.Append("\x12B\x17F1\v\x12B\x3\x12C\x3\x12C\x3\x12D\x3\x12D\x3\x12D\x3");
		sb.Append("\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D");
		sb.Append("\x3\x12D\x3\x12D\x3\x12D\x5\x12D\x1803\n\x12D\x3\x12E\x3\x12E");
		sb.Append("\x3\x12E\x3\x12E\x3\x12E\x3\x12E\x3\x12E\x5\x12E\x180C\n\x12E");
		sb.Append("\x3\x12F\x3\x12F\x3\x12F\x3\x12F\x3\x12F\x3\x12F\x3\x12F\x5");
		sb.Append("\x12F\x1815\n\x12F\x3\x130\x3\x130\x3\x131\x3\x131\x3\x132\x3");
		sb.Append("\x132\x3\x133\x3\x133\x3\x134\x3\x134\x3\x135\x3\x135\x3\x136");
		sb.Append("\x3\x136\x3\x137\x3\x137\x3\x137\x2\x5\x250\x252\x254\x138\x2");
		sb.Append("\x4\x6\b\n\f\xE\x10\x12\x14\x16\x18\x1A\x1C\x1E \"$&(*,.\x30");
		sb.Append("\x32\x34\x36\x38:<>@\x42\x44\x46HJLNPRTVXZ\\^`\x62\x64\x66h");
		sb.Append("jlnprtvxz|~\x80\x82\x84\x86\x88\x8A\x8C\x8E\x90\x92\x94\x96");
		sb.Append("\x98\x9A\x9C\x9E\xA0\xA2\xA4\xA6\xA8\xAA\xAC\xAE\xB0\xB2\xB4");
		sb.Append("\xB6\xB8\xBA\xBC\xBE\xC0\xC2\xC4\xC6\xC8\xCA\xCC\xCE\xD0\xD2");
		sb.Append("\xD4\xD6\xD8\xDA\xDC\xDE\xE0\xE2\xE4\xE6\xE8\xEA\xEC\xEE\xF0");
		sb.Append("\xF2\xF4\xF6\xF8\xFA\xFC\xFE\x100\x102\x104\x106\x108\x10A\x10C");
		sb.Append("\x10E\x110\x112\x114\x116\x118\x11A\x11C\x11E\x120\x122\x124");
		sb.Append("\x126\x128\x12A\x12C\x12E\x130\x132\x134\x136\x138\x13A\x13C");
		sb.Append("\x13E\x140\x142\x144\x146\x148\x14A\x14C\x14E\x150\x152\x154");
		sb.Append("\x156\x158\x15A\x15C\x15E\x160\x162\x164\x166\x168\x16A\x16C");
		sb.Append("\x16E\x170\x172\x174\x176\x178\x17A\x17C\x17E\x180\x182\x184");
		sb.Append("\x186\x188\x18A\x18C\x18E\x190\x192\x194\x196\x198\x19A\x19C");
		sb.Append("\x19E\x1A0\x1A2\x1A4\x1A6\x1A8\x1AA\x1AC\x1AE\x1B0\x1B2\x1B4");
		sb.Append("\x1B6\x1B8\x1BA\x1BC\x1BE\x1C0\x1C2\x1C4\x1C6\x1C8\x1CA\x1CC");
		sb.Append("\x1CE\x1D0\x1D2\x1D4\x1D6\x1D8\x1DA\x1DC\x1DE\x1E0\x1E2\x1E4");
		sb.Append("\x1E6\x1E8\x1EA\x1EC\x1EE\x1F0\x1F2\x1F4\x1F6\x1F8\x1FA\x1FC");
		sb.Append("\x1FE\x200\x202\x204\x206\x208\x20A\x20C\x20E\x210\x212\x214");
		sb.Append("\x216\x218\x21A\x21C\x21E\x220\x222\x224\x226\x228\x22A\x22C");
		sb.Append("\x22E\x230\x232\x234\x236\x238\x23A\x23C\x23E\x240\x242\x244");
		sb.Append("\x246\x248\x24A\x24C\x24E\x250\x252\x254\x256\x258\x25A\x25C");
		sb.Append("\x25E\x260\x262\x264\x266\x268\x26A\x26C\x2z\x4\x2$$\x84\x84");
		sb.Append("\x4\x2\x1AA\x1AA\x1AF\x1AF\x5\x2>>\x8A\x8A\x9E\x9E\x5\x2\'\'");
		sb.Append("\x12B\x12B\x169\x169\x6\x2\'\'\x14A\x14A\x1A9\x1A9\x1ED\x1ED");
		sb.Append("\x4\x2\x1A1\x1A1\x3D0\x3D0\x4\x2\x45\x45}}\x4\x2\xF\xF\x100");
		sb.Append("\x100\x5\x2))KK\xA1\xA1\x4\x2\x157\x157\x1C1\x1C1\x5\x2\x19A");
		sb.Append("\x19A\x211\x211\x217\x217\x4\x2\x131\x131\x16D\x16D\x4\x2\x112");
		sb.Append("\x112\x17B\x17B\x4\x2\x110\x110\x160\x160\x5\x2\x46\x46JJnn");
		sb.Append("\x5\x2\'\'\x13B\x13B\x155\x155\x5\x2\'\'\x137\x137\x271\x271");
		sb.Append("\x4\x2\x207\x207\x225\x225\x4\x2GGQQ\x5\x2\x159\x159\x1B8\x1B8");
		sb.Append("\x1EF\x1EF\x4\x2>>\x8A\x8A\x3\x2\x116\x117\x3\x2\x3C6\x3C7\x4");
		sb.Append("\x2\x3D0\x3D0\x3D8\x3D8\x5\x2\x154\x154\x176\x176\x1A7\x1A7");
		sb.Append("\x4\x2\'\'\x3C6\x3C7\b\x2\'\'\x121\x121\x123\x123\x13B\x13B");
		sb.Append("\x155\x155\x1CE\x1CE\x3\x2\x3C7\x3C8\x4\x2\a\a//\x4\x2\r\r\x98");
		sb.Append("\x98\x4\x2\xA9\xA9\x228\x228\x4\x2\x14\x14\x7F\x7F\x5\x2((\x43");
		sb.Append("\x43^^\x4\x2^^\x125\x125\x4\x2\x11D\x11D\x151\x151\x4\x2ZZ\x1E5");
		sb.Append("\x1E5\x4\x2((^^\x4\x2\b\b--\x4\x2\xA5\xA5\x222\x222\x6\x2\x154");
		sb.Append("\x154\x176\x176\x1A6\x1A6\x1C4\x1C4\x4\x2\x154\x154\x1A6\x1A6");
		sb.Append("\x4\x2\xE\xE**\x5\x2;;\x45\x45\xA3\xA3\x4\x2!!II\x4\x2VV\x82");
		sb.Append("\x82\x4\x2\b\b-.\x3\x2\x1FC\x1FD\x4\x2\x15C\x15C\x1EB\x1EB\x4");
		sb.Append("\x2\xC3\xC3\x17E\x17E\a\x2__\x183\x184\x186\x186\x18A\x192\x1D0");
		sb.Append("\x1D0\x6\x2\x180\x181\x185\x185\x187\x188\x1D1\x1D1\x5\x2``");
		sb.Append("\x17F\x17F\x189\x189\x4\x2\x16F\x16F\x1FE\x1FE\x4\x2\x1F8\x1F8");
		sb.Append("\x1FA\x1FA\x4\x2\x10A\x10A\x1FF\x1FF\x4\x2PP\x1DF\x1DF\x4\x2");
		sb.Append("//\x12F\x12F\x5\x2\x1E\x1E\x36\x36\x9C\x9C\x5\x2ss\x95\x95\x15A");
		sb.Append("\x15A\x4\x2\\\\\x9F\x9F\x4\x2\x119\x119\x1F0\x1F0\x4\x2%%\x224");
		sb.Append("\x224\x4\x2\x66\x66\x17B\x17B\x4\x2\x14D\x14D\x1CA\x1CA\x6\x2");
		sb.Append("\xB1\xB1\xB3\xB3\xB7\xB7\x208\x208\x4\x2\x3A7\x3A7\x3B8\x3B8");
		sb.Append("\x4\x2\x10B\x10B\x1D2\x1D2\x4\x2==\x46\x46\b\x2ss\x95\x95\x9A");
		sb.Append("\x9A\x146\x146\x15A\x15A\x224\x224\x4\x2\x1A0\x1A0\x204\x204");
		sb.Append("\x4\x2\x143\x143\x227\x227\x4\x2ss\x15A\x15A\x5\x2GGRR\x167");
		sb.Append("\x167\x5\x2\x15C\x15C\x17B\x17B\x1EB\x1EB\x4\x2\x204\x204\x223");
		sb.Append("\x223\x4\x2\x126\x126\x1C9\x1C9\b\x2\xC3\xC3\x140\x140\x142");
		sb.Append("\x142\x15B\x15B\x1CF\x1CF\x1F1\x1F1\x4\x2*+\x37\x37\x5\x2\x14D");
		sb.Append("\x14D\x1BA\x1BA\x2CC\x2CC\x4\x2\x173\x173\x213\x213\x5\x2\x3D0");
		sb.Append("\x3D0\x3D8\x3D8\x3DA\x3DA\x3\x2\x3DB\x3DC\x5\x2\x26C\x277\x3D0");
		sb.Append("\x3D0\x3D9\x3D9\x4\x2\x3C6\x3C8\x3D1\x3D1\x4\x2\x38\x38\x9B");
		sb.Append("\x9B\x4\x2gg\x3D4\x3D4\x5\x2\xBF\xC1\xC9\xCC\x1A4\x1A4\x4\x2");
		sb.Append("\x18\x18\xC0\xC0\x4\x2\x18\x18\xBF\xBF\x3\x2\xAD\xB2\x4\x2\xA0");
		sb.Append("\xA0\x1EE\x1EE\x4\x2\xB6\xB9\x155\x155\x6\x2\xBA\xBA\xC5\xC8");
		sb.Append("\xCF\xCF\x10E\x10F\x5\x2\xBB\xBE\xC3\xC4\x10C\x10C\x4\x2\x87");
		sb.Append("\x87\xCD\xCD\x4\x2\x173\x173\x27C\x284\x4\x2\xC3\xC3\x1A4\x1A4");
		sb.Append("\x4\x2\xBA\xBB\xBD\xBD\x4\x2\xED\xEE\xF4\xF4\x4\x2\"\"\xEB\xEE");
		sb.Append("\x3\x2\xF7\xF8\x5\x2\x11\x11TT\x99\x99\x4\x2\xBF\xBF\xC3\xC3");
		sb.Append("\x5\x2\xE\xE**\x338\x338\x5\x2\xDB\xDB\xE1\xE2\xE7\xE7\x5\x2");
		sb.Append("\xDC\xDE\xE3\xE6\xE8\xEA\x4\x2\x1AD\x1AD\x1BB\x1BB\x4\x2\x65");
		sb.Append("\x65\x3BB\x3BB\x5\x2\x38\x38\x9B\x9B\x21B\x21B\x4\x2yy\x83\x83");
		sb.Append("\x5\x2\b\b\x103\x103\x1F4\x1F4\x6\x2\x65\x65\x3B3\x3B3\x3B5");
		sb.Append("\x3B5\x3BB\x3BC\x3\x2\x3B0\x3B7\x3\x2\x244\x26B\x3\x2\x278\x27B");
		sb.Append("\x3\x2\x23B\x243\x3\x2\x233\x23A\x5\x2\xBA\xBE\xCA\xCA\xCD\xCD");
		sb.Append("\b\x2\xCF\xCF\xFE\x206\x208\x224\x226\x22D\x232\x232\x271\x271");
		sb.Append("\f\x2$$VV\x82\x82\xBA\xBC\xBE\xBE\xDF\xDF\xF6\xF6\x233\x23A");
		sb.Append("\x27C\x27C\x27F\x3A6\x1C49\x2\x26F\x3\x2\x2\x2\x4\x280\x3\x2");
		sb.Append("\x2\x2\x6\x294\x3\x2\x2\x2\b\x296\x3\x2\x2\x2\n\x2BB\x3\x2\x2");
		sb.Append("\x2\f\x2C7\x3\x2\x2\x2\xE\x2D2\x3\x2\x2\x2\x10\x2E3\x3\x2\x2");
		sb.Append("\x2\x12\x2E8\x3\x2\x2\x2\x14\x2F4\x3\x2\x2\x2\x16\x30F\x3\x2");
		sb.Append("\x2\x2\x18\x315\x3\x2\x2\x2\x1A\x317\x3\x2\x2\x2\x1C\x323\x3");
		sb.Append("\x2\x2\x2\x1E\x341\x3\x2\x2\x2 \x365\x3\x2\x2\x2\"\x398\x3\x2");
		sb.Append("\x2\x2$\x3B2\x3\x2\x2\x2&\x3CE\x3\x2\x2\x2(\x42F\x3\x2\x2\x2");
		sb.Append("*\x431\x3\x2\x2\x2,\x443\x3\x2\x2\x2.\x480\x3\x2\x2\x2\x30\x493");
		sb.Append("\x3\x2\x2\x2\x32\x4CB\x3\x2\x2\x2\x34\x4CD\x3\x2\x2\x2\x36\x4F9");
		sb.Append("\x3\x2\x2\x2\x38\x4FF\x3\x2\x2\x2:\x501\x3\x2\x2\x2<\x516\x3");
		sb.Append("\x2\x2\x2>\x51D\x3\x2\x2\x2@\x51F\x3\x2\x2\x2\x42\x52D\x3\x2");
		sb.Append("\x2\x2\x44\x530\x3\x2\x2\x2\x46\x535\x3\x2\x2\x2H\x54F\x3\x2");
		sb.Append("\x2\x2J\x55F\x3\x2\x2\x2L\x561\x3\x2\x2\x2N\x571\x3\x2\x2\x2");
		sb.Append("P\x573\x3\x2\x2\x2R\x5A2\x3\x2\x2\x2T\x5E9\x3\x2\x2\x2V\x5EB");
		sb.Append("\x3\x2\x2\x2X\x607\x3\x2\x2\x2Z\x60F\x3\x2\x2\x2\\\x62D\x3\x2");
		sb.Append("\x2\x2^\x6BC\x3\x2\x2\x2`\x6BE\x3\x2\x2\x2\x62\x6C1\x3\x2\x2");
		sb.Append("\x2\x64\x70B\x3\x2\x2\x2\x66\x722\x3\x2\x2\x2h\x7A7\x3\x2\x2");
		sb.Append("\x2j\x7AC\x3\x2\x2\x2l\x7AE\x3\x2\x2\x2n\x7B8\x3\x2\x2\x2p\x7ED");
		sb.Append("\x3\x2\x2\x2r\x801\x3\x2\x2\x2t\x803\x3\x2\x2\x2v\x826\x3\x2");
		sb.Append("\x2\x2x\x82F\x3\x2\x2\x2z\x836\x3\x2\x2\x2|\x84D\x3\x2\x2\x2");
		sb.Append("~\x856\x3\x2\x2\x2\x80\x865\x3\x2\x2\x2\x82\x87B\x3\x2\x2\x2");
		sb.Append("\x84\x88F\x3\x2\x2\x2\x86\xA12\x3\x2\x2\x2\x88\xA14\x3\x2\x2");
		sb.Append("\x2\x8A\xA1B\x3\x2\x2\x2\x8C\xA22\x3\x2\x2\x2\x8E\xA39\x3\x2");
		sb.Append("\x2\x2\x90\xA41\x3\x2\x2\x2\x92\xA48\x3\x2\x2\x2\x94\xA4F\x3");
		sb.Append("\x2\x2\x2\x96\xA56\x3\x2\x2\x2\x98\xA62\x3\x2\x2\x2\x9A\xA6C");
		sb.Append("\x3\x2\x2\x2\x9C\xA73\x3\x2\x2\x2\x9E\xA83\x3\x2\x2\x2\xA0\xA8D");
		sb.Append("\x3\x2\x2\x2\xA2\xA91\x3\x2\x2\x2\xA4\xA97\x3\x2\x2\x2\xA6\xAA3");
		sb.Append("\x3\x2\x2\x2\xA8\xAA5\x3\x2\x2\x2\xAA\xAAC\x3\x2\x2\x2\xAC\xAAE");
		sb.Append("\x3\x2\x2\x2\xAE\xAE0\x3\x2\x2\x2\xB0\xB2A\x3\x2\x2\x2\xB2\xB65");
		sb.Append("\x3\x2\x2\x2\xB4\xBBD\x3\x2\x2\x2\xB6\xBC1\x3\x2\x2\x2\xB8\xBD2");
		sb.Append("\x3\x2\x2\x2\xBA\xBD4\x3\x2\x2\x2\xBC\xBDC\x3\x2\x2\x2\xBE\xBE4");
		sb.Append("\x3\x2\x2\x2\xC0\xBE6\x3\x2\x2\x2\xC2\xC04\x3\x2\x2\x2\xC4\xC3B");
		sb.Append("\x3\x2\x2\x2\xC6\xC44\x3\x2\x2\x2\xC8\xC58\x3\x2\x2\x2\xCA\xC64");
		sb.Append("\x3\x2\x2\x2\xCC\xC68\x3\x2\x2\x2\xCE\xC89\x3\x2\x2\x2\xD0\xC9E");
		sb.Append("\x3\x2\x2\x2\xD2\xCA8\x3\x2\x2\x2\xD4\xCAC\x3\x2\x2\x2\xD6\xCC5");
		sb.Append("\x3\x2\x2\x2\xD8\xCEF\x3\x2\x2\x2\xDA\xCF1\x3\x2\x2\x2\xDC\xD00");
		sb.Append("\x3\x2\x2\x2\xDE\xD2E\x3\x2\x2\x2\xE0\xD38\x3\x2\x2\x2\xE2\xD42");
		sb.Append("\x3\x2\x2\x2\xE4\xD6C\x3\x2\x2\x2\xE6\xD6E\x3\x2\x2\x2\xE8\xD7F");
		sb.Append("\x3\x2\x2\x2\xEA\xD85\x3\x2\x2\x2\xEC\xD95\x3\x2\x2\x2\xEE\xD99");
		sb.Append("\x3\x2\x2\x2\xF0\xDBF\x3\x2\x2\x2\xF2\xDE5\x3\x2\x2\x2\xF4\xDF3");
		sb.Append("\x3\x2\x2\x2\xF6\xDFB\x3\x2\x2\x2\xF8\xDFD\x3\x2\x2\x2\xFA\xE17");
		sb.Append("\x3\x2\x2\x2\xFC\xE1B\x3\x2\x2\x2\xFE\xE2A\x3\x2\x2\x2\x100");
		sb.Append("\xE2C\x3\x2\x2\x2\x102\xE38\x3\x2\x2\x2\x104\xE3C\x3\x2\x2\x2");
		sb.Append("\x106\xE4D\x3\x2\x2\x2\x108\xE5E\x3\x2\x2\x2\x10A\xE61\x3\x2");
		sb.Append("\x2\x2\x10C\xE6B\x3\x2\x2\x2\x10E\xE6F\x3\x2\x2\x2\x110\xE79");
		sb.Append("\x3\x2\x2\x2\x112\xE7C\x3\x2\x2\x2\x114\xE81\x3\x2\x2\x2\x116");
		sb.Append("\xE95\x3\x2\x2\x2\x118\xE97\x3\x2\x2\x2\x11A\xEA8\x3\x2\x2\x2");
		sb.Append("\x11C\xEB1\x3\x2\x2\x2\x11E\xEBA\x3\x2\x2\x2\x120\xEBC\x3\x2");
		sb.Append("\x2\x2\x122\xECA\x3\x2\x2\x2\x124\xED5\x3\x2\x2\x2\x126\xEDE");
		sb.Append("\x3\x2\x2\x2\x128\xEE1\x3\x2\x2\x2\x12A\xEE9\x3\x2\x2\x2\x12C");
		sb.Append("\xF02\x3\x2\x2\x2\x12E\xF0E\x3\x2\x2\x2\x130\xF11\x3\x2\x2\x2");
		sb.Append("\x132\xF31\x3\x2\x2\x2\x134\xF33\x3\x2\x2\x2\x136\xF35\x3\x2");
		sb.Append("\x2\x2\x138\xF37\x3\x2\x2\x2\x13A\xF39\x3\x2\x2\x2\x13C\xF6E");
		sb.Append("\x3\x2\x2\x2\x13E\xF70\x3\x2\x2\x2\x140\xF76\x3\x2\x2\x2\x142");
		sb.Append("\xF8A\x3\x2\x2\x2\x144\xF98\x3\x2\x2\x2\x146\xFA3\x3\x2\x2\x2");
		sb.Append("\x148\xFA5\x3\x2\x2\x2\x14A\xFAB\x3\x2\x2\x2\x14C\xFB5\x3\x2");
		sb.Append("\x2\x2\x14E\xFB9\x3\x2\x2\x2\x150\xFC0\x3\x2\x2\x2\x152\xFC4");
		sb.Append("\x3\x2\x2\x2\x154\xFCA\x3\x2\x2\x2\x156\xFD1\x3\x2\x2\x2\x158");
		sb.Append("\xFD7\x3\x2\x2\x2\x15A\xFDD\x3\x2\x2\x2\x15C\xFE2\x3\x2\x2\x2");
		sb.Append("\x15E\x1011\x3\x2\x2\x2\x160\x1026\x3\x2\x2\x2\x162\x103F\x3");
		sb.Append("\x2\x2\x2\x164\x1042\x3\x2\x2\x2\x166\x1048\x3\x2\x2\x2\x168");
		sb.Append("\x1058\x3\x2\x2\x2\x16A\x1067\x3\x2\x2\x2\x16C\x106D\x3\x2\x2");
		sb.Append("\x2\x16E\x108B\x3\x2\x2\x2\x170\x108D\x3\x2\x2\x2\x172\x1094");
		sb.Append("\x3\x2\x2\x2\x174\x10A0\x3\x2\x2\x2\x176\x10A6\x3\x2\x2\x2\x178");
		sb.Append("\x10BF\x3\x2\x2\x2\x17A\x10C3\x3\x2\x2\x2\x17C\x10C7\x3\x2\x2");
		sb.Append("\x2\x17E\x10D2\x3\x2\x2\x2\x180\x1110\x3\x2\x2\x2\x182\x1148");
		sb.Append("\x3\x2\x2\x2\x184\x114A\x3\x2\x2\x2\x186\x1157\x3\x2\x2\x2\x188");
		sb.Append("\x1189\x3\x2\x2\x2\x18A\x119B\x3\x2\x2\x2\x18C\x11CD\x3\x2\x2");
		sb.Append("\x2\x18E\x11CF\x3\x2\x2\x2\x190\x11DC\x3\x2\x2\x2\x192\x11E7");
		sb.Append("\x3\x2\x2\x2\x194\x1202\x3\x2\x2\x2\x196\x120C\x3\x2\x2\x2\x198");
		sb.Append("\x1216\x3\x2\x2\x2\x19A\x1218\x3\x2\x2\x2\x19C\x1222\x3\x2\x2");
		sb.Append("\x2\x19E\x1225\x3\x2\x2\x2\x1A0\x1256\x3\x2\x2\x2\x1A2\x1265");
		sb.Append("\x3\x2\x2\x2\x1A4\x1267\x3\x2\x2\x2\x1A6\x126B\x3\x2\x2\x2\x1A8");
		sb.Append("\x1272\x3\x2\x2\x2\x1AA\x127B\x3\x2\x2\x2\x1AC\x1281\x3\x2\x2");
		sb.Append("\x2\x1AE\x1288\x3\x2\x2\x2\x1B0\x129E\x3\x2\x2\x2\x1B2\x12A0");
		sb.Append("\x3\x2\x2\x2\x1B4\x12AB\x3\x2\x2\x2\x1B6\x12B1\x3\x2\x2\x2\x1B8");
		sb.Append("\x12DF\x3\x2\x2\x2\x1BA\x1378\x3\x2\x2\x2\x1BC\x1384\x3\x2\x2");
		sb.Append("\x2\x1BE\x1393\x3\x2\x2\x2\x1C0\x1399\x3\x2\x2\x2\x1C2\x13AC");
		sb.Append("\x3\x2\x2\x2\x1C4\x13B6\x3\x2\x2\x2\x1C6\x13C4\x3\x2\x2\x2\x1C8");
		sb.Append("\x13C6\x3\x2\x2\x2\x1CA\x13C9\x3\x2\x2\x2\x1CC\x13DF\x3\x2\x2");
		sb.Append("\x2\x1CE\x13EB\x3\x2\x2\x2\x1D0\x13F4\x3\x2\x2\x2\x1D2\x1400");
		sb.Append("\x3\x2\x2\x2\x1D4\x1404\x3\x2\x2\x2\x1D6\x1406\x3\x2\x2\x2\x1D8");
		sb.Append("\x142E\x3\x2\x2\x2\x1DA\x1435\x3\x2\x2\x2\x1DC\x1437\x3\x2\x2");
		sb.Append("\x2\x1DE\x144E\x3\x2\x2\x2\x1E0\x1454\x3\x2\x2\x2\x1E2\x145C");
		sb.Append("\x3\x2\x2\x2\x1E4\x145F\x3\x2\x2\x2\x1E6\x146C\x3\x2\x2\x2\x1E8");
		sb.Append("\x146E\x3\x2\x2\x2\x1EA\x1474\x3\x2\x2\x2\x1EC\x1476\x3\x2\x2");
		sb.Append("\x2\x1EE\x147F\x3\x2\x2\x2\x1F0\x148A\x3\x2\x2\x2\x1F2\x148C");
		sb.Append("\x3\x2\x2\x2\x1F4\x1492\x3\x2\x2\x2\x1F6\x1496\x3\x2\x2\x2\x1F8");
		sb.Append("\x1498\x3\x2\x2\x2\x1FA\x149A\x3\x2\x2\x2\x1FC\x14AC\x3\x2\x2");
		sb.Append("\x2\x1FE\x14BC\x3\x2\x2\x2\x200\x14C0\x3\x2\x2\x2\x202\x14C5");
		sb.Append("\x3\x2\x2\x2\x204\x14D0\x3\x2\x2\x2\x206\x14D5\x3\x2\x2\x2\x208");
		sb.Append("\x14D7\x3\x2\x2\x2\x20A\x14DB\x3\x2\x2\x2\x20C\x14F4\x3\x2\x2");
		sb.Append("\x2\x20E\x14F6\x3\x2\x2\x2\x210\x14F9\x3\x2\x2\x2\x212\x14FE");
		sb.Append("\x3\x2\x2\x2\x214\x150E\x3\x2\x2\x2\x216\x157A\x3\x2\x2\x2\x218");
		sb.Append("\x157C\x3\x2\x2\x2\x21A\x15A0\x3\x2\x2\x2\x21C\x15A2\x3\x2\x2");
		sb.Append("\x2\x21E\x15A6\x3\x2\x2\x2\x220\x15AC\x3\x2\x2\x2\x222\x15B4");
		sb.Append("\x3\x2\x2\x2\x224\x15BC\x3\x2\x2\x2\x226\x15C4\x3\x2\x2\x2\x228");
		sb.Append("\x15CF\x3\x2\x2\x2\x22A\x15D7\x3\x2\x2\x2\x22C\x15DF\x3\x2\x2");
		sb.Append("\x2\x22E\x15E7\x3\x2\x2\x2\x230\x15EF\x3\x2\x2\x2\x232\x1602");
		sb.Append("\x3\x2\x2\x2\x234\x1612\x3\x2\x2\x2\x236\x1616\x3\x2\x2\x2\x238");
		sb.Append("\x1618\x3\x2\x2\x2\x23A\x161B\x3\x2\x2\x2\x23C\x1630\x3\x2\x2");
		sb.Append("\x2\x23E\x16CF\x3\x2\x2\x2\x240\x16D1\x3\x2\x2\x2\x242\x16E4");
		sb.Append("\x3\x2\x2\x2\x244\x16E6\x3\x2\x2\x2\x246\x1722\x3\x2\x2\x2\x248");
		sb.Append("\x173B\x3\x2\x2\x2\x24A\x173D\x3\x2\x2\x2\x24C\x1746\x3\x2\x2");
		sb.Append("\x2\x24E\x1758\x3\x2\x2\x2\x250\x1765\x3\x2\x2\x2\x252\x1770");
		sb.Append("\x3\x2\x2\x2\x254\x17E0\x3\x2\x2\x2\x256\x17F2\x3\x2\x2\x2\x258");
		sb.Append("\x1802\x3\x2\x2\x2\x25A\x180B\x3\x2\x2\x2\x25C\x1814\x3\x2\x2");
		sb.Append("\x2\x25E\x1816\x3\x2\x2\x2\x260\x1818\x3\x2\x2\x2\x262\x181A");
		sb.Append("\x3\x2\x2\x2\x264\x181C\x3\x2\x2\x2\x266\x181E\x3\x2\x2\x2\x268");
		sb.Append("\x1820\x3\x2\x2\x2\x26A\x1822\x3\x2\x2\x2\x26C\x1824\x3\x2\x2");
		sb.Append("\x2\x26E\x270\x5\x4\x3\x2\x26F\x26E\x3\x2\x2\x2\x26F\x270\x3");
		sb.Append("\x2\x2\x2\x270\x272\x3\x2\x2\x2\x271\x273\a\x3B4\x2\x2\x272");
		sb.Append("\x271\x3\x2\x2\x2\x272\x273\x3\x2\x2\x2\x273\x274\x3\x2\x2\x2");
		sb.Append("\x274\x275\a\x2\x2\x3\x275\x3\x3\x2\x2\x2\x276\x278\x5\x6\x4");
		sb.Append("\x2\x277\x279\a\x3B4\x2\x2\x278\x277\x3\x2\x2\x2\x278\x279\x3");
		sb.Append("\x2\x2\x2\x279\x27B\x3\x2\x2\x2\x27A\x27C\a\x3C4\x2\x2\x27B");
		sb.Append("\x27A\x3\x2\x2\x2\x27B\x27C\x3\x2\x2\x2\x27C\x27F\x3\x2\x2\x2");
		sb.Append("\x27D\x27F\x5\b\x5\x2\x27E\x276\x3\x2\x2\x2\x27E\x27D\x3\x2");
		sb.Append("\x2\x2\x27F\x282\x3\x2\x2\x2\x280\x27E\x3\x2\x2\x2\x280\x281");
		sb.Append("\x3\x2\x2\x2\x281\x28B\x3\x2\x2\x2\x282\x280\x3\x2\x2\x2\x283");
		sb.Append("\x288\x5\x6\x4\x2\x284\x286\a\x3B4\x2\x2\x285\x284\x3\x2\x2");
		sb.Append("\x2\x285\x286\x3\x2\x2\x2\x286\x287\x3\x2\x2\x2\x287\x289\a");
		sb.Append("\x3C4\x2\x2\x288\x285\x3\x2\x2\x2\x288\x289\x3\x2\x2\x2\x289");
		sb.Append("\x28C\x3\x2\x2\x2\x28A\x28C\x5\b\x5\x2\x28B\x283\x3\x2\x2\x2");
		sb.Append("\x28B\x28A\x3\x2\x2\x2\x28C\x5\x3\x2\x2\x2\x28D\x295\x5\n\x6");
		sb.Append("\x2\x28E\x295\x5\f\a\x2\x28F\x295\x5\xE\b\x2\x290\x295\x5\x10");
		sb.Append("\t\x2\x291\x295\x5\x12\n\x2\x292\x295\x5\x16\f\x2\x293\x295");
		sb.Append("\x5\x18\r\x2\x294\x28D\x3\x2\x2\x2\x294\x28E\x3\x2\x2\x2\x294");
		sb.Append("\x28F\x3\x2\x2\x2\x294\x290\x3\x2\x2\x2\x294\x291\x3\x2\x2\x2");
		sb.Append("\x294\x292\x3\x2\x2\x2\x294\x293\x3\x2\x2\x2\x295\a\x3\x2\x2");
		sb.Append("\x2\x296\x297\a\x3C4\x2\x2\x297\t\x3\x2\x2\x2\x298\x2BC\x5\x1A");
		sb.Append("\xE\x2\x299\x2BC\x5\x1C\xF\x2\x29A\x2BC\x5\x1E\x10\x2\x29B\x2BC");
		sb.Append("\x5 \x11\x2\x29C\x2BC\x5\"\x12\x2\x29D\x2BC\x5$\x13\x2\x29E");
		sb.Append("\x2BC\x5&\x14\x2\x29F\x2BC\x5(\x15\x2\x2A0\x2BC\x5*\x16\x2\x2A1");
		sb.Append("\x2BC\x5,\x17\x2\x2A2\x2BC\x5.\x18\x2\x2A3\x2BC\x5\x30\x19\x2");
		sb.Append("\x2A4\x2BC\x5r:\x2\x2A5\x2BC\x5t;\x2\x2A6\x2BC\x5v<\x2\x2A7");
		sb.Append("\x2BC\x5x=\x2\x2A8\x2BC\x5z>\x2\x2A9\x2BC\x5|?\x2\x2AA\x2BC");
		sb.Append("\x5~@\x2\x2AB\x2BC\x5\x80\x41\x2\x2AC\x2BC\x5\x82\x42\x2\x2AD");
		sb.Append("\x2BC\x5\x84\x43\x2\x2AE\x2BC\x5\x88\x45\x2\x2AF\x2BC\x5\x8A");
		sb.Append("\x46\x2\x2B0\x2BC\x5\x8CG\x2\x2B1\x2BC\x5\x8EH\x2\x2B2\x2BC");
		sb.Append("\x5\x90I\x2\x2B3\x2BC\x5\x92J\x2\x2B4\x2BC\x5\x94K\x2\x2B5\x2BC");
		sb.Append("\x5\x96L\x2\x2B6\x2BC\x5\x98M\x2\x2B7\x2BC\x5\x9AN\x2\x2B8\x2BC");
		sb.Append("\x5\x9CO\x2\x2B9\x2BC\x5\x9EP\x2\x2BA\x2BC\x5\xA2R\x2\x2BB\x298");
		sb.Append("\x3\x2\x2\x2\x2BB\x299\x3\x2\x2\x2\x2BB\x29A\x3\x2\x2\x2\x2BB");
		sb.Append("\x29B\x3\x2\x2\x2\x2BB\x29C\x3\x2\x2\x2\x2BB\x29D\x3\x2\x2\x2");
		sb.Append("\x2BB\x29E\x3\x2\x2\x2\x2BB\x29F\x3\x2\x2\x2\x2BB\x2A0\x3\x2");
		sb.Append("\x2\x2\x2BB\x2A1\x3\x2\x2\x2\x2BB\x2A2\x3\x2\x2\x2\x2BB\x2A3");
		sb.Append("\x3\x2\x2\x2\x2BB\x2A4\x3\x2\x2\x2\x2BB\x2A5\x3\x2\x2\x2\x2BB");
		sb.Append("\x2A6\x3\x2\x2\x2\x2BB\x2A7\x3\x2\x2\x2\x2BB\x2A8\x3\x2\x2\x2");
		sb.Append("\x2BB\x2A9\x3\x2\x2\x2\x2BB\x2AA\x3\x2\x2\x2\x2BB\x2AB\x3\x2");
		sb.Append("\x2\x2\x2BB\x2AC\x3\x2\x2\x2\x2BB\x2AD\x3\x2\x2\x2\x2BB\x2AE");
		sb.Append("\x3\x2\x2\x2\x2BB\x2AF\x3\x2\x2\x2\x2BB\x2B0\x3\x2\x2\x2\x2BB");
		sb.Append("\x2B1\x3\x2\x2\x2\x2BB\x2B2\x3\x2\x2\x2\x2BB\x2B3\x3\x2\x2\x2");
		sb.Append("\x2BB\x2B4\x3\x2\x2\x2\x2BB\x2B5\x3\x2\x2\x2\x2BB\x2B6\x3\x2");
		sb.Append("\x2\x2\x2BB\x2B7\x3\x2\x2\x2\x2BB\x2B8\x3\x2\x2\x2\x2BB\x2B9");
		sb.Append("\x3\x2\x2\x2\x2BB\x2BA\x3\x2\x2\x2\x2BC\v\x3\x2\x2\x2\x2BD\x2C8");
		sb.Append("\x5\xB4[\x2\x2BE\x2C8\x5\xACW\x2\x2BF\x2C8\x5\xB6\\\x2\x2C0");
		sb.Append("\x2C8\x5\xA6T\x2\x2C1\x2C8\x5\xB2Z\x2\x2C2\x2C8\x5\xA4S\x2\x2C3");
		sb.Append("\x2C8\x5\xAEX\x2\x2C4\x2C8\x5\xB0Y\x2\x2C5\x2C8\x5\xA8U\x2\x2C6");
		sb.Append("\x2C8\x5\xAAV\x2\x2C7\x2BD\x3\x2\x2\x2\x2C7\x2BE\x3\x2\x2\x2");
		sb.Append("\x2C7\x2BF\x3\x2\x2\x2\x2C7\x2C0\x3\x2\x2\x2\x2C7\x2C1\x3\x2");
		sb.Append("\x2\x2\x2C7\x2C2\x3\x2\x2\x2\x2C7\x2C3\x3\x2\x2\x2\x2C7\x2C4");
		sb.Append("\x3\x2\x2\x2\x2C7\x2C5\x3\x2\x2\x2\x2C7\x2C6\x3\x2\x2\x2\x2C8");
		sb.Append("\r\x3\x2\x2\x2\x2C9\x2D3\x5\x100\x81\x2\x2CA\x2D3\x5\x102\x82");
		sb.Append("\x2\x2CB\x2D3\x5\x104\x83\x2\x2CC\x2D3\x5\x106\x84\x2\x2CD\x2D3");
		sb.Append("\x5\x108\x85\x2\x2CE\x2D3\x5\x10A\x86\x2\x2CF\x2D3\x5\x10C\x87");
		sb.Append("\x2\x2D0\x2D3\x5\x10E\x88\x2\x2D1\x2D3\x5\x110\x89\x2\x2D2\x2C9");
		sb.Append("\x3\x2\x2\x2\x2D2\x2CA\x3\x2\x2\x2\x2D2\x2CB\x3\x2\x2\x2\x2D2");
		sb.Append("\x2CC\x3\x2\x2\x2\x2D2\x2CD\x3\x2\x2\x2\x2D2\x2CE\x3\x2\x2\x2");
		sb.Append("\x2D2\x2CF\x3\x2\x2\x2\x2D2\x2D0\x3\x2\x2\x2\x2D2\x2D1\x3\x2");
		sb.Append("\x2\x2\x2D3\xF\x3\x2\x2\x2\x2D4\x2E4\x5\x120\x91\x2\x2D5\x2E4");
		sb.Append("\x5\x122\x92\x2\x2D6\x2E4\x5\x124\x93\x2\x2D7\x2E4\x5\x126\x94");
		sb.Append("\x2\x2D8\x2E4\x5\x128\x95\x2\x2D9\x2E4\x5\x12A\x96\x2\x2DA\x2E4");
		sb.Append("\x5\x12C\x97\x2\x2DB\x2E4\x5\x12E\x98\x2\x2DC\x2E4\x5\x130\x99");
		sb.Append("\x2\x2DD\x2E4\x5\x148\xA5\x2\x2DE\x2E4\x5\x14A\xA6\x2\x2DF\x2E4");
		sb.Append("\x5\x14C\xA7\x2\x2E0\x2E4\x5\x14E\xA8\x2\x2E1\x2E4\x5\x150\xA9");
		sb.Append("\x2\x2E2\x2E4\x5\x152\xAA\x2\x2E3\x2D4\x3\x2\x2\x2\x2E3\x2D5");
		sb.Append("\x3\x2\x2\x2\x2E3\x2D6\x3\x2\x2\x2\x2E3\x2D7\x3\x2\x2\x2\x2E3");
		sb.Append("\x2D8\x3\x2\x2\x2\x2E3\x2D9\x3\x2\x2\x2\x2E3\x2DA\x3\x2\x2\x2");
		sb.Append("\x2E3\x2DB\x3\x2\x2\x2\x2E3\x2DC\x3\x2\x2\x2\x2E3\x2DD\x3\x2");
		sb.Append("\x2\x2\x2E3\x2DE\x3\x2\x2\x2\x2E3\x2DF\x3\x2\x2\x2\x2E3\x2E0");
		sb.Append("\x3\x2\x2\x2\x2E3\x2E1\x3\x2\x2\x2\x2E3\x2E2\x3\x2\x2\x2\x2E4");
		sb.Append("\x11\x3\x2\x2\x2\x2E5\x2E9\x5\x154\xAB\x2\x2E6\x2E9\x5\x156");
		sb.Append("\xAC\x2\x2E7\x2E9\x5\x158\xAD\x2\x2E8\x2E5\x3\x2\x2\x2\x2E8");
		sb.Append("\x2E6\x3\x2\x2\x2\x2E8\x2E7\x3\x2\x2\x2\x2E9\x13\x3\x2\x2\x2");
		sb.Append("\x2EA\x2F5\x5\x15C\xAF\x2\x2EB\x2F5\x5\x15E\xB0\x2\x2EC\x2F5");
		sb.Append("\x5\x160\xB1\x2\x2ED\x2F5\x5\x164\xB3\x2\x2EE\x2F5\x5\x166\xB4");
		sb.Append("\x2\x2EF\x2F5\x5\x168\xB5\x2\x2F0\x2F5\x5\x16C\xB7\x2\x2F1\x2F5");
		sb.Append("\x5\x162\xB2\x2\x2F2\x2F5\x5\x16A\xB6\x2\x2F3\x2F5\x5\x16E\xB8");
		sb.Append("\x2\x2F4\x2EA\x3\x2\x2\x2\x2F4\x2EB\x3\x2\x2\x2\x2F4\x2EC\x3");
		sb.Append("\x2\x2\x2\x2F4\x2ED\x3\x2\x2\x2\x2F4\x2EE\x3\x2\x2\x2\x2F4\x2EF");
		sb.Append("\x3\x2\x2\x2\x2F4\x2F0\x3\x2\x2\x2\x2F4\x2F1\x3\x2\x2\x2\x2F4");
		sb.Append("\x2F2\x3\x2\x2\x2\x2F4\x2F3\x3\x2\x2\x2\x2F5\x15\x3\x2\x2\x2");
		sb.Append("\x2F6\x310\x5\x180\xC1\x2\x2F7\x310\x5\x182\xC2\x2\x2F8\x310");
		sb.Append("\x5\x184\xC3\x2\x2F9\x310\x5\x186\xC4\x2\x2FA\x310\x5\x188\xC5");
		sb.Append("\x2\x2FB\x310\x5\x18A\xC6\x2\x2FC\x310\x5\x18C\xC7\x2\x2FD\x310");
		sb.Append("\x5\x18E\xC8\x2\x2FE\x310\x5\x1A6\xD4\x2\x2FF\x310\x5\x1A8\xD5");
		sb.Append("\x2\x300\x310\x5\x1AA\xD6\x2\x301\x310\x5\x1AC\xD7\x2\x302\x310");
		sb.Append("\x5\x1AE\xD8\x2\x303\x310\x5\x1B2\xDA\x2\x304\x310\x5\x1B4\xDB");
		sb.Append("\x2\x305\x310\x5\x1B6\xDC\x2\x306\x310\x5\x1B8\xDD\x2\x307\x310");
		sb.Append("\x5\x1BA\xDE\x2\x308\x310\x5\x1C8\xE5\x2\x309\x310\x5\x1CA\xE6");
		sb.Append("\x2\x30A\x310\x5\x1CC\xE7\x2\x30B\x310\x5\x1CE\xE8\x2\x30C\x310");
		sb.Append("\x5\x1D0\xE9\x2\x30D\x310\x5\x1D2\xEA\x2\x30E\x310\x5\x1D4\xEB");
		sb.Append("\x2\x30F\x2F6\x3\x2\x2\x2\x30F\x2F7\x3\x2\x2\x2\x30F\x2F8\x3");
		sb.Append("\x2\x2\x2\x30F\x2F9\x3\x2\x2\x2\x30F\x2FA\x3\x2\x2\x2\x30F\x2FB");
		sb.Append("\x3\x2\x2\x2\x30F\x2FC\x3\x2\x2\x2\x30F\x2FD\x3\x2\x2\x2\x30F");
		sb.Append("\x2FE\x3\x2\x2\x2\x30F\x2FF\x3\x2\x2\x2\x30F\x300\x3\x2\x2\x2");
		sb.Append("\x30F\x301\x3\x2\x2\x2\x30F\x302\x3\x2\x2\x2\x30F\x303\x3\x2");
		sb.Append("\x2\x2\x30F\x304\x3\x2\x2\x2\x30F\x305\x3\x2\x2\x2\x30F\x306");
		sb.Append("\x3\x2\x2\x2\x30F\x307\x3\x2\x2\x2\x30F\x308\x3\x2\x2\x2\x30F");
		sb.Append("\x309\x3\x2\x2\x2\x30F\x30A\x3\x2\x2\x2\x30F\x30B\x3\x2\x2\x2");
		sb.Append("\x30F\x30C\x3\x2\x2\x2\x30F\x30D\x3\x2\x2\x2\x30F\x30E\x3\x2");
		sb.Append("\x2\x2\x310\x17\x3\x2\x2\x2\x311\x316\x5\x1DE\xF0\x2\x312\x316");
		sb.Append("\x5\x1E0\xF1\x2\x313\x316\x5\x1E2\xF2\x2\x314\x316\x5\x1E4\xF3");
		sb.Append("\x2\x315\x311\x3\x2\x2\x2\x315\x312\x3\x2\x2\x2\x315\x313\x3");
		sb.Append("\x2\x2\x2\x315\x314\x3\x2\x2\x2\x316\x19\x3\x2\x2\x2\x317\x318");
		sb.Append("\a \x2\x2\x318\x31A\t\x2\x2\x2\x319\x31B\x5\x23A\x11E\x2\x31A");
		sb.Append("\x319\x3\x2\x2\x2\x31A\x31B\x3\x2\x2\x2\x31B\x31C\x3\x2\x2\x2");
		sb.Append("\x31C\x320\x5\x202\x102\x2\x31D\x31F\x5\x32\x1A\x2\x31E\x31D");
		sb.Append("\x3\x2\x2\x2\x31F\x322\x3\x2\x2\x2\x320\x31E\x3\x2\x2\x2\x320");
		sb.Append("\x321\x3\x2\x2\x2\x321\x1B\x3\x2\x2\x2\x322\x320\x3\x2\x2\x2");
		sb.Append("\x323\x325\a \x2\x2\x324\x326\x5\x34\x1B\x2\x325\x324\x3\x2");
		sb.Append("\x2\x2\x325\x326\x3\x2\x2\x2\x326\x327\x3\x2\x2\x2\x327\x329");
		sb.Append("\a\x146\x2\x2\x328\x32A\x5\x23A\x11E\x2\x329\x328\x3\x2\x2\x2");
		sb.Append("\x329\x32A\x3\x2\x2\x2\x32A\x32B\x3\x2\x2\x2\x32B\x32C\x5\x1E8");
		sb.Append("\xF5\x2\x32C\x32D\ah\x2\x2\x32D\x32E\a\x1E8\x2\x2\x32E\x335");
		sb.Append("\x5\x36\x1C\x2\x32F\x330\ah\x2\x2\x330\x332\a\x122\x2\x2\x331");
		sb.Append("\x333\a\x65\x2\x2\x332\x331\x3\x2\x2\x2\x332\x333\x3\x2\x2\x2");
		sb.Append("\x333\x334\x3\x2\x2\x2\x334\x336\a\x1C3\x2\x2\x335\x32F\x3\x2");
		sb.Append("\x2\x2\x335\x336\x3\x2\x2\x2\x336\x338\x3\x2\x2\x2\x337\x339");
		sb.Append("\x5> \x2\x338\x337\x3\x2\x2\x2\x338\x339\x3\x2\x2\x2\x339\x33C");
		sb.Append("\x3\x2\x2\x2\x33A\x33B\a\x11F\x2\x2\x33B\x33D\a\x3D0\x2\x2\x33C");
		sb.Append("\x33A\x3\x2\x2\x2\x33C\x33D\x3\x2\x2\x2\x33D\x33E\x3\x2\x2\x2");
		sb.Append("\x33E\x33F\a\x138\x2\x2\x33F\x340\x5\x15A\xAE\x2\x340\x1D\x3");
		sb.Append("\x2\x2\x2\x341\x343\a \x2\x2\x342\x344\t\x3\x2\x2\x343\x342");
		sb.Append("\x3\x2\x2\x2\x343\x344\x3\x2\x2\x2\x344\x346\x3\x2\x2\x2\x345");
		sb.Append("\x347\t\x4\x2\x2\x346\x345\x3\x2\x2\x2\x346\x347\x3\x2\x2\x2");
		sb.Append("\x347\x348\x3\x2\x2\x2\x348\x349\aG\x2\x2\x349\x34B\x5\x202");
		sb.Append("\x102\x2\x34A\x34C\x5@!\x2\x34B\x34A\x3\x2\x2\x2\x34B\x34C\x3");
		sb.Append("\x2\x2\x2\x34C\x34D\x3\x2\x2\x2\x34D\x34E\ah\x2\x2\x34E\x34F");
		sb.Append("\x5\x1EA\xF6\x2\x34F\x353\x5\x226\x114\x2\x350\x352\x5\x42\"");
		sb.Append("\x2\x351\x350\x3\x2\x2\x2\x352\x355\x3\x2\x2\x2\x353\x351\x3");
		sb.Append("\x2\x2\x2\x353\x354\x3\x2\x2\x2\x354\x362\x3\x2\x2\x2\x355\x353");
		sb.Append("\x3\x2\x2\x2\x356\x358\a\x102\x2\x2\x357\x359\a\x3B8\x2\x2\x358");
		sb.Append("\x357\x3\x2\x2\x2\x358\x359\x3\x2\x2\x2\x359\x35A\x3\x2\x2\x2");
		sb.Append("\x35A\x361\t\x5\x2\x2\x35B\x35D\a\\\x2\x2\x35C\x35E\a\x3B8\x2");
		sb.Append("\x2\x35D\x35C\x3\x2\x2\x2\x35D\x35E\x3\x2\x2\x2\x35E\x35F\x3");
		sb.Append("\x2\x2\x2\x35F\x361\t\x6\x2\x2\x360\x356\x3\x2\x2\x2\x360\x35B");
		sb.Append("\x3\x2\x2\x2\x361\x364\x3\x2\x2\x2\x362\x360\x3\x2\x2\x2\x362");
		sb.Append("\x363\x3\x2\x2\x2\x363\x1F\x3\x2\x2\x2\x364\x362\x3\x2\x2\x2");
		sb.Append("\x365\x366\a \x2\x2\x366\x367\a\x17C\x2\x2\x367\x368\a\x41\x2");
		sb.Append("\x2\x368\x369\x5\x202\x102\x2\x369\x36A\a\a\x2\x2\x36A\x36B");
		sb.Append("\a\x218\x2\x2\x36B\x371\a\x3D0\x2\x2\x36C\x36E\a\x168\x2\x2");
		sb.Append("\x36D\x36F\a\x3B8\x2\x2\x36E\x36D\x3\x2\x2\x2\x36E\x36F\x3\x2");
		sb.Append("\x2\x2\x36F\x370\x3\x2\x2\x2\x370\x372\x5\x20A\x106\x2\x371");
		sb.Append("\x36C\x3\x2\x2\x2\x371\x372\x3\x2\x2\x2\x372\x378\x3\x2\x2\x2");
		sb.Append("\x373\x375\a\x219\x2\x2\x374\x376\a\x3B8\x2\x2\x375\x374\x3");
		sb.Append("\x2\x2\x2\x375\x376\x3\x2\x2\x2\x376\x377\x3\x2\x2\x2\x377\x379");
		sb.Append("\x5\x20A\x106\x2\x378\x373\x3\x2\x2\x2\x378\x379\x3\x2\x2\x2");
		sb.Append("\x379\x37F\x3\x2\x2\x2\x37A\x37C\a\x1CD\x2\x2\x37B\x37D\a\x3B8");
		sb.Append("\x2\x2\x37C\x37B\x3\x2\x2\x2\x37C\x37D\x3\x2\x2\x2\x37D\x37E");
		sb.Append("\x3\x2\x2\x2\x37E\x380\x5\x20A\x106\x2\x37F\x37A\x3\x2\x2\x2");
		sb.Append("\x37F\x380\x3\x2\x2\x2\x380\x386\x3\x2\x2\x2\x381\x383\a\x1A8");
		sb.Append("\x2\x2\x382\x384\a\x3B8\x2\x2\x383\x382\x3\x2\x2\x2\x383\x384");
		sb.Append("\x3\x2\x2\x2\x384\x385\x3\x2\x2\x2\x385\x387\x5\x202\x102\x2");
		sb.Append("\x386\x381\x3\x2\x2\x2\x386\x387\x3\x2\x2\x2\x387\x389\x3\x2");
		sb.Append("\x2\x2\x388\x38A\a\x226\x2\x2\x389\x388\x3\x2\x2\x2\x389\x38A");
		sb.Append("\x3\x2\x2\x2\x38A\x390\x3\x2\x2\x2\x38B\x38D\a\x11F\x2\x2\x38C");
		sb.Append("\x38E\a\x3B8\x2\x2\x38D\x38C\x3\x2\x2\x2\x38D\x38E\x3\x2\x2");
		sb.Append("\x2\x38E\x38F\x3\x2\x2\x2\x38F\x391\a\x3D0\x2\x2\x390\x38B\x3");
		sb.Append("\x2\x2\x2\x390\x391\x3\x2\x2\x2\x391\x392\x3\x2\x2\x2\x392\x394");
		sb.Append("\a\x140\x2\x2\x393\x395\a\x3B8\x2\x2\x394\x393\x3\x2\x2\x2\x394");
		sb.Append("\x395\x3\x2\x2\x2\x395\x396\x3\x2\x2\x2\x396\x397\x5\x1F8\xFD");
		sb.Append("\x2\x397!\x3\x2\x2\x2\x398\x39A\a \x2\x2\x399\x39B\x5\x34\x1B");
		sb.Append("\x2\x39A\x399\x3\x2\x2\x2\x39A\x39B\x3\x2\x2\x2\x39B\x39C\x3");
		sb.Append("\x2\x2\x2\x39C\x39D\as\x2\x2\x39D\x39E\x5\x1E8\xF5\x2\x39E\x3A0");
		sb.Append("\a\x3C1\x2\x2\x39F\x3A1\x5\x44#\x2\x3A0\x39F\x3\x2\x2\x2\x3A0");
		sb.Append("\x3A1\x3\x2\x2\x2\x3A1\x3A6\x3\x2\x2\x2\x3A2\x3A3\a\x3C3\x2");
		sb.Append("\x2\x3A3\x3A5\x5\x44#\x2\x3A4\x3A2\x3\x2\x2\x2\x3A5\x3A8\x3");
		sb.Append("\x2\x2\x2\x3A6\x3A4\x3\x2\x2\x2\x3A6\x3A7\x3\x2\x2\x2\x3A7\x3A9");
		sb.Append("\x3\x2\x2\x2\x3A8\x3A6\x3\x2\x2\x2\x3A9\x3AD\a\x3C2\x2\x2\x3AA");
		sb.Append("\x3AC\x5H%\x2\x3AB\x3AA\x3\x2\x2\x2\x3AC\x3AF\x3\x2\x2\x2\x3AD");
		sb.Append("\x3AB\x3\x2\x2\x2\x3AD\x3AE\x3\x2\x2\x2\x3AE\x3B0\x3\x2\x2\x2");
		sb.Append("\x3AF\x3AD\x3\x2\x2\x2\x3B0\x3B1\x5\x15A\xAE\x2\x3B1#\x3\x2");
		sb.Append("\x2\x2\x3B2\x3B4\a \x2\x2\x3B3\x3B5\x5\x34\x1B\x2\x3B4\x3B3");
		sb.Append("\x3\x2\x2\x2\x3B4\x3B5\x3\x2\x2\x2\x3B5\x3B6\x3\x2\x2\x2\x3B6");
		sb.Append("\x3B7\a\x15A\x2\x2\x3B7\x3B8\x5\x1E8\xF5\x2\x3B8\x3BA\a\x3C1");
		sb.Append("\x2\x2\x3B9\x3BB\x5\x46$\x2\x3BA\x3B9\x3\x2\x2\x2\x3BA\x3BB");
		sb.Append("\x3\x2\x2\x2\x3BB\x3C0\x3\x2\x2\x2\x3BC\x3BD\a\x3C3\x2\x2\x3BD");
		sb.Append("\x3BF\x5\x46$\x2\x3BE\x3BC\x3\x2\x2\x2\x3BF\x3C2\x3\x2\x2\x2");
		sb.Append("\x3C0\x3BE\x3\x2\x2\x2\x3C0\x3C1\x3\x2\x2\x2\x3C1\x3C3\x3\x2");
		sb.Append("\x2\x2\x3C2\x3C0\x3\x2\x2\x2\x3C3\x3C4\a\x3C2\x2\x2\x3C4\x3C5");
		sb.Append("\a\x1E0\x2\x2\x3C5\x3C9\x5\x216\x10C\x2\x3C6\x3C8\x5H%\x2\x3C7");
		sb.Append("\x3C6\x3\x2\x2\x2\x3C8\x3CB\x3\x2\x2\x2\x3C9\x3C7\x3\x2\x2\x2");
		sb.Append("\x3C9\x3CA\x3\x2\x2\x2\x3CA\x3CC\x3\x2\x2\x2\x3CB\x3C9\x3\x2");
		sb.Append("\x2\x2\x3CC\x3CD\x5\x15A\xAE\x2\x3CD%\x3\x2\x2\x2\x3CE\x3CF");
		sb.Append("\a \x2\x2\x3CF\x3D0\a\x1EA\x2\x2\x3D0\x3D1\x5\x202\x102\x2\x3D1");
		sb.Append("\x3D2\a<\x2\x2\x3D2\x3D3\a\x12D\x2\x2\x3D3\x3D4\a\x22A\x2\x2");
		sb.Append("\x3D4\x3D5\t\a\x2\x2\x3D5\x3D6\a\x1B3\x2\x2\x3D6\x3D7\a\x3C1");
		sb.Append("\x2\x2\x3D7\x3DC\x5J&\x2\x3D8\x3D9\a\x3C3\x2\x2\x3D9\x3DB\x5");
		sb.Append("J&\x2\x3DA\x3D8\x3\x2\x2\x2\x3DB\x3DE\x3\x2\x2\x2\x3DC\x3DA");
		sb.Append("\x3\x2\x2\x2\x3DC\x3DD\x3\x2\x2\x2\x3DD\x3DF\x3\x2\x2\x2\x3DE");
		sb.Append("\x3DC\x3\x2\x2\x2\x3DF\x3E0\a\x3C2\x2\x2\x3E0\'\x3\x2\x2\x2");
		sb.Append("\x3E1\x3E3\a \x2\x2\x3E2\x3E4\a\x210\x2\x2\x3E3\x3E2\x3\x2\x2");
		sb.Append("\x2\x3E3\x3E4\x3\x2\x2\x2\x3E4\x3E5\x3\x2\x2\x2\x3E5\x3E7\a");
		sb.Append("\x95\x2\x2\x3E6\x3E8\x5\x23A\x11E\x2\x3E7\x3E6\x3\x2\x2\x2\x3E7");
		sb.Append("\x3E8\x3\x2\x2\x2\x3E8\x3E9\x3\x2\x2\x2\x3E9\x3F1\x5\x1EA\xF6");
		sb.Append("\x2\x3EA\x3EB\aW\x2\x2\x3EB\x3F2\x5\x1EA\xF6\x2\x3EC\x3ED\a");
		sb.Append("\x3C1\x2\x2\x3ED\x3EE\aW\x2\x2\x3EE\x3EF\x5\x1EA\xF6\x2\x3EF");
		sb.Append("\x3F0\a\x3C2\x2\x2\x3F0\x3F2\x3\x2\x2\x2\x3F1\x3EA\x3\x2\x2");
		sb.Append("\x2\x3F1\x3EC\x3\x2\x2\x2\x3F2\x430\x3\x2\x2\x2\x3F3\x3F5\a");
		sb.Append(" \x2\x2\x3F4\x3F6\a\x210\x2\x2\x3F5\x3F4\x3\x2\x2\x2\x3F5\x3F6");
		sb.Append("\x3\x2\x2\x2\x3F6\x3F7\x3\x2\x2\x2\x3F7\x3F9\a\x95\x2\x2\x3F8");
		sb.Append("\x3FA\x5\x23A\x11E\x2\x3F9\x3F8\x3\x2\x2\x2\x3F9\x3FA\x3\x2");
		sb.Append("\x2\x2\x3FA\x3FB\x3\x2\x2\x2\x3FB\x3FD\x5\x1EA\xF6\x2\x3FC\x3FE");
		sb.Append("\x5L\'\x2\x3FD\x3FC\x3\x2\x2\x2\x3FD\x3FE\x3\x2\x2\x2\x3FE\x409");
		sb.Append("\x3\x2\x2\x2\x3FF\x406\x5^\x30\x2\x400\x402\a\x3C3\x2\x2\x401");
		sb.Append("\x400\x3\x2\x2\x2\x401\x402\x3\x2\x2\x2\x402\x403\x3\x2\x2\x2");
		sb.Append("\x403\x405\x5^\x30\x2\x404\x401\x3\x2\x2\x2\x405\x408\x3\x2");
		sb.Append("\x2\x2\x406\x404\x3\x2\x2\x2\x406\x407\x3\x2\x2\x2\x407\x40A");
		sb.Append("\x3\x2\x2\x2\x408\x406\x3\x2\x2\x2\x409\x3FF\x3\x2\x2\x2\x409");
		sb.Append("\x40A\x3\x2\x2\x2\x40A\x40C\x3\x2\x2\x2\x40B\x40D\x5\x62\x32");
		sb.Append("\x2\x40C\x40B\x3\x2\x2\x2\x40C\x40D\x3\x2\x2\x2\x40D\x40F\x3");
		sb.Append("\x2\x2\x2\x40E\x410\t\b\x2\x2\x40F\x40E\x3\x2\x2\x2\x40F\x410");
		sb.Append("\x3\x2\x2\x2\x410\x412\x3\x2\x2\x2\x411\x413\a\r\x2\x2\x412");
		sb.Append("\x411\x3\x2\x2\x2\x412\x413\x3\x2\x2\x2\x413\x414\x3\x2\x2\x2");
		sb.Append("\x414\x415\x5\xB4[\x2\x415\x430\x3\x2\x2\x2\x416\x418\a \x2");
		sb.Append("\x2\x417\x419\a\x210\x2\x2\x418\x417\x3\x2\x2\x2\x418\x419\x3");
		sb.Append("\x2\x2\x2\x419\x41A\x3\x2\x2\x2\x41A\x41C\a\x95\x2\x2\x41B\x41D");
		sb.Append("\x5\x23A\x11E\x2\x41C\x41B\x3\x2\x2\x2\x41C\x41D\x3\x2\x2\x2");
		sb.Append("\x41D\x41E\x3\x2\x2\x2\x41E\x41F\x5\x1EA\xF6\x2\x41F\x42A\x5");
		sb.Append("L\'\x2\x420\x427\x5^\x30\x2\x421\x423\a\x3C3\x2\x2\x422\x421");
		sb.Append("\x3\x2\x2\x2\x422\x423\x3\x2\x2\x2\x423\x424\x3\x2\x2\x2\x424");
		sb.Append("\x426\x5^\x30\x2\x425\x422\x3\x2\x2\x2\x426\x429\x3\x2\x2\x2");
		sb.Append("\x427\x425\x3\x2\x2\x2\x427\x428\x3\x2\x2\x2\x428\x42B\x3\x2");
		sb.Append("\x2\x2\x429\x427\x3\x2\x2\x2\x42A\x420\x3\x2\x2\x2\x42A\x42B");
		sb.Append("\x3\x2\x2\x2\x42B\x42D\x3\x2\x2\x2\x42C\x42E\x5\x62\x32\x2\x42D");
		sb.Append("\x42C\x3\x2\x2\x2\x42D\x42E\x3\x2\x2\x2\x42E\x430\x3\x2\x2\x2");
		sb.Append("\x42F\x3E1\x3\x2\x2\x2\x42F\x3F3\x3\x2\x2\x2\x42F\x416\x3\x2");
		sb.Append("\x2\x2\x430)\x3\x2\x2\x2\x431\x432\a \x2\x2\x432\x433\a\x20F");
		sb.Append("\x2\x2\x433\x434\x5\x202\x102\x2\x434\x435\a\a\x2\x2\x435\x436");
		sb.Append("\a\x12E\x2\x2\x436\x43A\a\x3D0\x2\x2\x437\x438\a\x152\x2\x2");
		sb.Append("\x438\x439\a\x3B8\x2\x2\x439\x43B\x5\x20A\x106\x2\x43A\x437");
		sb.Append("\x3\x2\x2\x2\x43A\x43B\x3\x2\x2\x2\x43B\x441\x3\x2\x2\x2\x43C");
		sb.Append("\x43E\a\x140\x2\x2\x43D\x43F\a\x3B8\x2\x2\x43E\x43D\x3\x2\x2");
		sb.Append("\x2\x43E\x43F\x3\x2\x2\x2\x43F\x440\x3\x2\x2\x2\x440\x442\x5");
		sb.Append("\x1F8\xFD\x2\x441\x43C\x3\x2\x2\x2\x441\x442\x3\x2\x2\x2\x442");
		sb.Append("+\x3\x2\x2\x2\x443\x444\a \x2\x2\x444\x445\a\x20F\x2\x2\x445");
		sb.Append("\x446\x5\x202\x102\x2\x446\x447\a\a\x2\x2\x447\x448\a\x12E\x2");
		sb.Append("\x2\x448\x449\a\x3D0\x2\x2\x449\x44A\a\xA3\x2\x2\x44A\x44B\a");
		sb.Append("\x17C\x2\x2\x44B\x44C\a\x41\x2\x2\x44C\x452\x5\x202\x102\x2");
		sb.Append("\x44D\x44F\a\x14E\x2\x2\x44E\x450\a\x3B8\x2\x2\x44F\x44E\x3");
		sb.Append("\x2\x2\x2\x44F\x450\x3\x2\x2\x2\x450\x451\x3\x2\x2\x2\x451\x453");
		sb.Append("\x5\x20A\x106\x2\x452\x44D\x3\x2\x2\x2\x452\x453\x3\x2\x2\x2");
		sb.Append("\x453\x459\x3\x2\x2\x2\x454\x456\a\x168\x2\x2\x455\x457\a\x3B8");
		sb.Append("\x2\x2\x456\x455\x3\x2\x2\x2\x456\x457\x3\x2\x2\x2\x457\x458");
		sb.Append("\x3\x2\x2\x2\x458\x45A\x5\x20A\x106\x2\x459\x454\x3\x2\x2\x2");
		sb.Append("\x459\x45A\x3\x2\x2\x2\x45A\x460\x3\x2\x2\x2\x45B\x45D\a\x107");
		sb.Append("\x2\x2\x45C\x45E\a\x3B8\x2\x2\x45D\x45C\x3\x2\x2\x2\x45D\x45E");
		sb.Append("\x3\x2\x2\x2\x45E\x45F\x3\x2\x2\x2\x45F\x461\x5\x20A\x106\x2");
		sb.Append("\x460\x45B\x3\x2\x2\x2\x460\x461\x3\x2\x2\x2\x461\x467\x3\x2");
		sb.Append("\x2\x2\x462\x464\a\x196\x2\x2\x463\x465\a\x3B8\x2\x2\x464\x463");
		sb.Append("\x3\x2\x2\x2\x464\x465\x3\x2\x2\x2\x465\x466\x3\x2\x2\x2\x466");
		sb.Append("\x468\x5\x20A\x106\x2\x467\x462\x3\x2\x2\x2\x467\x468\x3\x2");
		sb.Append("\x2\x2\x468\x46E\x3\x2\x2\x2\x469\x46B\a\x1A8\x2\x2\x46A\x46C");
		sb.Append("\a\x3B8\x2\x2\x46B\x46A\x3\x2\x2\x2\x46B\x46C\x3\x2\x2\x2\x46C");
		sb.Append("\x46D\x3\x2\x2\x2\x46D\x46F\x5\x202\x102\x2\x46E\x469\x3\x2");
		sb.Append("\x2\x2\x46E\x46F\x3\x2\x2\x2\x46F\x471\x3\x2\x2\x2\x470\x472");
		sb.Append("\a\x226\x2\x2\x471\x470\x3\x2\x2\x2\x471\x472\x3\x2\x2\x2\x472");
		sb.Append("\x478\x3\x2\x2\x2\x473\x475\a\x11F\x2\x2\x474\x476\a\x3B8\x2");
		sb.Append("\x2\x475\x474\x3\x2\x2\x2\x475\x476\x3\x2\x2\x2\x476\x477\x3");
		sb.Append("\x2\x2\x2\x477\x479\a\x3D0\x2\x2\x478\x473\x3\x2\x2\x2\x478");
		sb.Append("\x479\x3\x2\x2\x2\x479\x47A\x3\x2\x2\x2\x47A\x47C\a\x140\x2");
		sb.Append("\x2\x47B\x47D\a\x3B8\x2\x2\x47C\x47B\x3\x2\x2\x2\x47C\x47D\x3");
		sb.Append("\x2\x2\x2\x47D\x47E\x3\x2\x2\x2\x47E\x47F\x5\x1F8\xFD\x2\x47F");
		sb.Append("-\x3\x2\x2\x2\x480\x482\a \x2\x2\x481\x483\x5\x34\x1B\x2\x482");
		sb.Append("\x481\x3\x2\x2\x2\x482\x483\x3\x2\x2\x2\x483\x484\x3\x2\x2\x2");
		sb.Append("\x484\x485\a\x9A\x2\x2\x485\x486\x5\x1E8\xF5\x2\x486\x487\t");
		sb.Append("\t\x2\x2\x487\x488\t\n\x2\x2\x488\x489\ah\x2\x2\x489\x48A\x5");
		sb.Append("\x1EA\xF6\x2\x48A\x48B\a:\x2\x2\x48B\x48C\a\x30\x2\x2\x48C\x48F");
		sb.Append("\a\x1E4\x2\x2\x48D\x48E\t\v\x2\x2\x48E\x490\x5\x1E8\xF5\x2\x48F");
		sb.Append("\x48D\x3\x2\x2\x2\x48F\x490\x3\x2\x2\x2\x490\x491\x3\x2\x2\x2");
		sb.Append("\x491\x492\x5\x15A\xAE\x2\x492/\x3\x2\x2\x2\x493\x496\a \x2");
		sb.Append("\x2\x494\x495\al\x2\x2\x495\x497\a}\x2\x2\x496\x494\x3\x2\x2");
		sb.Append("\x2\x496\x497\x3\x2\x2\x2\x497\x49B\x3\x2\x2\x2\x498\x499\a");
		sb.Append("\x102\x2\x2\x499\x49A\a\x3B8\x2\x2\x49A\x49C\t\f\x2\x2\x49B");
		sb.Append("\x498\x3\x2\x2\x2\x49B\x49C\x3\x2\x2\x2\x49C\x49E\x3\x2\x2\x2");
		sb.Append("\x49D\x49F\x5\x34\x1B\x2\x49E\x49D\x3\x2\x2\x2\x49E\x49F\x3");
		sb.Append("\x2\x2\x2\x49F\x4A3\x3\x2\x2\x2\x4A0\x4A1\a\x8B\x2\x2\x4A1\x4A2");
		sb.Append("\a\x1E9\x2\x2\x4A2\x4A4\t\r\x2\x2\x4A3\x4A0\x3\x2\x2\x2\x4A3");
		sb.Append("\x4A4\x3\x2\x2\x2\x4A4\x4A5\x3\x2\x2\x2\x4A5\x4A6\a\x224\x2");
		sb.Append("\x2\x4A6\x4AB\x5\x1E8\xF5\x2\x4A7\x4A8\a\x3C1\x2\x2\x4A8\x4A9");
		sb.Append("\x5\x222\x112\x2\x4A9\x4AA\a\x3C2\x2\x2\x4AA\x4AC\x3\x2\x2\x2");
		sb.Append("\x4AB\x4A7\x3\x2\x2\x2\x4AB\x4AC\x3\x2\x2\x2\x4AC\x4AD\x3\x2");
		sb.Append("\x2\x2\x4AD\x4AE\a\r\x2\x2\x4AE\x4B5\x5\xB4[\x2\x4AF\x4B1\a");
		sb.Append("\xA9\x2\x2\x4B0\x4B2\t\xE\x2\x2\x4B1\x4B0\x3\x2\x2\x2\x4B1\x4B2");
		sb.Append("\x3\x2\x2\x2\x4B2\x4B3\x3\x2\x2\x2\x4B3\x4B4\a\x19\x2\x2\x4B4");
		sb.Append("\x4B6\aj\x2\x2\x4B5\x4AF\x3\x2\x2\x2\x4B5\x4B6\x3\x2\x2\x2\x4B6");
		sb.Append("\x31\x3\x2\x2\x2\x4B7\x4B9\a\'\x2\x2\x4B8\x4B7\x3\x2\x2\x2\x4B8");
		sb.Append("\x4B9\x3\x2\x2\x2\x4B9\x4BD\x3\x2\x2\x2\x4BA\x4BB\a\x18\x2\x2");
		sb.Append("\x4BB\x4BE\a\x87\x2\x2\x4BC\x4BE\a\x2A1\x2\x2\x4BD\x4BA\x3\x2");
		sb.Append("\x2\x2\x4BD\x4BC\x3\x2\x2\x2\x4BE\x4C0\x3\x2\x2\x2\x4BF\x4C1");
		sb.Append("\a\x3B8\x2\x2\x4C0\x4BF\x3\x2\x2\x2\x4C0\x4C1\x3\x2\x2\x2\x4C1");
		sb.Append("\x4C2\x3\x2\x2\x2\x4C2\x4CC\x5\x1F4\xFB\x2\x4C3\x4C5\a\'\x2");
		sb.Append("\x2\x4C4\x4C3\x3\x2\x2\x2\x4C4\x4C5\x3\x2\x2\x2\x4C5\x4C6\x3");
		sb.Append("\x2\x2\x2\x4C6\x4C8\a\x1A\x2\x2\x4C7\x4C9\a\x3B8\x2\x2\x4C8");
		sb.Append("\x4C7\x3\x2\x2\x2\x4C8\x4C9\x3\x2\x2\x2\x4C9\x4CA\x3\x2\x2\x2");
		sb.Append("\x4CA\x4CC\x5\x1F6\xFC\x2\x4CB\x4B8\x3\x2\x2\x2\x4CB\x4C4\x3");
		sb.Append("\x2\x2\x2\x4CC\x33\x3\x2\x2\x2\x4CD\x4CE\a\x131\x2\x2\x4CE\x4D5");
		sb.Append("\a\x3B8\x2\x2\x4CF\x4D6\x5\x1F0\xF9\x2\x4D0\x4D3\a\"\x2\x2\x4D1");
		sb.Append("\x4D2\a\x3C1\x2\x2\x4D2\x4D4\a\x3C2\x2\x2\x4D3\x4D1\x3\x2\x2");
		sb.Append("\x2\x4D3\x4D4\x3\x2\x2\x2\x4D4\x4D6\x3\x2\x2\x2\x4D5\x4CF\x3");
		sb.Append("\x2\x2\x2\x4D5\x4D0\x3\x2\x2\x2\x4D6\x35\x3\x2\x2\x2\x4D7\x4D8");
		sb.Append("\a\x104\x2\x2\x4D8\x4DC\x5\x38\x1D\x2\x4D9\x4DB\x5:\x1E\x2\x4DA");
		sb.Append("\x4D9\x3\x2\x2\x2\x4DB\x4DE\x3\x2\x2\x2\x4DC\x4DA\x3\x2\x2\x2");
		sb.Append("\x4DC\x4DD\x3\x2\x2\x2\x4DD\x4FA\x3\x2\x2\x2\x4DE\x4DC\x3\x2");
		sb.Append("\x2\x2\x4DF\x4E2\a\x148\x2\x2\x4E0\x4E3\x5\x208\x105\x2\x4E1");
		sb.Append("\x4E3\x5\x250\x129\x2\x4E2\x4E0\x3\x2\x2\x2\x4E2\x4E1\x3\x2");
		sb.Append("\x2\x2\x4E3\x4E4\x3\x2\x2\x2\x4E4\x4ED\x5<\x1F\x2\x4E5\x4E6");
		sb.Append("\a\x200\x2\x2\x4E6\x4EA\x5\x38\x1D\x2\x4E7\x4E9\x5:\x1E\x2\x4E8");
		sb.Append("\x4E7\x3\x2\x2\x2\x4E9\x4EC\x3\x2\x2\x2\x4EA\x4E8\x3\x2\x2\x2");
		sb.Append("\x4EA\x4EB\x3\x2\x2\x2\x4EB\x4EE\x3\x2\x2\x2\x4EC\x4EA\x3\x2");
		sb.Append("\x2\x2\x4ED\x4E5\x3\x2\x2\x2\x4ED\x4EE\x3\x2\x2\x2\x4EE\x4F7");
		sb.Append("\x3\x2\x2\x2\x4EF\x4F0\a\x13F\x2\x2\x4F0\x4F4\x5\x38\x1D\x2");
		sb.Append("\x4F1\x4F3\x5:\x1E\x2\x4F2\x4F1\x3\x2\x2\x2\x4F3\x4F6\x3\x2");
		sb.Append("\x2\x2\x4F4\x4F2\x3\x2\x2\x2\x4F4\x4F5\x3\x2\x2\x2\x4F5\x4F8");
		sb.Append("\x3\x2\x2\x2\x4F6\x4F4\x3\x2\x2\x2\x4F7\x4EF\x3\x2\x2\x2\x4F7");
		sb.Append("\x4F8\x3\x2\x2\x2\x4F8\x4FA\x3\x2\x2\x2\x4F9\x4D7\x3\x2\x2\x2");
		sb.Append("\x4F9\x4DF\x3\x2\x2\x2\x4FA\x37\x3\x2\x2\x2\x4FB\x500\a\xED");
		sb.Append("\x2\x2\x4FC\x500\x5\x20C\x107\x2\x4FD\x500\x5\x208\x105\x2\x4FE");
		sb.Append("\x500\x5\x250\x129\x2\x4FF\x4FB\x3\x2\x2\x2\x4FF\x4FC\x3\x2");
		sb.Append("\x2\x2\x4FF\x4FD\x3\x2\x2\x2\x4FF\x4FE\x3\x2\x2\x2\x500\x39");
		sb.Append("\x3\x2\x2\x2\x501\x502\a\x3B3\x2\x2\x502\x505\aL\x2\x2\x503");
		sb.Append("\x506\x5\x208\x105\x2\x504\x506\x5\x250\x129\x2\x505\x503\x3");
		sb.Append("\x2\x2\x2\x505\x504\x3\x2\x2\x2\x506\x507\x3\x2\x2\x2\x507\x508");
		sb.Append("\x5<\x1F\x2\x508;\x3\x2\x2\x2\x509\x517\x5\x266\x134\x2\x50A");
		sb.Append("\x517\a\xBE\x2\x2\x50B\x517\a\xD0\x2\x2\x50C\x517\a\xD1\x2\x2");
		sb.Append("\x50D\x517\a\xD2\x2\x2\x50E\x517\a\xD3\x2\x2\x50F\x517\a\xD4");
		sb.Append("\x2\x2\x510\x517\a\xD5\x2\x2\x511\x517\a\xD6\x2\x2\x512\x517");
		sb.Append("\a\xD7\x2\x2\x513\x517\a\xD8\x2\x2\x514\x517\a\xD9\x2\x2\x515");
		sb.Append("\x517\a\xDA\x2\x2\x516\x509\x3\x2\x2\x2\x516\x50A\x3\x2\x2\x2");
		sb.Append("\x516\x50B\x3\x2\x2\x2\x516\x50C\x3\x2\x2\x2\x516\x50D\x3\x2");
		sb.Append("\x2\x2\x516\x50E\x3\x2\x2\x2\x516\x50F\x3\x2\x2\x2\x516\x510");
		sb.Append("\x3\x2\x2\x2\x516\x511\x3\x2\x2\x2\x516\x512\x3\x2\x2\x2\x516");
		sb.Append("\x513\x3\x2\x2\x2\x516\x514\x3\x2\x2\x2\x516\x515\x3\x2\x2\x2");
		sb.Append("\x517=\x3\x2\x2\x2\x518\x51E\a\x13C\x2\x2\x519\x51E\a\x135\x2");
		sb.Append("\x2\x51A\x51B\a\x135\x2\x2\x51B\x51C\ah\x2\x2\x51C\x51E\a\x1F0");
		sb.Append("\x2\x2\x51D\x518\x3\x2\x2\x2\x51D\x519\x3\x2\x2\x2\x51D\x51A");
		sb.Append("\x3\x2\x2\x2\x51E?\x3\x2\x2\x2\x51F\x520\a\xA4\x2\x2\x520\x521");
		sb.Append("\t\xF\x2\x2\x521\x41\x3\x2\x2\x2\x522\x524\a\x174\x2\x2\x523");
		sb.Append("\x525\a\x3B8\x2\x2\x524\x523\x3\x2\x2\x2\x524\x525\x3\x2\x2");
		sb.Append("\x2\x525\x526\x3\x2\x2\x2\x526\x52E\x5\x20A\x106\x2\x527\x52E");
		sb.Append("\x5@!\x2\x528\x529\a\xA9\x2\x2\x529\x52A\a\x1B7\x2\x2\x52A\x52E");
		sb.Append("\x5\x202\x102\x2\x52B\x52C\a\x11F\x2\x2\x52C\x52E\a\x3D0\x2");
		sb.Append("\x2\x52D\x522\x3\x2\x2\x2\x52D\x527\x3\x2\x2\x2\x52D\x528\x3");
		sb.Append("\x2\x2\x2\x52D\x52B\x3\x2\x2\x2\x52E\x43\x3\x2\x2\x2\x52F\x531");
		sb.Append("\t\x10\x2\x2\x530\x52F\x3\x2\x2\x2\x530\x531\x3\x2\x2\x2\x531");
		sb.Append("\x532\x3\x2\x2\x2\x532\x533\x5\x202\x102\x2\x533\x534\x5\x216");
		sb.Append("\x10C\x2\x534\x45\x3\x2\x2\x2\x535\x536\x5\x202\x102\x2\x536");
		sb.Append("\x537\x5\x216\x10C\x2\x537G\x3\x2\x2\x2\x538\x539\a\x11F\x2");
		sb.Append("\x2\x539\x550\a\x3D0\x2\x2\x53A\x53B\a\x175\x2\x2\x53B\x550");
		sb.Append("\a\x8B\x2\x2\x53C\x53E\a\x65\x2\x2\x53D\x53C\x3\x2\x2\x2\x53D");
		sb.Append("\x53E\x3\x2\x2\x2\x53E\x53F\x3\x2\x2\x2\x53F\x550\a,\x2\x2\x540");
		sb.Append("\x541\a\x128\x2\x2\x541\x54B\a\x8B\x2\x2\x542\x543\a\x1A7\x2");
		sb.Append("\x2\x543\x54B\a\x8B\x2\x2\x544\x545\aw\x2\x2\x545\x546\a\x8B");
		sb.Append("\x2\x2\x546\x54B\a\x12D\x2\x2\x547\x548\a\x63\x2\x2\x548\x549");
		sb.Append("\a\x8B\x2\x2\x549\x54B\a\x12D\x2\x2\x54A\x540\x3\x2\x2\x2\x54A");
		sb.Append("\x542\x3\x2\x2\x2\x54A\x544\x3\x2\x2\x2\x54A\x547\x3\x2\x2\x2");
		sb.Append("\x54B\x550\x3\x2\x2\x2\x54C\x54D\a\x8B\x2\x2\x54D\x54E\a\x1E9");
		sb.Append("\x2\x2\x54E\x550\t\r\x2\x2\x54F\x538\x3\x2\x2\x2\x54F\x53A\x3");
		sb.Append("\x2\x2\x2\x54F\x53D\x3\x2\x2\x2\x54F\x54A\x3\x2\x2\x2\x54F\x54C");
		sb.Append("\x3\x2\x2\x2\x550I\x3\x2\x2\x2\x551\x552\a\x162\x2\x2\x552\x560");
		sb.Append("\a\x3D0\x2\x2\x553\x554\a$\x2\x2\x554\x560\a\x3D0\x2\x2\x555");
		sb.Append("\x556\a\x21E\x2\x2\x556\x560\a\x3D0\x2\x2\x557\x558\a\x1BB\x2");
		sb.Append("\x2\x558\x560\a\x3D0\x2\x2\x559\x55A\a\x1F3\x2\x2\x55A\x560");
		sb.Append("\a\x3D0\x2\x2\x55B\x55C\a\x1B4\x2\x2\x55C\x560\a\x3D0\x2\x2");
		sb.Append("\x55D\x55E\a\x1C0\x2\x2\x55E\x560\x5\x208\x105\x2\x55F\x551");
		sb.Append("\x3\x2\x2\x2\x55F\x553\x3\x2\x2\x2\x55F\x555\x3\x2\x2\x2\x55F");
		sb.Append("\x557\x3\x2\x2\x2\x55F\x559\x3\x2\x2\x2\x55F\x55B\x3\x2\x2\x2");
		sb.Append("\x55F\x55D\x3\x2\x2\x2\x560K\x3\x2\x2\x2\x561\x562\a\x3C1\x2");
		sb.Append("\x2\x562\x567\x5N(\x2\x563\x564\a\x3C3\x2\x2\x564\x566\x5N(");
		sb.Append("\x2\x565\x563\x3\x2\x2\x2\x566\x569\x3\x2\x2\x2\x567\x565\x3");
		sb.Append("\x2\x2\x2\x567\x568\x3\x2\x2\x2\x568\x56A\x3\x2\x2\x2\x569\x567");
		sb.Append("\x3\x2\x2\x2\x56A\x56B\a\x3C2\x2\x2\x56BM\x3\x2\x2\x2\x56C\x56D");
		sb.Append("\x5\x202\x102\x2\x56D\x56E\x5P)\x2\x56E\x572\x3\x2\x2\x2\x56F");
		sb.Append("\x572\x5T+\x2\x570\x572\x5\\/\x2\x571\x56C\x3\x2\x2\x2\x571");
		sb.Append("\x56F\x3\x2\x2\x2\x571\x570\x3\x2\x2\x2\x572O\x3\x2\x2\x2\x573");
		sb.Append("\x577\x5\x216\x10C\x2\x574\x576\x5R*\x2\x575\x574\x3\x2\x2\x2");
		sb.Append("\x576\x579\x3\x2\x2\x2\x577\x575\x3\x2\x2\x2\x577\x578\x3\x2");
		sb.Append("\x2\x2\x578Q\x3\x2\x2\x2\x579\x577\x3\x2\x2\x2\x57A\x5A3\x5");
		sb.Append("\x212\x10A\x2\x57B\x57C\a\'\x2\x2\x57C\x5A3\x5\x232\x11A\x2");
		sb.Append("\x57D\x582\a\x108\x2\x2\x57E\x57F\ah\x2\x2\x57F\x580\a\xA1\x2");
		sb.Append("\x2\x580\x582\x5\x234\x11B\x2\x581\x57D\x3\x2\x2\x2\x581\x57E");
		sb.Append("\x3\x2\x2\x2\x582\x5A3\x3\x2\x2\x2\x583\x585\ar\x2\x2\x584\x583");
		sb.Append("\x3\x2\x2\x2\x584\x585\x3\x2\x2\x2\x585\x586\x3\x2\x2\x2\x586");
		sb.Append("\x5A3\aQ\x2\x2\x587\x589\a\x9E\x2\x2\x588\x58A\aQ\x2\x2\x589");
		sb.Append("\x588\x3\x2\x2\x2\x589\x58A\x3\x2\x2\x2\x58A\x5A3\x3\x2\x2\x2");
		sb.Append("\x58B\x58C\a\x11F\x2\x2\x58C\x5A3\a\x3D0\x2\x2\x58D\x58E\a\x11E");
		sb.Append("\x2\x2\x58E\x5A3\t\x11\x2\x2\x58F\x590\a\x206\x2\x2\x590\x5A3");
		sb.Append("\t\x12\x2\x2\x591\x5A3\x5V,\x2\x592\x593\a\x1A\x2\x2\x593\x5A3");
		sb.Append("\x5\x1F6\xFC\x2\x594\x595\a?\x2\x2\x595\x597\a\n\x2\x2\x596");
		sb.Append("\x594\x3\x2\x2\x2\x596\x597\x3\x2\x2\x2\x597\x598\x3\x2\x2\x2");
		sb.Append("\x598\x599\a\r\x2\x2\x599\x59A\a\x3C1\x2\x2\x59A\x59B\x5\x250");
		sb.Append("\x129\x2\x59B\x59D\a\x3C2\x2\x2\x59C\x59E\t\x13\x2\x2\x59D\x59C");
		sb.Append("\x3\x2\x2\x2\x59D\x59E\x3\x2\x2\x2\x59E\x5A3\x3\x2\x2\x2\x59F");
		sb.Append("\x5A0\a\xCF\x2\x2\x5A0\x5A1\a\'\x2\x2\x5A1\x5A3\a\x222\x2\x2");
		sb.Append("\x5A2\x57A\x3\x2\x2\x2\x5A2\x57B\x3\x2\x2\x2\x5A2\x581\x3\x2");
		sb.Append("\x2\x2\x5A2\x584\x3\x2\x2\x2\x5A2\x587\x3\x2\x2\x2\x5A2\x58B");
		sb.Append("\x3\x2\x2\x2\x5A2\x58D\x3\x2\x2\x2\x5A2\x58F\x3\x2\x2\x2\x5A2");
		sb.Append("\x591\x3\x2\x2\x2\x5A2\x592\x3\x2\x2\x2\x5A2\x596\x3\x2\x2\x2");
		sb.Append("\x5A2\x59F\x3\x2\x2\x2\x5A3S\x3\x2\x2\x2\x5A4\x5A6\a\x1D\x2");
		sb.Append("\x2\x5A5\x5A7\x5\x202\x102\x2\x5A6\x5A5\x3\x2\x2\x2\x5A6\x5A7");
		sb.Append("\x3\x2\x2\x2\x5A7\x5A9\x3\x2\x2\x2\x5A8\x5A4\x3\x2\x2\x2\x5A8");
		sb.Append("\x5A9\x3\x2\x2\x2\x5A9\x5AA\x3\x2\x2\x2\x5AA\x5AB\ar\x2\x2\x5AB");
		sb.Append("\x5AD\aQ\x2\x2\x5AC\x5AE\x5\x202\x102\x2\x5AD\x5AC\x3\x2\x2");
		sb.Append("\x2\x5AD\x5AE\x3\x2\x2\x2\x5AE\x5B0\x3\x2\x2\x2\x5AF\x5B1\x5");
		sb.Append("@!\x2\x5B0\x5AF\x3\x2\x2\x2\x5B0\x5B1\x3\x2\x2\x2\x5B1\x5B2");
		sb.Append("\x3\x2\x2\x2\x5B2\x5B6\x5\x226\x114\x2\x5B3\x5B5\x5\x42\"\x2");
		sb.Append("\x5B4\x5B3\x3\x2\x2\x2\x5B5\x5B8\x3\x2\x2\x2\x5B6\x5B4\x3\x2");
		sb.Append("\x2\x2\x5B6\x5B7\x3\x2\x2\x2\x5B7\x5EA\x3\x2\x2\x2\x5B8\x5B6");
		sb.Append("\x3\x2\x2\x2\x5B9\x5BB\a\x1D\x2\x2\x5BA\x5BC\x5\x202\x102\x2");
		sb.Append("\x5BB\x5BA\x3\x2\x2\x2\x5BB\x5BC\x3\x2\x2\x2\x5BC\x5BE\x3\x2");
		sb.Append("\x2\x2\x5BD\x5B9\x3\x2\x2\x2\x5BD\x5BE\x3\x2\x2\x2\x5BE\x5BF");
		sb.Append("\x3\x2\x2\x2\x5BF\x5C1\a\x9E\x2\x2\x5C0\x5C2\t\x14\x2\x2\x5C1");
		sb.Append("\x5C0\x3\x2\x2\x2\x5C1\x5C2\x3\x2\x2\x2\x5C2\x5C4\x3\x2\x2\x2");
		sb.Append("\x5C3\x5C5\x5\x202\x102\x2\x5C4\x5C3\x3\x2\x2\x2\x5C4\x5C5\x3");
		sb.Append("\x2\x2\x2\x5C5\x5C7\x3\x2\x2\x2\x5C6\x5C8\x5@!\x2\x5C7\x5C6");
		sb.Append("\x3\x2\x2\x2\x5C7\x5C8\x3\x2\x2\x2\x5C8\x5C9\x3\x2\x2\x2\x5C9");
		sb.Append("\x5CD\x5\x226\x114\x2\x5CA\x5CC\x5\x42\"\x2\x5CB\x5CA\x3\x2");
		sb.Append("\x2\x2\x5CC\x5CF\x3\x2\x2\x2\x5CD\x5CB\x3\x2\x2\x2\x5CD\x5CE");
		sb.Append("\x3\x2\x2\x2\x5CE\x5EA\x3\x2\x2\x2\x5CF\x5CD\x3\x2\x2\x2\x5D0");
		sb.Append("\x5D2\a\x1D\x2\x2\x5D1\x5D3\x5\x202\x102\x2\x5D2\x5D1\x3\x2");
		sb.Append("\x2\x2\x5D2\x5D3\x3\x2\x2\x2\x5D3\x5D5\x3\x2\x2\x2\x5D4\x5D0");
		sb.Append("\x3\x2\x2\x2\x5D4\x5D5\x3\x2\x2\x2\x5D5\x5D6\x3\x2\x2\x2\x5D6");
		sb.Append("\x5D7\a<\x2\x2\x5D7\x5D9\aQ\x2\x2\x5D8\x5DA\x5\x202\x102\x2");
		sb.Append("\x5D9\x5D8\x3\x2\x2\x2\x5D9\x5DA\x3\x2\x2\x2\x5DA\x5DB\x3\x2");
		sb.Append("\x2\x2\x5DB\x5DC\x5\x226\x114\x2\x5DC\x5DD\x5V,\x2\x5DD\x5EA");
		sb.Append("\x3\x2\x2\x2\x5DE\x5E0\a\x1D\x2\x2\x5DF\x5E1\x5\x202\x102\x2");
		sb.Append("\x5E0\x5DF\x3\x2\x2\x2\x5E0\x5E1\x3\x2\x2\x2\x5E1\x5E3\x3\x2");
		sb.Append("\x2\x2\x5E2\x5DE\x3\x2\x2\x2\x5E2\x5E3\x3\x2\x2\x2\x5E3\x5E4");
		sb.Append("\x3\x2\x2\x2\x5E4\x5E5\a\x19\x2\x2\x5E5\x5E6\a\x3C1\x2\x2\x5E6");
		sb.Append("\x5E7\x5\x250\x129\x2\x5E7\x5E8\a\x3C2\x2\x2\x5E8\x5EA\x3\x2");
		sb.Append("\x2\x2\x5E9\x5A8\x3\x2\x2\x2\x5E9\x5BD\x3\x2\x2\x2\x5E9\x5D4");
		sb.Append("\x3\x2\x2\x2\x5E9\x5E2\x3\x2\x2\x2\x5EAU\x3\x2\x2\x2\x5EB\x5EC");
		sb.Append("\ax\x2\x2\x5EC\x5EE\x5\x1EA\xF6\x2\x5ED\x5EF\x5\x226\x114\x2");
		sb.Append("\x5EE\x5ED\x3\x2\x2\x2\x5EE\x5EF\x3\x2\x2\x2\x5EF\x5F2\x3\x2");
		sb.Append("\x2\x2\x5F0\x5F1\a\x61\x2\x2\x5F1\x5F3\t\x15\x2\x2\x5F2\x5F0");
		sb.Append("\x3\x2\x2\x2\x5F2\x5F3\x3\x2\x2\x2\x5F3\x5F5\x3\x2\x2\x2\x5F4");
		sb.Append("\x5F6\x5X-\x2\x5F5\x5F4\x3\x2\x2\x2\x5F5\x5F6\x3\x2\x2\x2\x5F6");
		sb.Append("W\x3\x2\x2\x2\x5F7\x5F8\ah\x2\x2\x5F8\x5F9\a)\x2\x2\x5F9\x5FD");
		sb.Append("\x5Z.\x2\x5FA\x5FB\ah\x2\x2\x5FB\x5FC\a\xA1\x2\x2\x5FC\x5FE");
		sb.Append("\x5Z.\x2\x5FD\x5FA\x3\x2\x2\x2\x5FD\x5FE\x3\x2\x2\x2\x5FE\x608");
		sb.Append("\x3\x2\x2\x2\x5FF\x600\ah\x2\x2\x600\x601\a\xA1\x2\x2\x601\x605");
		sb.Append("\x5Z.\x2\x602\x603\ah\x2\x2\x603\x604\a)\x2\x2\x604\x606\x5");
		sb.Append("Z.\x2\x605\x602\x3\x2\x2\x2\x605\x606\x3\x2\x2\x2\x606\x608");
		sb.Append("\x3\x2\x2\x2\x607\x5F7\x3\x2\x2\x2\x607\x5FF\x3\x2\x2\x2\x608");
		sb.Append("Y\x3\x2\x2\x2\x609\x610\a\x7F\x2\x2\x60A\x610\a\x14\x2\x2\x60B");
		sb.Append("\x60C\a\x87\x2\x2\x60C\x610\ag\x2\x2\x60D\x60E\a\x1A7\x2\x2");
		sb.Append("\x60E\x610\a\xFF\x2\x2\x60F\x609\x3\x2\x2\x2\x60F\x60A\x3\x2");
		sb.Append("\x2\x2\x60F\x60B\x3\x2\x2\x2\x60F\x60D\x3\x2\x2\x2\x610[\x3");
		sb.Append("\x2\x2\x2\x611\x613\t\x14\x2\x2\x612\x614\x5\x202\x102\x2\x613");
		sb.Append("\x612\x3\x2\x2\x2\x613\x614\x3\x2\x2\x2\x614\x616\x3\x2\x2\x2");
		sb.Append("\x615\x617\x5@!\x2\x616\x615\x3\x2\x2\x2\x616\x617\x3\x2\x2");
		sb.Append("\x2\x617\x618\x3\x2\x2\x2\x618\x61C\x5\x226\x114\x2\x619\x61B");
		sb.Append("\x5\x42\"\x2\x61A\x619\x3\x2\x2\x2\x61B\x61E\x3\x2\x2\x2\x61C");
		sb.Append("\x61A\x3\x2\x2\x2\x61C\x61D\x3\x2\x2\x2\x61D\x62E\x3\x2\x2\x2");
		sb.Append("\x61E\x61C\x3\x2\x2\x2\x61F\x621\t\x16\x2\x2\x620\x622\t\x14");
		sb.Append("\x2\x2\x621\x620\x3\x2\x2\x2\x621\x622\x3\x2\x2\x2\x622\x624");
		sb.Append("\x3\x2\x2\x2\x623\x625\x5\x202\x102\x2\x624\x623\x3\x2\x2\x2");
		sb.Append("\x624\x625\x3\x2\x2\x2\x625\x626\x3\x2\x2\x2\x626\x62A\x5\x226");
		sb.Append("\x114\x2\x627\x629\x5\x42\"\x2\x628\x627\x3\x2\x2\x2\x629\x62C");
		sb.Append("\x3\x2\x2\x2\x62A\x628\x3\x2\x2\x2\x62A\x62B\x3\x2\x2\x2\x62B");
		sb.Append("\x62E\x3\x2\x2\x2\x62C\x62A\x3\x2\x2\x2\x62D\x611\x3\x2\x2\x2");
		sb.Append("\x62D\x61F\x3\x2\x2\x2\x62E]\x3\x2\x2\x2\x62F\x631\a\x140\x2");
		sb.Append("\x2\x630\x632\a\x3B8\x2\x2\x631\x630\x3\x2\x2\x2\x631\x632\x3");
		sb.Append("\x2\x2\x2\x632\x633\x3\x2\x2\x2\x633\x6BD\x5\x1F8\xFD\x2\x634");
		sb.Append("\x636\a\x108\x2\x2\x635\x637\a\x3B8\x2\x2\x636\x635\x3\x2\x2");
		sb.Append("\x2\x636\x637\x3\x2\x2\x2\x637\x638\x3\x2\x2\x2\x638\x6BD\x5");
		sb.Append("\x208\x105\x2\x639\x63B\a\x109\x2\x2\x63A\x63C\a\x3B8\x2\x2");
		sb.Append("\x63B\x63A\x3\x2\x2\x2\x63B\x63C\x3\x2\x2\x2\x63C\x63D\x3\x2");
		sb.Append("\x2\x2\x63D\x6BD\x5\x208\x105\x2\x63E\x640\a\'\x2\x2\x63F\x63E");
		sb.Append("\x3\x2\x2\x2\x63F\x640\x3\x2\x2\x2\x640\x644\x3\x2\x2\x2\x641");
		sb.Append("\x642\a\x18\x2\x2\x642\x645\a\x87\x2\x2\x643\x645\a\x2A1\x2");
		sb.Append("\x2\x644\x641\x3\x2\x2\x2\x644\x643\x3\x2\x2\x2\x645\x647\x3");
		sb.Append("\x2\x2\x2\x646\x648\a\x3B8\x2\x2\x647\x646\x3\x2\x2\x2\x647");
		sb.Append("\x648\x3\x2\x2\x2\x648\x649\x3\x2\x2\x2\x649\x6BD\x5\x1F4\xFB");
		sb.Append("\x2\x64A\x64C\t\x17\x2\x2\x64B\x64D\a\x3B8\x2\x2\x64C\x64B\x3");
		sb.Append("\x2\x2\x2\x64C\x64D\x3\x2\x2\x2\x64D\x64E\x3\x2\x2\x2\x64E\x6BD");
		sb.Append("\t\x18\x2\x2\x64F\x651\a\'\x2\x2\x650\x64F\x3\x2\x2\x2\x650");
		sb.Append("\x651\x3\x2\x2\x2\x651\x652\x3\x2\x2\x2\x652\x654\a\x1A\x2\x2");
		sb.Append("\x653\x655\a\x3B8\x2\x2\x654\x653\x3\x2\x2\x2\x654\x655\x3\x2");
		sb.Append("\x2\x2\x655\x656\x3\x2\x2\x2\x656\x6BD\x5\x1F6\xFC\x2\x657\x659");
		sb.Append("\a\x11F\x2\x2\x658\x65A\a\x3B8\x2\x2\x659\x658\x3\x2\x2\x2\x659");
		sb.Append("\x65A\x3\x2\x2\x2\x65A\x65B\x3\x2\x2\x2\x65B\x6BD\a\x3D0\x2");
		sb.Append("\x2\x65C\x65E\a\x124\x2\x2\x65D\x65F\a\x3B8\x2\x2\x65E\x65D");
		sb.Append("\x3\x2\x2\x2\x65E\x65F\x3\x2\x2\x2\x65F\x660\x3\x2\x2\x2\x660");
		sb.Append("\x6BD\t\x19\x2\x2\x661\x663\a\x126\x2\x2\x662\x664\a\x3B8\x2");
		sb.Append("\x2\x663\x662\x3\x2\x2\x2\x663\x664\x3\x2\x2\x2\x664\x665\x3");
		sb.Append("\x2\x2\x2\x665\x6BD\a\x3D0\x2\x2\x666\x667\a\x12D\x2\x2\x667");
		sb.Append("\x669\a\x134\x2\x2\x668\x66A\a\x3B8\x2\x2\x669\x668\x3\x2\x2");
		sb.Append("\x2\x669\x66A\x3\x2\x2\x2\x66A\x66B\x3\x2\x2\x2\x66B\x6BD\a");
		sb.Append("\x3D0\x2\x2\x66C\x66E\a\x132\x2\x2\x66D\x66F\a\x3B8\x2\x2\x66E");
		sb.Append("\x66D\x3\x2\x2\x2\x66E\x66F\x3\x2\x2\x2\x66F\x670\x3\x2\x2\x2");
		sb.Append("\x670\x6BD\t\x18\x2\x2\x671\x673\a\x13D\x2\x2\x672\x674\a\x3B8");
		sb.Append("\x2\x2\x673\x672\x3\x2\x2\x2\x673\x674\x3\x2\x2\x2\x674\x675");
		sb.Append("\x3\x2\x2\x2\x675\x6BD\a\x3D0\x2\x2\x676\x677\aG\x2\x2\x677");
		sb.Append("\x679\a\x134\x2\x2\x678\x67A\a\x3B8\x2\x2\x679\x678\x3\x2\x2");
		sb.Append("\x2\x679\x67A\x3\x2\x2\x2\x67A\x67B\x3\x2\x2\x2\x67B\x6BD\a");
		sb.Append("\x3D0\x2\x2\x67C\x67E\a\x16A\x2\x2\x67D\x67F\a\x3B8\x2\x2\x67E");
		sb.Append("\x67D\x3\x2\x2\x2\x67E\x67F\x3\x2\x2\x2\x67F\x680\x3\x2\x2\x2");
		sb.Append("\x680\x6BD\t\x1A\x2\x2\x681\x683\a\x174\x2\x2\x682\x684\a\x3B8");
		sb.Append("\x2\x2\x683\x682\x3\x2\x2\x2\x683\x684\x3\x2\x2\x2\x684\x685");
		sb.Append("\x3\x2\x2\x2\x685\x6BD\x5\x20A\x106\x2\x686\x688\a\x195\x2\x2");
		sb.Append("\x687\x689\a\x3B8\x2\x2\x688\x687\x3\x2\x2\x2\x688\x689\x3\x2");
		sb.Append("\x2\x2\x689\x68A\x3\x2\x2\x2\x68A\x6BD\x5\x208\x105\x2\x68B");
		sb.Append("\x68D\a\x19D\x2\x2\x68C\x68E\a\x3B8\x2\x2\x68D\x68C\x3\x2\x2");
		sb.Append("\x2\x68D\x68E\x3\x2\x2\x2\x68E\x68F\x3\x2\x2\x2\x68F\x6BD\x5");
		sb.Append("\x208\x105\x2\x690\x692\a\x1B5\x2\x2\x691\x693\a\x3B8\x2\x2");
		sb.Append("\x692\x691\x3\x2\x2\x2\x692\x693\x3\x2\x2\x2\x693\x694\x3\x2");
		sb.Append("\x2\x2\x694\x6BD\t\x1B\x2\x2\x695\x697\a\x1BB\x2\x2\x696\x698");
		sb.Append("\a\x3B8\x2\x2\x697\x696\x3\x2\x2\x2\x697\x698\x3\x2\x2\x2\x698");
		sb.Append("\x699\x3\x2\x2\x2\x699\x6BD\a\x3D0\x2\x2\x69A\x69C\a\x1E6\x2");
		sb.Append("\x2\x69B\x69D\a\x3B8\x2\x2\x69C\x69B\x3\x2\x2\x2\x69C\x69D\x3");
		sb.Append("\x2\x2\x2\x69D\x69E\x3\x2\x2\x2\x69E\x6BD\t\x1C\x2\x2\x69F\x6A1");
		sb.Append("\a\x201\x2\x2\x6A0\x6A2\a\x3B8\x2\x2\x6A1\x6A0\x3\x2\x2\x2\x6A1");
		sb.Append("\x6A2\x3\x2\x2\x2\x6A2\x6A3\x3\x2\x2\x2\x6A3\x6BD\t\x1B\x2\x2");
		sb.Append("\x6A4\x6A6\a\x202\x2\x2\x6A5\x6A7\a\x3B8\x2\x2\x6A6\x6A5\x3");
		sb.Append("\x2\x2\x2\x6A6\x6A7\x3\x2\x2\x2\x6A7\x6A8\x3\x2\x2\x2\x6A8\x6BD");
		sb.Append("\t\x1B\x2\x2\x6A9\x6AB\a\x203\x2\x2\x6AA\x6AC\a\x3B8\x2\x2\x6AB");
		sb.Append("\x6AA\x3\x2\x2\x2\x6AB\x6AC\x3\x2\x2\x2\x6AC\x6AD\x3\x2\x2\x2");
		sb.Append("\x6AD\x6BD\x5\x208\x105\x2\x6AE\x6AF\a\x20F\x2\x2\x6AF\x6B1");
		sb.Append("\x5\x202\x102\x2\x6B0\x6B2\x5`\x31\x2\x6B1\x6B0\x3\x2\x2\x2");
		sb.Append("\x6B1\x6B2\x3\x2\x2\x2\x6B2\x6BD\x3\x2\x2\x2\x6B3\x6BD\x5`\x31");
		sb.Append("\x2\x6B4\x6B6\a\x9D\x2\x2\x6B5\x6B7\a\x3B8\x2\x2\x6B6\x6B5\x3");
		sb.Append("\x2\x2\x2\x6B6\x6B7\x3\x2\x2\x2\x6B7\x6B8\x3\x2\x2\x2\x6B8\x6B9");
		sb.Append("\a\x3C1\x2\x2\x6B9\x6BA\x5\x224\x113\x2\x6BA\x6BB\a\x3C2\x2");
		sb.Append("\x2\x6BB\x6BD\x3\x2\x2\x2\x6BC\x62F\x3\x2\x2\x2\x6BC\x634\x3");
		sb.Append("\x2\x2\x2\x6BC\x639\x3\x2\x2\x2\x6BC\x63F\x3\x2\x2\x2\x6BC\x64A");
		sb.Append("\x3\x2\x2\x2\x6BC\x650\x3\x2\x2\x2\x6BC\x657\x3\x2\x2\x2\x6BC");
		sb.Append("\x65C\x3\x2\x2\x2\x6BC\x661\x3\x2\x2\x2\x6BC\x666\x3\x2\x2\x2");
		sb.Append("\x6BC\x66C\x3\x2\x2\x2\x6BC\x671\x3\x2\x2\x2\x6BC\x676\x3\x2");
		sb.Append("\x2\x2\x6BC\x67C\x3\x2\x2\x2\x6BC\x681\x3\x2\x2\x2\x6BC\x686");
		sb.Append("\x3\x2\x2\x2\x6BC\x68B\x3\x2\x2\x2\x6BC\x690\x3\x2\x2\x2\x6BC");
		sb.Append("\x695\x3\x2\x2\x2\x6BC\x69A\x3\x2\x2\x2\x6BC\x69F\x3\x2\x2\x2");
		sb.Append("\x6BC\x6A4\x3\x2\x2\x2\x6BC\x6A9\x3\x2\x2\x2\x6BC\x6AE\x3\x2");
		sb.Append("\x2\x2\x6BC\x6B3\x3\x2\x2\x2\x6BC\x6B4\x3\x2\x2\x2\x6BD_\x3");
		sb.Append("\x2\x2\x2\x6BE\x6BF\a\x206\x2\x2\x6BF\x6C0\t\x12\x2\x2\x6C0");
		sb.Append("\x61\x3\x2\x2\x2\x6C1\x6C2\aq\x2\x2\x6C2\x6C3\a\x12\x2\x2\x6C3");
		sb.Append("\x6C6\x5\x64\x33\x2\x6C4\x6C5\a\x1BA\x2\x2\x6C5\x6C7\x5\x208");
		sb.Append("\x105\x2\x6C6\x6C4\x3\x2\x2\x2\x6C6\x6C7\x3\x2\x2\x2\x6C7\x6CF");
		sb.Append("\x3\x2\x2\x2\x6C8\x6C9\a\x20A\x2\x2\x6C9\x6CA\a\x12\x2\x2\x6CA");
		sb.Append("\x6CD\x5\x66\x34\x2\x6CB\x6CC\a\x20B\x2\x2\x6CC\x6CE\x5\x208");
		sb.Append("\x105\x2\x6CD\x6CB\x3\x2\x2\x2\x6CD\x6CE\x3\x2\x2\x2\x6CE\x6D0");
		sb.Append("\x3\x2\x2\x2\x6CF\x6C8\x3\x2\x2\x2\x6CF\x6D0\x3\x2\x2\x2\x6D0");
		sb.Append("\x6DC\x3\x2\x2\x2\x6D1\x6D2\a\x3C1\x2\x2\x6D2\x6D7\x5h\x35\x2");
		sb.Append("\x6D3\x6D4\a\x3C3\x2\x2\x6D4\x6D6\x5h\x35\x2\x6D5\x6D3\x3\x2");
		sb.Append("\x2\x2\x6D6\x6D9\x3\x2\x2\x2\x6D7\x6D5\x3\x2\x2\x2\x6D7\x6D8");
		sb.Append("\x3\x2\x2\x2\x6D8\x6DA\x3\x2\x2\x2\x6D9\x6D7\x3\x2\x2\x2\x6DA");
		sb.Append("\x6DB\a\x3C2\x2\x2\x6DB\x6DD\x3\x2\x2\x2\x6DC\x6D1\x3\x2\x2");
		sb.Append("\x2\x6DC\x6DD\x3\x2\x2\x2\x6DD\x63\x3\x2\x2\x2\x6DE\x6E0\aY");
		sb.Append("\x2\x2\x6DF\x6DE\x3\x2\x2\x2\x6DF\x6E0\x3\x2\x2\x2\x6E0\x6E1");
		sb.Append("\x3\x2\x2\x2\x6E1\x6E2\a\x160\x2\x2\x6E2\x6E3\a\x3C1\x2\x2\x6E3");
		sb.Append("\x6E4\x5\x250\x129\x2\x6E4\x6E5\a\x3C2\x2\x2\x6E5\x70C\x3\x2");
		sb.Append("\x2\x2\x6E6\x6E8\aY\x2\x2\x6E7\x6E6\x3\x2\x2\x2\x6E7\x6E8\x3");
		sb.Append("\x2\x2\x2\x6E8\x6E9\x3\x2\x2\x2\x6E9\x6ED\aQ\x2\x2\x6EA\x6EB");
		sb.Append("\a\x102\x2\x2\x6EB\x6EC\a\x3B8\x2\x2\x6EC\x6EE\t\x1D\x2\x2\x6ED");
		sb.Append("\x6EA\x3\x2\x2\x2\x6ED\x6EE\x3\x2\x2\x2\x6EE\x6EF\x3\x2\x2\x2");
		sb.Append("\x6EF\x6F0\a\x3C1\x2\x2\x6F0\x6F1\x5\x222\x112\x2\x6F1\x6F2");
		sb.Append("\a\x3C2\x2\x2\x6F2\x70C\x3\x2\x2\x2\x6F3\x6FD\au\x2\x2\x6F4");
		sb.Append("\x6F5\a\x3C1\x2\x2\x6F5\x6F6\x5\x250\x129\x2\x6F6\x6F7\a\x3C2");
		sb.Append("\x2\x2\x6F7\x6FE\x3\x2\x2\x2\x6F8\x6F9\a\x11D\x2\x2\x6F9\x6FA");
		sb.Append("\a\x3C1\x2\x2\x6FA\x6FB\x5\x222\x112\x2\x6FB\x6FC\a\x3C2\x2");
		sb.Append("\x2\x6FC\x6FE\x3\x2\x2\x2\x6FD\x6F4\x3\x2\x2\x2\x6FD\x6F8\x3");
		sb.Append("\x2\x2\x2\x6FE\x70C\x3\x2\x2\x2\x6FF\x709\a\x17A\x2\x2\x700");
		sb.Append("\x701\a\x3C1\x2\x2\x701\x702\x5\x250\x129\x2\x702\x703\a\x3C2");
		sb.Append("\x2\x2\x703\x70A\x3\x2\x2\x2\x704\x705\a\x11D\x2\x2\x705\x706");
		sb.Append("\a\x3C1\x2\x2\x706\x707\x5\x222\x112\x2\x707\x708\a\x3C2\x2");
		sb.Append("\x2\x708\x70A\x3\x2\x2\x2\x709\x700\x3\x2\x2\x2\x709\x704\x3");
		sb.Append("\x2\x2\x2\x70A\x70C\x3\x2\x2\x2\x70B\x6DF\x3\x2\x2\x2\x70B\x6E7");
		sb.Append("\x3\x2\x2\x2\x70B\x6F3\x3\x2\x2\x2\x70B\x6FF\x3\x2\x2\x2\x70C");
		sb.Append("\x65\x3\x2\x2\x2\x70D\x70F\aY\x2\x2\x70E\x70D\x3\x2\x2\x2\x70E");
		sb.Append("\x70F\x3\x2\x2\x2\x70F\x710\x3\x2\x2\x2\x710\x711\a\x160\x2");
		sb.Append("\x2\x711\x712\a\x3C1\x2\x2\x712\x713\x5\x250\x129\x2\x713\x714");
		sb.Append("\a\x3C2\x2\x2\x714\x723\x3\x2\x2\x2\x715\x717\aY\x2\x2\x716");
		sb.Append("\x715\x3\x2\x2\x2\x716\x717\x3\x2\x2\x2\x717\x718\x3\x2\x2\x2");
		sb.Append("\x718\x71C\aQ\x2\x2\x719\x71A\a\x102\x2\x2\x71A\x71B\a\x3B8");
		sb.Append("\x2\x2\x71B\x71D\t\x1D\x2\x2\x71C\x719\x3\x2\x2\x2\x71C\x71D");
		sb.Append("\x3\x2\x2\x2\x71D\x71E\x3\x2\x2\x2\x71E\x71F\a\x3C1\x2\x2\x71F");
		sb.Append("\x720\x5\x222\x112\x2\x720\x721\a\x3C2\x2\x2\x721\x723\x3\x2");
		sb.Append("\x2\x2\x722\x70E\x3\x2\x2\x2\x722\x716\x3\x2\x2\x2\x723g\x3");
		sb.Append("\x2\x2\x2\x724\x725\aq\x2\x2\x725\x726\x5\x202\x102\x2\x726");
		sb.Append("\x727\a\xA5\x2\x2\x727\x728\a\x178\x2\x2\x728\x729\a\x212\x2");
		sb.Append("\x2\x729\x72A\a\x3C1\x2\x2\x72A\x72F\x5j\x36\x2\x72B\x72C\a");
		sb.Append("\x3C3\x2\x2\x72C\x72E\x5j\x36\x2\x72D\x72B\x3\x2\x2\x2\x72E");
		sb.Append("\x731\x3\x2\x2\x2\x72F\x72D\x3\x2\x2\x2\x72F\x730\x3\x2\x2\x2");
		sb.Append("\x730\x732\x3\x2\x2\x2\x731\x72F\x3\x2\x2\x2\x732\x736\a\x3C2");
		sb.Append("\x2\x2\x733\x735\x5p\x39\x2\x734\x733\x3\x2\x2\x2\x735\x738");
		sb.Append("\x3\x2\x2\x2\x736\x734\x3\x2\x2\x2\x736\x737\x3\x2\x2\x2\x737");
		sb.Append("\x741\x3\x2\x2\x2\x738\x736\x3\x2\x2\x2\x739\x73E\x5n\x38\x2");
		sb.Append("\x73A\x73B\a\x3C3\x2\x2\x73B\x73D\x5n\x38\x2\x73C\x73A\x3\x2");
		sb.Append("\x2\x2\x73D\x740\x3\x2\x2\x2\x73E\x73C\x3\x2\x2\x2\x73E\x73F");
		sb.Append("\x3\x2\x2\x2\x73F\x742\x3\x2\x2\x2\x740\x73E\x3\x2\x2\x2\x741");
		sb.Append("\x739\x3\x2\x2\x2\x741\x742\x3\x2\x2\x2\x742\x7A8\x3\x2\x2\x2");
		sb.Append("\x743\x744\aq\x2\x2\x744\x745\x5\x202\x102\x2\x745\x746\a\xA5");
		sb.Append("\x2\x2\x746\x747\a\x178\x2\x2\x747\x748\a\x212\x2\x2\x748\x74C");
		sb.Append("\x5j\x36\x2\x749\x74B\x5p\x39\x2\x74A\x749\x3\x2\x2\x2\x74B");
		sb.Append("\x74E\x3\x2\x2\x2\x74C\x74A\x3\x2\x2\x2\x74C\x74D\x3\x2\x2\x2");
		sb.Append("\x74D\x757\x3\x2\x2\x2\x74E\x74C\x3\x2\x2\x2\x74F\x754\x5n\x38");
		sb.Append("\x2\x750\x751\a\x3C3\x2\x2\x751\x753\x5n\x38\x2\x752\x750\x3");
		sb.Append("\x2\x2\x2\x753\x756\x3\x2\x2\x2\x754\x752\x3\x2\x2\x2\x754\x755");
		sb.Append("\x3\x2\x2\x2\x755\x758\x3\x2\x2\x2\x756\x754\x3\x2\x2\x2\x757");
		sb.Append("\x74F\x3\x2\x2\x2\x757\x758\x3\x2\x2\x2\x758\x7A8\x3\x2\x2\x2");
		sb.Append("\x759\x75A\aq\x2\x2\x75A\x75B\x5\x202\x102\x2\x75B\x75C\a\xA5");
		sb.Append("\x2\x2\x75C\x75D\a\x46\x2\x2\x75D\x75E\a\x3C1\x2\x2\x75E\x763");
		sb.Append("\x5j\x36\x2\x75F\x760\a\x3C3\x2\x2\x760\x762\x5j\x36\x2\x761");
		sb.Append("\x75F\x3\x2\x2\x2\x762\x765\x3\x2\x2\x2\x763\x761\x3\x2\x2\x2");
		sb.Append("\x763\x764\x3\x2\x2\x2\x764\x766\x3\x2\x2\x2\x765\x763\x3\x2");
		sb.Append("\x2\x2\x766\x76A\a\x3C2\x2\x2\x767\x769\x5p\x39\x2\x768\x767");
		sb.Append("\x3\x2\x2\x2\x769\x76C\x3\x2\x2\x2\x76A\x768\x3\x2\x2\x2\x76A");
		sb.Append("\x76B\x3\x2\x2\x2\x76B\x775\x3\x2\x2\x2\x76C\x76A\x3\x2\x2\x2");
		sb.Append("\x76D\x772\x5n\x38\x2\x76E\x76F\a\x3C3\x2\x2\x76F\x771\x5n\x38");
		sb.Append("\x2\x770\x76E\x3\x2\x2\x2\x771\x774\x3\x2\x2\x2\x772\x770\x3");
		sb.Append("\x2\x2\x2\x772\x773\x3\x2\x2\x2\x773\x776\x3\x2\x2\x2\x774\x772");
		sb.Append("\x3\x2\x2\x2\x775\x76D\x3\x2\x2\x2\x775\x776\x3\x2\x2\x2\x776");
		sb.Append("\x7A8\x3\x2\x2\x2\x777\x778\aq\x2\x2\x778\x779\x5\x202\x102");
		sb.Append("\x2\x779\x77A\a\xA5\x2\x2\x77A\x77B\a\x46\x2\x2\x77B\x77C\a");
		sb.Append("\x3C1\x2\x2\x77C\x781\x5l\x37\x2\x77D\x77E\a\x3C3\x2\x2\x77E");
		sb.Append("\x780\x5l\x37\x2\x77F\x77D\x3\x2\x2\x2\x780\x783\x3\x2\x2\x2");
		sb.Append("\x781\x77F\x3\x2\x2\x2\x781\x782\x3\x2\x2\x2\x782\x784\x3\x2");
		sb.Append("\x2\x2\x783\x781\x3\x2\x2\x2\x784\x788\a\x3C2\x2\x2\x785\x787");
		sb.Append("\x5p\x39\x2\x786\x785\x3\x2\x2\x2\x787\x78A\x3\x2\x2\x2\x788");
		sb.Append("\x786\x3\x2\x2\x2\x788\x789\x3\x2\x2\x2\x789\x793\x3\x2\x2\x2");
		sb.Append("\x78A\x788\x3\x2\x2\x2\x78B\x790\x5n\x38\x2\x78C\x78D\a\x3C3");
		sb.Append("\x2\x2\x78D\x78F\x5n\x38\x2\x78E\x78C\x3\x2\x2\x2\x78F\x792");
		sb.Append("\x3\x2\x2\x2\x790\x78E\x3\x2\x2\x2\x790\x791\x3\x2\x2\x2\x791");
		sb.Append("\x794\x3\x2\x2\x2\x792\x790\x3\x2\x2\x2\x793\x78B\x3\x2\x2\x2");
		sb.Append("\x793\x794\x3\x2\x2\x2\x794\x7A8\x3\x2\x2\x2\x795\x796\aq\x2");
		sb.Append("\x2\x796\x79A\x5\x202\x102\x2\x797\x799\x5p\x39\x2\x798\x797");
		sb.Append("\x3\x2\x2\x2\x799\x79C\x3\x2\x2\x2\x79A\x798\x3\x2\x2\x2\x79A");
		sb.Append("\x79B\x3\x2\x2\x2\x79B\x7A5\x3\x2\x2\x2\x79C\x79A\x3\x2\x2\x2");
		sb.Append("\x79D\x7A2\x5n\x38\x2\x79E\x79F\a\x3C3\x2\x2\x79F\x7A1\x5n\x38");
		sb.Append("\x2\x7A0\x79E\x3\x2\x2\x2\x7A1\x7A4\x3\x2\x2\x2\x7A2\x7A0\x3");
		sb.Append("\x2\x2\x2\x7A2\x7A3\x3\x2\x2\x2\x7A3\x7A6\x3\x2\x2\x2\x7A4\x7A2");
		sb.Append("\x3\x2\x2\x2\x7A5\x79D\x3\x2\x2\x2\x7A5\x7A6\x3\x2\x2\x2\x7A6");
		sb.Append("\x7A8\x3\x2\x2\x2\x7A7\x724\x3\x2\x2\x2\x7A7\x743\x3\x2\x2\x2");
		sb.Append("\x7A7\x759\x3\x2\x2\x2\x7A7\x777\x3\x2\x2\x2\x7A7\x795\x3\x2");
		sb.Append("\x2\x2\x7A8i\x3\x2\x2\x2\x7A9\x7AD\x5\x214\x10B\x2\x7AA\x7AD");
		sb.Append("\x5\x250\x129\x2\x7AB\x7AD\a\x62\x2\x2\x7AC\x7A9\x3\x2\x2\x2");
		sb.Append("\x7AC\x7AA\x3\x2\x2\x2\x7AC\x7AB\x3\x2\x2\x2\x7ADk\x3\x2\x2");
		sb.Append("\x2\x7AE\x7AF\a\x3C1\x2\x2\x7AF\x7B2\x5j\x36\x2\x7B0\x7B1\a");
		sb.Append("\x3C3\x2\x2\x7B1\x7B3\x5j\x36\x2\x7B2\x7B0\x3\x2\x2\x2\x7B3");
		sb.Append("\x7B4\x3\x2\x2\x2\x7B4\x7B2\x3\x2\x2\x2\x7B4\x7B5\x3\x2\x2\x2");
		sb.Append("\x7B5\x7B6\x3\x2\x2\x2\x7B6\x7B7\a\x3C2\x2\x2\x7B7m\x3\x2\x2");
		sb.Append("\x2\x7B8\x7B9\a\x20A\x2\x2\x7B9\x7BD\x5\x202\x102\x2\x7BA\x7BC");
		sb.Append("\x5p\x39\x2\x7BB\x7BA\x3\x2\x2\x2\x7BC\x7BF\x3\x2\x2\x2\x7BD");
		sb.Append("\x7BB\x3\x2\x2\x2\x7BD\x7BE\x3\x2\x2\x2\x7BEo\x3\x2\x2\x2\x7BF");
		sb.Append("\x7BD\x3\x2\x2\x2\x7C0\x7C2\a\x206\x2\x2\x7C1\x7C0\x3\x2\x2");
		sb.Append("\x2\x7C1\x7C2\x3\x2\x2\x2\x7C2\x7C3\x3\x2\x2\x2\x7C3\x7C5\a");
		sb.Append("\x140\x2\x2\x7C4\x7C6\a\x3B8\x2\x2\x7C5\x7C4\x3\x2\x2\x2\x7C5");
		sb.Append("\x7C6\x3\x2\x2\x2\x7C6\x7C7\x3\x2\x2\x2\x7C7\x7EE\x5\x1F8\xFD");
		sb.Append("\x2\x7C8\x7CA\a\x11F\x2\x2\x7C9\x7CB\a\x3B8\x2\x2\x7CA\x7C9");
		sb.Append("\x3\x2\x2\x2\x7CA\x7CB\x3\x2\x2\x2\x7CB\x7CC\x3\x2\x2\x2\x7CC");
		sb.Append("\x7EE\a\x3D0\x2\x2\x7CD\x7CE\a\x12D\x2\x2\x7CE\x7D0\a\x134\x2");
		sb.Append("\x2\x7CF\x7D1\a\x3B8\x2\x2\x7D0\x7CF\x3\x2\x2\x2\x7D0\x7D1\x3");
		sb.Append("\x2\x2\x2\x7D1\x7D2\x3\x2\x2\x2\x7D2\x7EE\a\x3D0\x2\x2\x7D3");
		sb.Append("\x7D4\aG\x2\x2\x7D4\x7D6\a\x134\x2\x2\x7D5\x7D7\a\x3B8\x2\x2");
		sb.Append("\x7D6\x7D5\x3\x2\x2\x2\x7D6\x7D7\x3\x2\x2\x2\x7D7\x7D8\x3\x2");
		sb.Append("\x2\x2\x7D8\x7EE\a\x3D0\x2\x2\x7D9\x7DB\a\x195\x2\x2\x7DA\x7DC");
		sb.Append("\a\x3B8\x2\x2\x7DB\x7DA\x3\x2\x2\x2\x7DB\x7DC\x3\x2\x2\x2\x7DC");
		sb.Append("\x7DD\x3\x2\x2\x2\x7DD\x7EE\x5\x208\x105\x2\x7DE\x7E0\a\x19D");
		sb.Append("\x2\x2\x7DF\x7E1\a\x3B8\x2\x2\x7E0\x7DF\x3\x2\x2\x2\x7E0\x7E1");
		sb.Append("\x3\x2\x2\x2\x7E1\x7E2\x3\x2\x2\x2\x7E2\x7EE\x5\x208\x105\x2");
		sb.Append("\x7E3\x7E5\a\x20F\x2\x2\x7E4\x7E6\a\x3B8\x2\x2\x7E5\x7E4\x3");
		sb.Append("\x2\x2\x2\x7E5\x7E6\x3\x2\x2\x2\x7E6\x7E7\x3\x2\x2\x2\x7E7\x7EE");
		sb.Append("\x5\x202\x102\x2\x7E8\x7EA\a\x1A8\x2\x2\x7E9\x7EB\a\x3B8\x2");
		sb.Append("\x2\x7EA\x7E9\x3\x2\x2\x2\x7EA\x7EB\x3\x2\x2\x2\x7EB\x7EC\x3");
		sb.Append("\x2\x2\x2\x7EC\x7EE\x5\x202\x102\x2\x7ED\x7C1\x3\x2\x2\x2\x7ED");
		sb.Append("\x7C8\x3\x2\x2\x2\x7ED\x7CD\x3\x2\x2\x2\x7ED\x7D3\x3\x2\x2\x2");
		sb.Append("\x7ED\x7D9\x3\x2\x2\x2\x7ED\x7DE\x3\x2\x2\x2\x7ED\x7E3\x3\x2");
		sb.Append("\x2\x2\x7ED\x7E8\x3\x2\x2\x2\x7EEq\x3\x2\x2\x2\x7EF\x7F0\a\t");
		sb.Append("\x2\x2\x7F0\x7F2\t\x2\x2\x2\x7F1\x7F3\x5\x202\x102\x2\x7F2\x7F1");
		sb.Append("\x3\x2\x2\x2\x7F2\x7F3\x3\x2\x2\x2\x7F3\x7F5\x3\x2\x2\x2\x7F4");
		sb.Append("\x7F6\x5\x32\x1A\x2\x7F5\x7F4\x3\x2\x2\x2\x7F6\x7F7\x3\x2\x2");
		sb.Append("\x2\x7F7\x7F5\x3\x2\x2\x2\x7F7\x7F8\x3\x2\x2\x2\x7F8\x802\x3");
		sb.Append("\x2\x2\x2\x7F9\x7FA\a\t\x2\x2\x7FA\x7FB\t\x2\x2\x2\x7FB\x7FC");
		sb.Append("\x5\x202\x102\x2\x7FC\x7FD\a\x21D\x2\x2\x7FD\x7FE\a\x12D\x2");
		sb.Append("\x2\x7FE\x7FF\a\x134\x2\x2\x7FF\x800\a\x1A2\x2\x2\x800\x802");
		sb.Append("\x3\x2\x2\x2\x801\x7EF\x3\x2\x2\x2\x801\x7F9\x3\x2\x2\x2\x802");
		sb.Append("s\x3\x2\x2\x2\x803\x805\a\t\x2\x2\x804\x806\x5\x34\x1B\x2\x805");
		sb.Append("\x804\x3\x2\x2\x2\x805\x806\x3\x2\x2\x2\x806\x807\x3\x2\x2\x2");
		sb.Append("\x807\x808\a\x146\x2\x2\x808\x80C\x5\x1E8\xF5\x2\x809\x80A\a");
		sb.Append("h\x2\x2\x80A\x80B\a\x1E8\x2\x2\x80B\x80D\x5\x36\x1C\x2\x80C");
		sb.Append("\x809\x3\x2\x2\x2\x80C\x80D\x3\x2\x2\x2\x80D\x814\x3\x2\x2\x2");
		sb.Append("\x80E\x80F\ah\x2\x2\x80F\x811\a\x122\x2\x2\x810\x812\a\x65\x2");
		sb.Append("\x2\x811\x810\x3\x2\x2\x2\x811\x812\x3\x2\x2\x2\x812\x813\x3");
		sb.Append("\x2\x2\x2\x813\x815\a\x1C3\x2\x2\x814\x80E\x3\x2\x2\x2\x814");
		sb.Append("\x815\x3\x2\x2\x2\x815\x819\x3\x2\x2\x2\x816\x817\a{\x2\x2\x817");
		sb.Append("\x818\a\x98\x2\x2\x818\x81A\x5\x1E8\xF5\x2\x819\x816\x3\x2\x2");
		sb.Append("\x2\x819\x81A\x3\x2\x2\x2\x81A\x81C\x3\x2\x2\x2\x81B\x81D\x5");
		sb.Append("> \x2\x81C\x81B\x3\x2\x2\x2\x81C\x81D\x3\x2\x2\x2\x81D\x820");
		sb.Append("\x3\x2\x2\x2\x81E\x81F\a\x11F\x2\x2\x81F\x821\a\x3D0\x2\x2\x820");
		sb.Append("\x81E\x3\x2\x2\x2\x820\x821\x3\x2\x2\x2\x821\x824\x3\x2\x2\x2");
		sb.Append("\x822\x823\a\x138\x2\x2\x823\x825\x5\x15A\xAE\x2\x824\x822\x3");
		sb.Append("\x2\x2\x2\x824\x825\x3\x2\x2\x2\x825u\x3\x2\x2\x2\x826\x827");
		sb.Append("\a\t\x2\x2\x827\x828\a\x15A\x2\x2\x828\x82C\x5\x1E8\xF5\x2\x829");
		sb.Append("\x82B\x5H%\x2\x82A\x829\x3\x2\x2\x2\x82B\x82E\x3\x2\x2\x2\x82C");
		sb.Append("\x82A\x3\x2\x2\x2\x82C\x82D\x3\x2\x2\x2\x82Dw\x3\x2\x2\x2\x82E");
		sb.Append("\x82C\x3\x2\x2\x2\x82F\x830\a\t\x2\x2\x830\x831\a\x16C\x2\x2");
		sb.Append("\x831\x832\a\x1E3\x2\x2\x832\x833\a\x270\x2\x2\x833\x834\a\x17E");
		sb.Append("\x2\x2\x834\x835\aQ\x2\x2\x835y\x3\x2\x2\x2\x836\x837\a\t\x2");
		sb.Append("\x2\x837\x838\a\x17C\x2\x2\x838\x839\a\x41\x2\x2\x839\x83A\x5");
		sb.Append("\x202\x102\x2\x83A\x83B\a\a\x2\x2\x83B\x83C\a\x218\x2\x2\x83C");
		sb.Append("\x842\a\x3D0\x2\x2\x83D\x83F\a\x168\x2\x2\x83E\x840\a\x3B8\x2");
		sb.Append("\x2\x83F\x83E\x3\x2\x2\x2\x83F\x840\x3\x2\x2\x2\x840\x841\x3");
		sb.Append("\x2\x2\x2\x841\x843\x5\x20A\x106\x2\x842\x83D\x3\x2\x2\x2\x842");
		sb.Append("\x843\x3\x2\x2\x2\x843\x845\x3\x2\x2\x2\x844\x846\a\x226\x2");
		sb.Append("\x2\x845\x844\x3\x2\x2\x2\x845\x846\x3\x2\x2\x2\x846\x847\x3");
		sb.Append("\x2\x2\x2\x847\x849\a\x140\x2\x2\x848\x84A\a\x3B8\x2\x2\x849");
		sb.Append("\x848\x3\x2\x2\x2\x849\x84A\x3\x2\x2\x2\x84A\x84B\x3\x2\x2\x2");
		sb.Append("\x84B\x84C\x5\x1F8\xFD\x2\x84C{\x3\x2\x2\x2\x84D\x84E\a\t\x2");
		sb.Append("\x2\x84E\x84F\as\x2\x2\x84F\x853\x5\x1E8\xF5\x2\x850\x852\x5");
		sb.Append("H%\x2\x851\x850\x3\x2\x2\x2\x852\x855\x3\x2\x2\x2\x853\x851");
		sb.Append("\x3\x2\x2\x2\x853\x854\x3\x2\x2\x2\x854}\x3\x2\x2\x2\x855\x853");
		sb.Append("\x3\x2\x2\x2\x856\x857\a\t\x2\x2\x857\x858\a\x1EA\x2\x2\x858");
		sb.Append("\x859\x5\x202\x102\x2\x859\x85A\a\x1B3\x2\x2\x85A\x85B\a\x3C1");
		sb.Append("\x2\x2\x85B\x860\x5J&\x2\x85C\x85D\a\x3C3\x2\x2\x85D\x85F\x5");
		sb.Append("J&\x2\x85E\x85C\x3\x2\x2\x2\x85F\x862\x3\x2\x2\x2\x860\x85E");
		sb.Append("\x3\x2\x2\x2\x860\x861\x3\x2\x2\x2\x861\x863\x3\x2\x2\x2\x862");
		sb.Append("\x860\x3\x2\x2\x2\x863\x864\a\x3C2\x2\x2\x864\x7F\x3\x2\x2\x2");
		sb.Append("\x865\x867\a\t\x2\x2\x866\x868\t\x3\x2\x2\x867\x866\x3\x2\x2");
		sb.Append("\x2\x867\x868\x3\x2\x2\x2\x868\x86A\x3\x2\x2\x2\x869\x86B\a");
		sb.Append("\x45\x2\x2\x86A\x869\x3\x2\x2\x2\x86A\x86B\x3\x2\x2\x2\x86B");
		sb.Append("\x86C\x3\x2\x2\x2\x86C\x86D\a\x95\x2\x2\x86D\x876\x5\x1EA\xF6");
		sb.Append("\x2\x86E\x873\x5\x86\x44\x2\x86F\x870\a\x3C3\x2\x2\x870\x872");
		sb.Append("\x5\x86\x44\x2\x871\x86F\x3\x2\x2\x2\x872\x875\x3\x2\x2\x2\x873");
		sb.Append("\x871\x3\x2\x2\x2\x873\x874\x3\x2\x2\x2\x874\x877\x3\x2\x2\x2");
		sb.Append("\x875\x873\x3\x2\x2\x2\x876\x86E\x3\x2\x2\x2\x876\x877\x3\x2");
		sb.Append("\x2\x2\x877\x879\x3\x2\x2\x2\x878\x87A\x5\x62\x32\x2\x879\x878");
		sb.Append("\x3\x2\x2\x2\x879\x87A\x3\x2\x2\x2\x87A\x81\x3\x2\x2\x2\x87B");
		sb.Append("\x87C\a\t\x2\x2\x87C\x87D\a\x20F\x2\x2\x87D\x87E\x5\x202\x102");
		sb.Append("\x2\x87E\x87F\t\x1E\x2\x2\x87F\x880\a\x12E\x2\x2\x880\x884\a");
		sb.Append("\x3D0\x2\x2\x881\x882\a\x168\x2\x2\x882\x883\a\x3B8\x2\x2\x883");
		sb.Append("\x885\x5\x20A\x106\x2\x884\x881\x3\x2\x2\x2\x884\x885\x3\x2");
		sb.Append("\x2\x2\x885\x887\x3\x2\x2\x2\x886\x888\a\x226\x2\x2\x887\x886");
		sb.Append("\x3\x2\x2\x2\x887\x888\x3\x2\x2\x2\x888\x889\x3\x2\x2\x2\x889");
		sb.Append("\x88B\a\x140\x2\x2\x88A\x88C\a\x3B8\x2\x2\x88B\x88A\x3\x2\x2");
		sb.Append("\x2\x88B\x88C\x3\x2\x2\x2\x88C\x88D\x3\x2\x2\x2\x88D\x88E\x5");
		sb.Append("\x1F8\xFD\x2\x88E\x83\x3\x2\x2\x2\x88F\x893\a\t\x2\x2\x890\x891");
		sb.Append("\a\x102\x2\x2\x891\x892\a\x3B8\x2\x2\x892\x894\t\f\x2\x2\x893");
		sb.Append("\x890\x3\x2\x2\x2\x893\x894\x3\x2\x2\x2\x894\x896\x3\x2\x2\x2");
		sb.Append("\x895\x897\x5\x34\x1B\x2\x896\x895\x3\x2\x2\x2\x896\x897\x3");
		sb.Append("\x2\x2\x2\x897\x89B\x3\x2\x2\x2\x898\x899\a\x8B\x2\x2\x899\x89A");
		sb.Append("\a\x1E9\x2\x2\x89A\x89C\t\r\x2\x2\x89B\x898\x3\x2\x2\x2\x89B");
		sb.Append("\x89C\x3\x2\x2\x2\x89C\x89D\x3\x2\x2\x2\x89D\x89E\a\x224\x2");
		sb.Append("\x2\x89E\x8A3\x5\x1E8\xF5\x2\x89F\x8A0\a\x3C1\x2\x2\x8A0\x8A1");
		sb.Append("\x5\x222\x112\x2\x8A1\x8A2\a\x3C2\x2\x2\x8A2\x8A4\x3\x2\x2\x2");
		sb.Append("\x8A3\x89F\x3\x2\x2\x2\x8A3\x8A4\x3\x2\x2\x2\x8A4\x8A5\x3\x2");
		sb.Append("\x2\x2\x8A5\x8A6\a\r\x2\x2\x8A6\x8AD\x5\xB4[\x2\x8A7\x8A9\a");
		sb.Append("\xA9\x2\x2\x8A8\x8AA\t\xE\x2\x2\x8A9\x8A8\x3\x2\x2\x2\x8A9\x8AA");
		sb.Append("\x3\x2\x2\x2\x8AA\x8AB\x3\x2\x2\x2\x8AB\x8AC\a\x19\x2\x2\x8AC");
		sb.Append("\x8AE\aj\x2\x2\x8AD\x8A7\x3\x2\x2\x2\x8AD\x8AE\x3\x2\x2\x2\x8AE");
		sb.Append("\x85\x3\x2\x2\x2\x8AF\x8B6\x5^\x30\x2\x8B0\x8B2\a\x3C3\x2\x2");
		sb.Append("\x8B1\x8B0\x3\x2\x2\x2\x8B1\x8B2\x3\x2\x2\x2\x8B2\x8B3\x3\x2");
		sb.Append("\x2\x2\x8B3\x8B5\x5^\x30\x2\x8B4\x8B1\x3\x2\x2\x2\x8B5\x8B8");
		sb.Append("\x3\x2\x2\x2\x8B6\x8B4\x3\x2\x2\x2\x8B6\x8B7\x3\x2\x2\x2\x8B7");
		sb.Append("\xA13\x3\x2\x2\x2\x8B8\x8B6\x3\x2\x2\x2\x8B9\x8BB\a\a\x2\x2");
		sb.Append("\x8BA\x8BC\a\x1B\x2\x2\x8BB\x8BA\x3\x2\x2\x2\x8BB\x8BC\x3\x2");
		sb.Append("\x2\x2\x8BC\x8BD\x3\x2\x2\x2\x8BD\x8BE\x5\x202\x102\x2\x8BE");
		sb.Append("\x8C2\x5P)\x2\x8BF\x8C3\a\x154\x2\x2\x8C0\x8C1\a\x100\x2\x2");
		sb.Append("\x8C1\x8C3\x5\x202\x102\x2\x8C2\x8BF\x3\x2\x2\x2\x8C2\x8C0\x3");
		sb.Append("\x2\x2\x2\x8C2\x8C3\x3\x2\x2\x2\x8C3\xA13\x3\x2\x2\x2\x8C4\x8C6");
		sb.Append("\a\a\x2\x2\x8C5\x8C7\a\x1B\x2\x2\x8C6\x8C5\x3\x2\x2\x2\x8C6");
		sb.Append("\x8C7\x3\x2\x2\x2\x8C7\x8C8\x3\x2\x2\x2\x8C8\x8C9\a\x3C1\x2");
		sb.Append("\x2\x8C9\x8CA\x5\x202\x102\x2\x8CA\x8D1\x5P)\x2\x8CB\x8CC\a");
		sb.Append("\x3C3\x2\x2\x8CC\x8CD\x5\x202\x102\x2\x8CD\x8CE\x5P)\x2\x8CE");
		sb.Append("\x8D0\x3\x2\x2\x2\x8CF\x8CB\x3\x2\x2\x2\x8D0\x8D3\x3\x2\x2\x2");
		sb.Append("\x8D1\x8CF\x3\x2\x2\x2\x8D1\x8D2\x3\x2\x2\x2\x8D2\x8D4\x3\x2");
		sb.Append("\x2\x2\x8D3\x8D1\x3\x2\x2\x2\x8D4\x8D5\a\x3C2\x2\x2\x8D5\xA13");
		sb.Append("\x3\x2\x2\x2\x8D6\x8D7\a\a\x2\x2\x8D7\x8D9\t\x14\x2\x2\x8D8");
		sb.Append("\x8DA\x5\x202\x102\x2\x8D9\x8D8\x3\x2\x2\x2\x8D9\x8DA\x3\x2");
		sb.Append("\x2\x2\x8DA\x8DC\x3\x2\x2\x2\x8DB\x8DD\x5@!\x2\x8DC\x8DB\x3");
		sb.Append("\x2\x2\x2\x8DC\x8DD\x3\x2\x2\x2\x8DD\x8DE\x3\x2\x2\x2\x8DE\x8E2");
		sb.Append("\x5\x226\x114\x2\x8DF\x8E1\x5\x42\"\x2\x8E0\x8DF\x3\x2\x2\x2");
		sb.Append("\x8E1\x8E4\x3\x2\x2\x2\x8E2\x8E0\x3\x2\x2\x2\x8E2\x8E3\x3\x2");
		sb.Append("\x2\x2\x8E3\xA13\x3\x2\x2\x2\x8E4\x8E2\x3\x2\x2\x2\x8E5\x8EA");
		sb.Append("\a\a\x2\x2\x8E6\x8E8\a\x1D\x2\x2\x8E7\x8E9\x5\x202\x102\x2\x8E8");
		sb.Append("\x8E7\x3\x2\x2\x2\x8E8\x8E9\x3\x2\x2\x2\x8E9\x8EB\x3\x2\x2\x2");
		sb.Append("\x8EA\x8E6\x3\x2\x2\x2\x8EA\x8EB\x3\x2\x2\x2\x8EB\x8EC\x3\x2");
		sb.Append("\x2\x2\x8EC\x8ED\ar\x2\x2\x8ED\x8EF\aQ\x2\x2\x8EE\x8F0\x5@!");
		sb.Append("\x2\x8EF\x8EE\x3\x2\x2\x2\x8EF\x8F0\x3\x2\x2\x2\x8F0\x8F1\x3");
		sb.Append("\x2\x2\x2\x8F1\x8F5\x5\x226\x114\x2\x8F2\x8F4\x5\x42\"\x2\x8F3");
		sb.Append("\x8F2\x3\x2\x2\x2\x8F4\x8F7\x3\x2\x2\x2\x8F5\x8F3\x3\x2\x2\x2");
		sb.Append("\x8F5\x8F6\x3\x2\x2\x2\x8F6\xA13\x3\x2\x2\x2\x8F7\x8F5\x3\x2");
		sb.Append("\x2\x2\x8F8\x8FD\a\a\x2\x2\x8F9\x8FB\a\x1D\x2\x2\x8FA\x8FC\x5");
		sb.Append("\x202\x102\x2\x8FB\x8FA\x3\x2\x2\x2\x8FB\x8FC\x3\x2\x2\x2\x8FC");
		sb.Append("\x8FE\x3\x2\x2\x2\x8FD\x8F9\x3\x2\x2\x2\x8FD\x8FE\x3\x2\x2\x2");
		sb.Append("\x8FE\x8FF\x3\x2\x2\x2\x8FF\x901\a\x9E\x2\x2\x900\x902\t\x14");
		sb.Append("\x2\x2\x901\x900\x3\x2\x2\x2\x901\x902\x3\x2\x2\x2\x902\x904");
		sb.Append("\x3\x2\x2\x2\x903\x905\x5\x202\x102\x2\x904\x903\x3\x2\x2\x2");
		sb.Append("\x904\x905\x3\x2\x2\x2\x905\x907\x3\x2\x2\x2\x906\x908\x5@!");
		sb.Append("\x2\x907\x906\x3\x2\x2\x2\x907\x908\x3\x2\x2\x2\x908\x909\x3");
		sb.Append("\x2\x2\x2\x909\x90D\x5\x226\x114\x2\x90A\x90C\x5\x42\"\x2\x90B");
		sb.Append("\x90A\x3\x2\x2\x2\x90C\x90F\x3\x2\x2\x2\x90D\x90B\x3\x2\x2\x2");
		sb.Append("\x90D\x90E\x3\x2\x2\x2\x90E\xA13\x3\x2\x2\x2\x90F\x90D\x3\x2");
		sb.Append("\x2\x2\x910\x911\a\a\x2\x2\x911\x913\t\x16\x2\x2\x912\x914\t");
		sb.Append("\x14\x2\x2\x913\x912\x3\x2\x2\x2\x913\x914\x3\x2\x2\x2\x914");
		sb.Append("\x916\x3\x2\x2\x2\x915\x917\x5\x202\x102\x2\x916\x915\x3\x2");
		sb.Append("\x2\x2\x916\x917\x3\x2\x2\x2\x917\x918\x3\x2\x2\x2\x918\x91C");
		sb.Append("\x5\x226\x114\x2\x919\x91B\x5\x42\"\x2\x91A\x919\x3\x2\x2\x2");
		sb.Append("\x91B\x91E\x3\x2\x2\x2\x91C\x91A\x3\x2\x2\x2\x91C\x91D\x3\x2");
		sb.Append("\x2\x2\x91D\xA13\x3\x2\x2\x2\x91E\x91C\x3\x2\x2\x2\x91F\x924");
		sb.Append("\a\a\x2\x2\x920\x922\a\x1D\x2\x2\x921\x923\x5\x202\x102\x2\x922");
		sb.Append("\x921\x3\x2\x2\x2\x922\x923\x3\x2\x2\x2\x923\x925\x3\x2\x2\x2");
		sb.Append("\x924\x920\x3\x2\x2\x2\x924\x925\x3\x2\x2\x2\x925\x926\x3\x2");
		sb.Append("\x2\x2\x926\x927\a<\x2\x2\x927\x929\aQ\x2\x2\x928\x92A\x5\x202");
		sb.Append("\x102\x2\x929\x928\x3\x2\x2\x2\x929\x92A\x3\x2\x2\x2\x92A\x92B");
		sb.Append("\x3\x2\x2\x2\x92B\x92C\x5\x226\x114\x2\x92C\x92D\x5V,\x2\x92D");
		sb.Append("\xA13\x3\x2\x2\x2\x92E\x933\a\a\x2\x2\x92F\x931\a\x1D\x2\x2");
		sb.Append("\x930\x932\x5\x202\x102\x2\x931\x930\x3\x2\x2\x2\x931\x932\x3");
		sb.Append("\x2\x2\x2\x932\x934\x3\x2\x2\x2\x933\x92F\x3\x2\x2\x2\x933\x934");
		sb.Append("\x3\x2\x2\x2\x934\x935\x3\x2\x2\x2\x935\x936\a\x19\x2\x2\x936");
		sb.Append("\x937\a\x3C1\x2\x2\x937\x938\x5\x250\x129\x2\x938\x939\a\x3C2");
		sb.Append("\x2\x2\x939\xA13\x3\x2\x2\x2\x93A\x93C\a\x102\x2\x2\x93B\x93D");
		sb.Append("\a\x3B8\x2\x2\x93C\x93B\x3\x2\x2\x2\x93C\x93D\x3\x2\x2\x2\x93D");
		sb.Append("\x93E\x3\x2\x2\x2\x93E\xA13\t\x5\x2\x2\x93F\x941\a\t\x2\x2\x940");
		sb.Append("\x942\a\x1B\x2\x2\x941\x940\x3\x2\x2\x2\x941\x942\x3\x2\x2\x2");
		sb.Append("\x942\x943\x3\x2\x2\x2\x943\x949\x5\x202\x102\x2\x944\x945\a");
		sb.Append("\x87\x2\x2\x945\x946\a\'\x2\x2\x946\x94A\x5\x232\x11A\x2\x947");
		sb.Append("\x948\a/\x2\x2\x948\x94A\a\'\x2\x2\x949\x944\x3\x2\x2\x2\x949");
		sb.Append("\x947\x3\x2\x2\x2\x94A\xA13\x3\x2\x2\x2\x94B\x94D\a\x17\x2\x2");
		sb.Append("\x94C\x94E\a\x1B\x2\x2\x94D\x94C\x3\x2\x2\x2\x94D\x94E\x3\x2");
		sb.Append("\x2\x2\x94E\x94F\x3\x2\x2\x2\x94F\x950\x5\x202\x102\x2\x950");
		sb.Append("\x951\x5\x202\x102\x2\x951\x955\x5P)\x2\x952\x956\a\x154\x2");
		sb.Append("\x2\x953\x954\a\x100\x2\x2\x954\x956\x5\x202\x102\x2\x955\x952");
		sb.Append("\x3\x2\x2\x2\x955\x953\x3\x2\x2\x2\x955\x956\x3\x2\x2\x2\x956");
		sb.Append("\xA13\x3\x2\x2\x2\x957\x958\a{\x2\x2\x958\x959\a\x1B\x2\x2\x959");
		sb.Append("\x95A\x5\x202\x102\x2\x95A\x95B\a\x98\x2\x2\x95B\x95C\x5\x202");
		sb.Append("\x102\x2\x95C\xA13\x3\x2\x2\x2\x95D\x95F\a\\\x2\x2\x95E\x960");
		sb.Append("\a\x3B8\x2\x2\x95F\x95E\x3\x2\x2\x2\x95F\x960\x3\x2\x2\x2\x960");
		sb.Append("\x961\x3\x2\x2\x2\x961\xA13\t\x6\x2\x2\x962\x964\a\x19F\x2\x2");
		sb.Append("\x963\x965\a\x1B\x2\x2\x964\x963\x3\x2\x2\x2\x964\x965\x3\x2");
		sb.Append("\x2\x2\x965\x966\x3\x2\x2\x2\x966\x967\x5\x202\x102\x2\x967");
		sb.Append("\x96B\x5P)\x2\x968\x96C\a\x154\x2\x2\x969\x96A\a\x100\x2\x2");
		sb.Append("\x96A\x96C\x5\x202\x102\x2\x96B\x968\x3\x2\x2\x2\x96B\x969\x3");
		sb.Append("\x2\x2\x2\x96B\x96C\x3\x2\x2\x2\x96C\xA13\x3\x2\x2\x2\x96D\x96F");
		sb.Append("\a/\x2\x2\x96E\x970\a\x1B\x2\x2\x96F\x96E\x3\x2\x2\x2\x96F\x970");
		sb.Append("\x3\x2\x2\x2\x970\x971\x3\x2\x2\x2\x971\x973\x5\x202\x102\x2");
		sb.Append("\x972\x974\a\x7F\x2\x2\x973\x972\x3\x2\x2\x2\x973\x974\x3\x2");
		sb.Append("\x2\x2\x974\xA13\x3\x2\x2\x2\x975\x976\a/\x2\x2\x976\x977\a");
		sb.Append("r\x2\x2\x977\xA13\aQ\x2\x2\x978\x979\a{\x2\x2\x979\x97A\t\x14");
		sb.Append("\x2\x2\x97A\x97B\x5\x202\x102\x2\x97B\x97C\a\x98\x2\x2\x97C");
		sb.Append("\x97D\x5\x202\x102\x2\x97D\xA13\x3\x2\x2\x2\x97E\x97F\a/\x2");
		sb.Append("\x2\x97F\x980\t\x14\x2\x2\x980\xA13\x5\x202\x102\x2\x981\x982");
		sb.Append("\a/\x2\x2\x982\x983\a<\x2\x2\x983\x984\aQ\x2\x2\x984\xA13\x5");
		sb.Append("\x202\x102\x2\x985\x986\a\x135\x2\x2\x986\xA13\aR\x2\x2\x987");
		sb.Append("\x988\a\x13C\x2\x2\x988\xA13\aR\x2\x2\x989\x98B\a{\x2\x2\x98A");
		sb.Append("\x98C\t\x1F\x2\x2\x98B\x98A\x3\x2\x2\x2\x98B\x98C\x3\x2\x2\x2");
		sb.Append("\x98C\x98F\x3\x2\x2\x2\x98D\x990\x5\x202\x102\x2\x98E\x990\x5");
		sb.Append("\x1E8\xF5\x2\x98F\x98D\x3\x2\x2\x2\x98F\x98E\x3\x2\x2\x2\x990");
		sb.Append("\xA13\x3\x2\x2\x2\x991\x992\am\x2\x2\x992\x993\a\x12\x2\x2\x993");
		sb.Append("\xA13\x5\x222\x112\x2\x994\x995\a\x1F\x2\x2\x995\x996\a\x98");
		sb.Append("\x2\x2\x996\x997\a\x18\x2\x2\x997\x998\a\x87\x2\x2\x998\x99B");
		sb.Append("\x5\x1F4\xFB\x2\x999\x99A\a\x1A\x2\x2\x99A\x99C\x5\x1F6\xFC");
		sb.Append("\x2\x99B\x999\x3\x2\x2\x2\x99B\x99C\x3\x2\x2\x2\x99C\xA13\x3");
		sb.Append("\x2\x2\x2\x99D\x99F\a\'\x2\x2\x99E\x99D\x3\x2\x2\x2\x99E\x99F");
		sb.Append("\x3\x2\x2\x2\x99F\x9A0\x3\x2\x2\x2\x9A0\x9A1\a\x18\x2\x2\x9A1");
		sb.Append("\x9A2\a\x87\x2\x2\x9A2\x9A3\a\x3B8\x2\x2\x9A3\x9A7\x5\x1F4\xFB");
		sb.Append("\x2\x9A4\x9A5\a\x1A\x2\x2\x9A5\x9A6\a\x3B8\x2\x2\x9A6\x9A8\x5");
		sb.Append("\x1F6\xFC\x2\x9A7\x9A4\x3\x2\x2\x2\x9A7\x9A8\x3\x2\x2\x2\x9A8");
		sb.Append("\xA13\x3\x2\x2\x2\x9A9\x9AA\a\x136\x2\x2\x9AA\xA13\a\x20F\x2");
		sb.Append("\x2\x9AB\x9AC\a\x166\x2\x2\x9AC\xA13\a\x20F\x2\x2\x9AD\xA13");
		sb.Append("\a;\x2\x2\x9AE\x9AF\t \x2\x2\x9AF\xA13\a\x221\x2\x2\x9B0\x9B1");
		sb.Append("\a\a\x2\x2\x9B1\x9B2\aq\x2\x2\x9B2\x9B3\a\x3C1\x2\x2\x9B3\x9B8");
		sb.Append("\x5h\x35\x2\x9B4\x9B5\a\x3C3\x2\x2\x9B5\x9B7\x5h\x35\x2\x9B6");
		sb.Append("\x9B4\x3\x2\x2\x2\x9B7\x9BA\x3\x2\x2\x2\x9B8\x9B6\x3\x2\x2\x2");
		sb.Append("\x9B8\x9B9\x3\x2\x2\x2\x9B9\x9BB\x3\x2\x2\x2\x9BA\x9B8\x3\x2");
		sb.Append("\x2\x2\x9BB\x9BC\a\x3C2\x2\x2\x9BC\xA13\x3\x2\x2\x2\x9BD\x9BE");
		sb.Append("\a/\x2\x2\x9BE\x9BF\aq\x2\x2\x9BF\xA13\x5\x222\x112\x2\x9C0");
		sb.Append("\x9C1\a\x136\x2\x2\x9C1\x9C4\aq\x2\x2\x9C2\x9C5\x5\x222\x112");
		sb.Append("\x2\x9C3\x9C5\a\b\x2\x2\x9C4\x9C2\x3\x2\x2\x2\x9C4\x9C3\x3\x2");
		sb.Append("\x2\x2\x9C5\x9C6\x3\x2\x2\x2\x9C6\xA13\a\x20F\x2\x2\x9C7\x9C8");
		sb.Append("\a\x166\x2\x2\x9C8\x9CB\aq\x2\x2\x9C9\x9CC\x5\x222\x112\x2\x9CA");
		sb.Append("\x9CC\a\b\x2\x2\x9CB\x9C9\x3\x2\x2\x2\x9CB\x9CA\x3\x2\x2\x2");
		sb.Append("\x9CC\x9CD\x3\x2\x2\x2\x9CD\xA13\a\x20F\x2\x2\x9CE\x9CF\a\x216");
		sb.Append("\x2\x2\x9CF\x9D2\aq\x2\x2\x9D0\x9D3\x5\x222\x112\x2\x9D1\x9D3");
		sb.Append("\a\b\x2\x2\x9D2\x9D0\x3\x2\x2\x2\x9D2\x9D1\x3\x2\x2\x2\x9D3");
		sb.Append("\xA13\x3\x2\x2\x2\x9D4\x9D5\a\x11B\x2\x2\x9D5\x9D6\aq\x2\x2");
		sb.Append("\x9D6\xA13\x5\x208\x105\x2\x9D7\x9D8\a\x1D4\x2\x2\x9D8\x9D9");
		sb.Append("\aq\x2\x2\x9D9\x9DA\x5\x222\x112\x2\x9DA\x9DB\aM\x2\x2\x9DB");
		sb.Append("\x9DC\a\x3C1\x2\x2\x9DC\x9E1\x5h\x35\x2\x9DD\x9DE\a\x3C3\x2");
		sb.Append("\x2\x9DE\x9E0\x5h\x35\x2\x9DF\x9DD\x3\x2\x2\x2\x9E0\x9E3\x3");
		sb.Append("\x2\x2\x2\x9E1\x9DF\x3\x2\x2\x2\x9E1\x9E2\x3\x2\x2\x2\x9E2\x9E4");
		sb.Append("\x3\x2\x2\x2\x9E3\x9E1\x3\x2\x2\x2\x9E4\x9E5\a\x3C2\x2\x2\x9E5");
		sb.Append("\xA13\x3\x2\x2\x2\x9E6\x9E7\a\x149\x2\x2\x9E7\x9E8\aq\x2\x2");
		sb.Append("\x9E8\x9E9\x5\x202\x102\x2\x9E9\x9EA\a\xA9\x2\x2\x9EA\x9EB\a");
		sb.Append("\x95\x2\x2\x9EB\x9EE\x5\x1EA\xF6\x2\x9EC\x9ED\t \x2\x2\x9ED");
		sb.Append("\x9EF\a\x221\x2\x2\x9EE\x9EC\x3\x2\x2\x2\x9EE\x9EF\x3\x2\x2");
		sb.Append("\x2\x9EF\xA13\x3\x2\x2\x2\x9F0\x9F1\a\v\x2\x2\x9F1\x9F4\aq\x2");
		sb.Append("\x2\x9F2\x9F5\x5\x222\x112\x2\x9F3\x9F5\a\b\x2\x2\x9F4\x9F2");
		sb.Append("\x3\x2\x2\x2\x9F4\x9F3\x3\x2\x2\x2\x9F5\xA13\x3\x2\x2\x2\x9F6");
		sb.Append("\x9F7\a\x19\x2\x2\x9F7\x9FA\aq\x2\x2\x9F8\x9FB\x5\x222\x112");
		sb.Append("\x2\x9F9\x9FB\a\b\x2\x2\x9FA\x9F8\x3\x2\x2\x2\x9FA\x9F9\x3\x2");
		sb.Append("\x2\x2\x9FB\xA13\x3\x2\x2\x2\x9FC\x9FD\ai\x2\x2\x9FD\xA00\a");
		sb.Append("q\x2\x2\x9FE\xA01\x5\x222\x112\x2\x9FF\xA01\a\b\x2\x2\xA00\x9FE");
		sb.Append("\x3\x2\x2\x2\xA00\x9FF\x3\x2\x2\x2\xA01\xA13\x3\x2\x2\x2\xA02");
		sb.Append("\xA03\a\x1CB\x2\x2\xA03\xA06\aq\x2\x2\xA04\xA07\x5\x222\x112");
		sb.Append("\x2\xA05\xA07\a\b\x2\x2\xA06\xA04\x3\x2\x2\x2\xA06\xA05\x3\x2");
		sb.Append("\x2\x2\xA07\xA13\x3\x2\x2\x2\xA08\xA09\a\x1D5\x2\x2\xA09\xA0C");
		sb.Append("\aq\x2\x2\xA0A\xA0D\x5\x222\x112\x2\xA0B\xA0D\a\b\x2\x2\xA0C");
		sb.Append("\xA0A\x3\x2\x2\x2\xA0C\xA0B\x3\x2\x2\x2\xA0D\xA13\x3\x2\x2\x2");
		sb.Append("\xA0E\xA0F\a\x1D3\x2\x2\xA0F\xA13\a\x1B9\x2\x2\xA10\xA11\a\x21D");
		sb.Append("\x2\x2\xA11\xA13\a\x1B9\x2\x2\xA12\x8AF\x3\x2\x2\x2\xA12\x8B9");
		sb.Append("\x3\x2\x2\x2\xA12\x8C4\x3\x2\x2\x2\xA12\x8D6\x3\x2\x2\x2\xA12");
		sb.Append("\x8E5\x3\x2\x2\x2\xA12\x8F8\x3\x2\x2\x2\xA12\x910\x3\x2\x2\x2");
		sb.Append("\xA12\x91F\x3\x2\x2\x2\xA12\x92E\x3\x2\x2\x2\xA12\x93A\x3\x2");
		sb.Append("\x2\x2\xA12\x93F\x3\x2\x2\x2\xA12\x94B\x3\x2\x2\x2\xA12\x957");
		sb.Append("\x3\x2\x2\x2\xA12\x95D\x3\x2\x2\x2\xA12\x962\x3\x2\x2\x2\xA12");
		sb.Append("\x96D\x3\x2\x2\x2\xA12\x975\x3\x2\x2\x2\xA12\x978\x3\x2\x2\x2");
		sb.Append("\xA12\x97E\x3\x2\x2\x2\xA12\x981\x3\x2\x2\x2\xA12\x985\x3\x2");
		sb.Append("\x2\x2\xA12\x987\x3\x2\x2\x2\xA12\x989\x3\x2\x2\x2\xA12\x991");
		sb.Append("\x3\x2\x2\x2\xA12\x994\x3\x2\x2\x2\xA12\x99E\x3\x2\x2\x2\xA12");
		sb.Append("\x9A9\x3\x2\x2\x2\xA12\x9AB\x3\x2\x2\x2\xA12\x9AD\x3\x2\x2\x2");
		sb.Append("\xA12\x9AE\x3\x2\x2\x2\xA12\x9B0\x3\x2\x2\x2\xA12\x9BD\x3\x2");
		sb.Append("\x2\x2\xA12\x9C0\x3\x2\x2\x2\xA12\x9C7\x3\x2\x2\x2\xA12\x9CE");
		sb.Append("\x3\x2\x2\x2\xA12\x9D4\x3\x2\x2\x2\xA12\x9D7\x3\x2\x2\x2\xA12");
		sb.Append("\x9E6\x3\x2\x2\x2\xA12\x9F0\x3\x2\x2\x2\xA12\x9F6\x3\x2\x2\x2");
		sb.Append("\xA12\x9FC\x3\x2\x2\x2\xA12\xA02\x3\x2\x2\x2\xA12\xA08\x3\x2");
		sb.Append("\x2\x2\xA12\xA0E\x3\x2\x2\x2\xA12\xA10\x3\x2\x2\x2\xA13\x87");
		sb.Append("\x3\x2\x2\x2\xA14\xA15\a/\x2\x2\xA15\xA17\t\x2\x2\x2\xA16\xA18");
		sb.Append("\x5\x238\x11D\x2\xA17\xA16\x3\x2\x2\x2\xA17\xA18\x3\x2\x2\x2");
		sb.Append("\xA18\xA19\x3\x2\x2\x2\xA19\xA1A\x5\x202\x102\x2\xA1A\x89\x3");
		sb.Append("\x2\x2\x2\xA1B\xA1C\a/\x2\x2\xA1C\xA1E\a\x146\x2\x2\xA1D\xA1F");
		sb.Append("\x5\x238\x11D\x2\xA1E\xA1D\x3\x2\x2\x2\xA1E\xA1F\x3\x2\x2\x2");
		sb.Append("\xA1F\xA20\x3\x2\x2\x2\xA20\xA21\x5\x1E8\xF5\x2\xA21\x8B\x3");
		sb.Append("\x2\x2\x2\xA22\xA23\a/\x2\x2\xA23\xA25\aG\x2\x2\xA24\xA26\t");
		sb.Append("\x3\x2\x2\xA25\xA24\x3\x2\x2\x2\xA25\xA26\x3\x2\x2\x2\xA26\xA27");
		sb.Append("\x3\x2\x2\x2\xA27\xA28\x5\x202\x102\x2\xA28\xA29\ah\x2\x2\xA29");
		sb.Append("\xA36\x5\x1EA\xF6\x2\xA2A\xA2C\a\x102\x2\x2\xA2B\xA2D\a\x3B8");
		sb.Append("\x2\x2\xA2C\xA2B\x3\x2\x2\x2\xA2C\xA2D\x3\x2\x2\x2\xA2D\xA2E");
		sb.Append("\x3\x2\x2\x2\xA2E\xA35\t\x5\x2\x2\xA2F\xA31\a\\\x2\x2\xA30\xA32");
		sb.Append("\a\x3B8\x2\x2\xA31\xA30\x3\x2\x2\x2\xA31\xA32\x3\x2\x2\x2\xA32");
		sb.Append("\xA33\x3\x2\x2\x2\xA33\xA35\t\x6\x2\x2\xA34\xA2A\x3\x2\x2\x2");
		sb.Append("\xA34\xA2F\x3\x2\x2\x2\xA35\xA38\x3\x2\x2\x2\xA36\xA34\x3\x2");
		sb.Append("\x2\x2\xA36\xA37\x3\x2\x2\x2\xA37\x8D\x3\x2\x2\x2\xA38\xA36");
		sb.Append("\x3\x2\x2\x2\xA39\xA3A\a/\x2\x2\xA3A\xA3B\a\x17C\x2\x2\xA3B");
		sb.Append("\xA3C\a\x41\x2\x2\xA3C\xA3D\x5\x202\x102\x2\xA3D\xA3E\a\x140");
		sb.Append("\x2\x2\xA3E\xA3F\a\x3B8\x2\x2\xA3F\xA40\x5\x1F8\xFD\x2\xA40");
		sb.Append("\x8F\x3\x2\x2\x2\xA41\xA42\a/\x2\x2\xA42\xA44\as\x2\x2\xA43");
		sb.Append("\xA45\x5\x238\x11D\x2\xA44\xA43\x3\x2\x2\x2\xA44\xA45\x3\x2");
		sb.Append("\x2\x2\xA45\xA46\x3\x2\x2\x2\xA46\xA47\x5\x1E8\xF5\x2\xA47\x91");
		sb.Append("\x3\x2\x2\x2\xA48\xA49\a/\x2\x2\xA49\xA4B\a\x15A\x2\x2\xA4A");
		sb.Append("\xA4C\x5\x238\x11D\x2\xA4B\xA4A\x3\x2\x2\x2\xA4B\xA4C\x3\x2");
		sb.Append("\x2\x2\xA4C\xA4D\x3\x2\x2\x2\xA4D\xA4E\x5\x1E8\xF5\x2\xA4E\x93");
		sb.Append("\x3\x2\x2\x2\xA4F\xA50\a/\x2\x2\xA50\xA52\a\x1EA\x2\x2\xA51");
		sb.Append("\xA53\x5\x238\x11D\x2\xA52\xA51\x3\x2\x2\x2\xA52\xA53\x3\x2");
		sb.Append("\x2\x2\xA53\xA54\x3\x2\x2\x2\xA54\xA55\x5\x202\x102\x2\xA55");
		sb.Append("\x95\x3\x2\x2\x2\xA56\xA58\a/\x2\x2\xA57\xA59\a\x210\x2\x2\xA58");
		sb.Append("\xA57\x3\x2\x2\x2\xA58\xA59\x3\x2\x2\x2\xA59\xA5A\x3\x2\x2\x2");
		sb.Append("\xA5A\xA5C\a\x95\x2\x2\xA5B\xA5D\x5\x238\x11D\x2\xA5C\xA5B\x3");
		sb.Append("\x2\x2\x2\xA5C\xA5D\x3\x2\x2\x2\xA5D\xA5E\x3\x2\x2\x2\xA5E\xA60");
		sb.Append("\x5\x224\x113\x2\xA5F\xA61\t!\x2\x2\xA60\xA5F\x3\x2\x2\x2\xA60");
		sb.Append("\xA61\x3\x2\x2\x2\xA61\x97\x3\x2\x2\x2\xA62\xA63\a/\x2\x2\xA63");
		sb.Append("\xA64\a\x20F\x2\x2\xA64\xA6A\x5\x202\x102\x2\xA65\xA67\a\x140");
		sb.Append("\x2\x2\xA66\xA68\a\x3B8\x2\x2\xA67\xA66\x3\x2\x2\x2\xA67\xA68");
		sb.Append("\x3\x2\x2\x2\xA68\xA69\x3\x2\x2\x2\xA69\xA6B\x5\x1F8\xFD\x2");
		sb.Append("\xA6A\xA65\x3\x2\x2\x2\xA6A\xA6B\x3\x2\x2\x2\xA6B\x99\x3\x2");
		sb.Append("\x2\x2\xA6C\xA6D\a/\x2\x2\xA6D\xA6F\a\x9A\x2\x2\xA6E\xA70\x5");
		sb.Append("\x238\x11D\x2\xA6F\xA6E\x3\x2\x2\x2\xA6F\xA70\x3\x2\x2\x2\xA70");
		sb.Append("\xA71\x3\x2\x2\x2\xA71\xA72\x5\x1E8\xF5\x2\xA72\x9B\x3\x2\x2");
		sb.Append("\x2\xA73\xA74\a/\x2\x2\xA74\xA76\a\x224\x2\x2\xA75\xA77\x5\x238");
		sb.Append("\x11D\x2\xA76\xA75\x3\x2\x2\x2\xA76\xA77\x3\x2\x2\x2\xA77\xA78");
		sb.Append("\x3\x2\x2\x2\xA78\xA7D\x5\x1E8\xF5\x2\xA79\xA7A\a\x3C3\x2\x2");
		sb.Append("\xA7A\xA7C\x5\x1E8\xF5\x2\xA7B\xA79\x3\x2\x2\x2\xA7C\xA7F\x3");
		sb.Append("\x2\x2\x2\xA7D\xA7B\x3\x2\x2\x2\xA7D\xA7E\x3\x2\x2\x2\xA7E\xA81");
		sb.Append("\x3\x2\x2\x2\xA7F\xA7D\x3\x2\x2\x2\xA80\xA82\t!\x2\x2\xA81\xA80");
		sb.Append("\x3\x2\x2\x2\xA81\xA82\x3\x2\x2\x2\xA82\x9D\x3\x2\x2\x2\xA83");
		sb.Append("\xA84\a{\x2\x2\xA84\xA85\a\x95\x2\x2\xA85\xA8A\x5\xA0Q\x2\xA86");
		sb.Append("\xA87\a\x3C3\x2\x2\xA87\xA89\x5\xA0Q\x2\xA88\xA86\x3\x2\x2\x2");
		sb.Append("\xA89\xA8C\x3\x2\x2\x2\xA8A\xA88\x3\x2\x2\x2\xA8A\xA8B\x3\x2");
		sb.Append("\x2\x2\xA8B\x9F\x3\x2\x2\x2\xA8C\xA8A\x3\x2\x2\x2\xA8D\xA8E");
		sb.Append("\x5\x1EA\xF6\x2\xA8E\xA8F\a\x98\x2\x2\xA8F\xA90\x5\x1EA\xF6");
		sb.Append("\x2\xA90\xA1\x3\x2\x2\x2\xA91\xA93\a\x216\x2\x2\xA92\xA94\a");
		sb.Append("\x95\x2\x2\xA93\xA92\x3\x2\x2\x2\xA93\xA94\x3\x2\x2\x2\xA94");
		sb.Append("\xA95\x3\x2\x2\x2\xA95\xA96\x5\x1EA\xF6\x2\xA96\xA3\x3\x2\x2");
		sb.Append("\x2\xA97\xA98\a\x13\x2\x2\xA98\xA9F\x5\x1E8\xF5\x2\xA99\xA9C");
		sb.Append("\a\x3C1\x2\x2\xA9A\xA9D\x5\x22C\x117\x2\xA9B\xA9D\x5\x228\x115");
		sb.Append("\x2\xA9C\xA9A\x3\x2\x2\x2\xA9C\xA9B\x3\x2\x2\x2\xA9C\xA9D\x3");
		sb.Append("\x2\x2\x2\xA9D\xA9E\x3\x2\x2\x2\xA9E\xAA0\a\x3C2\x2\x2\xA9F");
		sb.Append("\xA99\x3\x2\x2\x2\xA9F\xAA0\x3\x2\x2\x2\xAA0\xA5\x3\x2\x2\x2");
		sb.Append("\xAA1\xAA4\x5\xC0\x61\x2\xAA2\xAA4\x5\xC2\x62\x2\xAA3\xAA1\x3");
		sb.Append("\x2\x2\x2\xAA3\xAA2\x3\x2\x2\x2\xAA4\xA7\x3\x2\x2\x2\xAA5\xAA6");
		sb.Append("\a\x138\x2\x2\xAA6\xAA7\x5\x228\x115\x2\xAA7\xA9\x3\x2\x2\x2");
		sb.Append("\xAA8\xAAD\x5\xC4\x63\x2\xAA9\xAAD\x5\xC6\x64\x2\xAAA\xAAD\x5");
		sb.Append("\xC8\x65\x2\xAAB\xAAD\x5\xCA\x66\x2\xAAC\xAA8\x3\x2\x2\x2\xAAC");
		sb.Append("\xAA9\x3\x2\x2\x2\xAAC\xAAA\x3\x2\x2\x2\xAAC\xAAB\x3\x2\x2\x2");
		sb.Append("\xAAD\xAB\x3\x2\x2\x2\xAAE\xAB0\aK\x2\x2\xAAF\xAB1\t\"\x2\x2");
		sb.Append("\xAB0\xAAF\x3\x2\x2\x2\xAB0\xAB1\x3\x2\x2\x2\xAB1\xAB3\x3\x2");
		sb.Append("\x2\x2\xAB2\xAB4\a\x45\x2\x2\xAB3\xAB2\x3\x2\x2\x2\xAB3\xAB4");
		sb.Append("\x3\x2\x2\x2\xAB4\xAB6\x3\x2\x2\x2\xAB5\xAB7\aM\x2\x2\xAB6\xAB5");
		sb.Append("\x3\x2\x2\x2\xAB6\xAB7\x3\x2\x2\x2\xAB7\xAB8\x3\x2\x2\x2\xAB8");
		sb.Append("\xABE\x5\x1EA\xF6\x2\xAB9\xABA\aq\x2\x2\xABA\xABB\a\x3C1\x2");
		sb.Append("\x2\xABB\xABC\x5\x222\x112\x2\xABC\xABD\a\x3C2\x2\x2\xABD\xABF");
		sb.Append("\x3\x2\x2\x2\xABE\xAB9\x3\x2\x2\x2\xABE\xABF\x3\x2\x2\x2\xABF");
		sb.Append("\xAD0\x3\x2\x2\x2\xAC0\xAC1\a\x3C1\x2\x2\xAC1\xAC2\x5\x222\x112");
		sb.Append("\x2\xAC2\xAC3\a\x3C2\x2\x2\xAC3\xAC5\x3\x2\x2\x2\xAC4\xAC0\x3");
		sb.Append("\x2\x2\x2\xAC4\xAC5\x3\x2\x2\x2\xAC5\xAC6\x3\x2\x2\x2\xAC6\xAD1");
		sb.Append("\x5\xB8]\x2\xAC7\xAC8\a\x87\x2\x2\xAC8\xACD\x5\xBA^\x2\xAC9");
		sb.Append("\xACA\a\x3C3\x2\x2\xACA\xACC\x5\xBA^\x2\xACB\xAC9\x3\x2\x2\x2");
		sb.Append("\xACC\xACF\x3\x2\x2\x2\xACD\xACB\x3\x2\x2\x2\xACD\xACE\x3\x2");
		sb.Append("\x2\x2\xACE\xAD1\x3\x2\x2\x2\xACF\xACD\x3\x2\x2\x2\xAD0\xAC4");
		sb.Append("\x3\x2\x2\x2\xAD0\xAC7\x3\x2\x2\x2\xAD1\xADE\x3\x2\x2\x2\xAD2");
		sb.Append("\xAD3\ah\x2\x2\xAD3\xAD4\a\x13A\x2\x2\xAD4\xAD5\aQ\x2\x2\xAD5");
		sb.Append("\xAD6\a\xA1\x2\x2\xAD6\xADB\x5\xBA^\x2\xAD7\xAD8\a\x3C3\x2\x2");
		sb.Append("\xAD8\xADA\x5\xBA^\x2\xAD9\xAD7\x3\x2\x2\x2\xADA\xADD\x3\x2");
		sb.Append("\x2\x2\xADB\xAD9\x3\x2\x2\x2\xADB\xADC\x3\x2\x2\x2\xADC\xADF");
		sb.Append("\x3\x2\x2\x2\xADD\xADB\x3\x2\x2\x2\xADE\xAD2\x3\x2\x2\x2\xADE");
		sb.Append("\xADF\x3\x2\x2\x2\xADF\xAD\x3\x2\x2\x2\xAE0\xAE1\a[\x2\x2\xAE1");
		sb.Append("\xAE3\a\x12D\x2\x2\xAE2\xAE4\t#\x2\x2\xAE3\xAE2\x3\x2\x2\x2");
		sb.Append("\xAE3\xAE4\x3\x2\x2\x2\xAE4\xAE6\x3\x2\x2\x2\xAE5\xAE7\a\x17B");
		sb.Append("\x2\x2\xAE6\xAE5\x3\x2\x2\x2\xAE6\xAE7\x3\x2\x2\x2\xAE7\xAE8");
		sb.Append("\x3\x2\x2\x2\xAE8\xAE9\aH\x2\x2\xAE9\xAEB\a\x3D0\x2\x2\xAEA");
		sb.Append("\xAEC\t\b\x2\x2\xAEB\xAEA\x3\x2\x2\x2\xAEB\xAEC\x3\x2\x2\x2");
		sb.Append("\xAEC\xAED\x3\x2\x2\x2\xAED\xAEE\aM\x2\x2\xAEE\xAEF\a\x95\x2");
		sb.Append("\x2\xAEF\xAF5\x5\x1EA\xF6\x2\xAF0\xAF1\aq\x2\x2\xAF1\xAF2\a");
		sb.Append("\x3C1\x2\x2\xAF2\xAF3\x5\x222\x112\x2\xAF3\xAF4\a\x3C2\x2\x2");
		sb.Append("\xAF4\xAF6\x3\x2\x2\x2\xAF5\xAF0\x3\x2\x2\x2\xAF5\xAF6\x3\x2");
		sb.Append("\x2\x2\xAF6\xAFA\x3\x2\x2\x2\xAF7\xAF8\a\x18\x2\x2\xAF8\xAF9");
		sb.Append("\a\x87\x2\x2\xAF9\xAFB\x5\x1F4\xFB\x2\xAFA\xAF7\x3\x2\x2\x2");
		sb.Append("\xAFA\xAFB\x3\x2\x2\x2\xAFB\xB02\x3\x2\x2\x2\xAFC\xAFE\t$\x2");
		sb.Append("\x2\xAFD\xAFF\x5\xF4{\x2\xAFE\xAFD\x3\x2\x2\x2\xAFF\xB00\x3");
		sb.Append("\x2\x2\x2\xB00\xAFE\x3\x2\x2\x2\xB00\xB01\x3\x2\x2\x2\xB01\xB03");
		sb.Append("\x3\x2\x2\x2\xB02\xAFC\x3\x2\x2\x2\xB02\xB03\x3\x2\x2\x2\xB03");
		sb.Append("\xB0A\x3\x2\x2\x2\xB04\xB06\aZ\x2\x2\xB05\xB07\x5\xF6|\x2\xB06");
		sb.Append("\xB05\x3\x2\x2\x2\xB07\xB08\x3\x2\x2\x2\xB08\xB06\x3\x2\x2\x2");
		sb.Append("\xB08\xB09\x3\x2\x2\x2\xB09\xB0B\x3\x2\x2\x2\xB0A\xB04\x3\x2");
		sb.Append("\x2\x2\xB0A\xB0B\x3\x2\x2\x2\xB0B\xB10\x3\x2\x2\x2\xB0C\xB0D");
		sb.Append("\a\x45\x2\x2\xB0D\xB0E\x5\x208\x105\x2\xB0E\xB0F\t%\x2\x2\xB0F");
		sb.Append("\xB11\x3\x2\x2\x2\xB10\xB0C\x3\x2\x2\x2\xB10\xB11\x3\x2\x2\x2");
		sb.Append("\xB11\xB1D\x3\x2\x2\x2\xB12\xB13\a\x3C1\x2\x2\xB13\xB18\x5\xBC");
		sb.Append("_\x2\xB14\xB15\a\x3C3\x2\x2\xB15\xB17\x5\xBC_\x2\xB16\xB14\x3");
		sb.Append("\x2\x2\x2\xB17\xB1A\x3\x2\x2\x2\xB18\xB16\x3\x2\x2\x2\xB18\xB19");
		sb.Append("\x3\x2\x2\x2\xB19\xB1B\x3\x2\x2\x2\xB1A\xB18\x3\x2\x2\x2\xB1B");
		sb.Append("\xB1C\a\x3C2\x2\x2\xB1C\xB1E\x3\x2\x2\x2\xB1D\xB12\x3\x2\x2");
		sb.Append("\x2\xB1D\xB1E\x3\x2\x2\x2\xB1E\xB28\x3\x2\x2\x2\xB1F\xB20\a");
		sb.Append("\x87\x2\x2\xB20\xB25\x5\xBA^\x2\xB21\xB22\a\x3C3\x2\x2\xB22");
		sb.Append("\xB24\x5\xBA^\x2\xB23\xB21\x3\x2\x2\x2\xB24\xB27\x3\x2\x2\x2");
		sb.Append("\xB25\xB23\x3\x2\x2\x2\xB25\xB26\x3\x2\x2\x2\xB26\xB29\x3\x2");
		sb.Append("\x2\x2\xB27\xB25\x3\x2\x2\x2\xB28\xB1F\x3\x2\x2\x2\xB28\xB29");
		sb.Append("\x3\x2\x2\x2\xB29\xAF\x3\x2\x2\x2\xB2A\xB2B\a[\x2\x2\xB2B\xB2D");
		sb.Append("\a\x22D\x2\x2\xB2C\xB2E\t#\x2\x2\xB2D\xB2C\x3\x2\x2\x2\xB2D");
		sb.Append("\xB2E\x3\x2\x2\x2\xB2E\xB30\x3\x2\x2\x2\xB2F\xB31\a\x17B\x2");
		sb.Append("\x2\xB30\xB2F\x3\x2\x2\x2\xB30\xB31\x3\x2\x2\x2\xB31\xB32\x3");
		sb.Append("\x2\x2\x2\xB32\xB33\aH\x2\x2\xB33\xB35\a\x3D0\x2\x2\xB34\xB36");
		sb.Append("\t\b\x2\x2\xB35\xB34\x3\x2\x2\x2\xB35\xB36\x3\x2\x2\x2\xB36");
		sb.Append("\xB37\x3\x2\x2\x2\xB37\xB38\aM\x2\x2\xB38\xB39\a\x95\x2\x2\xB39");
		sb.Append("\xB3D\x5\x1EA\xF6\x2\xB3A\xB3B\a\x18\x2\x2\xB3B\xB3C\a\x87\x2");
		sb.Append("\x2\xB3C\xB3E\x5\x1F4\xFB\x2\xB3D\xB3A\x3\x2\x2\x2\xB3D\xB3E");
		sb.Append("\x3\x2\x2\x2\xB3E\xB45\x3\x2\x2\x2\xB3F\xB40\a\x1E5\x2\x2\xB40");
		sb.Append("\xB41\a\x164\x2\x2\xB41\xB42\a\x12\x2\x2\xB42\xB43\a\x3BA\x2");
		sb.Append("\x2\xB43\xB44\a\x3D0\x2\x2\xB44\xB46\a\x3B9\x2\x2\xB45\xB3F");
		sb.Append("\x3\x2\x2\x2\xB45\xB46\x3\x2\x2\x2\xB46\xB4B\x3\x2\x2\x2\xB47");
		sb.Append("\xB48\a\x45\x2\x2\xB48\xB49\x5\x208\x105\x2\xB49\xB4A\t%\x2");
		sb.Append("\x2\xB4A\xB4C\x3\x2\x2\x2\xB4B\xB47\x3\x2\x2\x2\xB4B\xB4C\x3");
		sb.Append("\x2\x2\x2\xB4C\xB58\x3\x2\x2\x2\xB4D\xB4E\a\x3C1\x2\x2\xB4E");
		sb.Append("\xB53\x5\xBC_\x2\xB4F\xB50\a\x3C3\x2\x2\xB50\xB52\x5\xBC_\x2");
		sb.Append("\xB51\xB4F\x3\x2\x2\x2\xB52\xB55\x3\x2\x2\x2\xB53\xB51\x3\x2");
		sb.Append("\x2\x2\xB53\xB54\x3\x2\x2\x2\xB54\xB56\x3\x2\x2\x2\xB55\xB53");
		sb.Append("\x3\x2\x2\x2\xB56\xB57\a\x3C2\x2\x2\xB57\xB59\x3\x2\x2\x2\xB58");
		sb.Append("\xB4D\x3\x2\x2\x2\xB58\xB59\x3\x2\x2\x2\xB59\xB63\x3\x2\x2\x2");
		sb.Append("\xB5A\xB5B\a\x87\x2\x2\xB5B\xB60\x5\xBA^\x2\xB5C\xB5D\a\x3C3");
		sb.Append("\x2\x2\xB5D\xB5F\x5\xBA^\x2\xB5E\xB5C\x3\x2\x2\x2\xB5F\xB62");
		sb.Append("\x3\x2\x2\x2\xB60\xB5E\x3\x2\x2\x2\xB60\xB61\x3\x2\x2\x2\xB61");
		sb.Append("\xB64\x3\x2\x2\x2\xB62\xB60\x3\x2\x2\x2\xB63\xB5A\x3\x2\x2\x2");
		sb.Append("\xB63\xB64\x3\x2\x2\x2\xB64\xB1\x3\x2\x2\x2\xB65\xB67\a}\x2");
		sb.Append("\x2\xB66\xB68\t&\x2\x2\xB67\xB66\x3\x2\x2\x2\xB67\xB68\x3\x2");
		sb.Append("\x2\x2\xB68\xB6A\x3\x2\x2\x2\xB69\xB6B\aM\x2\x2\xB6A\xB69\x3");
		sb.Append("\x2\x2\x2\xB6A\xB6B\x3\x2\x2\x2\xB6B\xB6C\x3\x2\x2\x2\xB6C\xB72");
		sb.Append("\x5\x1EA\xF6\x2\xB6D\xB6E\aq\x2\x2\xB6E\xB6F\a\x3C1\x2\x2\xB6F");
		sb.Append("\xB70\x5\x222\x112\x2\xB70\xB71\a\x3C2\x2\x2\xB71\xB73\x3\x2");
		sb.Append("\x2\x2\xB72\xB6D\x3\x2\x2\x2\xB72\xB73\x3\x2\x2\x2\xB73\xB84");
		sb.Append("\x3\x2\x2\x2\xB74\xB75\a\x3C1\x2\x2\xB75\xB76\x5\x222\x112\x2");
		sb.Append("\xB76\xB77\a\x3C2\x2\x2\xB77\xB79\x3\x2\x2\x2\xB78\xB74\x3\x2");
		sb.Append("\x2\x2\xB78\xB79\x3\x2\x2\x2\xB79\xB7A\x3\x2\x2\x2\xB7A\xB85");
		sb.Append("\x5\xB8]\x2\xB7B\xB7C\a\x87\x2\x2\xB7C\xB81\x5\xBA^\x2\xB7D");
		sb.Append("\xB7E\a\x3C3\x2\x2\xB7E\xB80\x5\xBA^\x2\xB7F\xB7D\x3\x2\x2\x2");
		sb.Append("\xB80\xB83\x3\x2\x2\x2\xB81\xB7F\x3\x2\x2\x2\xB81\xB82\x3\x2");
		sb.Append("\x2\x2\xB82\xB85\x3\x2\x2\x2\xB83\xB81\x3\x2\x2\x2\xB84\xB78");
		sb.Append("\x3\x2\x2\x2\xB84\xB7B\x3\x2\x2\x2\xB85\xB3\x3\x2\x2\x2\xB86");
		sb.Append("\xB88\x5\xE4s\x2\xB87\xB89\x5\xBE`\x2\xB88\xB87\x3\x2\x2\x2");
		sb.Append("\xB88\xB89\x3\x2\x2\x2\xB89\xBBE\x3\x2\x2\x2\xB8A\xB8C\x5\xE0");
		sb.Append("q\x2\xB8B\xB8D\x5\xBE`\x2\xB8C\xB8B\x3\x2\x2\x2\xB8C\xB8D\x3");
		sb.Append("\x2\x2\x2\xB8D\xBBE\x3\x2\x2\x2\xB8E\xB90\x5\xE6t\x2\xB8F\xB91");
		sb.Append("\x5\xEAv\x2\xB90\xB8F\x3\x2\x2\x2\xB91\xB92\x3\x2\x2\x2\xB92");
		sb.Append("\xB90\x3\x2\x2\x2\xB92\xB93\x3\x2\x2\x2\xB93\xB9C\x3\x2\x2\x2");
		sb.Append("\xB94\xB96\a\x9D\x2\x2\xB95\xB97\t\'\x2\x2\xB96\xB95\x3\x2\x2");
		sb.Append("\x2\xB96\xB97\x3\x2\x2\x2\xB97\xB9A\x3\x2\x2\x2\xB98\xB9B\x5");
		sb.Append("\xE4s\x2\xB99\xB9B\x5\xE0q\x2\xB9A\xB98\x3\x2\x2\x2\xB9A\xB99");
		sb.Append("\x3\x2\x2\x2\xB9B\xB9D\x3\x2\x2\x2\xB9C\xB94\x3\x2\x2\x2\xB9C");
		sb.Append("\xB9D\x3\x2\x2\x2\xB9D\xB9F\x3\x2\x2\x2\xB9E\xBA0\x5\xD0i\x2");
		sb.Append("\xB9F\xB9E\x3\x2\x2\x2\xB9F\xBA0\x3\x2\x2\x2\xBA0\xBA2\x3\x2");
		sb.Append("\x2\x2\xBA1\xBA3\x5\xFC\x7F\x2\xBA2\xBA1\x3\x2\x2\x2\xBA2\xBA3");
		sb.Append("\x3\x2\x2\x2\xBA3\xBA5\x3\x2\x2\x2\xBA4\xBA6\x5\xBE`\x2\xBA5");
		sb.Append("\xBA4\x3\x2\x2\x2\xBA5\xBA6\x3\x2\x2\x2\xBA6\xBBE\x3\x2\x2\x2");
		sb.Append("\xBA7\xBA9\x5\xE2r\x2\xBA8\xBAA\x5\xE8u\x2\xBA9\xBA8\x3\x2\x2");
		sb.Append("\x2\xBAA\xBAB\x3\x2\x2\x2\xBAB\xBA9\x3\x2\x2\x2\xBAB\xBAC\x3");
		sb.Append("\x2\x2\x2\xBAC\xBB2\x3\x2\x2\x2\xBAD\xBAF\a\x9D\x2\x2\xBAE\xBB0");
		sb.Append("\t\'\x2\x2\xBAF\xBAE\x3\x2\x2\x2\xBAF\xBB0\x3\x2\x2\x2\xBB0");
		sb.Append("\xBB1\x3\x2\x2\x2\xBB1\xBB3\x5\xE0q\x2\xBB2\xBAD\x3\x2\x2\x2");
		sb.Append("\xBB2\xBB3\x3\x2\x2\x2\xBB3\xBB5\x3\x2\x2\x2\xBB4\xBB6\x5\xD0");
		sb.Append("i\x2\xBB5\xBB4\x3\x2\x2\x2\xBB5\xBB6\x3\x2\x2\x2\xBB6\xBB8\x3");
		sb.Append("\x2\x2\x2\xBB7\xBB9\x5\xFC\x7F\x2\xBB8\xBB7\x3\x2\x2\x2\xBB8");
		sb.Append("\xBB9\x3\x2\x2\x2\xBB9\xBBB\x3\x2\x2\x2\xBBA\xBBC\x5\xBE`\x2");
		sb.Append("\xBBB\xBBA\x3\x2\x2\x2\xBBB\xBBC\x3\x2\x2\x2\xBBC\xBBE\x3\x2");
		sb.Append("\x2\x2\xBBD\xB86\x3\x2\x2\x2\xBBD\xB8A\x3\x2\x2\x2\xBBD\xB8E");
		sb.Append("\x3\x2\x2\x2\xBBD\xBA7\x3\x2\x2\x2\xBBE\xB5\x3\x2\x2\x2\xBBF");
		sb.Append("\xBC2\x5\xCCg\x2\xBC0\xBC2\x5\xCEh\x2\xBC1\xBBF\x3\x2\x2\x2");
		sb.Append("\xBC1\xBC0\x3\x2\x2\x2\xBC2\xB7\x3\x2\x2\x2\xBC3\xBD3\x5\xB4");
		sb.Append("[\x2\xBC4\xBC5\t(\x2\x2\xBC5\xBC6\a\x3C1\x2\x2\xBC6\xBC7\x5");
		sb.Append("\x22A\x116\x2\xBC7\xBCF\a\x3C2\x2\x2\xBC8\xBC9\a\x3C3\x2\x2");
		sb.Append("\xBC9\xBCA\a\x3C1\x2\x2\xBCA\xBCB\x5\x22A\x116\x2\xBCB\xBCC");
		sb.Append("\a\x3C2\x2\x2\xBCC\xBCE\x3\x2\x2\x2\xBCD\xBC8\x3\x2\x2\x2\xBCE");
		sb.Append("\xBD1\x3\x2\x2\x2\xBCF\xBCD\x3\x2\x2\x2\xBCF\xBD0\x3\x2\x2\x2");
		sb.Append("\xBD0\xBD3\x3\x2\x2\x2\xBD1\xBCF\x3\x2\x2\x2\xBD2\xBC3\x3\x2");
		sb.Append("\x2\x2\xBD2\xBC4\x3\x2\x2\x2\xBD3\xB9\x3\x2\x2\x2\xBD4\xBD5");
		sb.Append("\x5\x1EC\xF7\x2\xBD5\xBD8\a\x3B8\x2\x2\xBD6\xBD9\x5\x250\x129");
		sb.Append("\x2\xBD7\xBD9\a\'\x2\x2\xBD8\xBD6\x3\x2\x2\x2\xBD8\xBD7\x3\x2");
		sb.Append("\x2\x2\xBD9\xBB\x3\x2\x2\x2\xBDA\xBDD\x5\x202\x102\x2\xBDB\xBDD");
		sb.Append("\a\x3DB\x2\x2\xBDC\xBDA\x3\x2\x2\x2\xBDC\xBDB\x3\x2\x2\x2\xBDD");
		sb.Append("\xBD\x3\x2\x2\x2\xBDE\xBDF\a:\x2\x2\xBDF\xBE5\a\xA1\x2\x2\xBE0");
		sb.Append("\xBE1\a\\\x2\x2\xBE1\xBE2\a\x46\x2\x2\xBE2\xBE3\a\x1EC\x2\x2");
		sb.Append("\xBE3\xBE5\a\x19E\x2\x2\xBE4\xBDE\x3\x2\x2\x2\xBE4\xBE0\x3\x2");
		sb.Append("\x2\x2\xBE5\xBF\x3\x2\x2\x2\xBE6\xBE8\a)\x2\x2\xBE7\xBE9\a^");
		sb.Append("\x2\x2\xBE8\xBE7\x3\x2\x2\x2\xBE8\xBE9\x3\x2\x2\x2\xBE9\xBEB");
		sb.Append("\x3\x2\x2\x2\xBEA\xBEC\a\x1CA\x2\x2\xBEB\xBEA\x3\x2\x2\x2\xBEB");
		sb.Append("\xBEC\x3\x2\x2\x2\xBEC\xBEE\x3\x2\x2\x2\xBED\xBEF\a\x45\x2\x2");
		sb.Append("\xBEE\xBED\x3\x2\x2\x2\xBEE\xBEF\x3\x2\x2\x2\xBEF\xBF0\x3\x2");
		sb.Append("\x2\x2\xBF0\xBF1\a=\x2\x2\xBF1\xBF7\x5\x1EA\xF6\x2\xBF2\xBF3");
		sb.Append("\aq\x2\x2\xBF3\xBF4\a\x3C1\x2\x2\xBF4\xBF5\x5\x222\x112\x2\xBF5");
		sb.Append("\xBF6\a\x3C2\x2\x2\xBF6\xBF8\x3\x2\x2\x2\xBF7\xBF2\x3\x2\x2");
		sb.Append("\x2\xBF7\xBF8\x3\x2\x2\x2\xBF8\xBFB\x3\x2\x2\x2\xBF9\xBFA\a");
		sb.Append("\xA7\x2\x2\xBFA\xBFC\x5\x250\x129\x2\xBFB\xBF9\x3\x2\x2\x2\xBFB");
		sb.Append("\xBFC\x3\x2\x2\x2\xBFC\xBFE\x3\x2\x2\x2\xBFD\xBFF\x5\xD0i\x2");
		sb.Append("\xBFE\xBFD\x3\x2\x2\x2\xBFE\xBFF\x3\x2\x2\x2\xBFF\xC02\x3\x2");
		sb.Append("\x2\x2\xC00\xC01\aX\x2\x2\xC01\xC03\x5\x208\x105\x2\xC02\xC00");
		sb.Append("\x3\x2\x2\x2\xC02\xC03\x3\x2\x2\x2\xC03\xC1\x3\x2\x2\x2\xC04");
		sb.Append("\xC06\a)\x2\x2\xC05\xC07\a^\x2\x2\xC06\xC05\x3\x2\x2\x2\xC06");
		sb.Append("\xC07\x3\x2\x2\x2\xC07\xC09\x3\x2\x2\x2\xC08\xC0A\a\x1CA\x2");
		sb.Append("\x2\xC09\xC08\x3\x2\x2\x2\xC09\xC0A\x3\x2\x2\x2\xC0A\xC0C\x3");
		sb.Append("\x2\x2\x2\xC0B\xC0D\a\x45\x2\x2\xC0C\xC0B\x3\x2\x2\x2\xC0C\xC0D");
		sb.Append("\x3\x2\x2\x2\xC0D\xC35\x3\x2\x2\x2\xC0E\xC11\x5\x1EA\xF6\x2");
		sb.Append("\xC0F\xC10\a\x3C0\x2\x2\xC10\xC12\a\x3B0\x2\x2\xC11\xC0F\x3");
		sb.Append("\x2\x2\x2\xC11\xC12\x3\x2\x2\x2\xC12\xC1B\x3\x2\x2\x2\xC13\xC14");
		sb.Append("\a\x3C3\x2\x2\xC14\xC17\x5\x1EA\xF6\x2\xC15\xC16\a\x3C0\x2\x2");
		sb.Append("\xC16\xC18\a\x3B0\x2\x2\xC17\xC15\x3\x2\x2\x2\xC17\xC18\x3\x2");
		sb.Append("\x2\x2\xC18\xC1A\x3\x2\x2\x2\xC19\xC13\x3\x2\x2\x2\xC1A\xC1D");
		sb.Append("\x3\x2\x2\x2\xC1B\xC19\x3\x2\x2\x2\xC1B\xC1C\x3\x2\x2\x2\xC1C");
		sb.Append("\xC1E\x3\x2\x2\x2\xC1D\xC1B\x3\x2\x2\x2\xC1E\xC1F\a=\x2\x2\xC1F");
		sb.Append("\xC20\x5\xD4k\x2\xC20\xC36\x3\x2\x2\x2\xC21\xC22\a=\x2\x2\xC22");
		sb.Append("\xC25\x5\x1EA\xF6\x2\xC23\xC24\a\x3C0\x2\x2\xC24\xC26\a\x3B0");
		sb.Append("\x2\x2\xC25\xC23\x3\x2\x2\x2\xC25\xC26\x3\x2\x2\x2\xC26\xC2F");
		sb.Append("\x3\x2\x2\x2\xC27\xC28\a\x3C3\x2\x2\xC28\xC2B\x5\x1EA\xF6\x2");
		sb.Append("\xC29\xC2A\a\x3C0\x2\x2\xC2A\xC2C\a\x3B0\x2\x2\xC2B\xC29\x3");
		sb.Append("\x2\x2\x2\xC2B\xC2C\x3\x2\x2\x2\xC2C\xC2E\x3\x2\x2\x2\xC2D\xC27");
		sb.Append("\x3\x2\x2\x2\xC2E\xC31\x3\x2\x2\x2\xC2F\xC2D\x3\x2\x2\x2\xC2F");
		sb.Append("\xC30\x3\x2\x2\x2\xC30\xC32\x3\x2\x2\x2\xC31\xC2F\x3\x2\x2\x2");
		sb.Append("\xC32\xC33\a\xA4\x2\x2\xC33\xC34\x5\xD4k\x2\xC34\xC36\x3\x2");
		sb.Append("\x2\x2\xC35\xC0E\x3\x2\x2\x2\xC35\xC21\x3\x2\x2\x2\xC36\xC39");
		sb.Append("\x3\x2\x2\x2\xC37\xC38\a\xA7\x2\x2\xC38\xC3A\x5\x250\x129\x2");
		sb.Append("\xC39\xC37\x3\x2\x2\x2\xC39\xC3A\x3\x2\x2\x2\xC3A\xC3\x3\x2");
		sb.Append("\x2\x2\xC3B\xC3C\a\x15F\x2\x2\xC3C\xC3D\x5\x1EA\xF6\x2\xC3D");
		sb.Append("\xC42\a\x1B1\x2\x2\xC3E\xC40\a\r\x2\x2\xC3F\xC3E\x3\x2\x2\x2");
		sb.Append("\xC3F\xC40\x3\x2\x2\x2\xC40\xC41\x3\x2\x2\x2\xC41\xC43\x5\x202");
		sb.Append("\x102\x2\xC42\xC3F\x3\x2\x2\x2\xC42\xC43\x3\x2\x2\x2\xC43\xC5");
		sb.Append("\x3\x2\x2\x2\xC44\xC45\a\x15F\x2\x2\xC45\xC46\x5\x1EA\xF6\x2");
		sb.Append("\xC46\xC47\av\x2\x2\xC47\xC4E\x5\x202\x102\x2\xC48\xC49\x5\x258");
		sb.Append("\x12D\x2\xC49\xC4A\a\x3C1\x2\x2\xC4A\xC4B\x5\x22C\x117\x2\xC4B");
		sb.Append("\xC4C\a\x3C2\x2\x2\xC4C\xC4F\x3\x2\x2\x2\xC4D\xC4F\t)\x2\x2");
		sb.Append("\xC4E\xC48\x3\x2\x2\x2\xC4E\xC4D\x3\x2\x2\x2\xC4F\xC52\x3\x2");
		sb.Append("\x2\x2\xC50\xC51\a\xA7\x2\x2\xC51\xC53\x5\x250\x129\x2\xC52");
		sb.Append("\xC50\x3\x2\x2\x2\xC52\xC53\x3\x2\x2\x2\xC53\xC56\x3\x2\x2\x2");
		sb.Append("\xC54\xC55\aX\x2\x2\xC55\xC57\x5\x208\x105\x2\xC56\xC54\x3\x2");
		sb.Append("\x2\x2\xC56\xC57\x3\x2\x2\x2\xC57\xC7\x3\x2\x2\x2\xC58\xC59");
		sb.Append("\a\x15F\x2\x2\xC59\xC5A\x5\x1EA\xF6\x2\xC5A\xC5B\av\x2\x2\xC5B");
		sb.Append("\xC5E\t*\x2\x2\xC5C\xC5D\a\xA7\x2\x2\xC5D\xC5F\x5\x250\x129");
		sb.Append("\x2\xC5E\xC5C\x3\x2\x2\x2\xC5E\xC5F\x3\x2\x2\x2\xC5F\xC62\x3");
		sb.Append("\x2\x2\x2\xC60\xC61\aX\x2\x2\xC61\xC63\x5\x208\x105\x2\xC62");
		sb.Append("\xC60\x3\x2\x2\x2\xC62\xC63\x3\x2\x2\x2\xC63\xC9\x3\x2\x2\x2");
		sb.Append("\xC64\xC65\a\x15F\x2\x2\xC65\xC66\x5\x1EA\xF6\x2\xC66\xC67\a");
		sb.Append("\x11A\x2\x2\xC67\xCB\x3\x2\x2\x2\xC68\xC6A\a\xA1\x2\x2\xC69");
		sb.Append("\xC6B\a^\x2\x2\xC6A\xC69\x3\x2\x2\x2\xC6A\xC6B\x3\x2\x2\x2\xC6B");
		sb.Append("\xC6D\x3\x2\x2\x2\xC6C\xC6E\a\x45\x2\x2\xC6D\xC6C\x3\x2\x2\x2");
		sb.Append("\xC6D\xC6E\x3\x2\x2\x2\xC6E\xC6F\x3\x2\x2\x2\xC6F\xC74\x5\x1EA");
		sb.Append("\xF6\x2\xC70\xC72\a\r\x2\x2\xC71\xC70\x3\x2\x2\x2\xC71\xC72");
		sb.Append("\x3\x2\x2\x2\xC72\xC73\x3\x2\x2\x2\xC73\xC75\x5\x202\x102\x2");
		sb.Append("\xC74\xC71\x3\x2\x2\x2\xC74\xC75\x3\x2\x2\x2\xC75\xC76\x3\x2");
		sb.Append("\x2\x2\xC76\xC77\a\x87\x2\x2\xC77\xC7C\x5\xBA^\x2\xC78\xC79");
		sb.Append("\a\x3C3\x2\x2\xC79\xC7B\x5\xBA^\x2\xC7A\xC78\x3\x2\x2\x2\xC7B");
		sb.Append("\xC7E\x3\x2\x2\x2\xC7C\xC7A\x3\x2\x2\x2\xC7C\xC7D\x3\x2\x2\x2");
		sb.Append("\xC7D\xC81\x3\x2\x2\x2\xC7E\xC7C\x3\x2\x2\x2\xC7F\xC80\a\xA7");
		sb.Append("\x2\x2\xC80\xC82\x5\x250\x129\x2\xC81\xC7F\x3\x2\x2\x2\xC81");
		sb.Append("\xC82\x3\x2\x2\x2\xC82\xC84\x3\x2\x2\x2\xC83\xC85\x5\xD0i\x2");
		sb.Append("\xC84\xC83\x3\x2\x2\x2\xC84\xC85\x3\x2\x2\x2\xC85\xC87\x3\x2");
		sb.Append("\x2\x2\xC86\xC88\x5\xFC\x7F\x2\xC87\xC86\x3\x2\x2\x2\xC87\xC88");
		sb.Append("\x3\x2\x2\x2\xC88\xCD\x3\x2\x2\x2\xC89\xC8B\a\xA1\x2\x2\xC8A");
		sb.Append("\xC8C\a^\x2\x2\xC8B\xC8A\x3\x2\x2\x2\xC8B\xC8C\x3\x2\x2\x2\xC8C");
		sb.Append("\xC8E\x3\x2\x2\x2\xC8D\xC8F\a\x45\x2\x2\xC8E\xC8D\x3\x2\x2\x2");
		sb.Append("\xC8E\xC8F\x3\x2\x2\x2\xC8F\xC90\x3\x2\x2\x2\xC90\xC91\x5\xD4");
		sb.Append("k\x2\xC91\xC92\a\x87\x2\x2\xC92\xC97\x5\xBA^\x2\xC93\xC94\a");
		sb.Append("\x3C3\x2\x2\xC94\xC96\x5\xBA^\x2\xC95\xC93\x3\x2\x2\x2\xC96");
		sb.Append("\xC99\x3\x2\x2\x2\xC97\xC95\x3\x2\x2\x2\xC97\xC98\x3\x2\x2\x2");
		sb.Append("\xC98\xC9C\x3\x2\x2\x2\xC99\xC97\x3\x2\x2\x2\xC9A\xC9B\a\xA7");
		sb.Append("\x2\x2\xC9B\xC9D\x5\x250\x129\x2\xC9C\xC9A\x3\x2\x2\x2\xC9C");
		sb.Append("\xC9D\x3\x2\x2\x2\xC9D\xCF\x3\x2\x2\x2\xC9E\xC9F\am\x2\x2\xC9F");
		sb.Append("\xCA0\a\x12\x2\x2\xCA0\xCA5\x5\xD2j\x2\xCA1\xCA2\a\x3C3\x2\x2");
		sb.Append("\xCA2\xCA4\x5\xD2j\x2\xCA3\xCA1\x3\x2\x2\x2\xCA4\xCA7\x3\x2");
		sb.Append("\x2\x2\xCA5\xCA3\x3\x2\x2\x2\xCA5\xCA6\x3\x2\x2\x2\xCA6\xD1");
		sb.Append("\x3\x2\x2\x2\xCA7\xCA5\x3\x2\x2\x2\xCA8\xCAA\x5\x250\x129\x2");
		sb.Append("\xCA9\xCAB\t+\x2\x2\xCAA\xCA9\x3\x2\x2\x2\xCAA\xCAB\x3\x2\x2");
		sb.Append("\x2\xCAB\xD3\x3\x2\x2\x2\xCAC\xCB1\x5\xD6l\x2\xCAD\xCAE\a\x3C3");
		sb.Append("\x2\x2\xCAE\xCB0\x5\xD6l\x2\xCAF\xCAD\x3\x2\x2\x2\xCB0\xCB3");
		sb.Append("\x3\x2\x2\x2\xCB1\xCAF\x3\x2\x2\x2\xCB1\xCB2\x3\x2\x2\x2\xCB2");
		sb.Append("\xD5\x3\x2\x2\x2\xCB3\xCB1\x3\x2\x2\x2\xCB4\xCB8\x5\xD8m\x2");
		sb.Append("\xCB5\xCB7\x5\xDEp\x2\xCB6\xCB5\x3\x2\x2\x2\xCB7\xCBA\x3\x2");
		sb.Append("\x2\x2\xCB8\xCB6\x3\x2\x2\x2\xCB8\xCB9\x3\x2\x2\x2\xCB9\xCC6");
		sb.Append("\x3\x2\x2\x2\xCBA\xCB8\x3\x2\x2\x2\xCBB\xCBC\a\x3C1\x2\x2\xCBC");
		sb.Append("\xCC0\x5\xD8m\x2\xCBD\xCBF\x5\xDEp\x2\xCBE\xCBD\x3\x2\x2\x2");
		sb.Append("\xCBF\xCC2\x3\x2\x2\x2\xCC0\xCBE\x3\x2\x2\x2\xCC0\xCC1\x3\x2");
		sb.Append("\x2\x2\xCC1\xCC3\x3\x2\x2\x2\xCC2\xCC0\x3\x2\x2\x2\xCC3\xCC4");
		sb.Append("\a\x3C2\x2\x2\xCC4\xCC6\x3\x2\x2\x2\xCC5\xCB4\x3\x2\x2\x2\xCC5");
		sb.Append("\xCBB\x3\x2\x2\x2\xCC6\xD7\x3\x2\x2\x2\xCC7\xCCD\x5\x1EA\xF6");
		sb.Append("\x2\xCC8\xCC9\aq\x2\x2\xCC9\xCCA\a\x3C1\x2\x2\xCCA\xCCB\x5\x222");
		sb.Append("\x112\x2\xCCB\xCCC\a\x3C2\x2\x2\xCCC\xCCE\x3\x2\x2\x2\xCCD\xCC8");
		sb.Append("\x3\x2\x2\x2\xCCD\xCCE\x3\x2\x2\x2\xCCE\xCD3\x3\x2\x2\x2\xCCF");
		sb.Append("\xCD1\a\r\x2\x2\xCD0\xCCF\x3\x2\x2\x2\xCD0\xCD1\x3\x2\x2\x2");
		sb.Append("\xCD1\xCD2\x3\x2\x2\x2\xCD2\xCD4\x5\x202\x102\x2\xCD3\xCD0\x3");
		sb.Append("\x2\x2\x2\xCD3\xCD4\x3\x2\x2\x2\xCD4\xCDD\x3\x2\x2\x2\xCD5\xCDA");
		sb.Append("\x5\xDAn\x2\xCD6\xCD7\a\x3C3\x2\x2\xCD7\xCD9\x5\xDAn\x2\xCD8");
		sb.Append("\xCD6\x3\x2\x2\x2\xCD9\xCDC\x3\x2\x2\x2\xCDA\xCD8\x3\x2\x2\x2");
		sb.Append("\xCDA\xCDB\x3\x2\x2\x2\xCDB\xCDE\x3\x2\x2\x2\xCDC\xCDA\x3\x2");
		sb.Append("\x2\x2\xCDD\xCD5\x3\x2\x2\x2\xCDD\xCDE\x3\x2\x2\x2\xCDE\xCF0");
		sb.Append("\x3\x2\x2\x2\xCDF\xCE5\x5\xB4[\x2\xCE0\xCE1\a\x3C1\x2\x2\xCE1");
		sb.Append("\xCE2\x5\xB4[\x2\xCE2\xCE3\a\x3C2\x2\x2\xCE3\xCE5\x3\x2\x2\x2");
		sb.Append("\xCE4\xCDF\x3\x2\x2\x2\xCE4\xCE0\x3\x2\x2\x2\xCE5\xCE7\x3\x2");
		sb.Append("\x2\x2\xCE6\xCE8\a\r\x2\x2\xCE7\xCE6\x3\x2\x2\x2\xCE7\xCE8\x3");
		sb.Append("\x2\x2\x2\xCE8\xCE9\x3\x2\x2\x2\xCE9\xCEA\x5\x202\x102\x2\xCEA");
		sb.Append("\xCF0\x3\x2\x2\x2\xCEB\xCEC\a\x3C1\x2\x2\xCEC\xCED\x5\xD4k\x2");
		sb.Append("\xCED\xCEE\a\x3C2\x2\x2\xCEE\xCF0\x3\x2\x2\x2\xCEF\xCC7\x3\x2");
		sb.Append("\x2\x2\xCEF\xCE4\x3\x2\x2\x2\xCEF\xCEB\x3\x2\x2\x2\xCF0\xD9");
		sb.Append("\x3\x2\x2\x2\xCF1\xCF2\t,\x2\x2\xCF2\xCF5\t\x14\x2\x2\xCF3\xCF4");
		sb.Append("\a:\x2\x2\xCF4\xCF6\x5\xDCo\x2\xCF5\xCF3\x3\x2\x2\x2\xCF5\xCF6");
		sb.Append("\x3\x2\x2\x2\xCF6\xCF7\x3\x2\x2\x2\xCF7\xCF8\a\x3C1\x2\x2\xCF8");
		sb.Append("\xCF9\x5\x222\x112\x2\xCF9\xCFA\a\x3C2\x2\x2\xCFA\xDB\x3\x2");
		sb.Append("\x2\x2\xCFB\xD01\aP\x2\x2\xCFC\xCFD\am\x2\x2\xCFD\xD01\a\x12");
		sb.Append("\x2\x2\xCFE\xCFF\a\x41\x2\x2\xCFF\xD01\a\x12\x2\x2\xD00\xCFB");
		sb.Append("\x3\x2\x2\x2\xD00\xCFC\x3\x2\x2\x2\xD00\xCFE\x3\x2\x2\x2\xD01");
		sb.Append("\xDD\x3\x2\x2\x2\xD02\xD04\t-\x2\x2\xD03\xD02\x3\x2\x2\x2\xD03");
		sb.Append("\xD04\x3\x2\x2\x2\xD04\xD05\x3\x2\x2\x2\xD05\xD06\aP\x2\x2\xD06");
		sb.Append("\xD0E\x5\xD8m\x2\xD07\xD08\ah\x2\x2\xD08\xD0F\x5\x250\x129\x2");
		sb.Append("\xD09\xD0A\a\xA4\x2\x2\xD0A\xD0B\a\x3C1\x2\x2\xD0B\xD0C\x5\x222");
		sb.Append("\x112\x2\xD0C\xD0D\a\x3C2\x2\x2\xD0D\xD0F\x3\x2\x2\x2\xD0E\xD07");
		sb.Append("\x3\x2\x2\x2\xD0E\xD09\x3\x2\x2\x2\xD0E\xD0F\x3\x2\x2\x2\xD0F");
		sb.Append("\xD2F\x3\x2\x2\x2\xD10\xD11\a\x94\x2\x2\xD11\xD14\x5\xD8m\x2");
		sb.Append("\xD12\xD13\ah\x2\x2\xD13\xD15\x5\x250\x129\x2\xD14\xD12\x3\x2");
		sb.Append("\x2\x2\xD14\xD15\x3\x2\x2\x2\xD15\xD2F\x3\x2\x2\x2\xD16\xD18");
		sb.Append("\t.\x2\x2\xD17\xD19\ao\x2\x2\xD18\xD17\x3\x2\x2\x2\xD18\xD19");
		sb.Append("\x3\x2\x2\x2\xD19\xD1A\x3\x2\x2\x2\xD1A\xD1B\aP\x2\x2\xD1B\xD23");
		sb.Append("\x5\xD8m\x2\xD1C\xD1D\ah\x2\x2\xD1D\xD24\x5\x250\x129\x2\xD1E");
		sb.Append("\xD1F\a\xA4\x2\x2\xD1F\xD20\a\x3C1\x2\x2\xD20\xD21\x5\x222\x112");
		sb.Append("\x2\xD21\xD22\a\x3C2\x2\x2\xD22\xD24\x3\x2\x2\x2\xD23\xD1C\x3");
		sb.Append("\x2\x2\x2\xD23\xD1E\x3\x2\x2\x2\xD24\xD2F\x3\x2\x2\x2\xD25\xD2A");
		sb.Append("\a\x64\x2\x2\xD26\xD28\t.\x2\x2\xD27\xD29\ao\x2\x2\xD28\xD27");
		sb.Append("\x3\x2\x2\x2\xD28\xD29\x3\x2\x2\x2\xD29\xD2B\x3\x2\x2\x2\xD2A");
		sb.Append("\xD26\x3\x2\x2\x2\xD2A\xD2B\x3\x2\x2\x2\xD2B\xD2C\x3\x2\x2\x2");
		sb.Append("\xD2C\xD2D\aP\x2\x2\xD2D\xD2F\x5\xD8m\x2\xD2E\xD03\x3\x2\x2");
		sb.Append("\x2\xD2E\xD10\x3\x2\x2\x2\xD2E\xD16\x3\x2\x2\x2\xD2E\xD25\x3");
		sb.Append("\x2\x2\x2\xD2F\xDF\x3\x2\x2\x2\xD30\xD31\a\x3C1\x2\x2\xD31\xD32");
		sb.Append("\x5\xE4s\x2\xD32\xD33\a\x3C2\x2\x2\xD33\xD39\x3\x2\x2\x2\xD34");
		sb.Append("\xD35\a\x3C1\x2\x2\xD35\xD36\x5\xE0q\x2\xD36\xD37\a\x3C2\x2");
		sb.Append("\x2\xD37\xD39\x3\x2\x2\x2\xD38\xD30\x3\x2\x2\x2\xD38\xD34\x3");
		sb.Append("\x2\x2\x2\xD39\xE1\x3\x2\x2\x2\xD3A\xD3B\a\x3C1\x2\x2\xD3B\xD3C");
		sb.Append("\x5\xE6t\x2\xD3C\xD3D\a\x3C2\x2\x2\xD3D\xD43\x3\x2\x2\x2\xD3E");
		sb.Append("\xD3F\a\x3C1\x2\x2\xD3F\xD40\x5\xE2r\x2\xD40\xD41\a\x3C2\x2");
		sb.Append("\x2\xD41\xD43\x3\x2\x2\x2\xD42\xD3A\x3\x2\x2\x2\xD42\xD3E\x3");
		sb.Append("\x2\x2\x2\xD43\xE3\x3\x2\x2\x2\xD44\xD48\a\x86\x2\x2\xD45\xD47");
		sb.Append("\x5\xECw\x2\xD46\xD45\x3\x2\x2\x2\xD47\xD4A\x3\x2\x2\x2\xD48");
		sb.Append("\xD46\x3\x2\x2\x2\xD48\xD49\x3\x2\x2\x2\xD49\xD4B\x3\x2\x2\x2");
		sb.Append("\xD4A\xD48\x3\x2\x2\x2\xD4B\xD4D\x5\xEEx\x2\xD4C\xD4E\x5\xF2");
		sb.Append("z\x2\xD4D\xD4C\x3\x2\x2\x2\xD4D\xD4E\x3\x2\x2\x2\xD4E\xD50\x3");
		sb.Append("\x2\x2\x2\xD4F\xD51\x5\xF8}\x2\xD50\xD4F\x3\x2\x2\x2\xD50\xD51");
		sb.Append("\x3\x2\x2\x2\xD51\xD53\x3\x2\x2\x2\xD52\xD54\x5\xD0i\x2\xD53");
		sb.Append("\xD52\x3\x2\x2\x2\xD53\xD54\x3\x2\x2\x2\xD54\xD56\x3\x2\x2\x2");
		sb.Append("\xD55\xD57\x5\xFC\x7F\x2\xD56\xD55\x3\x2\x2\x2\xD56\xD57\x3");
		sb.Append("\x2\x2\x2\xD57\xD6D\x3\x2\x2\x2\xD58\xD5C\a\x86\x2\x2\xD59\xD5B");
		sb.Append("\x5\xECw\x2\xD5A\xD59\x3\x2\x2\x2\xD5B\xD5E\x3\x2\x2\x2\xD5C");
		sb.Append("\xD5A\x3\x2\x2\x2\xD5C\xD5D\x3\x2\x2\x2\xD5D\xD5F\x3\x2\x2\x2");
		sb.Append("\xD5E\xD5C\x3\x2\x2\x2\xD5F\xD61\x5\xEEx\x2\xD60\xD62\x5\xF8");
		sb.Append("}\x2\xD61\xD60\x3\x2\x2\x2\xD61\xD62\x3\x2\x2\x2\xD62\xD64\x3");
		sb.Append("\x2\x2\x2\xD63\xD65\x5\xD0i\x2\xD64\xD63\x3\x2\x2\x2\xD64\xD65");
		sb.Append("\x3\x2\x2\x2\xD65\xD67\x3\x2\x2\x2\xD66\xD68\x5\xFC\x7F\x2\xD67");
		sb.Append("\xD66\x3\x2\x2\x2\xD67\xD68\x3\x2\x2\x2\xD68\xD6A\x3\x2\x2\x2");
		sb.Append("\xD69\xD6B\x5\xF2z\x2\xD6A\xD69\x3\x2\x2\x2\xD6A\xD6B\x3\x2");
		sb.Append("\x2\x2\xD6B\xD6D\x3\x2\x2\x2\xD6C\xD44\x3\x2\x2\x2\xD6C\xD58");
		sb.Append("\x3\x2\x2\x2\xD6D\xE5\x3\x2\x2\x2\xD6E\xD72\a\x86\x2\x2\xD6F");
		sb.Append("\xD71\x5\xECw\x2\xD70\xD6F\x3\x2\x2\x2\xD71\xD74\x3\x2\x2\x2");
		sb.Append("\xD72\xD70\x3\x2\x2\x2\xD72\xD73\x3\x2\x2\x2\xD73\xD75\x3\x2");
		sb.Append("\x2\x2\xD74\xD72\x3\x2\x2\x2\xD75\xD77\x5\xEEx\x2\xD76\xD78");
		sb.Append("\x5\xF8}\x2\xD77\xD76\x3\x2\x2\x2\xD77\xD78\x3\x2\x2\x2\xD78");
		sb.Append("\xD7A\x3\x2\x2\x2\xD79\xD7B\x5\xD0i\x2\xD7A\xD79\x3\x2\x2\x2");
		sb.Append("\xD7A\xD7B\x3\x2\x2\x2\xD7B\xD7D\x3\x2\x2\x2\xD7C\xD7E\x5\xFC");
		sb.Append("\x7F\x2\xD7D\xD7C\x3\x2\x2\x2\xD7D\xD7E\x3\x2\x2\x2\xD7E\xE7");
		sb.Append("\x3\x2\x2\x2\xD7F\xD81\a\x9D\x2\x2\xD80\xD82\t\'\x2\x2\xD81");
		sb.Append("\xD80\x3\x2\x2\x2\xD81\xD82\x3\x2\x2\x2\xD82\xD83\x3\x2\x2\x2");
		sb.Append("\xD83\xD84\x5\xE2r\x2\xD84\xE9\x3\x2\x2\x2\xD85\xD87\a\x9D\x2");
		sb.Append("\x2\xD86\xD88\t\'\x2\x2\xD87\xD86\x3\x2\x2\x2\xD87\xD88\x3\x2");
		sb.Append("\x2\x2\xD88\xD8B\x3\x2\x2\x2\xD89\xD8C\x5\xE6t\x2\xD8A\xD8C");
		sb.Append("\x5\xE2r\x2\xD8B\xD89\x3\x2\x2\x2\xD8B\xD8A\x3\x2\x2\x2\xD8C");
		sb.Append("\xEB\x3\x2\x2\x2\xD8D\xD96\t/\x2\x2\xD8E\xD96\a\x43\x2\x2\xD8F");
		sb.Append("\xD96\a\x94\x2\x2\xD90\xD96\a\x91\x2\x2\xD91\xD96\a\x8F\x2\x2");
		sb.Append("\xD92\xD96\a\x1FB\x2\x2\xD93\xD96\t\x30\x2\x2\xD94\xD96\a\x90");
		sb.Append("\x2\x2\xD95\xD8D\x3\x2\x2\x2\xD95\xD8E\x3\x2\x2\x2\xD95\xD8F");
		sb.Append("\x3\x2\x2\x2\xD95\xD90\x3\x2\x2\x2\xD95\xD91\x3\x2\x2\x2\xD95");
		sb.Append("\xD92\x3\x2\x2\x2\xD95\xD93\x3\x2\x2\x2\xD95\xD94\x3\x2\x2\x2");
		sb.Append("\xD96\xED\x3\x2\x2\x2\xD97\xD9A\a\x3B0\x2\x2\xD98\xD9A\x5\xF0");
		sb.Append("y\x2\xD99\xD97\x3\x2\x2\x2\xD99\xD98\x3\x2\x2\x2\xD9A\xD9F\x3");
		sb.Append("\x2\x2\x2\xD9B\xD9C\a\x3C3\x2\x2\xD9C\xD9E\x5\xF0y\x2\xD9D\xD9B");
		sb.Append("\x3\x2\x2\x2\xD9E\xDA1\x3\x2\x2\x2\xD9F\xD9D\x3\x2\x2\x2\xD9F");
		sb.Append("\xDA0\x3\x2\x2\x2\xDA0\xEF\x3\x2\x2\x2\xDA1\xD9F\x3\x2\x2\x2");
		sb.Append("\xDA2\xDA3\x5\x1E8\xF5\x2\xDA3\xDA4\a\x3C0\x2\x2\xDA4\xDA5\a");
		sb.Append("\x3B0\x2\x2\xDA5\xDC0\x3\x2\x2\x2\xDA6\xDAB\x5\x1EC\xF7\x2\xDA7");
		sb.Append("\xDA9\a\r\x2\x2\xDA8\xDA7\x3\x2\x2\x2\xDA8\xDA9\x3\x2\x2\x2");
		sb.Append("\xDA9\xDAA\x3\x2\x2\x2\xDAA\xDAC\x5\x202\x102\x2\xDAB\xDA8\x3");
		sb.Append("\x2\x2\x2\xDAB\xDAC\x3\x2\x2\x2\xDAC\xDC0\x3\x2\x2\x2\xDAD\xDB2");
		sb.Append("\x5\x23C\x11F\x2\xDAE\xDB0\a\r\x2\x2\xDAF\xDAE\x3\x2\x2\x2\xDAF");
		sb.Append("\xDB0\x3\x2\x2\x2\xDB0\xDB1\x3\x2\x2\x2\xDB1\xDB3\x5\x202\x102");
		sb.Append("\x2\xDB2\xDAF\x3\x2\x2\x2\xDB2\xDB3\x3\x2\x2\x2\xDB3\xDC0\x3");
		sb.Append("\x2\x2\x2\xDB4\xDB5\a\x3DB\x2\x2\xDB5\xDB7\a\x3A7\x2\x2\xDB6");
		sb.Append("\xDB4\x3\x2\x2\x2\xDB6\xDB7\x3\x2\x2\x2\xDB7\xDB8\x3\x2\x2\x2");
		sb.Append("\xDB8\xDBD\x5\x250\x129\x2\xDB9\xDBB\a\r\x2\x2\xDBA\xDB9\x3");
		sb.Append("\x2\x2\x2\xDBA\xDBB\x3\x2\x2\x2\xDBB\xDBC\x3\x2\x2\x2\xDBC\xDBE");
		sb.Append("\x5\x202\x102\x2\xDBD\xDBA\x3\x2\x2\x2\xDBD\xDBE\x3\x2\x2\x2");
		sb.Append("\xDBE\xDC0\x3\x2\x2\x2\xDBF\xDA2\x3\x2\x2\x2\xDBF\xDA6\x3\x2");
		sb.Append("\x2\x2\xDBF\xDAD\x3\x2\x2\x2\xDBF\xDB6\x3\x2\x2\x2\xDC0\xF1");
		sb.Append("\x3\x2\x2\x2\xDC1\xDC2\aM\x2\x2\xDC2\xDC7\x5\xBC_\x2\xDC3\xDC4");
		sb.Append("\a\x3C3\x2\x2\xDC4\xDC6\x5\xBC_\x2\xDC5\xDC3\x3\x2\x2\x2\xDC6");
		sb.Append("\xDC9\x3\x2\x2\x2\xDC7\xDC5\x3\x2\x2\x2\xDC7\xDC8\x3\x2\x2\x2");
		sb.Append("\xDC8\xDE6\x3\x2\x2\x2\xDC9\xDC7\x3\x2\x2\x2\xDCA\xDCB\aM\x2");
		sb.Append("\x2\xDCB\xDCC\a\x139\x2\x2\xDCC\xDE6\a\x3D0\x2\x2\xDCD\xDCE");
		sb.Append("\aM\x2\x2\xDCE\xDCF\ap\x2\x2\xDCF\xDD3\a\x3D0\x2\x2\xDD0\xDD1");
		sb.Append("\a\x18\x2\x2\xDD1\xDD2\a\x87\x2\x2\xDD2\xDD4\x5\x1F4\xFB\x2");
		sb.Append("\xDD3\xDD0\x3\x2\x2\x2\xDD3\xDD4\x3\x2\x2\x2\xDD4\xDDB\x3\x2");
		sb.Append("\x2\x2\xDD5\xDD7\t$\x2\x2\xDD6\xDD8\x5\xF4{\x2\xDD7\xDD6\x3");
		sb.Append("\x2\x2\x2\xDD8\xDD9\x3\x2\x2\x2\xDD9\xDD7\x3\x2\x2\x2\xDD9\xDDA");
		sb.Append("\x3\x2\x2\x2\xDDA\xDDC\x3\x2\x2\x2\xDDB\xDD5\x3\x2\x2\x2\xDDB");
		sb.Append("\xDDC\x3\x2\x2\x2\xDDC\xDE3\x3\x2\x2\x2\xDDD\xDDF\aZ\x2\x2\xDDE");
		sb.Append("\xDE0\x5\xF6|\x2\xDDF\xDDE\x3\x2\x2\x2\xDE0\xDE1\x3\x2\x2\x2");
		sb.Append("\xDE1\xDDF\x3\x2\x2\x2\xDE1\xDE2\x3\x2\x2\x2\xDE2\xDE4\x3\x2");
		sb.Append("\x2\x2\xDE3\xDDD\x3\x2\x2\x2\xDE3\xDE4\x3\x2\x2\x2\xDE4\xDE6");
		sb.Append("\x3\x2\x2\x2\xDE5\xDC1\x3\x2\x2\x2\xDE5\xDCA\x3\x2\x2\x2\xDE5");
		sb.Append("\xDCD\x3\x2\x2\x2\xDE6\xF3\x3\x2\x2\x2\xDE7\xDE8\a\x96\x2\x2");
		sb.Append("\xDE8\xDE9\a\x12\x2\x2\xDE9\xDF4\a\x3D0\x2\x2\xDEA\xDEC\ak\x2");
		sb.Append("\x2\xDEB\xDEA\x3\x2\x2\x2\xDEB\xDEC\x3\x2\x2\x2\xDEC\xDED\x3");
		sb.Append("\x2\x2\x2\xDED\xDEE\a\x33\x2\x2\xDEE\xDEF\a\x12\x2\x2\xDEF\xDF4");
		sb.Append("\a\x3D0\x2\x2\xDF0\xDF1\a\x34\x2\x2\xDF1\xDF2\a\x12\x2\x2\xDF2");
		sb.Append("\xDF4\a\x3D0\x2\x2\xDF3\xDE7\x3\x2\x2\x2\xDF3\xDEB\x3\x2\x2");
		sb.Append("\x2\xDF3\xDF0\x3\x2\x2\x2\xDF4\xF5\x3\x2\x2\x2\xDF5\xDF6\a\x93");
		sb.Append("\x2\x2\xDF6\xDF7\a\x12\x2\x2\xDF7\xDFC\a\x3D0\x2\x2\xDF8\xDF9");
		sb.Append("\a\x96\x2\x2\xDF9\xDFA\a\x12\x2\x2\xDFA\xDFC\a\x3D0\x2\x2\xDFB");
		sb.Append("\xDF5\x3\x2\x2\x2\xDFB\xDF8\x3\x2\x2\x2\xDFC\xF7\x3\x2\x2\x2");
		sb.Append("\xDFD\xDFE\a=\x2\x2\xDFE\xE01\x5\xD4k\x2\xDFF\xE00\a\xA7\x2");
		sb.Append("\x2\xE00\xE02\x5\x250\x129\x2\xE01\xDFF\x3\x2\x2\x2\xE01\xE02");
		sb.Append("\x3\x2\x2\x2\xE02\xE11\x3\x2\x2\x2\xE03\xE04\a\x41\x2\x2\xE04");
		sb.Append("\xE05\a\x12\x2\x2\xE05\xE0A\x5\xFA~\x2\xE06\xE07\a\x3C3\x2\x2");
		sb.Append("\xE07\xE09\x5\xFA~\x2\xE08\xE06\x3\x2\x2\x2\xE09\xE0C\x3\x2");
		sb.Append("\x2\x2\xE0A\xE08\x3\x2\x2\x2\xE0A\xE0B\x3\x2\x2\x2\xE0B\xE0F");
		sb.Append("\x3\x2\x2\x2\xE0C\xE0A\x3\x2\x2\x2\xE0D\xE0E\a\xA9\x2\x2\xE0E");
		sb.Append("\xE10\a\x1E2\x2\x2\xE0F\xE0D\x3\x2\x2\x2\xE0F\xE10\x3\x2\x2");
		sb.Append("\x2\xE10\xE12\x3\x2\x2\x2\xE11\xE03\x3\x2\x2\x2\xE11\xE12\x3");
		sb.Append("\x2\x2\x2\xE12\xE15\x3\x2\x2\x2\xE13\xE14\a\x42\x2\x2\xE14\xE16");
		sb.Append("\x5\x250\x129\x2\xE15\xE13\x3\x2\x2\x2\xE15\xE16\x3\x2\x2\x2");
		sb.Append("\xE16\xF9\x3\x2\x2\x2\xE17\xE19\x5\x250\x129\x2\xE18\xE1A\t");
		sb.Append("+\x2\x2\xE19\xE18\x3\x2\x2\x2\xE19\xE1A\x3\x2\x2\x2\xE1A\xFB");
		sb.Append("\x3\x2\x2\x2\xE1B\xE26\aX\x2\x2\xE1C\xE1D\x5\xFE\x80\x2\xE1D");
		sb.Append("\xE1E\a\x3C3\x2\x2\xE1E\xE20\x3\x2\x2\x2\xE1F\xE1C\x3\x2\x2");
		sb.Append("\x2\xE1F\xE20\x3\x2\x2\x2\xE20\xE21\x3\x2\x2\x2\xE21\xE27\x5");
		sb.Append("\xFE\x80\x2\xE22\xE23\x5\xFE\x80\x2\xE23\xE24\a\x1AB\x2\x2\xE24");
		sb.Append("\xE25\x5\xFE\x80\x2\xE25\xE27\x3\x2\x2\x2\xE26\xE1F\x3\x2\x2");
		sb.Append("\x2\xE26\xE22\x3\x2\x2\x2\xE27\xFD\x3\x2\x2\x2\xE28\xE2B\x5");
		sb.Append("\x208\x105\x2\xE29\xE2B\x5\x1F2\xFA\x2\xE2A\xE28\x3\x2\x2\x2");
		sb.Append("\xE2A\xE29\x3\x2\x2\x2\xE2B\xFF\x3\x2\x2\x2\xE2C\xE2D\a\x1FF");
		sb.Append("\x2\x2\xE2D\xE36\a\x214\x2\x2\xE2E\xE33\x5\x116\x8C\x2\xE2F");
		sb.Append("\xE30\a\x3C3\x2\x2\xE30\xE32\x5\x116\x8C\x2\xE31\xE2F\x3\x2");
		sb.Append("\x2\x2\xE32\xE35\x3\x2\x2\x2\xE33\xE31\x3\x2\x2\x2\xE33\xE34");
		sb.Append("\x3\x2\x2\x2\xE34\xE37\x3\x2\x2\x2\xE35\xE33\x3\x2\x2\x2\xE36");
		sb.Append("\xE2E\x3\x2\x2\x2\xE36\xE37\x3\x2\x2\x2\xE37\x101\x3\x2\x2\x2");
		sb.Append("\xE38\xE3A\a\x10A\x2\x2\xE39\xE3B\a\x229\x2\x2\xE3A\xE39\x3");
		sb.Append("\x2\x2\x2\xE3A\xE3B\x3\x2\x2\x2\xE3B\x103\x3\x2\x2\x2\xE3C\xE3E");
		sb.Append("\a\x120\x2\x2\xE3D\xE3F\a\x229\x2\x2\xE3E\xE3D\x3\x2\x2\x2\xE3E");
		sb.Append("\xE3F\x3\x2\x2\x2\xE3F\xE45\x3\x2\x2\x2\xE40\xE42\a\f\x2\x2");
		sb.Append("\xE41\xE43\a\x1A7\x2\x2\xE42\xE41\x3\x2\x2\x2\xE42\xE43\x3\x2");
		sb.Append("\x2\x2\xE43\xE44\x3\x2\x2\x2\xE44\xE46\a\x113\x2\x2\xE45\xE40");
		sb.Append("\x3\x2\x2\x2\xE45\xE46\x3\x2\x2\x2\xE46\xE4B\x3\x2\x2\x2\xE47");
		sb.Append("\xE49\a\x1A7\x2\x2\xE48\xE47\x3\x2\x2\x2\xE48\xE49\x3\x2\x2");
		sb.Append("\x2\xE49\xE4A\x3\x2\x2\x2\xE4A\xE4C\az\x2\x2\xE4B\xE48\x3\x2");
		sb.Append("\x2\x2\xE4B\xE4C\x3\x2\x2\x2\xE4C\x105\x3\x2\x2\x2\xE4D\xE4F");
		sb.Append("\a\x1E1\x2\x2\xE4E\xE50\a\x229\x2\x2\xE4F\xE4E\x3\x2\x2\x2\xE4F");
		sb.Append("\xE50\x3\x2\x2\x2\xE50\xE56\x3\x2\x2\x2\xE51\xE53\a\f\x2\x2");
		sb.Append("\xE52\xE54\a\x1A7\x2\x2\xE53\xE52\x3\x2\x2\x2\xE53\xE54\x3\x2");
		sb.Append("\x2\x2\xE54\xE55\x3\x2\x2\x2\xE55\xE57\a\x113\x2\x2\xE56\xE51");
		sb.Append("\x3\x2\x2\x2\xE56\xE57\x3\x2\x2\x2\xE57\xE5C\x3\x2\x2\x2\xE58");
		sb.Append("\xE5A\a\x1A7\x2\x2\xE59\xE58\x3\x2\x2\x2\xE59\xE5A\x3\x2\x2");
		sb.Append("\x2\xE5A\xE5B\x3\x2\x2\x2\xE5B\xE5D\az\x2\x2\xE5C\xE59\x3\x2");
		sb.Append("\x2\x2\xE5C\xE5D\x3\x2\x2\x2\xE5D\x107\x3\x2\x2\x2\xE5E\xE5F");
		sb.Append("\a\x1E7\x2\x2\xE5F\xE60\x5\x202\x102\x2\xE60\x109\x3\x2\x2\x2");
		sb.Append("\xE61\xE63\a\x1E1\x2\x2\xE62\xE64\a\x229\x2\x2\xE63\xE62\x3");
		sb.Append("\x2\x2\x2\xE63\xE64\x3\x2\x2\x2\xE64\xE65\x3\x2\x2\x2\xE65\xE67");
		sb.Append("\a\x98\x2\x2\xE66\xE68\a\x1E7\x2\x2\xE67\xE66\x3\x2\x2\x2\xE67");
		sb.Append("\xE68\x3\x2\x2\x2\xE68\xE69\x3\x2\x2\x2\xE69\xE6A\x5\x202\x102");
		sb.Append("\x2\xE6A\x10B\x3\x2\x2\x2\xE6B\xE6C\az\x2\x2\xE6C\xE6D\a\x1E7");
		sb.Append("\x2\x2\xE6D\xE6E\x5\x202\x102\x2\xE6E\x10D\x3\x2\x2\x2\xE6F");
		sb.Append("\xE70\a\\\x2\x2\xE70\xE71\a\x23B\x2\x2\xE71\xE76\x5\x118\x8D");
		sb.Append("\x2\xE72\xE73\a\x3C3\x2\x2\xE73\xE75\x5\x118\x8D\x2\xE74\xE72");
		sb.Append("\x3\x2\x2\x2\xE75\xE78\x3\x2\x2\x2\xE76\xE74\x3\x2\x2\x2\xE76");
		sb.Append("\xE77\x3\x2\x2\x2\xE77\x10F\x3\x2\x2\x2\xE78\xE76\x3\x2\x2\x2");
		sb.Append("\xE79\xE7A\a\x9F\x2\x2\xE7A\xE7B\a\x23B\x2\x2\xE7B\x111\x3\x2");
		sb.Append("\x2\x2\xE7C\xE7D\a\x87\x2\x2\xE7D\xE7E\a\x106\x2\x2\xE7E\xE7F");
		sb.Append("\a\x3B8\x2\x2\xE7F\xE80\t\x18\x2\x2\xE80\x113\x3\x2\x2\x2\xE81");
		sb.Append("\xE83\a\x87\x2\x2\xE82\xE84\t\x31\x2\x2\xE83\xE82\x3\x2\x2\x2");
		sb.Append("\xE83\xE84\x3\x2\x2\x2\xE84\xE85\x3\x2\x2\x2\xE85\xE86\a\x214");
		sb.Append("\x2\x2\xE86\xE8B\x5\x11C\x8F\x2\xE87\xE88\a\x3C3\x2\x2\xE88");
		sb.Append("\xE8A\x5\x11C\x8F\x2\xE89\xE87\x3\x2\x2\x2\xE8A\xE8D\x3\x2\x2");
		sb.Append("\x2\xE8B\xE89\x3\x2\x2\x2\xE8B\xE8C\x3\x2\x2\x2\xE8C\x115\x3");
		sb.Append("\x2\x2\x2\xE8D\xE8B\x3\x2\x2\x2\xE8E\xE8F\a\xA9\x2\x2\xE8F\xE90");
		sb.Append("\a\x127\x2\x2\xE90\xE96\a\x1F2\x2\x2\xE91\xE92\av\x2\x2\xE92");
		sb.Append("\xE96\a\xAA\x2\x2\xE93\xE94\av\x2\x2\xE94\xE96\a\x1B0\x2\x2");
		sb.Append("\xE95\xE8E\x3\x2\x2\x2\xE95\xE91\x3\x2\x2\x2\xE95\xE93\x3\x2");
		sb.Append("\x2\x2\xE96\x117\x3\x2\x2\x2\xE97\xE9C\x5\x1EA\xF6\x2\xE98\xE9A");
		sb.Append("\a\r\x2\x2\xE99\xE98\x3\x2\x2\x2\xE99\xE9A\x3\x2\x2\x2\xE9A");
		sb.Append("\xE9B\x3\x2\x2\x2\xE9B\xE9D\x5\x202\x102\x2\xE9C\xE99\x3\x2");
		sb.Append("\x2\x2\xE9C\xE9D\x3\x2\x2\x2\xE9D\xE9E\x3\x2\x2\x2\xE9E\xE9F");
		sb.Append("\x5\x11A\x8E\x2\xE9F\x119\x3\x2\x2\x2\xEA0\xEA2\av\x2\x2\xEA1");
		sb.Append("\xEA3\a\x17B\x2\x2\xEA2\xEA1\x3\x2\x2\x2\xEA2\xEA3\x3\x2\x2");
		sb.Append("\x2\xEA3\xEA9\x3\x2\x2\x2\xEA4\xEA6\a^\x2\x2\xEA5\xEA4\x3\x2");
		sb.Append("\x2\x2\xEA5\xEA6\x3\x2\x2\x2\xEA6\xEA7\x3\x2\x2\x2\xEA7\xEA9");
		sb.Append("\a\xAA\x2\x2\xEA8\xEA0\x3\x2\x2\x2\xEA8\xEA5\x3\x2\x2\x2\xEA9");
		sb.Append("\x11B\x3\x2\x2\x2\xEAA\xEAB\a\x171\x2\x2\xEAB\xEAC\a\x179\x2");
		sb.Append("\x2\xEAC\xEB2\x5\x11E\x90\x2\xEAD\xEAE\av\x2\x2\xEAE\xEB2\a");
		sb.Append("\xAA\x2\x2\xEAF\xEB0\av\x2\x2\xEB0\xEB2\a\x1B0\x2\x2\xEB1\xEAA");
		sb.Append("\x3\x2\x2\x2\xEB1\xEAD\x3\x2\x2\x2\xEB1\xEAF\x3\x2\x2\x2\xEB2");
		sb.Append("\x11D\x3\x2\x2\x2\xEB3\xEB4\a\x278\x2\x2\xEB4\xEBB\av\x2\x2");
		sb.Append("\xEB5\xEB6\av\x2\x2\xEB6\xEBB\a\x279\x2\x2\xEB7\xEB8\av\x2\x2");
		sb.Append("\xEB8\xEBB\a\x27A\x2\x2\xEB9\xEBB\a\x27B\x2\x2\xEBA\xEB3\x3");
		sb.Append("\x2\x2\x2\xEBA\xEB5\x3\x2\x2\x2\xEBA\xEB7\x3\x2\x2\x2\xEBA\xEB9");
		sb.Append("\x3\x2\x2\x2\xEBB\x11F\x3\x2\x2\x2\xEBC\xEBD\a\x17\x2\x2\xEBD");
		sb.Append("\xEBE\a\x17E\x2\x2\xEBE\xEBF\a\x98\x2\x2\xEBF\xEC4\x5\x132\x9A");
		sb.Append("\x2\xEC0\xEC1\a\x3C3\x2\x2\xEC1\xEC3\x5\x132\x9A\x2\xEC2\xEC0");
		sb.Append("\x3\x2\x2\x2\xEC3\xEC6\x3\x2\x2\x2\xEC4\xEC2\x3\x2\x2\x2\xEC4");
		sb.Append("\xEC5\x3\x2\x2\x2\xEC5\xEC8\x3\x2\x2\x2\xEC6\xEC4\x3\x2\x2\x2");
		sb.Append("\xEC7\xEC9\x5\x13A\x9E\x2\xEC8\xEC7\x3\x2\x2\x2\xEC8\xEC9\x3");
		sb.Append("\x2\x2\x2\xEC9\x121\x3\x2\x2\x2\xECA\xECB\a\x17\x2\x2\xECB\xECC");
		sb.Append("\a\x1DD\x2\x2\xECC\xECD\a\x153\x2\x2\xECD\xED2\x5\x13C\x9F\x2");
		sb.Append("\xECE\xECF\a\x3C3\x2\x2\xECF\xED1\x5\x13C\x9F\x2\xED0\xECE\x3");
		sb.Append("\x2\x2\x2\xED1\xED4\x3\x2\x2\x2\xED2\xED0\x3\x2\x2\x2\xED2\xED3");
		sb.Append("\x3\x2\x2\x2\xED3\x123\x3\x2\x2\x2\xED4\xED2\x3\x2\x2\x2\xED5");
		sb.Append("\xED6\at\x2\x2\xED6\xED7\t\x32\x2\x2\xED7\xEDC\a\x17D\x2\x2");
		sb.Append("\xED8\xED9\a\x98\x2\x2\xED9\xEDD\a\x3D0\x2\x2\xEDA\xEDB\a\xF");
		sb.Append("\x2\x2\xEDB\xEDD\a\x3D0\x2\x2\xEDC\xED8\x3\x2\x2\x2\xEDC\xEDA");
		sb.Append("\x3\x2\x2\x2\xEDD\x125\x3\x2\x2\x2\xEDE\xEDF\a\x1DE\x2\x2\xEDF");
		sb.Append("\xEE0\a\x17E\x2\x2\xEE0\x127\x3\x2\x2\x2\xEE1\xEE2\a\x1DE\x2");
		sb.Append("\x2\xEE2\xEE4\a\x1F0\x2\x2\xEE3\xEE5\a\b\x2\x2\xEE4\xEE3\x3");
		sb.Append("\x2\x2\x2\xEE4\xEE5\x3\x2\x2\x2\xEE5\xEE7\x3\x2\x2\x2\xEE6\xEE8");
		sb.Append("\x5\x13A\x9E\x2\xEE7\xEE6\x3\x2\x2\x2\xEE7\xEE8\x3\x2\x2\x2");
		sb.Append("\xEE8\x129\x3\x2\x2\x2\xEE9\xEEA\a\x1FF\x2\x2\xEEA\xEF3\a\x1F0");
		sb.Append("\x2\x2\xEEB\xEF0\x5\x140\xA1\x2\xEEC\xEED\a\x3C3\x2\x2\xEED");
		sb.Append("\xEEF\x5\x140\xA1\x2\xEEE\xEEC\x3\x2\x2\x2\xEEF\xEF2\x3\x2\x2");
		sb.Append("\x2\xEF0\xEEE\x3\x2\x2\x2\xEF0\xEF1\x3\x2\x2\x2\xEF1\xEF4\x3");
		sb.Append("\x2\x2\x2\xEF2\xEF0\x3\x2\x2\x2\xEF3\xEEB\x3\x2\x2\x2\xEF3\xEF4");
		sb.Append("\x3\x2\x2\x2\xEF4\xEF7\x3\x2\x2\x2\xEF5\xEF6\a\x21C\x2\x2\xEF6");
		sb.Append("\xEF8\x5\x142\xA2\x2\xEF7\xEF5\x3\x2\x2\x2\xEF7\xEF8\x3\x2\x2");
		sb.Append("\x2\xEF8\xEFC\x3\x2\x2\x2\xEF9\xEFB\x5\x144\xA3\x2\xEFA\xEF9");
		sb.Append("\x3\x2\x2\x2\xEFB\xEFE\x3\x2\x2\x2\xEFC\xEFA\x3\x2\x2\x2\xEFC");
		sb.Append("\xEFD\x3\x2\x2\x2\xEFD\xF00\x3\x2\x2\x2\xEFE\xEFC\x3\x2\x2\x2");
		sb.Append("\xEFF\xF01\x5\x13A\x9E\x2\xF00\xEFF\x3\x2\x2\x2\xF00\xF01\x3");
		sb.Append("\x2\x2\x2\xF01\x12B\x3\x2\x2\x2\xF02\xF03\a\x205\x2\x2\xF03");
		sb.Append("\xF0C\a\x1F0\x2\x2\xF04\xF09\x5\x140\xA1\x2\xF05\xF06\a\x3C3");
		sb.Append("\x2\x2\xF06\xF08\x5\x140\xA1\x2\xF07\xF05\x3\x2\x2\x2\xF08\xF0B");
		sb.Append("\x3\x2\x2\x2\xF09\xF07\x3\x2\x2\x2\xF09\xF0A\x3\x2\x2\x2\xF0A");
		sb.Append("\xF0D\x3\x2\x2\x2\xF0B\xF09\x3\x2\x2\x2\xF0C\xF04\x3\x2\x2\x2");
		sb.Append("\xF0C\xF0D\x3\x2\x2\x2\xF0D\x12D\x3\x2\x2\x2\xF0E\xF0F\a\x1FF");
		sb.Append("\x2\x2\xF0F\xF10\a\x15E\x2\x2\xF10\x12F\x3\x2\x2\x2\xF11\xF12");
		sb.Append("\a\x205\x2\x2\xF12\xF13\a\x15E\x2\x2\xF13\x131\x3\x2\x2\x2\xF14");
		sb.Append("\xF15\x5\x134\x9B\x2\xF15\xF16\a\x3B8\x2\x2\xF16\xF17\a\x3D0");
		sb.Append("\x2\x2\xF17\xF32\x3\x2\x2\x2\xF18\xF19\x5\x136\x9C\x2\xF19\xF1A");
		sb.Append("\a\x3B8\x2\x2\xF1A\xF1B\x5\x208\x105\x2\xF1B\xF32\x3\x2\x2\x2");
		sb.Append("\xF1C\xF1D\x5\x138\x9D\x2\xF1D\xF1E\a\x3B8\x2\x2\xF1E\xF1F\t");
		sb.Append("\x18\x2\x2\xF1F\xF32\x3\x2\x2\x2\xF20\xF21\a\x182\x2\x2\xF21");
		sb.Append("\xF22\a\x3B8\x2\x2\xF22\xF32\a\x3D3\x2\x2\xF23\xF24\a\x165\x2");
		sb.Append("\x2\xF24\xF25\a\x3B8\x2\x2\xF25\xF2E\a\x3C1\x2\x2\xF26\xF2B");
		sb.Append("\x5\x202\x102\x2\xF27\xF28\a\x3C3\x2\x2\xF28\xF2A\x5\x202\x102");
		sb.Append("\x2\xF29\xF27\x3\x2\x2\x2\xF2A\xF2D\x3\x2\x2\x2\xF2B\xF29\x3");
		sb.Append("\x2\x2\x2\xF2B\xF2C\x3\x2\x2\x2\xF2C\xF2F\x3\x2\x2\x2\xF2D\xF2B");
		sb.Append("\x3\x2\x2\x2\xF2E\xF26\x3\x2\x2\x2\xF2E\xF2F\x3\x2\x2\x2\xF2F");
		sb.Append("\xF30\x3\x2\x2\x2\xF30\xF32\a\x3C2\x2\x2\xF31\xF14\x3\x2\x2");
		sb.Append("\x2\xF31\xF18\x3\x2\x2\x2\xF31\xF1C\x3\x2\x2\x2\xF31\xF20\x3");
		sb.Append("\x2\x2\x2\xF31\xF23\x3\x2\x2\x2\xF32\x133\x3\x2\x2\x2\xF33\xF34");
		sb.Append("\t\x33\x2\x2\xF34\x135\x3\x2\x2\x2\xF35\xF36\t\x34\x2\x2\xF36");
		sb.Append("\x137\x3\x2\x2\x2\xF37\xF38\t\x35\x2\x2\xF38\x139\x3\x2\x2\x2");
		sb.Append("\xF39\xF3A\a:\x2\x2\xF3A\xF3B\a\x115\x2\x2\xF3B\xF3C\a\x3D0");
		sb.Append("\x2\x2\xF3C\x13B\x3\x2\x2\x2\xF3D\xF3E\a\x1D6\x2\x2\xF3E\xF3F");
		sb.Append("\a\x3B8\x2\x2\xF3F\xF40\a\x3C1\x2\x2\xF40\xF41\x5\x222\x112");
		sb.Append("\x2\xF41\xF42\a\x3C2\x2\x2\xF42\xF6F\x3\x2\x2\x2\xF43\xF44\a");
		sb.Append("\x1D8\x2\x2\xF44\xF45\a\x3B8\x2\x2\xF45\xF46\a\x3C1\x2\x2\xF46");
		sb.Append("\xF47\x5\x222\x112\x2\xF47\xF48\a\x3C2\x2\x2\xF48\xF6F\x3\x2");
		sb.Append("\x2\x2\xF49\xF4A\a\x1D7\x2\x2\xF4A\xF4B\a\x3B8\x2\x2\xF4B\xF4C");
		sb.Append("\a\x3C1\x2\x2\xF4C\xF4D\x5\x224\x113\x2\xF4D\xF4E\a\x3C2\x2");
		sb.Append("\x2\xF4E\xF6F\x3\x2\x2\x2\xF4F\xF50\a\x1D9\x2\x2\xF50\xF51\a");
		sb.Append("\x3B8\x2\x2\xF51\xF52\a\x3C1\x2\x2\xF52\xF53\x5\x224\x113\x2");
		sb.Append("\xF53\xF54\a\x3C2\x2\x2\xF54\xF6F\x3\x2\x2\x2\xF55\xF56\a\x1DB");
		sb.Append("\x2\x2\xF56\xF57\a\x3B8\x2\x2\xF57\xF58\a\x3C1\x2\x2\xF58\xF59");
		sb.Append("\x5\x22E\x118\x2\xF59\xF5A\a\x3C2\x2\x2\xF5A\xF6F\x3\x2\x2\x2");
		sb.Append("\xF5B\xF5C\a\x1DC\x2\x2\xF5C\xF5D\a\x3B8\x2\x2\xF5D\xF5E\a\x3C1");
		sb.Append("\x2\x2\xF5E\xF5F\x5\x22E\x118\x2\xF5F\xF60\a\x3C2\x2\x2\xF60");
		sb.Append("\xF6F\x3\x2\x2\x2\xF61\xF62\a\x1DA\x2\x2\xF62\xF63\a\x3B8\x2");
		sb.Append("\x2\xF63\xF64\a\x3C1\x2\x2\xF64\xF69\x5\x13E\xA0\x2\xF65\xF66");
		sb.Append("\a\x3C3\x2\x2\xF66\xF68\x5\x13E\xA0\x2\xF67\xF65\x3\x2\x2\x2");
		sb.Append("\xF68\xF6B\x3\x2\x2\x2\xF69\xF67\x3\x2\x2\x2\xF69\xF6A\x3\x2");
		sb.Append("\x2\x2\xF6A\xF6C\x3\x2\x2\x2\xF6B\xF69\x3\x2\x2\x2\xF6C\xF6D");
		sb.Append("\a\x3C2\x2\x2\xF6D\xF6F\x3\x2\x2\x2\xF6E\xF3D\x3\x2\x2\x2\xF6E");
		sb.Append("\xF43\x3\x2\x2\x2\xF6E\xF49\x3\x2\x2\x2\xF6E\xF4F\x3\x2\x2\x2");
		sb.Append("\xF6E\xF55\x3\x2\x2\x2\xF6E\xF5B\x3\x2\x2\x2\xF6E\xF61\x3\x2");
		sb.Append("\x2\x2\xF6F\x13D\x3\x2\x2\x2\xF70\xF71\a\x3C1\x2\x2\xF71\xF72");
		sb.Append("\x5\x1EA\xF6\x2\xF72\xF73\a\x3C3\x2\x2\xF73\xF74\x5\x1EA\xF6");
		sb.Append("\x2\xF74\xF75\a\x3C2\x2\x2\xF75\x13F\x3\x2\x2\x2\xF76\xF77\t");
		sb.Append("\x36\x2\x2\xF77\x141\x3\x2\x2\x2\xF78\xF79\t\x37\x2\x2\xF79");
		sb.Append("\xF7A\a\x3B8\x2\x2\xF7A\xF8B\x5\x146\xA4\x2\xF7B\xF7C\a\x184");
		sb.Append("\x2\x2\xF7C\xF7D\a\x3B8\x2\x2\xF7D\xF7E\a\x3D0\x2\x2\xF7E\xF7F");
		sb.Append("\a\x3C3\x2\x2\xF7F\xF80\a\x185\x2\x2\xF80\xF81\a\x3B8\x2\x2");
		sb.Append("\xF81\xF8B\x5\x208\x105\x2\xF82\xF83\a\x1D0\x2\x2\xF83\xF84");
		sb.Append("\a\x3B8\x2\x2\xF84\xF85\a\x3D0\x2\x2\xF85\xF86\a\x3C3\x2\x2");
		sb.Append("\xF86\xF87\a\x1D1\x2\x2\xF87\xF88\a\x3B8\x2\x2\xF88\xF8B\x5");
		sb.Append("\x208\x105\x2\xF89\xF8B\a\x1F9\x2\x2\xF8A\xF78\x3\x2\x2\x2\xF8A");
		sb.Append("\xF7B\x3\x2\x2\x2\xF8A\xF82\x3\x2\x2\x2\xF8A\xF89\x3\x2\x2\x2");
		sb.Append("\xF8B\x143\x3\x2\x2\x2\xF8C\xF8D\a\x21E\x2\x2\xF8D\xF8E\a\x3B8");
		sb.Append("\x2\x2\xF8E\xF99\a\x3D0\x2\x2\xF8F\xF90\a\x1BB\x2\x2\xF90\xF91");
		sb.Append("\a\x3B8\x2\x2\xF91\xF99\a\x3D0\x2\x2\xF92\xF93\a\x130\x2\x2");
		sb.Append("\xF93\xF94\a\x3B8\x2\x2\xF94\xF99\a\x3D0\x2\x2\xF95\xF96\a\x1BE");
		sb.Append("\x2\x2\xF96\xF97\a\x3B8\x2\x2\xF97\xF99\a\x3D0\x2\x2\xF98\xF8C");
		sb.Append("\x3\x2\x2\x2\xF98\xF8F\x3\x2\x2\x2\xF98\xF92\x3\x2\x2\x2\xF98");
		sb.Append("\xF95\x3\x2\x2\x2\xF99\x145\x3\x2\x2\x2\xF9A\xF9F\x5\x1FA\xFE");
		sb.Append("\x2\xF9B\xF9C\a\x3C3\x2\x2\xF9C\xF9E\x5\x1FA\xFE\x2\xF9D\xF9B");
		sb.Append("\x3\x2\x2\x2\xF9E\xFA1\x3\x2\x2\x2\xF9F\xF9D\x3\x2\x2\x2\xF9F");
		sb.Append("\xFA0\x3\x2\x2\x2\xFA0\xFA4\x3\x2\x2\x2\xFA1\xF9F\x3\x2\x2\x2");
		sb.Append("\xFA2\xFA4\a\x3D0\x2\x2\xFA3\xF9A\x3\x2\x2\x2\xFA3\xFA2\x3\x2");
		sb.Append("\x2\x2\xFA4\x147\x3\x2\x2\x2\xFA5\xFA6\a\x22C\x2\x2\xFA6\xFA7");
		sb.Append("\t\x38\x2\x2\xFA7\xFA9\x5\x1FC\xFF\x2\xFA8\xFAA\t\x39\x2\x2");
		sb.Append("\xFA9\xFA8\x3\x2\x2\x2\xFA9\xFAA\x3\x2\x2\x2\xFAA\x149\x3\x2");
		sb.Append("\x2\x2\xFAB\xFAC\a\x22C\x2\x2\xFAC\xFAD\a\x13E\x2\x2\xFAD\xFB3");
		sb.Append("\x5\x1FC\xFF\x2\xFAE\xFB1\a\x20C\x2\x2\xFAF\xFB0\a:\x2\x2\xFB0");
		sb.Append("\xFB2\a\x19C\x2\x2\xFB1\xFAF\x3\x2\x2\x2\xFB1\xFB2\x3\x2\x2");
		sb.Append("\x2\xFB2\xFB4\x3\x2\x2\x2\xFB3\xFAE\x3\x2\x2\x2\xFB3\xFB4\x3");
		sb.Append("\x2\x2\x2\xFB4\x14B\x3\x2\x2\x2\xFB5\xFB6\a\x22C\x2\x2\xFB6");
		sb.Append("\xFB7\a\x1C2\x2\x2\xFB7\xFB8\x5\x1FC\xFF\x2\xFB8\x14D\x3\x2");
		sb.Append("\x2\x2\xFB9\xFBA\a\x22C\x2\x2\xFBA\xFBB\a\x120\x2\x2\xFBB\xFBE");
		sb.Append("\x5\x1FC\xFF\x2\xFBC\xFBD\a\x1AE\x2\x2\xFBD\xFBF\a\x1BC\x2\x2");
		sb.Append("\xFBE\xFBC\x3\x2\x2\x2\xFBE\xFBF\x3\x2\x2\x2\xFBF\x14F\x3\x2");
		sb.Append("\x2\x2\xFC0\xFC1\a\x22C\x2\x2\xFC1\xFC2\a\x1E1\x2\x2\xFC2\xFC3");
		sb.Append("\x5\x1FC\xFF\x2\xFC3\x151\x3\x2\x2\x2\xFC4\xFC5\a\x22C\x2\x2");
		sb.Append("\xFC5\xFC8\a\x1CC\x2\x2\xFC6\xFC7\a\x1F\x2\x2\xFC7\xFC9\x5\x1FC");
		sb.Append("\xFF\x2\xFC8\xFC6\x3\x2\x2\x2\xFC8\xFC9\x3\x2\x2\x2\xFC9\x153");
		sb.Append("\x3\x2\x2\x2\xFCA\xFCB\a\x1C2\x2\x2\xFCB\xFCC\x5\x202\x102\x2");
		sb.Append("\xFCC\xFCF\a=\x2\x2\xFCD\xFD0\a\x3D0\x2\x2\xFCE\xFD0\a\x3DB");
		sb.Append("\x2\x2\xFCF\xFCD\x3\x2\x2\x2\xFCF\xFCE\x3\x2\x2\x2\xFD0\x155");
		sb.Append("\x3\x2\x2\x2\xFD1\xFD2\a\x23D\x2\x2\xFD2\xFD5\x5\x202\x102\x2");
		sb.Append("\xFD3\xFD4\a\xA4\x2\x2\xFD4\xFD6\x5\x230\x119\x2\xFD5\xFD3\x3");
		sb.Append("\x2\x2\x2\xFD5\xFD6\x3\x2\x2\x2\xFD6\x157\x3\x2\x2\x2\xFD7\xFD8");
		sb.Append("\t:\x2\x2\xFD8\xFD9\a\x1C2\x2\x2\xFD9\xFDA\x5\x202\x102\x2\xFDA");
		sb.Append("\x159\x3\x2\x2\x2\xFDB\xFDE\x5\x15C\xAF\x2\xFDC\xFDE\x5\x6\x4");
		sb.Append("\x2\xFDD\xFDB\x3\x2\x2\x2\xFDD\xFDC\x3\x2\x2\x2\xFDE\x15B\x3");
		sb.Append("\x2\x2\x2\xFDF\xFE0\x5\x202\x102\x2\xFE0\xFE1\a\x3CC\x2\x2\xFE1");
		sb.Append("\xFE3\x3\x2\x2\x2\xFE2\xFDF\x3\x2\x2\x2\xFE2\xFE3\x3\x2\x2\x2");
		sb.Append("\xFE3\xFE4\x3\x2\x2\x2\xFE4\x100B\a\x10A\x2\x2\xFE5\xFE6\x5");
		sb.Append("\x170\xB9\x2\xFE6\xFE7\a\x3C4\x2\x2\xFE7\xFE9\x3\x2\x2\x2\xFE8");
		sb.Append("\xFE5\x3\x2\x2\x2\xFE9\xFEC\x3\x2\x2\x2\xFEA\xFE8\x3\x2\x2\x2");
		sb.Append("\xFEA\xFEB\x3\x2\x2\x2\xFEB\xFF2\x3\x2\x2\x2\xFEC\xFEA\x3\x2");
		sb.Append("\x2\x2\xFED\xFEE\x5\x172\xBA\x2\xFEE\xFEF\a\x3C4\x2\x2\xFEF");
		sb.Append("\xFF1\x3\x2\x2\x2\xFF0\xFED\x3\x2\x2\x2\xFF1\xFF4\x3\x2\x2\x2");
		sb.Append("\xFF2\xFF0\x3\x2\x2\x2\xFF2\xFF3\x3\x2\x2\x2\xFF3\xFFA\x3\x2");
		sb.Append("\x2\x2\xFF4\xFF2\x3\x2\x2\x2\xFF5\xFF6\x5\x174\xBB\x2\xFF6\xFF7");
		sb.Append("\a\x3C4\x2\x2\xFF7\xFF9\x3\x2\x2\x2\xFF8\xFF5\x3\x2\x2\x2\xFF9");
		sb.Append("\xFFC\x3\x2\x2\x2\xFFA\xFF8\x3\x2\x2\x2\xFFA\xFFB\x3\x2\x2\x2");
		sb.Append("\xFFB\x1002\x3\x2\x2\x2\xFFC\xFFA\x3\x2\x2\x2\xFFD\xFFE\x5\x176");
		sb.Append("\xBC\x2\xFFE\xFFF\a\x3C4\x2\x2\xFFF\x1001\x3\x2\x2\x2\x1000");
		sb.Append("\xFFD\x3\x2\x2\x2\x1001\x1004\x3\x2\x2\x2\x1002\x1000\x3\x2");
		sb.Append("\x2\x2\x1002\x1003\x3\x2\x2\x2\x1003\x1008\x3\x2\x2\x2\x1004");
		sb.Append("\x1002\x3\x2\x2\x2\x1005\x1007\x5\x17A\xBE\x2\x1006\x1005\x3");
		sb.Append("\x2\x2\x2\x1007\x100A\x3\x2\x2\x2\x1008\x1006\x3\x2\x2\x2\x1008");
		sb.Append("\x1009\x3\x2\x2\x2\x1009\x100C\x3\x2\x2\x2\x100A\x1008\x3\x2");
		sb.Append("\x2\x2\x100B\xFEA\x3\x2\x2\x2\x100B\x100C\x3\x2\x2\x2\x100C");
		sb.Append("\x100D\x3\x2\x2\x2\x100D\x100F\a\x13E\x2\x2\x100E\x1010\x5\x202");
		sb.Append("\x102\x2\x100F\x100E\x3\x2\x2\x2\x100F\x1010\x3\x2\x2\x2\x1010");
		sb.Append("\x15D\x3\x2\x2\x2\x1011\x1014\a\x15\x2\x2\x1012\x1015\x5\x202");
		sb.Append("\x102\x2\x1013\x1015\x5\x250\x129\x2\x1014\x1012\x3\x2\x2\x2");
		sb.Append("\x1014\x1013\x3\x2\x2\x2\x1014\x1015\x3\x2\x2\x2\x1015\x1017");
		sb.Append("\x3\x2\x2\x2\x1016\x1018\x5\x17C\xBF\x2\x1017\x1016\x3\x2\x2");
		sb.Append("\x2\x1018\x1019\x3\x2\x2\x2\x1019\x1017\x3\x2\x2\x2\x1019\x101A");
		sb.Append("\x3\x2\x2\x2\x101A\x1021\x3\x2\x2\x2\x101B\x101D\a\x31\x2\x2");
		sb.Append("\x101C\x101E\x5\x17A\xBE\x2\x101D\x101C\x3\x2\x2\x2\x101E\x101F");
		sb.Append("\x3\x2\x2\x2\x101F\x101D\x3\x2\x2\x2\x101F\x1020\x3\x2\x2\x2");
		sb.Append("\x1020\x1022\x3\x2\x2\x2\x1021\x101B\x3\x2\x2\x2\x1021\x1022");
		sb.Append("\x3\x2\x2\x2\x1022\x1023\x3\x2\x2\x2\x1023\x1024\a\x13E\x2\x2");
		sb.Append("\x1024\x1025\a\x15\x2\x2\x1025\x15F\x3\x2\x2\x2\x1026\x1027");
		sb.Append("\a\x44\x2\x2\x1027\x1028\x5\x250\x129\x2\x1028\x102A\a\x97\x2");
		sb.Append("\x2\x1029\x102B\x5\x17A\xBE\x2\x102A\x1029\x3\x2\x2\x2\x102B");
		sb.Append("\x102C\x3\x2\x2\x2\x102C\x102A\x3\x2\x2\x2\x102C\x102D\x3\x2");
		sb.Append("\x2\x2\x102D\x1031\x3\x2\x2\x2\x102E\x1030\x5\x17E\xC0\x2\x102F");
		sb.Append("\x102E\x3\x2\x2\x2\x1030\x1033\x3\x2\x2\x2\x1031\x102F\x3\x2");
		sb.Append("\x2\x2\x1031\x1032\x3\x2\x2\x2\x1032\x103A\x3\x2\x2\x2\x1033");
		sb.Append("\x1031\x3\x2\x2\x2\x1034\x1036\a\x31\x2\x2\x1035\x1037\x5\x17A");
		sb.Append("\xBE\x2\x1036\x1035\x3\x2\x2\x2\x1037\x1038\x3\x2\x2\x2\x1038");
		sb.Append("\x1036\x3\x2\x2\x2\x1038\x1039\x3\x2\x2\x2\x1039\x103B\x3\x2");
		sb.Append("\x2\x2\x103A\x1034\x3\x2\x2\x2\x103A\x103B\x3\x2\x2\x2\x103B");
		sb.Append("\x103C\x3\x2\x2\x2\x103C\x103D\a\x13E\x2\x2\x103D\x103E\a\x44");
		sb.Append("\x2\x2\x103E\x161\x3\x2\x2\x2\x103F\x1040\aO\x2\x2\x1040\x1041");
		sb.Append("\x5\x202\x102\x2\x1041\x163\x3\x2\x2\x2\x1042\x1043\aU\x2\x2");
		sb.Append("\x1043\x1044\x5\x202\x102\x2\x1044\x165\x3\x2\x2\x2\x1045\x1046");
		sb.Append("\x5\x202\x102\x2\x1046\x1047\a\x3CC\x2\x2\x1047\x1049\x3\x2");
		sb.Append("\x2\x2\x1048\x1045\x3\x2\x2\x2\x1048\x1049\x3\x2\x2\x2\x1049");
		sb.Append("\x104A\x3\x2\x2\x2\x104A\x104C\a]\x2\x2\x104B\x104D\x5\x17A");
		sb.Append("\xBE\x2\x104C\x104B\x3\x2\x2\x2\x104D\x104E\x3\x2\x2\x2\x104E");
		sb.Append("\x104C\x3\x2\x2\x2\x104E\x104F\x3\x2\x2\x2\x104F\x1050\x3\x2");
		sb.Append("\x2\x2\x1050\x1051\a\x13E\x2\x2\x1051\x1053\a]\x2\x2\x1052\x1054");
		sb.Append("\x5\x202\x102\x2\x1053\x1052\x3\x2\x2\x2\x1053\x1054\x3\x2\x2");
		sb.Append("\x2\x1054\x167\x3\x2\x2\x2\x1055\x1056\x5\x202\x102\x2\x1056");
		sb.Append("\x1057\a\x3CC\x2\x2\x1057\x1059\x3\x2\x2\x2\x1058\x1055\x3\x2");
		sb.Append("\x2\x2\x1058\x1059\x3\x2\x2\x2\x1059\x105A\x3\x2\x2\x2\x105A");
		sb.Append("\x105C\a|\x2\x2\x105B\x105D\x5\x17A\xBE\x2\x105C\x105B\x3\x2");
		sb.Append("\x2\x2\x105D\x105E\x3\x2\x2\x2\x105E\x105C\x3\x2\x2\x2\x105E");
		sb.Append("\x105F\x3\x2\x2\x2\x105F\x1060\x3\x2\x2\x2\x1060\x1061\a\x21C");
		sb.Append("\x2\x2\x1061\x1062\x5\x250\x129\x2\x1062\x1063\a\x13E\x2\x2");
		sb.Append("\x1063\x1065\a|\x2\x2\x1064\x1066\x5\x202\x102\x2\x1065\x1064");
		sb.Append("\x3\x2\x2\x2\x1065\x1066\x3\x2\x2\x2\x1066\x169\x3\x2\x2\x2");
		sb.Append("\x1067\x1068\a\x80\x2\x2\x1068\x1069\x5\x250\x129\x2\x1069\x16B");
		sb.Append("\x3\x2\x2\x2\x106A\x106B\x5\x202\x102\x2\x106B\x106C\a\x3CC");
		sb.Append("\x2\x2\x106C\x106E\x3\x2\x2\x2\x106D\x106A\x3\x2\x2\x2\x106D");
		sb.Append("\x106E\x3\x2\x2\x2\x106E\x106F\x3\x2\x2\x2\x106F\x1070\a\xA8");
		sb.Append("\x2\x2\x1070\x1071\x5\x250\x129\x2\x1071\x1073\a\x138\x2\x2");
		sb.Append("\x1072\x1074\x5\x17A\xBE\x2\x1073\x1072\x3\x2\x2\x2\x1074\x1075");
		sb.Append("\x3\x2\x2\x2\x1075\x1073\x3\x2\x2\x2\x1075\x1076\x3\x2\x2\x2");
		sb.Append("\x1076\x1077\x3\x2\x2\x2\x1077\x1078\a\x13E\x2\x2\x1078\x107A");
		sb.Append("\a\xA8\x2\x2\x1079\x107B\x5\x202\x102\x2\x107A\x1079\x3\x2\x2");
		sb.Append("\x2\x107A\x107B\x3\x2\x2\x2\x107B\x16D\x3\x2\x2\x2\x107C\x107D");
		sb.Append("\a\x11A\x2\x2\x107D\x108C\x5\x202\x102\x2\x107E\x1083\a\x39");
		sb.Append("\x2\x2\x107F\x1081\a\x1A6\x2\x2\x1080\x107F\x3\x2\x2\x2\x1080");
		sb.Append("\x1081\x3\x2\x2\x2\x1081\x1082\x3\x2\x2\x2\x1082\x1084\a=\x2");
		sb.Append("\x2\x1083\x1080\x3\x2\x2\x2\x1083\x1084\x3\x2\x2\x2\x1084\x1085");
		sb.Append("\x3\x2\x2\x2\x1085\x1086\x5\x202\x102\x2\x1086\x1087\aM\x2\x2");
		sb.Append("\x1087\x1088\x5\x222\x112\x2\x1088\x108C\x3\x2\x2\x2\x1089\x108A");
		sb.Append("\a\x1B1\x2\x2\x108A\x108C\x5\x202\x102\x2\x108B\x107C\x3\x2");
		sb.Append("\x2\x2\x108B\x107E\x3\x2\x2\x2\x108B\x1089\x3\x2\x2\x2\x108C");
		sb.Append("\x16F\x3\x2\x2\x2\x108D\x108E\a&\x2\x2\x108E\x108F\x5\x222\x112");
		sb.Append("\x2\x108F\x1092\x5\x216\x10C\x2\x1090\x1091\a\'\x2\x2\x1091");
		sb.Append("\x1093\x5\x232\x11A\x2\x1092\x1090\x3\x2\x2\x2\x1092\x1093\x3");
		sb.Append("\x2\x2\x2\x1093\x171\x3\x2\x2\x2\x1094\x1095\a&\x2\x2\x1095");
		sb.Append("\x1096\x5\x202\x102\x2\x1096\x1097\a\x1C\x2\x2\x1097\x109E\a");
		sb.Append(":\x2\x2\x1098\x109F\x5\x208\x105\x2\x1099\x109B\a\x8D\x2\x2");
		sb.Append("\x109A\x109C\a\x222\x2\x2\x109B\x109A\x3\x2\x2\x2\x109B\x109C");
		sb.Append("\x3\x2\x2\x2\x109C\x109D\x3\x2\x2\x2\x109D\x109F\a\x3D0\x2\x2");
		sb.Append("\x109E\x1098\x3\x2\x2\x2\x109E\x1099\x3\x2\x2\x2\x109F\x173");
		sb.Append("\x3\x2\x2\x2\x10A0\x10A1\a&\x2\x2\x10A1\x10A2\x5\x202\x102\x2");
		sb.Append("\x10A2\x10A3\a#\x2\x2\x10A3\x10A4\a:\x2\x2\x10A4\x10A5\x5\xB4");
		sb.Append("[\x2\x10A5\x175\x3\x2\x2\x2\x10A6\x10A7\a&\x2\x2\x10A7\x10A8");
		sb.Append("\t;\x2\x2\x10A8\x10A9\a\x15F\x2\x2\x10A9\x10AA\a:\x2\x2\x10AA");
		sb.Append("\x10AF\x5\x178\xBD\x2\x10AB\x10AC\a\x3C3\x2\x2\x10AC\x10AE\x5");
		sb.Append("\x178\xBD\x2\x10AD\x10AB\x3\x2\x2\x2\x10AE\x10B1\x3\x2\x2\x2");
		sb.Append("\x10AF\x10AD\x3\x2\x2\x2\x10AF\x10B0\x3\x2\x2\x2\x10B0\x10B2");
		sb.Append("\x3\x2\x2\x2\x10B1\x10AF\x3\x2\x2\x2\x10B2\x10B3\x5\x15A\xAE");
		sb.Append("\x2\x10B3\x177\x3\x2\x2\x2\x10B4\x10C0\x5\x208\x105\x2\x10B5");
		sb.Append("\x10B7\a\x8D\x2\x2\x10B6\x10B8\a\x222\x2\x2\x10B7\x10B6\x3\x2");
		sb.Append("\x2\x2\x10B7\x10B8\x3\x2\x2\x2\x10B8\x10B9\x3\x2\x2\x2\x10B9");
		sb.Append("\x10C0\a\x3D0\x2\x2\x10BA\x10C0\x5\x202\x102\x2\x10BB\x10C0");
		sb.Append("\a\x8E\x2\x2\x10BC\x10BD\a\x65\x2\x2\x10BD\x10C0\a\x158\x2\x2");
		sb.Append("\x10BE\x10C0\a\x8C\x2\x2\x10BF\x10B4\x3\x2\x2\x2\x10BF\x10B5");
		sb.Append("\x3\x2\x2\x2\x10BF\x10BA\x3\x2\x2\x2\x10BF\x10BB\x3\x2\x2\x2");
		sb.Append("\x10BF\x10BC\x3\x2\x2\x2\x10BF\x10BE\x3\x2\x2\x2\x10C0\x179");
		sb.Append("\x3\x2\x2\x2\x10C1\x10C4\x5\x14\v\x2\x10C2\x10C4\x5\x6\x4\x2");
		sb.Append("\x10C3\x10C1\x3\x2\x2\x2\x10C3\x10C2\x3\x2\x2\x2\x10C4\x10C5");
		sb.Append("\x3\x2\x2\x2\x10C5\x10C6\a\x3C4\x2\x2\x10C6\x17B\x3\x2\x2\x2");
		sb.Append("\x10C7\x10CA\a\xA6\x2\x2\x10C8\x10CB\x5\x214\x10B\x2\x10C9\x10CB");
		sb.Append("\x5\x250\x129\x2\x10CA\x10C8\x3\x2\x2\x2\x10CA\x10C9\x3\x2\x2");
		sb.Append("\x2\x10CB\x10CC\x3\x2\x2\x2\x10CC\x10CE\a\x97\x2\x2\x10CD\x10CF");
		sb.Append("\x5\x17A\xBE\x2\x10CE\x10CD\x3\x2\x2\x2\x10CF\x10D0\x3\x2\x2");
		sb.Append("\x2\x10D0\x10CE\x3\x2\x2\x2\x10D0\x10D1\x3\x2\x2\x2\x10D1\x17D");
		sb.Append("\x3\x2\x2\x2\x10D2\x10D3\a\x32\x2\x2\x10D3\x10D4\x5\x250\x129");
		sb.Append("\x2\x10D4\x10D6\a\x97\x2\x2\x10D5\x10D7\x5\x17A\xBE\x2\x10D6");
		sb.Append("\x10D5\x3\x2\x2\x2\x10D7\x10D8\x3\x2\x2\x2\x10D8\x10D6\x3\x2");
		sb.Append("\x2\x2\x10D8\x10D9\x3\x2\x2\x2\x10D9\x17F\x3\x2\x2\x2\x10DA");
		sb.Append("\x10DB\a\t\x2\x2\x10DB\x10DC\a\x21E\x2\x2\x10DC\x10E1\x5\x192");
		sb.Append("\xCA\x2\x10DD\x10DE\a\x3C3\x2\x2\x10DE\x10E0\x5\x192\xCA\x2");
		sb.Append("\x10DF\x10DD\x3\x2\x2\x2\x10E0\x10E3\x3\x2\x2\x2\x10E1\x10DF");
		sb.Append("\x3\x2\x2\x2\x10E1\x10E2\x3\x2\x2\x2\x10E2\x1111\x3\x2\x2\x2");
		sb.Append("\x10E3\x10E1\x3\x2\x2\x2\x10E4\x10E5\a\t\x2\x2\x10E5\x10E7\a");
		sb.Append("\x21E\x2\x2\x10E6\x10E8\x5\x238\x11D\x2\x10E7\x10E6\x3\x2\x2");
		sb.Append("\x2\x10E7\x10E8\x3\x2\x2\x2\x10E8\x10E9\x3\x2\x2\x2\x10E9\x10EE");
		sb.Append("\x5\x194\xCB\x2\x10EA\x10EB\a\x3C3\x2\x2\x10EB\x10ED\x5\x194");
		sb.Append("\xCB\x2\x10EC\x10EA\x3\x2\x2\x2\x10ED\x10F0\x3\x2\x2\x2\x10EE");
		sb.Append("\x10EC\x3\x2\x2\x2\x10EE\x10EF\x3\x2\x2\x2\x10EF\x10FF\x3\x2");
		sb.Append("\x2\x2\x10F0\x10EE\x3\x2\x2\x2\x10F1\x10FD\a~\x2\x2\x10F2\x10FE");
		sb.Append("\a\x1A9\x2\x2\x10F3\x10FA\x5\x196\xCC\x2\x10F4\x10F6\a\f\x2");
		sb.Append("\x2\x10F5\x10F4\x3\x2\x2\x2\x10F5\x10F6\x3\x2\x2\x2\x10F6\x10F7");
		sb.Append("\x3\x2\x2\x2\x10F7\x10F9\x5\x196\xCC\x2\x10F8\x10F5\x3\x2\x2");
		sb.Append("\x2\x10F9\x10FC\x3\x2\x2\x2\x10FA\x10F8\x3\x2\x2\x2\x10FA\x10FB");
		sb.Append("\x3\x2\x2\x2\x10FB\x10FE\x3\x2\x2\x2\x10FC\x10FA\x3\x2\x2\x2");
		sb.Append("\x10FD\x10F2\x3\x2\x2\x2\x10FD\x10F3\x3\x2\x2\x2\x10FE\x1100");
		sb.Append("\x3\x2\x2\x2\x10FF\x10F1\x3\x2\x2\x2\x10FF\x1100\x3\x2\x2\x2");
		sb.Append("\x1100\x1107\x3\x2\x2\x2\x1101\x1103\a\xA9\x2\x2\x1102\x1104");
		sb.Append("\x5\x198\xCD\x2\x1103\x1102\x3\x2\x2\x2\x1104\x1105\x3\x2\x2");
		sb.Append("\x2\x1105\x1103\x3\x2\x2\x2\x1105\x1106\x3\x2\x2\x2\x1106\x1108");
		sb.Append("\x3\x2\x2\x2\x1107\x1101\x3\x2\x2\x2\x1107\x1108\x3\x2\x2\x2");
		sb.Append("\x1108\x110D\x3\x2\x2\x2\x1109\x110C\x5\x19A\xCE\x2\x110A\x110C");
		sb.Append("\x5\x19C\xCF\x2\x110B\x1109\x3\x2\x2\x2\x110B\x110A\x3\x2\x2");
		sb.Append("\x2\x110C\x110F\x3\x2\x2\x2\x110D\x110B\x3\x2\x2\x2\x110D\x110E");
		sb.Append("\x3\x2\x2\x2\x110E\x1111\x3\x2\x2\x2\x110F\x110D\x3\x2\x2\x2");
		sb.Append("\x1110\x10DA\x3\x2\x2\x2\x1110\x10E4\x3\x2\x2\x2\x1111\x181");
		sb.Append("\x3\x2\x2\x2\x1112\x1113\a \x2\x2\x1113\x1114\a\x21E\x2\x2\x1114");
		sb.Append("\x1119\x5\x194\xCB\x2\x1115\x1116\a\x3C3\x2\x2\x1116\x1118\x5");
		sb.Append("\x194\xCB\x2\x1117\x1115\x3\x2\x2\x2\x1118\x111B\x3\x2\x2\x2");
		sb.Append("\x1119\x1117\x3\x2\x2\x2\x1119\x111A\x3\x2\x2\x2\x111A\x1149");
		sb.Append("\x3\x2\x2\x2\x111B\x1119\x3\x2\x2\x2\x111C\x111D\a \x2\x2\x111D");
		sb.Append("\x111F\a\x21E\x2\x2\x111E\x1120\x5\x23A\x11E\x2\x111F\x111E");
		sb.Append("\x3\x2\x2\x2\x111F\x1120\x3\x2\x2\x2\x1120\x1121\x3\x2\x2\x2");
		sb.Append("\x1121\x1126\x5\x194\xCB\x2\x1122\x1123\a\x3C3\x2\x2\x1123\x1125");
		sb.Append("\x5\x194\xCB\x2\x1124\x1122\x3\x2\x2\x2\x1125\x1128\x3\x2\x2");
		sb.Append("\x2\x1126\x1124\x3\x2\x2\x2\x1126\x1127\x3\x2\x2\x2\x1127\x1137");
		sb.Append("\x3\x2\x2\x2\x1128\x1126\x3\x2\x2\x2\x1129\x1135\a~\x2\x2\x112A");
		sb.Append("\x1136\a\x1A9\x2\x2\x112B\x1132\x5\x196\xCC\x2\x112C\x112E\a");
		sb.Append("\f\x2\x2\x112D\x112C\x3\x2\x2\x2\x112D\x112E\x3\x2\x2\x2\x112E");
		sb.Append("\x112F\x3\x2\x2\x2\x112F\x1131\x5\x196\xCC\x2\x1130\x112D\x3");
		sb.Append("\x2\x2\x2\x1131\x1134\x3\x2\x2\x2\x1132\x1130\x3\x2\x2\x2\x1132");
		sb.Append("\x1133\x3\x2\x2\x2\x1133\x1136\x3\x2\x2\x2\x1134\x1132\x3\x2");
		sb.Append("\x2\x2\x1135\x112A\x3\x2\x2\x2\x1135\x112B\x3\x2\x2\x2\x1136");
		sb.Append("\x1138\x3\x2\x2\x2\x1137\x1129\x3\x2\x2\x2\x1137\x1138\x3\x2");
		sb.Append("\x2\x2\x1138\x113F\x3\x2\x2\x2\x1139\x113B\a\xA9\x2\x2\x113A");
		sb.Append("\x113C\x5\x198\xCD\x2\x113B\x113A\x3\x2\x2\x2\x113C\x113D\x3");
		sb.Append("\x2\x2\x2\x113D\x113B\x3\x2\x2\x2\x113D\x113E\x3\x2\x2\x2\x113E");
		sb.Append("\x1140\x3\x2\x2\x2\x113F\x1139\x3\x2\x2\x2\x113F\x1140\x3\x2");
		sb.Append("\x2\x2\x1140\x1145\x3\x2\x2\x2\x1141\x1144\x5\x19A\xCE\x2\x1142");
		sb.Append("\x1144\x5\x19C\xCF\x2\x1143\x1141\x3\x2\x2\x2\x1143\x1142\x3");
		sb.Append("\x2\x2\x2\x1144\x1147\x3\x2\x2\x2\x1145\x1143\x3\x2\x2\x2\x1145");
		sb.Append("\x1146\x3\x2\x2\x2\x1146\x1149\x3\x2\x2\x2\x1147\x1145\x3\x2");
		sb.Append("\x2\x2\x1148\x1112\x3\x2\x2\x2\x1148\x111C\x3\x2\x2\x2\x1149");
		sb.Append("\x183\x3\x2\x2\x2\x114A\x114B\a/\x2\x2\x114B\x114D\a\x21E\x2");
		sb.Append("\x2\x114C\x114E\x5\x238\x11D\x2\x114D\x114C\x3\x2\x2\x2\x114D");
		sb.Append("\x114E\x3\x2\x2\x2\x114E\x114F\x3\x2\x2\x2\x114F\x1154\x5\x1F0");
		sb.Append("\xF9\x2\x1150\x1151\a\x3C3\x2\x2\x1151\x1153\x5\x1F0\xF9\x2");
		sb.Append("\x1152\x1150\x3\x2\x2\x2\x1153\x1156\x3\x2\x2\x2\x1154\x1152");
		sb.Append("\x3\x2\x2\x2\x1154\x1155\x3\x2\x2\x2\x1155\x185\x3\x2\x2\x2");
		sb.Append("\x1156\x1154\x3\x2\x2\x2\x1157\x1158\a@\x2\x2\x1158\x115D\x5");
		sb.Append("\x19E\xD0\x2\x1159\x115A\a\x3C3\x2\x2\x115A\x115C\x5\x19E\xD0");
		sb.Append("\x2\x115B\x1159\x3\x2\x2\x2\x115C\x115F\x3\x2\x2\x2\x115D\x115B");
		sb.Append("\x3\x2\x2\x2\x115D\x115E\x3\x2\x2\x2\x115E\x1160\x3\x2\x2\x2");
		sb.Append("\x115F\x115D\x3\x2\x2\x2\x1160\x1162\ah\x2\x2\x1161\x1163\t");
		sb.Append("<\x2\x2\x1162\x1161\x3\x2\x2\x2\x1162\x1163\x3\x2\x2\x2\x1163");
		sb.Append("\x1164\x3\x2\x2\x2\x1164\x1165\x5\x1A2\xD2\x2\x1165\x1166\a");
		sb.Append("\x98\x2\x2\x1166\x116B\x5\x194\xCB\x2\x1167\x1168\a\x3C3\x2");
		sb.Append("\x2\x1168\x116A\x5\x194\xCB\x2\x1169\x1167\x3\x2\x2\x2\x116A");
		sb.Append("\x116D\x3\x2\x2\x2\x116B\x1169\x3\x2\x2\x2\x116B\x116C\x3\x2");
		sb.Append("\x2\x2\x116C\x117C\x3\x2\x2\x2\x116D\x116B\x3\x2\x2\x2\x116E");
		sb.Append("\x117A\a~\x2\x2\x116F\x117B\a\x1A9\x2\x2\x1170\x1177\x5\x196");
		sb.Append("\xCC\x2\x1171\x1173\a\f\x2\x2\x1172\x1171\x3\x2\x2\x2\x1172");
		sb.Append("\x1173\x3\x2\x2\x2\x1173\x1174\x3\x2\x2\x2\x1174\x1176\x5\x196");
		sb.Append("\xCC\x2\x1175\x1172\x3\x2\x2\x2\x1176\x1179\x3\x2\x2\x2\x1177");
		sb.Append("\x1175\x3\x2\x2\x2\x1177\x1178\x3\x2\x2\x2\x1178\x117B\x3\x2");
		sb.Append("\x2\x2\x1179\x1177\x3\x2\x2\x2\x117A\x116F\x3\x2\x2\x2\x117A");
		sb.Append("\x1170\x3\x2\x2\x2\x117B\x117D\x3\x2\x2\x2\x117C\x116E\x3\x2");
		sb.Append("\x2\x2\x117C\x117D\x3\x2\x2\x2\x117D\x1187\x3\x2\x2\x2\x117E");
		sb.Append("\x1184\a\xA9\x2\x2\x117F\x1180\a@\x2\x2\x1180\x1183\aj\x2\x2");
		sb.Append("\x1181\x1183\x5\x198\xCD\x2\x1182\x117F\x3\x2\x2\x2\x1182\x1181");
		sb.Append("\x3\x2\x2\x2\x1183\x1186\x3\x2\x2\x2\x1184\x1182\x3\x2\x2\x2");
		sb.Append("\x1184\x1185\x3\x2\x2\x2\x1185\x1188\x3\x2\x2\x2\x1186\x1184");
		sb.Append("\x3\x2\x2\x2\x1187\x117E\x3\x2\x2\x2\x1187\x1188\x3\x2\x2\x2");
		sb.Append("\x1188\x187\x3\x2\x2\x2\x1189\x118A\a@\x2\x2\x118A\x118B\a\x1C8");
		sb.Append("\x2\x2\x118B\x118C\ah\x2\x2\x118C\x118D\x5\x1F0\xF9\x2\x118D");
		sb.Append("\x118E\a\x98\x2\x2\x118E\x1193\x5\x1F0\xF9\x2\x118F\x1190\a");
		sb.Append("\x3C3\x2\x2\x1190\x1192\x5\x1F0\xF9\x2\x1191\x118F\x3\x2\x2");
		sb.Append("\x2\x1192\x1195\x3\x2\x2\x2\x1193\x1191\x3\x2\x2\x2\x1193\x1194");
		sb.Append("\x3\x2\x2\x2\x1194\x1199\x3\x2\x2\x2\x1195\x1193\x3\x2\x2\x2");
		sb.Append("\x1196\x1197\a\xA9\x2\x2\x1197\x1198\a@\x2\x2\x1198\x119A\a");
		sb.Append("j\x2\x2\x1199\x1196\x3\x2\x2\x2\x1199\x119A\x3\x2\x2\x2\x119A");
		sb.Append("\x189\x3\x2\x2\x2\x119B\x119C\a{\x2\x2\x119C\x119D\a\x21E\x2");
		sb.Append("\x2\x119D\x11A2\x5\x1A4\xD3\x2\x119E\x119F\a\x3C3\x2\x2\x119F");
		sb.Append("\x11A1\x5\x1A4\xD3\x2\x11A0\x119E\x3\x2\x2\x2\x11A1\x11A4\x3");
		sb.Append("\x2\x2\x2\x11A2\x11A0\x3\x2\x2\x2\x11A2\x11A3\x3\x2\x2\x2\x11A3");
		sb.Append("\x18B\x3\x2\x2\x2\x11A4\x11A2\x3\x2\x2\x2\x11A5\x11A6\a\x81");
		sb.Append("\x2\x2\x11A6\x11AB\x5\x19E\xD0\x2\x11A7\x11A8\a\x3C3\x2\x2\x11A8");
		sb.Append("\x11AA\x5\x19E\xD0\x2\x11A9\x11A7\x3\x2\x2\x2\x11AA\x11AD\x3");
		sb.Append("\x2\x2\x2\x11AB\x11A9\x3\x2\x2\x2\x11AB\x11AC\x3\x2\x2\x2\x11AC");
		sb.Append("\x11AE\x3\x2\x2\x2\x11AD\x11AB\x3\x2\x2\x2\x11AE\x11B0\ah\x2");
		sb.Append("\x2\x11AF\x11B1\t<\x2\x2\x11B0\x11AF\x3\x2\x2\x2\x11B0\x11B1");
		sb.Append("\x3\x2\x2\x2\x11B1\x11B2\x3\x2\x2\x2\x11B2\x11B3\x5\x1A2\xD2");
		sb.Append("\x2\x11B3\x11B4\a=\x2\x2\x11B4\x11B9\x5\x1F0\xF9\x2\x11B5\x11B6");
		sb.Append("\a\x3C3\x2\x2\x11B6\x11B8\x5\x1F0\xF9\x2\x11B7\x11B5\x3\x2\x2");
		sb.Append("\x2\x11B8\x11BB\x3\x2\x2\x2\x11B9\x11B7\x3\x2\x2\x2\x11B9\x11BA");
		sb.Append("\x3\x2\x2\x2\x11BA\x11CE\x3\x2\x2\x2\x11BB\x11B9\x3\x2\x2\x2");
		sb.Append("\x11BC\x11BD\a\x81\x2\x2\x11BD\x11BF\a\b\x2\x2\x11BE\x11C0\a");
		sb.Append("\x243\x2\x2\x11BF\x11BE\x3\x2\x2\x2\x11BF\x11C0\x3\x2\x2\x2");
		sb.Append("\x11C0\x11C1\x3\x2\x2\x2\x11C1\x11C2\a\x3C3\x2\x2\x11C2\x11C3");
		sb.Append("\a@\x2\x2\x11C3\x11C4\aj\x2\x2\x11C4\x11C5\a=\x2\x2\x11C5\x11CA");
		sb.Append("\x5\x1F0\xF9\x2\x11C6\x11C7\a\x3C3\x2\x2\x11C7\x11C9\x5\x1F0");
		sb.Append("\xF9\x2\x11C8\x11C6\x3\x2\x2\x2\x11C9\x11CC\x3\x2\x2\x2\x11CA");
		sb.Append("\x11C8\x3\x2\x2\x2\x11CA\x11CB\x3\x2\x2\x2\x11CB\x11CE\x3\x2");
		sb.Append("\x2\x2\x11CC\x11CA\x3\x2\x2\x2\x11CD\x11A5\x3\x2\x2\x2\x11CD");
		sb.Append("\x11BC\x3\x2\x2\x2\x11CE\x18D\x3\x2\x2\x2\x11CF\x11D0\a\x81");
		sb.Append("\x2\x2\x11D0\x11D1\a\x1C8\x2\x2\x11D1\x11D2\ah\x2\x2\x11D2\x11D3");
		sb.Append("\x5\x1F0\xF9\x2\x11D3\x11D4\a=\x2\x2\x11D4\x11D9\x5\x1F0\xF9");
		sb.Append("\x2\x11D5\x11D6\a\x3C3\x2\x2\x11D6\x11D8\x5\x1F0\xF9\x2\x11D7");
		sb.Append("\x11D5\x3\x2\x2\x2\x11D8\x11DB\x3\x2\x2\x2\x11D9\x11D7\x3\x2");
		sb.Append("\x2\x2\x11D9\x11DA\x3\x2\x2\x2\x11DA\x18F\x3\x2\x2\x2\x11DB");
		sb.Append("\x11D9\x3\x2\x2\x2\x11DC\x11DD\a\x87\x2\x2\x11DD\x11E0\a\x1BB");
		sb.Append("\x2\x2\x11DE\x11DF\a:\x2\x2\x11DF\x11E1\x5\x1F0\xF9\x2\x11E0");
		sb.Append("\x11DE\x3\x2\x2\x2\x11E0\x11E1\x3\x2\x2\x2\x11E1\x11E2\x3\x2");
		sb.Append("\x2\x2\x11E2\x11E5\a\x3B8\x2\x2\x11E3\x11E6\x5\x24A\x126\x2");
		sb.Append("\x11E4\x11E6\a\x3D0\x2\x2\x11E5\x11E3\x3\x2\x2\x2\x11E5\x11E4");
		sb.Append("\x3\x2\x2\x2\x11E6\x191\x3\x2\x2\x2\x11E7\x11E8\x5\x1F0\xF9");
		sb.Append("\x2\x11E8\x11E9\x5\x19A\xCE\x2\x11E9\x193\x3\x2\x2\x2\x11EA");
		sb.Append("\x11EB\x5\x1F0\xF9\x2\x11EB\x11EC\a\x164\x2\x2\x11EC\x11ED\a");
		sb.Append("\x12\x2\x2\x11ED\x11EE\a\x1BB\x2\x2\x11EE\x11EF\a\x3D0\x2\x2");
		sb.Append("\x11EF\x1203\x3\x2\x2\x2\x11F0\x11F1\x5\x1F0\xF9\x2\x11F1\x11F4");
		sb.Append("\a\x164\x2\x2\x11F2\x11F3\a\xA9\x2\x2\x11F3\x11F5\x5\x200\x101");
		sb.Append("\x2\x11F4\x11F2\x3\x2\x2\x2\x11F4\x11F5\x3\x2\x2\x2\x11F5\x11F6");
		sb.Append("\x3\x2\x2\x2\x11F6\x11F7\a\x12\x2\x2\x11F7\x11F8\a\x3D0\x2\x2");
		sb.Append("\x11F8\x1203\x3\x2\x2\x2\x11F9\x11FA\x5\x1F0\xF9\x2\x11FA\x11FB");
		sb.Append("\a\x164\x2\x2\x11FB\x11FC\a\xA9\x2\x2\x11FC\x11FF\x5\x200\x101");
		sb.Append("\x2\x11FD\x11FE\a\r\x2\x2\x11FE\x1200\a\x3D0\x2\x2\x11FF\x11FD");
		sb.Append("\x3\x2\x2\x2\x11FF\x1200\x3\x2\x2\x2\x1200\x1203\x3\x2\x2\x2");
		sb.Append("\x1201\x1203\x5\x1F0\xF9\x2\x1202\x11EA\x3\x2\x2\x2\x1202\x11F0");
		sb.Append("\x3\x2\x2\x2\x1202\x11F9\x3\x2\x2\x2\x1202\x1201\x3\x2\x2\x2");
		sb.Append("\x1203\x195\x3\x2\x2\x2\x1204\x120D\a\x92\x2\x2\x1205\x120D");
		sb.Append("\a\x22B\x2\x2\x1206\x1207\a\x118\x2\x2\x1207\x120D\a\x3D0\x2");
		sb.Append("\x2\x1208\x1209\a\x172\x2\x2\x1209\x120D\a\x3D0\x2\x2\x120A");
		sb.Append("\x120B\a\x209\x2\x2\x120B\x120D\a\x3D0\x2\x2\x120C\x1204\x3");
		sb.Append("\x2\x2\x2\x120C\x1205\x3\x2\x2\x2\x120C\x1206\x3\x2\x2\x2\x120C");
		sb.Append("\x1208\x3\x2\x2\x2\x120C\x120A\x3\x2\x2\x2\x120D\x197\x3\x2");
		sb.Append("\x2\x2\x120E\x120F\a\x194\x2\x2\x120F\x1217\x5\x208\x105\x2");
		sb.Append("\x1210\x1211\a\x197\x2\x2\x1211\x1217\x5\x208\x105\x2\x1212");
		sb.Append("\x1213\a\x193\x2\x2\x1213\x1217\x5\x208\x105\x2\x1214\x1215");
		sb.Append("\a\x198\x2\x2\x1215\x1217\x5\x208\x105\x2\x1216\x120E\x3\x2");
		sb.Append("\x2\x2\x1216\x1210\x3\x2\x2\x2\x1216\x1212\x3\x2\x2\x2\x1216");
		sb.Append("\x1214\x3\x2\x2\x2\x1217\x199\x3\x2\x2\x2\x1218\x1219\a\x1BB");
		sb.Append("\x2\x2\x1219\x1220\a\x14B\x2\x2\x121A\x1221\a\'\x2\x2\x121B");
		sb.Append("\x1221\a\x1A5\x2\x2\x121C\x121D\aL\x2\x2\x121D\x121E\x5\x208");
		sb.Append("\x105\x2\x121E\x121F\a\x235\x2\x2\x121F\x1221\x3\x2\x2\x2\x1220");
		sb.Append("\x121A\x3\x2\x2\x2\x1220\x121B\x3\x2\x2\x2\x1220\x121C\x3\x2");
		sb.Append("\x2\x2\x1220\x1221\x3\x2\x2\x2\x1221\x19B\x3\x2\x2\x2\x1222");
		sb.Append("\x1223\a\xFE\x2\x2\x1223\x1224\t=\x2\x2\x1224\x19D\x3\x2\x2");
		sb.Append("\x2\x1225\x122A\x5\x1A0\xD1\x2\x1226\x1227\a\x3C1\x2\x2\x1227");
		sb.Append("\x1228\x5\x222\x112\x2\x1228\x1229\a\x3C2\x2\x2\x1229\x122B");
		sb.Append("\x3\x2\x2\x2\x122A\x1226\x3\x2\x2\x2\x122A\x122B\x3\x2\x2\x2");
		sb.Append("\x122B\x19F\x3\x2\x2\x2\x122C\x122E\a\b\x2\x2\x122D\x122F\a");
		sb.Append("\x243\x2\x2\x122E\x122D\x3\x2\x2\x2\x122E\x122F\x3\x2\x2\x2");
		sb.Append("\x122F\x1257\x3\x2\x2\x2\x1230\x1232\a\t\x2\x2\x1231\x1233\a");
		sb.Append("\x23C\x2\x2\x1232\x1231\x3\x2\x2\x2\x1232\x1233\x3\x2\x2\x2");
		sb.Append("\x1233\x1257\x3\x2\x2\x2\x1234\x123B\a \x2\x2\x1235\x1236\a");
		sb.Append("\x210\x2\x2\x1236\x123C\a\x23B\x2\x2\x1237\x123C\a\x23C\x2\x2");
		sb.Append("\x1238\x123C\a\x224\x2\x2\x1239\x123C\a\x21E\x2\x2\x123A\x123C");
		sb.Append("\a\x20F\x2\x2\x123B\x1235\x3\x2\x2\x2\x123B\x1237\x3\x2\x2\x2");
		sb.Append("\x123B\x1238\x3\x2\x2\x2\x123B\x1239\x3\x2\x2\x2\x123B\x123A");
		sb.Append("\x3\x2\x2\x2\x123B\x123C\x3\x2\x2\x2\x123C\x1257\x3\x2\x2\x2");
		sb.Append("\x123D\x1257\a)\x2\x2\x123E\x1257\a/\x2\x2\x123F\x1257\a\x146");
		sb.Append("\x2\x2\x1240\x1257\a\x23D\x2\x2\x1241\x1257\a\x23E\x2\x2\x1242");
		sb.Append("\x1243\a@\x2\x2\x1243\x1257\aj\x2\x2\x1244\x1257\aG\x2\x2\x1245");
		sb.Append("\x1257\aK\x2\x2\x1246\x1247\a\\\x2\x2\x1247\x1257\a\x23B\x2");
		sb.Append("\x2\x1248\x1257\a\x23F\x2\x2\x1249\x1257\a\x1C8\x2\x2\x124A");
		sb.Append("\x1257\ax\x2\x2\x124B\x1257\a\x240\x2\x2\x124C\x124D\a\x1DD");
		sb.Append("\x2\x2\x124D\x1257\t>\x2\x2\x124E\x1257\a\x86\x2\x2\x124F\x1250");
		sb.Append("\a\x89\x2\x2\x1250\x1257\t?\x2\x2\x1251\x1257\a\x241\x2\x2\x1252");
		sb.Append("\x1257\a\x242\x2\x2\x1253\x1257\a\x9A\x2\x2\x1254\x1257\a\xA1");
		sb.Append("\x2\x2\x1255\x1257\a\xA2\x2\x2\x1256\x122C\x3\x2\x2\x2\x1256");
		sb.Append("\x1230\x3\x2\x2\x2\x1256\x1234\x3\x2\x2\x2\x1256\x123D\x3\x2");
		sb.Append("\x2\x2\x1256\x123E\x3\x2\x2\x2\x1256\x123F\x3\x2\x2\x2\x1256");
		sb.Append("\x1240\x3\x2\x2\x2\x1256\x1241\x3\x2\x2\x2\x1256\x1242\x3\x2");
		sb.Append("\x2\x2\x1256\x1244\x3\x2\x2\x2\x1256\x1245\x3\x2\x2\x2\x1256");
		sb.Append("\x1246\x3\x2\x2\x2\x1256\x1248\x3\x2\x2\x2\x1256\x1249\x3\x2");
		sb.Append("\x2\x2\x1256\x124A\x3\x2\x2\x2\x1256\x124B\x3\x2\x2\x2\x1256");
		sb.Append("\x124C\x3\x2\x2\x2\x1256\x124E\x3\x2\x2\x2\x1256\x124F\x3\x2");
		sb.Append("\x2\x2\x1256\x1251\x3\x2\x2\x2\x1256\x1252\x3\x2\x2\x2\x1256");
		sb.Append("\x1253\x3\x2\x2\x2\x1256\x1254\x3\x2\x2\x2\x1256\x1255\x3\x2");
		sb.Append("\x2\x2\x1257\x1A1\x3\x2\x2\x2\x1258\x1266\a\x3B0\x2\x2\x1259");
		sb.Append("\x125A\a\x3B0\x2\x2\x125A\x125B\a\x3C0\x2\x2\x125B\x1266\a\x3B0");
		sb.Append("\x2\x2\x125C\x125D\x5\x202\x102\x2\x125D\x125E\a\x3C0\x2\x2");
		sb.Append("\x125E\x125F\a\x3B0\x2\x2\x125F\x1266\x3\x2\x2\x2\x1260\x1261");
		sb.Append("\x5\x202\x102\x2\x1261\x1262\a\x3C0\x2\x2\x1262\x1263\x5\x202");
		sb.Append("\x102\x2\x1263\x1266\x3\x2\x2\x2\x1264\x1266\x5\x202\x102\x2");
		sb.Append("\x1265\x1258\x3\x2\x2\x2\x1265\x1259\x3\x2\x2\x2\x1265\x125C");
		sb.Append("\x3\x2\x2\x2\x1265\x1260\x3\x2\x2\x2\x1265\x1264\x3\x2\x2\x2");
		sb.Append("\x1266\x1A3\x3\x2\x2\x2\x1267\x1268\x5\x1F0\xF9\x2\x1268\x1269");
		sb.Append("\a\x98\x2\x2\x1269\x126A\x5\x1F0\xF9\x2\x126A\x1A5\x3\x2\x2");
		sb.Append("\x2\x126B\x126D\a\v\x2\x2\x126C\x126E\t@\x2\x2\x126D\x126C\x3");
		sb.Append("\x2\x2\x2\x126D\x126E\x3\x2\x2\x2\x126E\x126F\x3\x2\x2\x2\x126F");
		sb.Append("\x1270\a\x95\x2\x2\x1270\x1271\x5\x224\x113\x2\x1271\x1A7\x3");
		sb.Append("\x2\x2\x2\x1272\x1273\a\x19\x2\x2\x1273\x1274\a\x95\x2\x2\x1274");
		sb.Append("\x1278\x5\x224\x113\x2\x1275\x1277\x5\x1B0\xD9\x2\x1276\x1275");
		sb.Append("\x3\x2\x2\x2\x1277\x127A\x3\x2\x2\x2\x1278\x1276\x3\x2\x2\x2");
		sb.Append("\x1278\x1279\x3\x2\x2\x2\x1279\x1A9\x3\x2\x2\x2\x127A\x1278");
		sb.Append("\x3\x2\x2\x2\x127B\x127C\a\x116\x2\x2\x127C\x127D\a\x95\x2\x2");
		sb.Append("\x127D\x127F\x5\x224\x113\x2\x127E\x1280\t\x41\x2\x2\x127F\x127E");
		sb.Append("\x3\x2\x2\x2\x127F\x1280\x3\x2\x2\x2\x1280\x1AB\x3\x2\x2\x2");
		sb.Append("\x1281\x1283\ai\x2\x2\x1282\x1284\t@\x2\x2\x1283\x1282\x3\x2");
		sb.Append("\x2\x2\x1283\x1284\x3\x2\x2\x2\x1284\x1285\x3\x2\x2\x2\x1285");
		sb.Append("\x1286\a\x95\x2\x2\x1286\x1287\x5\x224\x113\x2\x1287\x1AD\x3");
		sb.Append("\x2\x2\x2\x1288\x128A\a\x1D5\x2\x2\x1289\x128B\t@\x2\x2\x128A");
		sb.Append("\x1289\x3\x2\x2\x2\x128A\x128B\x3\x2\x2\x2\x128B\x128C\x3\x2");
		sb.Append("\x2\x2\x128C\x128D\a\x95\x2\x2\x128D\x128F\x5\x224\x113\x2\x128E");
		sb.Append("\x1290\a\x1CA\x2\x2\x128F\x128E\x3\x2\x2\x2\x128F\x1290\x3\x2");
		sb.Append("\x2\x2\x1290\x1292\x3\x2\x2\x2\x1291\x1293\a\x14D\x2\x2\x1292");
		sb.Append("\x1291\x3\x2\x2\x2\x1292\x1293\x3\x2\x2\x2\x1293\x1295\x3\x2");
		sb.Append("\x2\x2\x1294\x1296\a\x21F\x2\x2\x1295\x1294\x3\x2\x2\x2\x1295");
		sb.Append("\x1296\x3\x2\x2\x2\x1296\x1AF\x3\x2\x2\x2\x1297\x1298\a:\x2");
		sb.Append("\x2\x1298\x129F\a\x21D\x2\x2\x1299\x129F\a\x1CA\x2\x2\x129A");
		sb.Append("\x129F\a\x14F\x2\x2\x129B\x129F\a\x199\x2\x2\x129C\x129F\a\x14D");
		sb.Append("\x2\x2\x129D\x129F\a\x114\x2\x2\x129E\x1297\x3\x2\x2\x2\x129E");
		sb.Append("\x1299\x3\x2\x2\x2\x129E\x129A\x3\x2\x2\x2\x129E\x129B\x3\x2");
		sb.Append("\x2\x2\x129E\x129C\x3\x2\x2\x2\x129E\x129D\x3\x2\x2\x2\x129F");
		sb.Append("\x1B1\x3\x2\x2\x2\x12A0\x12A2\a \x2\x2\x12A1\x12A3\a\x101\x2");
		sb.Append("\x2\x12A2\x12A1\x3\x2\x2\x2\x12A2\x12A3\x3\x2\x2\x2\x12A3\x12A4");
		sb.Append("\x3\x2\x2\x2\x12A4\x12A5\a\x15A\x2\x2\x12A5\x12A6\x5\x202\x102");
		sb.Append("\x2\x12A6\x12A7\a\x1E0\x2\x2\x12A7\x12A8\t\x42\x2\x2\x12A8\x12A9");
		sb.Append("\a\x1F5\x2\x2\x12A9\x12AA\a\x3D0\x2\x2\x12AA\x1B3\x3\x2\x2\x2");
		sb.Append("\x12AB\x12AC\a\x16B\x2\x2\x12AC\x12AD\a\x1BD\x2\x2\x12AD\x12AE");
		sb.Append("\x5\x202\x102\x2\x12AE\x12AF\a\x1F5\x2\x2\x12AF\x12B0\a\x3D0");
		sb.Append("\x2\x2\x12B0\x1B5\x3\x2\x2\x2\x12B1\x12B2\a\x21A\x2\x2\x12B2");
		sb.Append("\x12B3\a\x1BD\x2\x2\x12B3\x12B4\x5\x202\x102\x2\x12B4\x1B7\x3");
		sb.Append("\x2\x2\x2\x12B5\x12B6\a\x87\x2\x2\x12B6\x12B7\x5\x1BC\xDF\x2");
		sb.Append("\x12B7\x12B8\t\x43\x2\x2\x12B8\x12C0\x5\x250\x129\x2\x12B9\x12BA");
		sb.Append("\a\x3C3\x2\x2\x12BA\x12BB\x5\x1BC\xDF\x2\x12BB\x12BC\t\x43\x2");
		sb.Append("\x2\x12BC\x12BD\x5\x250\x129\x2\x12BD\x12BF\x3\x2\x2\x2\x12BE");
		sb.Append("\x12B9\x3\x2\x2\x2\x12BF\x12C2\x3\x2\x2\x2\x12C0\x12BE\x3\x2");
		sb.Append("\x2\x2\x12C0\x12C1\x3\x2\x2\x2\x12C1\x12E0\x3\x2\x2\x2\x12C2");
		sb.Append("\x12C0\x3\x2\x2\x2\x12C3\x12C7\a\x87\x2\x2\x12C4\x12C5\a\x18");
		sb.Append("\x2\x2\x12C5\x12C8\a\x87\x2\x2\x12C6\x12C8\a\x2A1\x2\x2\x12C7");
		sb.Append("\x12C4\x3\x2\x2\x2\x12C7\x12C6\x3\x2\x2\x2\x12C8\x12CB\x3\x2");
		sb.Append("\x2\x2\x12C9\x12CC\x5\x1F4\xFB\x2\x12CA\x12CC\a\'\x2\x2\x12CB");
		sb.Append("\x12C9\x3\x2\x2\x2\x12CB\x12CA\x3\x2\x2\x2\x12CC\x12E0\x3\x2");
		sb.Append("\x2\x2\x12CD\x12CE\a\x87\x2\x2\x12CE\x12D5\a\x1A3\x2\x2\x12CF");
		sb.Append("\x12D2\x5\x1F4\xFB\x2\x12D0\x12D1\a\x1A\x2\x2\x12D1\x12D3\x5");
		sb.Append("\x1F6\xFC\x2\x12D2\x12D0\x3\x2\x2\x2\x12D2\x12D3\x3\x2\x2\x2");
		sb.Append("\x12D3\x12D6\x3\x2\x2\x2\x12D4\x12D6\a\'\x2\x2\x12D5\x12CF\x3");
		sb.Append("\x2\x2\x2\x12D5\x12D4\x3\x2\x2\x2\x12D6\x12E0\x3\x2\x2\x2\x12D7");
		sb.Append("\x12E0\x5\x190\xC9\x2\x12D8\x12E0\x5\x114\x8B\x2\x12D9\x12E0");
		sb.Append("\x5\x112\x8A\x2\x12DA\x12DB\a\x87\x2\x2\x12DB\x12DC\x5\x1E8");
		sb.Append("\xF5\x2\x12DC\x12DD\t\x43\x2\x2\x12DD\x12DE\x5\x250\x129\x2");
		sb.Append("\x12DE\x12E0\x3\x2\x2\x2\x12DF\x12B5\x3\x2\x2\x2\x12DF\x12C3");
		sb.Append("\x3\x2\x2\x2\x12DF\x12CD\x3\x2\x2\x2\x12DF\x12D7\x3\x2\x2\x2");
		sb.Append("\x12DF\x12D8\x3\x2\x2\x2\x12DF\x12D9\x3\x2\x2\x2\x12DF\x12DA");
		sb.Append("\x3\x2\x2\x2\x12E0\x1B9\x3\x2\x2\x2\x12E1\x12E2\a\x89\x2\x2");
		sb.Append("\x12E2\x12E3\t\x32\x2\x2\x12E3\x1379\a\x17D\x2\x2\x12E4\x12E5");
		sb.Append("\a\x89\x2\x2\x12E5\x12E6\t\x44\x2\x2\x12E6\x12E9\a\x147\x2\x2");
		sb.Append("\x12E7\x12E8\a\x46\x2\x2\x12E8\x12EA\a\x3D0\x2\x2\x12E9\x12E7");
		sb.Append("\x3\x2\x2\x2\x12E9\x12EA\x3\x2\x2\x2\x12EA\x12ED\x3\x2\x2\x2");
		sb.Append("\x12EB\x12EC\a=\x2\x2\x12EC\x12EE\x5\x208\x105\x2\x12ED\x12EB");
		sb.Append("\x3\x2\x2\x2\x12ED\x12EE\x3\x2\x2\x2\x12EE\x12F6\x3\x2\x2\x2");
		sb.Append("\x12EF\x12F3\aX\x2\x2\x12F0\x12F1\x5\x208\x105\x2\x12F1\x12F2");
		sb.Append("\a\x3C3\x2\x2\x12F2\x12F4\x3\x2\x2\x2\x12F3\x12F0\x3\x2\x2\x2");
		sb.Append("\x12F3\x12F4\x3\x2\x2\x2\x12F4\x12F5\x3\x2\x2\x2\x12F5\x12F7");
		sb.Append("\x5\x208\x105\x2\x12F6\x12EF\x3\x2\x2\x2\x12F6\x12F7\x3\x2\x2");
		sb.Append("\x2\x12F7\x1379\x3\x2\x2\x2\x12F8\x12F9\a\x89\x2\x2\x12F9\x12FB");
		sb.Append("\x5\x1BE\xE0\x2\x12FA\x12FC\x5\x1C0\xE1\x2\x12FB\x12FA\x3\x2");
		sb.Append("\x2\x2\x12FB\x12FC\x3\x2\x2\x2\x12FC\x1379\x3\x2\x2\x2\x12FD");
		sb.Append("\x12FF\a\x89\x2\x2\x12FE\x1300\a\x159\x2\x2\x12FF\x12FE\x3\x2");
		sb.Append("\x2\x2\x12FF\x1300\x3\x2\x2\x2\x1300\x1301\x3\x2\x2\x2\x1301");
		sb.Append("\x1302\t$\x2\x2\x1302\x1303\t\x45\x2\x2\x1303\x1306\x5\x1EA");
		sb.Append("\xF6\x2\x1304\x1305\t\x45\x2\x2\x1305\x1307\x5\x202\x102\x2");
		sb.Append("\x1306\x1304\x3\x2\x2\x2\x1306\x1307\x3\x2\x2\x2\x1307\x1309");
		sb.Append("\x3\x2\x2\x2\x1308\x130A\x5\x1C0\xE1\x2\x1309\x1308\x3\x2\x2");
		sb.Append("\x2\x1309\x130A\x3\x2\x2\x2\x130A\x1379\x3\x2\x2\x2\x130B\x130C");
		sb.Append("\a\x89\x2\x2\x130C\x130D\a \x2\x2\x130D\x130F\t\x2\x2\x2\x130E");
		sb.Append("\x1310\x5\x23A\x11E\x2\x130F\x130E\x3\x2\x2\x2\x130F\x1310\x3");
		sb.Append("\x2\x2\x2\x1310\x1311\x3\x2\x2\x2\x1311\x1379\x5\x202\x102\x2");
		sb.Append("\x1312\x1313\a\x89\x2\x2\x1313\x1314\a \x2\x2\x1314\x1315\t");
		sb.Append("\x46\x2\x2\x1315\x1379\x5\x1E8\xF5\x2\x1316\x1317\a\x89\x2\x2");
		sb.Append("\x1317\x1318\a \x2\x2\x1318\x1319\a\x21E\x2\x2\x1319\x1379\x5");
		sb.Append("\x1F0\xF9\x2\x131A\x131B\a\x89\x2\x2\x131B\x131C\a\x140\x2\x2");
		sb.Append("\x131C\x131D\x5\x1F8\xFD\x2\x131D\x131E\tG\x2\x2\x131E\x1379");
		sb.Append("\x3\x2\x2\x2\x131F\x1320\a\x89\x2\x2\x1320\x1379\x5\x1C2\xE2");
		sb.Append("\x2\x1321\x1322\a\x89\x2\x2\x1322\x1323\tH\x2\x2\x1323\x1327");
		sb.Append("\aX\x2\x2\x1324\x1325\x5\x208\x105\x2\x1325\x1326\a\x3C3\x2");
		sb.Append("\x2\x1326\x1328\x3\x2\x2\x2\x1327\x1324\x3\x2\x2\x2\x1327\x1328");
		sb.Append("\x3\x2\x2\x2\x1328\x1329\x3\x2\x2\x2\x1329\x1379\x5\x208\x105");
		sb.Append("\x2\x132A\x132B\a\x89\x2\x2\x132B\x132C\a\xDF\x2\x2\x132C\x132D");
		sb.Append("\a\x3C1\x2\x2\x132D\x132E\a\x3B0\x2\x2\x132E\x132F\a\x3C2\x2");
		sb.Append("\x2\x132F\x1379\tH\x2\x2\x1330\x1331\a\x89\x2\x2\x1331\x1334");
		sb.Append("\x5\x1C4\xE3\x2\x1332\x1333\t\x45\x2\x2\x1333\x1335\x5\x202");
		sb.Append("\x102\x2\x1334\x1332\x3\x2\x2\x2\x1334\x1335\x3\x2\x2\x2\x1335");
		sb.Append("\x1337\x3\x2\x2\x2\x1336\x1338\x5\x1C0\xE1\x2\x1337\x1336\x3");
		sb.Append("\x2\x2\x2\x1337\x1338\x3\x2\x2\x2\x1338\x1379\x3\x2\x2\x2\x1339");
		sb.Append("\x133A\a\x89\x2\x2\x133A\x133B\tI\x2\x2\x133B\x133C\a\x11C\x2");
		sb.Append("\x2\x133C\x1379\x5\x1E8\xF5\x2\x133D\x133E\a\x89\x2\x2\x133E");
		sb.Append("\x1341\a\x15D\x2\x2\x133F\x1340\a:\x2\x2\x1340\x1342\x5\x1F0");
		sb.Append("\xF9\x2\x1341\x133F\x3\x2\x2\x2\x1341\x1342\x3\x2\x2\x2\x1342");
		sb.Append("\x1379\x3\x2\x2\x2\x1343\x1344\a\x89\x2\x2\x1344\x1345\tJ\x2");
		sb.Append("\x2\x1345\x1346\t\x45\x2\x2\x1346\x1349\x5\x1EA\xF6\x2\x1347");
		sb.Append("\x1348\t\x45\x2\x2\x1348\x134A\x5\x202\x102\x2\x1349\x1347\x3");
		sb.Append("\x2\x2\x2\x1349\x134A\x3\x2\x2\x2\x134A\x134D\x3\x2\x2\x2\x134B");
		sb.Append("\x134C\a\xA7\x2\x2\x134C\x134E\x5\x250\x129\x2\x134D\x134B\x3");
		sb.Append("\x2\x2\x2\x134D\x134E\x3\x2\x2\x2\x134E\x1379\x3\x2\x2\x2\x134F");
		sb.Append("\x1350\a\x89\x2\x2\x1350\x1351\a\x1B1\x2\x2\x1351\x1354\a\x23B");
		sb.Append("\x2\x2\x1352\x1353\t\x45\x2\x2\x1353\x1355\x5\x202\x102\x2\x1354");
		sb.Append("\x1352\x3\x2\x2\x2\x1354\x1355\x3\x2\x2\x2\x1355\x1357\x3\x2");
		sb.Append("\x2\x2\x1356\x1358\x5\x1C0\xE1\x2\x1357\x1356\x3\x2\x2\x2\x1357");
		sb.Append("\x1358\x3\x2\x2\x2\x1358\x1379\x3\x2\x2\x2\x1359\x135A\a\x89");
		sb.Append("\x2\x2\x135A\x135B\a\x1C6\x2\x2\x135B\x1360\x5\x1C6\xE4\x2\x135C");
		sb.Append("\x135D\a\x3C3\x2\x2\x135D\x135F\x5\x1C6\xE4\x2\x135E\x135C\x3");
		sb.Append("\x2\x2\x2\x135F\x1362\x3\x2\x2\x2\x1360\x135E\x3\x2\x2\x2\x1360");
		sb.Append("\x1361\x3\x2\x2\x2\x1361\x1366\x3\x2\x2\x2\x1362\x1360\x3\x2");
		sb.Append("\x2\x2\x1363\x1364\a:\x2\x2\x1364\x1365\a\x1C9\x2\x2\x1365\x1367");
		sb.Append("\x5\x208\x105\x2\x1366\x1363\x3\x2\x2\x2\x1366\x1367\x3\x2\x2");
		sb.Append("\x2\x1367\x1368\x3\x2\x2\x2\x1368\x136C\aX\x2\x2\x1369\x136A");
		sb.Append("\x5\x208\x105\x2\x136A\x136B\a\x3C3\x2\x2\x136B\x136D\x3\x2");
		sb.Append("\x2\x2\x136C\x1369\x3\x2\x2\x2\x136C\x136D\x3\x2\x2\x2\x136D");
		sb.Append("\x136E\x3\x2\x2\x2\x136E\x136F\x5\x208\x105\x2\x136F\x1379\x3");
		sb.Append("\x2\x2\x2\x1370\x1371\a\x89\x2\x2\x1371\x1372\a\x1F0\x2\x2\x1372");
		sb.Append("\x1376\a\x204\x2\x2\x1373\x1374\a:\x2\x2\x1374\x1375\a\x115");
		sb.Append("\x2\x2\x1375\x1377\a\x3D0\x2\x2\x1376\x1373\x3\x2\x2\x2\x1376");
		sb.Append("\x1377\x3\x2\x2\x2\x1377\x1379\x3\x2\x2\x2\x1378\x12E1\x3\x2");
		sb.Append("\x2\x2\x1378\x12E4\x3\x2\x2\x2\x1378\x12F8\x3\x2\x2\x2\x1378");
		sb.Append("\x12FD\x3\x2\x2\x2\x1378\x130B\x3\x2\x2\x2\x1378\x1312\x3\x2");
		sb.Append("\x2\x2\x1378\x1316\x3\x2\x2\x2\x1378\x131A\x3\x2\x2\x2\x1378");
		sb.Append("\x131F\x3\x2\x2\x2\x1378\x1321\x3\x2\x2\x2\x1378\x132A\x3\x2");
		sb.Append("\x2\x2\x1378\x1330\x3\x2\x2\x2\x1378\x1339\x3\x2\x2\x2\x1378");
		sb.Append("\x133D\x3\x2\x2\x2\x1378\x1343\x3\x2\x2\x2\x1378\x134F\x3\x2");
		sb.Append("\x2\x2\x1378\x1359\x3\x2\x2\x2\x1378\x1370\x3\x2\x2\x2\x1379");
		sb.Append("\x1BB\x3\x2\x2\x2\x137A\x1385\a\x3DB\x2\x2\x137B\x1385\a\x3DC");
		sb.Append("\x2\x2\x137C\x137D\a\x3C5\x2\x2\x137D\x137F\a\x3C5\x2\x2\x137E");
		sb.Append("\x137C\x3\x2\x2\x2\x137E\x137F\x3\x2\x2\x2\x137F\x1380\x3\x2");
		sb.Append("\x2\x2\x1380\x1382\tK\x2\x2\x1381\x137E\x3\x2\x2\x2\x1381\x1382");
		sb.Append("\x3\x2\x2\x2\x1382\x1383\x3\x2\x2\x2\x1383\x1385\x5\x202\x102");
		sb.Append("\x2\x1384\x137A\x3\x2\x2\x2\x1384\x137B\x3\x2\x2\x2\x1384\x1381");
		sb.Append("\x3\x2\x2\x2\x1385\x1BD\x3\x2\x2\x2\x1386\x1387\a\x18\x2\x2");
		sb.Append("\x1387\x1394\a\x87\x2\x2\x1388\x1394\a\x2A4\x2\x2\x1389\x1394");
		sb.Append("\a%\x2\x2\x138A\x1394\a\x85\x2\x2\x138B\x138C\a\x15A\x2\x2\x138C");
		sb.Append("\x1394\a\x204\x2\x2\x138D\x138E\as\x2\x2\x138E\x1394\a\x204");
		sb.Append("\x2\x2\x138F\x1391\t\x31\x2\x2\x1390\x138F\x3\x2\x2\x2\x1390");
		sb.Append("\x1391\x3\x2\x2\x2\x1391\x1392\x3\x2\x2\x2\x1392\x1394\tL\x2");
		sb.Append("\x2\x1393\x1386\x3\x2\x2\x2\x1393\x1388\x3\x2\x2\x2\x1393\x1389");
		sb.Append("\x3\x2\x2\x2\x1393\x138A\x3\x2\x2\x2\x1393\x138B\x3\x2\x2\x2");
		sb.Append("\x1393\x138D\x3\x2\x2\x2\x1393\x1390\x3\x2\x2\x2\x1394\x1BF");
		sb.Append("\x3\x2\x2\x2\x1395\x1396\aW\x2\x2\x1396\x139A\a\x3D0\x2\x2\x1397");
		sb.Append("\x1398\a\xA7\x2\x2\x1398\x139A\x5\x250\x129\x2\x1399\x1395\x3");
		sb.Append("\x2\x2\x2\x1399\x1397\x3\x2\x2\x2\x139A\x1C1\x3\x2\x2\x2\x139B");
		sb.Append("\x139D\a\x206\x2\x2\x139C\x139B\x3\x2\x2\x2\x139C\x139D\x3\x2");
		sb.Append("\x2\x2\x139D\x139E\x3\x2\x2\x2\x139E\x13AD\a\x141\x2\x2\x139F");
		sb.Append("\x13A0\a\x17E\x2\x2\x13A0\x13AD\a\x204\x2\x2\x13A1\x13AD\a\x1BF");
		sb.Append("\x2\x2\x13A2\x13AD\a\x243\x2\x2\x13A3\x13A5\a\x159\x2\x2\x13A4");
		sb.Append("\x13A3\x3\x2\x2\x2\x13A4\x13A5\x3\x2\x2\x2\x13A5\x13A6\x3\x2");
		sb.Append("\x2\x2\x13A6\x13AD\a\x1C5\x2\x2\x13A7\x13AD\a\x1C7\x2\x2\x13A8");
		sb.Append("\x13A9\a\x1F0\x2\x2\x13A9\x13AD\a\x163\x2\x2\x13AA\x13AD\a\x105");
		sb.Append("\x2\x2\x13AB\x13AD\a\x12A\x2\x2\x13AC\x139C\x3\x2\x2\x2\x13AC");
		sb.Append("\x139F\x3\x2\x2\x2\x13AC\x13A1\x3\x2\x2\x2\x13AC\x13A2\x3\x2");
		sb.Append("\x2\x2\x13AC\x13A4\x3\x2\x2\x2\x13AC\x13A7\x3\x2\x2\x2\x13AC");
		sb.Append("\x13A8\x3\x2\x2\x2\x13AC\x13AA\x3\x2\x2\x2\x13AC\x13AB\x3\x2");
		sb.Append("\x2\x2\x13AD\x1C3\x3\x2\x2\x2\x13AE\x13B7\a\x147\x2\x2\x13AF");
		sb.Append("\x13B0\a\x95\x2\x2\x13B0\x13B7\a\x204\x2\x2\x13B1\x13B3\a\x159");
		sb.Append("\x2\x2\x13B2\x13B1\x3\x2\x2\x2\x13B2\x13B3\x3\x2\x2\x2\x13B3");
		sb.Append("\x13B4\x3\x2\x2\x2\x13B4\x13B7\a\x23B\x2\x2\x13B5\x13B7\a\x215");
		sb.Append("\x2\x2\x13B6\x13AE\x3\x2\x2\x2\x13B6\x13AF\x3\x2\x2\x2\x13B6");
		sb.Append("\x13B2\x3\x2\x2\x2\x13B6\x13B5\x3\x2\x2\x2\x13B7\x1C5\x3\x2");
		sb.Append("\x2\x2\x13B8\x13C5\a\b\x2\x2\x13B9\x13BA\a\x10D\x2\x2\x13BA");
		sb.Append("\x13C5\a\x16E\x2\x2\x13BB\x13BC\a\x129\x2\x2\x13BC\x13C5\a\x20E");
		sb.Append("\x2\x2\x13BD\x13C5\a\x12C\x2\x2\x13BE\x13C5\a\x170\x2\x2\x13BF");
		sb.Append("\x13C5\a\x271\x2\x2\x13C0\x13C1\a\x1B6\x2\x2\x13C1\x13C5\a\x150");
		sb.Append("\x2\x2\x13C2\x13C5\a\x1F7\x2\x2\x13C3\x13C5\a\x20D\x2\x2\x13C4");
		sb.Append("\x13B8\x3\x2\x2\x2\x13C4\x13B9\x3\x2\x2\x2\x13C4\x13BB\x3\x2");
		sb.Append("\x2\x2\x13C4\x13BD\x3\x2\x2\x2\x13C4\x13BE\x3\x2\x2\x2\x13C4");
		sb.Append("\x13BF\x3\x2\x2\x2\x13C4\x13C0\x3\x2\x2\x2\x13C4\x13C2\x3\x2");
		sb.Append("\x2\x2\x13C4\x13C3\x3\x2\x2\x2\x13C5\x1C7\x3\x2\x2\x2\x13C6");
		sb.Append("\x13C7\a\x10B\x2\x2\x13C7\x13C8\a\x3D0\x2\x2\x13C8\x1C9\x3\x2");
		sb.Append("\x2\x2\x13C9\x13CA\a\x111\x2\x2\x13CA\x13CB\aG\x2\x2\x13CB\x13D0");
		sb.Append("\x5\x1D6\xEC\x2\x13CC\x13CD\a\x3C3\x2\x2\x13CD\x13CF\x5\x1D6");
		sb.Append("\xEC\x2\x13CE\x13CC\x3\x2\x2\x2\x13CF\x13D2\x3\x2\x2\x2\x13D0");
		sb.Append("\x13CE\x3\x2\x2\x2\x13D0\x13D1\x3\x2\x2\x2\x13D1\x13DA\x3\x2");
		sb.Append("\x2\x2\x13D2\x13D0\x3\x2\x2\x2\x13D3\x13D4\aq\x2\x2\x13D4\x13D7");
		sb.Append("\a\x3C1\x2\x2\x13D5\x13D8\x5\x222\x112\x2\x13D6\x13D8\a\b\x2");
		sb.Append("\x2\x13D7\x13D5\x3\x2\x2\x2\x13D7\x13D6\x3\x2\x2\x2\x13D8\x13D9");
		sb.Append("\x3\x2\x2\x2\x13D9\x13DB\a\x3C2\x2\x2\x13DA\x13D3\x3\x2\x2\x2");
		sb.Append("\x13DA\x13DB\x3\x2\x2\x2\x13DB\x13DC\x3\x2\x2\x2\x13DC\x13DD");
		sb.Append("\a\x46\x2\x2\x13DD\x13DE\x5\x202\x102\x2\x13DE\x1CB\x3\x2\x2");
		sb.Append("\x2\x13DF\x13E1\a\x156\x2\x2\x13E0\x13E2\t@\x2\x2\x13E1\x13E0");
		sb.Append("\x3\x2\x2\x2\x13E1\x13E2\x3\x2\x2\x2\x13E2\x13E3\x3\x2\x2\x2");
		sb.Append("\x13E3\x13E8\x5\x1D8\xED\x2\x13E4\x13E5\a\x3C3\x2\x2\x13E5\x13E7");
		sb.Append("\x5\x1D8\xED\x2\x13E6\x13E4\x3\x2\x2\x2\x13E7\x13EA\x3\x2\x2");
		sb.Append("\x2\x13E8\x13E6\x3\x2\x2\x2\x13E8\x13E9\x3\x2\x2\x2\x13E9\x1CD");
		sb.Append("\x3\x2\x2\x2\x13EA\x13E8\x3\x2\x2\x2\x13EB\x13ED\aS\x2\x2\x13EC");
		sb.Append("\x13EE\tM\x2\x2\x13ED\x13EC\x3\x2\x2\x2\x13ED\x13EE\x3\x2\x2");
		sb.Append("\x2\x13EE\x13F0\x3\x2\x2\x2\x13EF\x13F1\x5\x208\x105\x2\x13F0");
		sb.Append("\x13EF\x3\x2\x2\x2\x13F1\x13F2\x3\x2\x2\x2\x13F2\x13F0\x3\x2");
		sb.Append("\x2\x2\x13F2\x13F3\x3\x2\x2\x2\x13F3\x1CF\x3\x2\x2\x2\x13F4");
		sb.Append("\x13F5\a[\x2\x2\x13F5\x13F6\aG\x2\x2\x13F6\x13F7\aM\x2\x2\x13F7");
		sb.Append("\x13F8\a\x111\x2\x2\x13F8\x13FD\x5\x1DC\xEF\x2\x13F9\x13FA\a");
		sb.Append("\x3C3\x2\x2\x13FA\x13FC\x5\x1DC\xEF\x2\x13FB\x13F9\x3\x2\x2");
		sb.Append("\x2\x13FC\x13FF\x3\x2\x2\x2\x13FD\x13FB\x3\x2\x2\x2\x13FD\x13FE");
		sb.Append("\x3\x2\x2\x2\x13FE\x1D1\x3\x2\x2\x2\x13FF\x13FD\x3\x2\x2\x2");
		sb.Append("\x1400\x1401\a\x1DE\x2\x2\x1401\x1402\a\x1C9\x2\x2\x1402\x1403");
		sb.Append("\a\x111\x2\x2\x1403\x1D3\x3\x2\x2\x2\x1404\x1405\a\x241\x2\x2");
		sb.Append("\x1405\x1D5\x3\x2\x2\x2\x1406\x140E\x5\x1EA\xF6\x2\x1407\x1409");
		sb.Append("\t\x14\x2\x2\x1408\x1407\x3\x2\x2\x2\x1408\x1409\x3\x2\x2\x2");
		sb.Append("\x1409\x140A\x3\x2\x2\x2\x140A\x140B\a\x3C1\x2\x2\x140B\x140C");
		sb.Append("\x5\x222\x112\x2\x140C\x140D\a\x3C2\x2\x2\x140D\x140F\x3\x2");
		sb.Append("\x2\x2\x140E\x1408\x3\x2\x2\x2\x140E\x140F\x3\x2\x2\x2\x140F");
		sb.Append("\x1D7\x3\x2\x2\x2\x1410\x1423\a\x133\x2\x2\x1411\x1423\a\x163");
		sb.Append("\x2\x2\x1412\x1414\tN\x2\x2\x1413\x1412\x3\x2\x2\x2\x1413\x1414");
		sb.Append("\x3\x2\x2\x2\x1414\x1415\x3\x2\x2\x2\x1415\x1423\a\x17D\x2\x2");
		sb.Append("\x1416\x1423\a\x1B2\x2\x2\x1417\x1423\a\x243\x2\x2\x1418\x1419");
		sb.Append("\a\x1C9\x2\x2\x1419\x1423\a\x111\x2\x2\x141A\x1423\a\x204\x2");
		sb.Append("\x2\x141B\x1423\a\x220\x2\x2\x141C\x1420\a\x23B\x2\x2\x141D");
		sb.Append("\x141E\a\xA9\x2\x2\x141E\x141F\av\x2\x2\x141F\x1421\a\\\x2\x2");
		sb.Append("\x1420\x141D\x3\x2\x2\x2\x1420\x1421\x3\x2\x2\x2\x1421\x1423");
		sb.Append("\x3\x2\x2\x2\x1422\x1410\x3\x2\x2\x2\x1422\x1411\x3\x2\x2\x2");
		sb.Append("\x1422\x1413\x3\x2\x2\x2\x1422\x1416\x3\x2\x2\x2\x1422\x1417");
		sb.Append("\x3\x2\x2\x2\x1422\x1418\x3\x2\x2\x2\x1422\x141A\x3\x2\x2\x2");
		sb.Append("\x1422\x141B\x3\x2\x2\x2\x1422\x141C\x3\x2\x2\x2\x1423\x142F");
		sb.Append("\x3\x2\x2\x2\x1424\x1425\a\x1CF\x2\x2\x1425\x1427\a\x17D\x2");
		sb.Append("\x2\x1426\x1428\x5\x13A\x9E\x2\x1427\x1426\x3\x2\x2\x2\x1427");
		sb.Append("\x1428\x3\x2\x2\x2\x1428\x142F\x3\x2\x2\x2\x1429\x142A\a\x23B");
		sb.Append("\x2\x2\x142A\x142C\x5\x224\x113\x2\x142B\x142D\x5\x1DA\xEE\x2");
		sb.Append("\x142C\x142B\x3\x2\x2\x2\x142C\x142D\x3\x2\x2\x2\x142D\x142F");
		sb.Append("\x3\x2\x2\x2\x142E\x1422\x3\x2\x2\x2\x142E\x1424\x3\x2\x2\x2");
		sb.Append("\x142E\x1429\x3\x2\x2\x2\x142F\x1D9\x3\x2\x2\x2\x1430\x1431");
		sb.Append("\a\xA9\x2\x2\x1431\x1432\av\x2\x2\x1432\x1436\a\\\x2\x2\x1433");
		sb.Append("\x1434\a:\x2\x2\x1434\x1436\a\x14C\x2\x2\x1435\x1430\x3\x2\x2");
		sb.Append("\x2\x1435\x1433\x3\x2\x2\x2\x1436\x1DB\x3\x2\x2\x2\x1437\x143F");
		sb.Append("\x5\x1EA\xF6\x2\x1438\x1439\aq\x2\x2\x1439\x143C\a\x3C1\x2\x2");
		sb.Append("\x143A\x143D\x5\x222\x112\x2\x143B\x143D\a\b\x2\x2\x143C\x143A");
		sb.Append("\x3\x2\x2\x2\x143C\x143B\x3\x2\x2\x2\x143D\x143E\x3\x2\x2\x2");
		sb.Append("\x143E\x1440\a\x3C2\x2\x2\x143F\x1438\x3\x2\x2\x2\x143F\x1440");
		sb.Append("\x3\x2\x2\x2\x1440\x1448\x3\x2\x2\x2\x1441\x1443\t\x14\x2\x2");
		sb.Append("\x1442\x1441\x3\x2\x2\x2\x1442\x1443\x3\x2\x2\x2\x1443\x1444");
		sb.Append("\x3\x2\x2\x2\x1444\x1445\a\x3C1\x2\x2\x1445\x1446\x5\x222\x112");
		sb.Append("\x2\x1446\x1447\a\x3C2\x2\x2\x1447\x1449\x3\x2\x2\x2\x1448\x1442");
		sb.Append("\x3\x2\x2\x2\x1448\x1449\x3\x2\x2\x2\x1449\x144C\x3\x2\x2\x2");
		sb.Append("\x144A\x144B\a\x45\x2\x2\x144B\x144D\a\x177\x2\x2\x144C\x144A");
		sb.Append("\x3\x2\x2\x2\x144C\x144D\x3\x2\x2\x2\x144D\x1DD\x3\x2\x2\x2");
		sb.Append("\x144E\x144F\tO\x2\x2\x144F\x1452\x5\x1EA\xF6\x2\x1450\x1453");
		sb.Append("\x5\x202\x102\x2\x1451\x1453\a\x3D0\x2\x2\x1452\x1450\x3\x2");
		sb.Append("\x2\x2\x1452\x1451\x3\x2\x2\x2\x1452\x1453\x3\x2\x2\x2\x1453");
		sb.Append("\x1DF\x3\x2\x2\x2\x1454\x1458\tO\x2\x2\x1455\x1456\tP\x2\x2");
		sb.Append("\x1456\x1457\a\x3B8\x2\x2\x1457\x1459\tQ\x2\x2\x1458\x1455\x3");
		sb.Append("\x2\x2\x2\x1458\x1459\x3\x2\x2\x2\x1459\x145A\x3\x2\x2\x2\x145A");
		sb.Append("\x145B\x5\x1E6\xF4\x2\x145B\x1E1\x3\x2\x2\x2\x145C\x145D\a\x161");
		sb.Append("\x2\x2\x145D\x145E\a\x3D0\x2\x2\x145E\x1E3\x3\x2\x2\x2\x145F");
		sb.Append("\x1460\a\xA3\x2\x2\x1460\x1461\x5\x202\x102\x2\x1461\x1E5\x3");
		sb.Append("\x2\x2\x2\x1462\x1468\x5\xB4[\x2\x1463\x1468\x5\xA6T\x2\x1464");
		sb.Append("\x1468\x5\xACW\x2\x1465\x1468\x5\xB2Z\x2\x1466\x1468\x5\xB6");
		sb.Append("\\\x2\x1467\x1462\x3\x2\x2\x2\x1467\x1463\x3\x2\x2\x2\x1467");
		sb.Append("\x1464\x3\x2\x2\x2\x1467\x1465\x3\x2\x2\x2\x1467\x1466\x3\x2");
		sb.Append("\x2\x2\x1468\x146D\x3\x2\x2\x2\x1469\x146A\a:\x2\x2\x146A\x146B");
		sb.Append("\a\x126\x2\x2\x146B\x146D\x5\x202\x102\x2\x146C\x1467\x3\x2");
		sb.Append("\x2\x2\x146C\x1469\x3\x2\x2\x2\x146D\x1E7\x3\x2\x2\x2\x146E");
		sb.Append("\x1472\x5\x202\x102\x2\x146F\x1473\a\x3D7\x2\x2\x1470\x1471");
		sb.Append("\a\x3C0\x2\x2\x1471\x1473\x5\x202\x102\x2\x1472\x146F\x3\x2");
		sb.Append("\x2\x2\x1472\x1470\x3\x2\x2\x2\x1472\x1473\x3\x2\x2\x2\x1473");
		sb.Append("\x1E9\x3\x2\x2\x2\x1474\x1475\x5\x1E8\xF5\x2\x1475\x1EB\x3\x2");
		sb.Append("\x2\x2\x1476\x147B\x5\x202\x102\x2\x1477\x1479\x5\x206\x104");
		sb.Append("\x2\x1478\x147A\x5\x206\x104\x2\x1479\x1478\x3\x2\x2\x2\x1479");
		sb.Append("\x147A\x3\x2\x2\x2\x147A\x147C\x3\x2\x2\x2\x147B\x1477\x3\x2");
		sb.Append("\x2\x2\x147B\x147C\x3\x2\x2\x2\x147C\x1ED\x3\x2\x2\x2\x147D");
		sb.Append("\x1480\x5\x202\x102\x2\x147E\x1480\a\x3D0\x2\x2\x147F\x147D");
		sb.Append("\x3\x2\x2\x2\x147F\x147E\x3\x2\x2\x2\x1480\x1485\x3\x2\x2\x2");
		sb.Append("\x1481\x1482\a\x3C1\x2\x2\x1482\x1483\x5\x208\x105\x2\x1483");
		sb.Append("\x1484\a\x3C2\x2\x2\x1484\x1486\x3\x2\x2\x2\x1485\x1481\x3\x2");
		sb.Append("\x2\x2\x1485\x1486\x3\x2\x2\x2\x1486\x1488\x3\x2\x2\x2\x1487");
		sb.Append("\x1489\t+\x2\x2\x1488\x1487\x3\x2\x2\x2\x1488\x1489\x3\x2\x2");
		sb.Append("\x2\x1489\x1EF\x3\x2\x2\x2\x148A\x148B\tR\x2\x2\x148B\x1F1\x3");
		sb.Append("\x2\x2\x2\x148C\x148D\tS\x2\x2\x148D\x1F3\x3\x2\x2\x2\x148E");
		sb.Append("\x1493\a\xC3\x2\x2\x148F\x1493\x5\x260\x131\x2\x1490\x1493\a");
		sb.Append("\x3D0\x2\x2\x1491\x1493\a\x3CD\x2\x2\x1492\x148E\x3\x2\x2\x2");
		sb.Append("\x1492\x148F\x3\x2\x2\x2\x1492\x1490\x3\x2\x2\x2\x1492\x1491");
		sb.Append("\x3\x2\x2\x2\x1493\x1F5\x3\x2\x2\x2\x1494\x1497\x5\x202\x102");
		sb.Append("\x2\x1495\x1497\a\x3D0\x2\x2\x1496\x1494\x3\x2\x2\x2\x1496\x1495");
		sb.Append("\x3\x2\x2\x2\x1497\x1F7\x3\x2\x2\x2\x1498\x1499\tT\x2\x2\x1499");
		sb.Append("\x1F9\x3\x2\x2\x2\x149A\x149B\x5\x208\x105\x2\x149B\x149C\a");
		sb.Append("\x3B5\x2\x2\x149C\x149D\x5\x208\x105\x2\x149D\x149E\a\x3B5\x2");
		sb.Append("\x2\x149E\x149F\x5\x208\x105\x2\x149F\x14A0\a\x3B5\x2\x2\x14A0");
		sb.Append("\x14A1\x5\x208\x105\x2\x14A1\x14A2\a\x3B5\x2\x2\x14A2\x14A8");
		sb.Append("\x5\x208\x105\x2\x14A3\x14A4\a\x3CC\x2\x2\x14A4\x14A5\x5\x208");
		sb.Append("\x105\x2\x14A5\x14A6\a\x3B5\x2\x2\x14A6\x14A7\x5\x208\x105\x2");
		sb.Append("\x14A7\x14A9\x3\x2\x2\x2\x14A8\x14A3\x3\x2\x2\x2\x14A9\x14AA");
		sb.Append("\x3\x2\x2\x2\x14AA\x14A8\x3\x2\x2\x2\x14AA\x14AB\x3\x2\x2\x2");
		sb.Append("\x14AB\x1FB\x3\x2\x2\x2\x14AC\x14B3\x5\x1FE\x100\x2\x14AD\x14AE");
		sb.Append("\a\x3C3\x2\x2\x14AE\x14B1\x5\x1FE\x100\x2\x14AF\x14B0\a\x3C3");
		sb.Append("\x2\x2\x14B0\x14B2\x5\x208\x105\x2\x14B1\x14AF\x3\x2\x2\x2\x14B1");
		sb.Append("\x14B2\x3\x2\x2\x2\x14B2\x14B4\x3\x2\x2\x2\x14B3\x14AD\x3\x2");
		sb.Append("\x2\x2\x14B3\x14B4\x3\x2\x2\x2\x14B4\x1FD\x3\x2\x2\x2\x14B5");
		sb.Append("\x14BD\a\x3D0\x2\x2\x14B6\x14BD\a\x3D5\x2\x2\x14B7\x14B9\a\x3D2");
		sb.Append("\x2\x2\x14B8\x14B7\x3\x2\x2\x2\x14B9\x14BA\x3\x2\x2\x2\x14BA");
		sb.Append("\x14B8\x3\x2\x2\x2\x14BA\x14BB\x3\x2\x2\x2\x14BB\x14BD\x3\x2");
		sb.Append("\x2\x2\x14BC\x14B5\x3\x2\x2\x2\x14BC\x14B6\x3\x2\x2\x2\x14BC");
		sb.Append("\x14B8\x3\x2\x2\x2\x14BD\x1FF\x3\x2\x2\x2\x14BE\x14C1\x5\x202");
		sb.Append("\x102\x2\x14BF\x14C1\a\x3D0\x2\x2\x14C0\x14BE\x3\x2\x2\x2\x14C0");
		sb.Append("\x14BF\x3\x2\x2\x2\x14C1\x201\x3\x2\x2\x2\x14C2\x14C6\x5\x204");
		sb.Append("\x103\x2\x14C3\x14C6\a\x3D9\x2\x2\x14C4\x14C6\a\x3CD\x2\x2\x14C5");
		sb.Append("\x14C2\x3\x2\x2\x2\x14C5\x14C3\x3\x2\x2\x2\x14C5\x14C4\x3\x2");
		sb.Append("\x2\x2\x14C6\x203\x3\x2\x2\x2\x14C7\x14D1\a\x3D8\x2\x2\x14C8");
		sb.Append("\x14D1\x5\x260\x131\x2\x14C9\x14D1\x5\x262\x132\x2\x14CA\x14D1");
		sb.Append("\x5\x1F8\xFD\x2\x14CB\x14D1\x5\x264\x133\x2\x14CC\x14D1\x5\x266");
		sb.Append("\x134\x2\x14CD\x14D1\x5\x268\x135\x2\x14CE\x14D1\x5\x26A\x136");
		sb.Append("\x2\x14CF\x14D1\x5\x26C\x137\x2\x14D0\x14C7\x3\x2\x2\x2\x14D0");
		sb.Append("\x14C8\x3\x2\x2\x2\x14D0\x14C9\x3\x2\x2\x2\x14D0\x14CA\x3\x2");
		sb.Append("\x2\x2\x14D0\x14CB\x3\x2\x2\x2\x14D0\x14CC\x3\x2\x2\x2\x14D0");
		sb.Append("\x14CD\x3\x2\x2\x2\x14D0\x14CE\x3\x2\x2\x2\x14D0\x14CF\x3\x2");
		sb.Append("\x2\x2\x14D1\x205\x3\x2\x2\x2\x14D2\x14D6\a\x3D7\x2\x2\x14D3");
		sb.Append("\x14D4\a\x3C0\x2\x2\x14D4\x14D6\x5\x202\x102\x2\x14D5\x14D2");
		sb.Append("\x3\x2\x2\x2\x14D5\x14D3\x3\x2\x2\x2\x14D6\x207\x3\x2\x2\x2");
		sb.Append("\x14D7\x14D8\tU\x2\x2\x14D8\x209\x3\x2\x2\x2\x14D9\x14DC\a\x3CE");
		sb.Append("\x2\x2\x14DA\x14DC\x5\x208\x105\x2\x14DB\x14D9\x3\x2\x2\x2\x14DB");
		sb.Append("\x14DA\x3\x2\x2\x2\x14DC\x20B\x3\x2\x2\x2\x14DD\x14DF\a\x3D6");
		sb.Append("\x2\x2\x14DE\x14DD\x3\x2\x2\x2\x14DE\x14DF\x3\x2\x2\x2\x14DF");
		sb.Append("\x14E0\x3\x2\x2\x2\x14E0\x14E3\a\x3D0\x2\x2\x14E1\x14E3\a\x3CF");
		sb.Append("\x2\x2\x14E2\x14DE\x3\x2\x2\x2\x14E2\x14E1\x3\x2\x2\x2\x14E3");
		sb.Append("\x14E5\x3\x2\x2\x2\x14E4\x14E6\a\x3D0\x2\x2\x14E5\x14E4\x3\x2");
		sb.Append("\x2\x2\x14E6\x14E7\x3\x2\x2\x2\x14E7\x14E5\x3\x2\x2\x2\x14E7");
		sb.Append("\x14E8\x3\x2\x2\x2\x14E8\x14F5\x3\x2\x2\x2\x14E9\x14EB\a\x3D6");
		sb.Append("\x2\x2\x14EA\x14E9\x3\x2\x2\x2\x14EA\x14EB\x3\x2\x2\x2\x14EB");
		sb.Append("\x14EC\x3\x2\x2\x2\x14EC\x14EF\a\x3D0\x2\x2\x14ED\x14EF\a\x3CF");
		sb.Append("\x2\x2\x14EE\x14EA\x3\x2\x2\x2\x14EE\x14ED\x3\x2\x2\x2\x14EF");
		sb.Append("\x14F2\x3\x2\x2\x2\x14F0\x14F1\a\x1A\x2\x2\x14F1\x14F3\x5\x1F6");
		sb.Append("\xFC\x2\x14F2\x14F0\x3\x2\x2\x2\x14F2\x14F3\x3\x2\x2\x2\x14F3");
		sb.Append("\x14F5\x3\x2\x2\x2\x14F4\x14E2\x3\x2\x2\x2\x14F4\x14EE\x3\x2");
		sb.Append("\x2\x2\x14F5\x20D\x3\x2\x2\x2\x14F6\x14F7\tV\x2\x2\x14F7\x20F");
		sb.Append("\x3\x2\x2\x2\x14F8\x14FA\a\x3D6\x2\x2\x14F9\x14F8\x3\x2\x2\x2");
		sb.Append("\x14F9\x14FA\x3\x2\x2\x2\x14FA\x14FB\x3\x2\x2\x2\x14FB\x14FC");
		sb.Append("\a\x3D2\x2\x2\x14FC\x211\x3\x2\x2\x2\x14FD\x14FF\a\x65\x2\x2");
		sb.Append("\x14FE\x14FD\x3\x2\x2\x2\x14FE\x14FF\x3\x2\x2\x2\x14FF\x1500");
		sb.Append("\x3\x2\x2\x2\x1500\x1501\tW\x2\x2\x1501\x213\x3\x2\x2\x2\x1502");
		sb.Append("\x150F\x5\x20C\x107\x2\x1503\x150F\x5\x208\x105\x2\x1504\x1505");
		sb.Append("\a\x3B5\x2\x2\x1505\x150F\x5\x208\x105\x2\x1506\x150F\x5\x210");
		sb.Append("\x109\x2\x1507\x150F\x5\x20E\x108\x2\x1508\x150F\a\x3D3\x2\x2");
		sb.Append("\x1509\x150F\a\x3D5\x2\x2\x150A\x150C\a\x65\x2\x2\x150B\x150A");
		sb.Append("\x3\x2\x2\x2\x150B\x150C\x3\x2\x2\x2\x150C\x150D\x3\x2\x2\x2");
		sb.Append("\x150D\x150F\tW\x2\x2\x150E\x1502\x3\x2\x2\x2\x150E\x1503\x3");
		sb.Append("\x2\x2\x2\x150E\x1504\x3\x2\x2\x2\x150E\x1506\x3\x2\x2\x2\x150E");
		sb.Append("\x1507\x3\x2\x2\x2\x150E\x1508\x3\x2\x2\x2\x150E\x1509\x3\x2");
		sb.Append("\x2\x2\x150E\x150B\x3\x2\x2\x2\x150F\x215\x3\x2\x2\x2\x1510");
		sb.Append("\x1512\tX\x2\x2\x1511\x1513\x5\x21C\x10F\x2\x1512\x1511\x3\x2");
		sb.Append("\x2\x2\x1512\x1513\x3\x2\x2\x2\x1513\x1515\x3\x2\x2\x2\x1514");
		sb.Append("\x1516\a\xC3\x2\x2\x1515\x1514\x3\x2\x2\x2\x1515\x1516\x3\x2");
		sb.Append("\x2\x2\x1516\x151D\x3\x2\x2\x2\x1517\x1518\a\x18\x2\x2\x1518");
		sb.Append("\x151B\a\x87\x2\x2\x1519\x151B\a\x2A1\x2\x2\x151A\x1517\x3\x2");
		sb.Append("\x2\x2\x151A\x1519\x3\x2\x2\x2\x151B\x151C\x3\x2\x2\x2\x151C");
		sb.Append("\x151E\x5\x1F4\xFB\x2\x151D\x151A\x3\x2\x2\x2\x151D\x151E\x3");
		sb.Append("\x2\x2\x2\x151E\x1521\x3\x2\x2\x2\x151F\x1520\a\x1A\x2\x2\x1520");
		sb.Append("\x1522\x5\x1F6\xFC\x2\x1521\x151F\x3\x2\x2\x2\x1521\x1522\x3");
		sb.Append("\x2\x2\x2\x1522\x157B\x3\x2\x2\x2\x1523\x1524\a\xC2\x2\x2\x1524");
		sb.Append("\x1526\tY\x2\x2\x1525\x1527\x5\x21C\x10F\x2\x1526\x1525\x3\x2");
		sb.Append("\x2\x2\x1526\x1527\x3\x2\x2\x2\x1527\x1529\x3\x2\x2\x2\x1528");
		sb.Append("\x152A\a\xC3\x2\x2\x1529\x1528\x3\x2\x2\x2\x1529\x152A\x3\x2");
		sb.Append("\x2\x2\x152A\x157B\x3\x2\x2\x2\x152B\x152C\a\x1A4\x2\x2\x152C");
		sb.Append("\x152E\a\xC0\x2\x2\x152D\x152F\x5\x21C\x10F\x2\x152E\x152D\x3");
		sb.Append("\x2\x2\x2\x152E\x152F\x3\x2\x2\x2\x152F\x1531\x3\x2\x2\x2\x1530");
		sb.Append("\x1532\a\xC3\x2\x2\x1531\x1530\x3\x2\x2\x2\x1531\x1532\x3\x2");
		sb.Append("\x2\x2\x1532\x157B\x3\x2\x2\x2\x1533\x1534\a\xC2\x2\x2\x1534");
		sb.Append("\x1535\tZ\x2\x2\x1535\x1537\a\xCE\x2\x2\x1536\x1538\x5\x21C");
		sb.Append("\x10F\x2\x1537\x1536\x3\x2\x2\x2\x1537\x1538\x3\x2\x2\x2\x1538");
		sb.Append("\x153A\x3\x2\x2\x2\x1539\x153B\a\xC3\x2\x2\x153A\x1539\x3\x2");
		sb.Append("\x2\x2\x153A\x153B\x3\x2\x2\x2\x153B\x157B\x3\x2\x2\x2\x153C");
		sb.Append("\x153E\t[\x2\x2\x153D\x153F\x5\x21C\x10F\x2\x153E\x153D\x3\x2");
		sb.Append("\x2\x2\x153E\x153F\x3\x2\x2\x2\x153F\x1541\x3\x2\x2\x2\x1540");
		sb.Append("\x1542\t\\\x2\x2\x1541\x1540\x3\x2\x2\x2\x1541\x1542\x3\x2\x2");
		sb.Append("\x2\x1542\x1544\x3\x2\x2\x2\x1543\x1545\a\xAC\x2\x2\x1544\x1543");
		sb.Append("\x3\x2\x2\x2\x1544\x1545\x3\x2\x2\x2\x1545\x157B\x3\x2\x2\x2");
		sb.Append("\x1546\x1548\a\xB3\x2\x2\x1547\x1549\x5\x21E\x110\x2\x1548\x1547");
		sb.Append("\x3\x2\x2\x2\x1548\x1549\x3\x2\x2\x2\x1549\x154B\x3\x2\x2\x2");
		sb.Append("\x154A\x154C\t\\\x2\x2\x154B\x154A\x3\x2\x2\x2\x154B\x154C\x3");
		sb.Append("\x2\x2\x2\x154C\x154E\x3\x2\x2\x2\x154D\x154F\a\xAC\x2\x2\x154E");
		sb.Append("\x154D\x3\x2\x2\x2\x154E\x154F\x3\x2\x2\x2\x154F\x157B\x3\x2");
		sb.Append("\x2\x2\x1550\x1552\a\xB4\x2\x2\x1551\x1553\a\xB5\x2\x2\x1552");
		sb.Append("\x1551\x3\x2\x2\x2\x1552\x1553\x3\x2\x2\x2\x1553\x1555\x3\x2");
		sb.Append("\x2\x2\x1554\x1556\x5\x21E\x110\x2\x1555\x1554\x3\x2\x2\x2\x1555");
		sb.Append("\x1556\x3\x2\x2\x2\x1556\x1558\x3\x2\x2\x2\x1557\x1559\t\\\x2");
		sb.Append("\x2\x1558\x1557\x3\x2\x2\x2\x1558\x1559\x3\x2\x2\x2\x1559\x155B");
		sb.Append("\x3\x2\x2\x2\x155A\x155C\a\xAC\x2\x2\x155B\x155A\x3\x2\x2\x2");
		sb.Append("\x155B\x155C\x3\x2\x2\x2\x155C\x157B\x3\x2\x2\x2\x155D\x155F");
		sb.Append("\t]\x2\x2\x155E\x1560\x5\x220\x111\x2\x155F\x155E\x3\x2\x2\x2");
		sb.Append("\x155F\x1560\x3\x2\x2\x2\x1560\x1562\x3\x2\x2\x2\x1561\x1563");
		sb.Append("\t\\\x2\x2\x1562\x1561\x3\x2\x2\x2\x1562\x1563\x3\x2\x2\x2\x1563");
		sb.Append("\x1565\x3\x2\x2\x2\x1564\x1566\a\xAC\x2\x2\x1565\x1564\x3\x2");
		sb.Append("\x2\x2\x1565\x1566\x3\x2\x2\x2\x1566\x157B\x3\x2\x2\x2\x1567");
		sb.Append("\x157B\t^\x2\x2\x1568\x156A\t_\x2\x2\x1569\x156B\x5\x21C\x10F");
		sb.Append("\x2\x156A\x1569\x3\x2\x2\x2\x156A\x156B\x3\x2\x2\x2\x156B\x157B");
		sb.Append("\x3\x2\x2\x2\x156C\x156D\t`\x2\x2\x156D\x156F\x5\x218\x10D\x2");
		sb.Append("\x156E\x1570\a\xC3\x2\x2\x156F\x156E\x3\x2\x2\x2\x156F\x1570");
		sb.Append("\x3\x2\x2\x2\x1570\x1577\x3\x2\x2\x2\x1571\x1572\a\x18\x2\x2");
		sb.Append("\x1572\x1575\a\x87\x2\x2\x1573\x1575\a\x2A1\x2\x2\x1574\x1571");
		sb.Append("\x3\x2\x2\x2\x1574\x1573\x3\x2\x2\x2\x1575\x1576\x3\x2\x2\x2");
		sb.Append("\x1576\x1578\x5\x1F4\xFB\x2\x1577\x1574\x3\x2\x2\x2\x1577\x1578");
		sb.Append("\x3\x2\x2\x2\x1578\x157B\x3\x2\x2\x2\x1579\x157B\t\x61\x2\x2");
		sb.Append("\x157A\x1510\x3\x2\x2\x2\x157A\x1523\x3\x2\x2\x2\x157A\x152B");
		sb.Append("\x3\x2\x2\x2\x157A\x1533\x3\x2\x2\x2\x157A\x153C\x3\x2\x2\x2");
		sb.Append("\x157A\x1546\x3\x2\x2\x2\x157A\x1550\x3\x2\x2\x2\x157A\x155D");
		sb.Append("\x3\x2\x2\x2\x157A\x1567\x3\x2\x2\x2\x157A\x1568\x3\x2\x2\x2");
		sb.Append("\x157A\x156C\x3\x2\x2\x2\x157A\x1579\x3\x2\x2\x2\x157B\x217");
		sb.Append("\x3\x2\x2\x2\x157C\x157D\a\x3C1\x2\x2\x157D\x1582\a\x3D0\x2");
		sb.Append("\x2\x157E\x157F\a\x3C3\x2\x2\x157F\x1581\a\x3D0\x2\x2\x1580");
		sb.Append("\x157E\x3\x2\x2\x2\x1581\x1584\x3\x2\x2\x2\x1582\x1580\x3\x2");
		sb.Append("\x2\x2\x1582\x1583\x3\x2\x2\x2\x1583\x1585\x3\x2\x2\x2\x1584");
		sb.Append("\x1582\x3\x2\x2\x2\x1585\x1586\a\x3C2\x2\x2\x1586\x219\x3\x2");
		sb.Append("\x2\x2\x1587\x1589\t\x62\x2\x2\x1588\x158A\x5\x21C\x10F\x2\x1589");
		sb.Append("\x1588\x3\x2\x2\x2\x1589\x158A\x3\x2\x2\x2\x158A\x15A1\x3\x2");
		sb.Append("\x2\x2\x158B\x158D\a\xBF\x2\x2\x158C\x158E\x5\x21C\x10F\x2\x158D");
		sb.Append("\x158C\x3\x2\x2\x2\x158D\x158E\x3\x2\x2\x2\x158E\x1595\x3\x2");
		sb.Append("\x2\x2\x158F\x1590\a\x18\x2\x2\x1590\x1593\a\x87\x2\x2\x1591");
		sb.Append("\x1593\a\x2A1\x2\x2\x1592\x158F\x3\x2\x2\x2\x1592\x1591\x3\x2");
		sb.Append("\x2\x2\x1593\x1594\x3\x2\x2\x2\x1594\x1596\x5\x1F4\xFB\x2\x1595");
		sb.Append("\x1592\x3\x2\x2\x2\x1595\x1596\x3\x2\x2\x2\x1596\x15A1\x3\x2");
		sb.Append("\x2\x2\x1597\x15A1\t\x63\x2\x2\x1598\x159A\a\xB7\x2\x2\x1599");
		sb.Append("\x159B\x5\x21E\x110\x2\x159A\x1599\x3\x2\x2\x2\x159A\x159B\x3");
		sb.Append("\x2\x2\x2\x159B\x15A1\x3\x2\x2\x2\x159C\x159E\t\\\x2\x2\x159D");
		sb.Append("\x159F\a\xB1\x2\x2\x159E\x159D\x3\x2\x2\x2\x159E\x159F\x3\x2");
		sb.Append("\x2\x2\x159F\x15A1\x3\x2\x2\x2\x15A0\x1587\x3\x2\x2\x2\x15A0");
		sb.Append("\x158B\x3\x2\x2\x2\x15A0\x1597\x3\x2\x2\x2\x15A0\x1598\x3\x2");
		sb.Append("\x2\x2\x15A0\x159C\x3\x2\x2\x2\x15A1\x21B\x3\x2\x2\x2\x15A2");
		sb.Append("\x15A3\a\x3C1\x2\x2\x15A3\x15A4\x5\x208\x105\x2\x15A4\x15A5");
		sb.Append("\a\x3C2\x2\x2\x15A5\x21D\x3\x2\x2\x2\x15A6\x15A7\a\x3C1\x2\x2");
		sb.Append("\x15A7\x15A8\x5\x208\x105\x2\x15A8\x15A9\a\x3C3\x2\x2\x15A9");
		sb.Append("\x15AA\x5\x208\x105\x2\x15AA\x15AB\a\x3C2\x2\x2\x15AB\x21F\x3");
		sb.Append("\x2\x2\x2\x15AC\x15AD\a\x3C1\x2\x2\x15AD\x15B0\x5\x208\x105");
		sb.Append("\x2\x15AE\x15AF\a\x3C3\x2\x2\x15AF\x15B1\x5\x208\x105\x2\x15B0");
		sb.Append("\x15AE\x3\x2\x2\x2\x15B0\x15B1\x3\x2\x2\x2\x15B1\x15B2\x3\x2");
		sb.Append("\x2\x2\x15B2\x15B3\a\x3C2\x2\x2\x15B3\x221\x3\x2\x2\x2\x15B4");
		sb.Append("\x15B9\x5\x202\x102\x2\x15B5\x15B6\a\x3C3\x2\x2\x15B6\x15B8");
		sb.Append("\x5\x202\x102\x2\x15B7\x15B5\x3\x2\x2\x2\x15B8\x15BB\x3\x2\x2");
		sb.Append("\x2\x15B9\x15B7\x3\x2\x2\x2\x15B9\x15BA\x3\x2\x2\x2\x15BA\x223");
		sb.Append("\x3\x2\x2\x2\x15BB\x15B9\x3\x2\x2\x2\x15BC\x15C1\x5\x1EA\xF6");
		sb.Append("\x2\x15BD\x15BE\a\x3C3\x2\x2\x15BE\x15C0\x5\x1EA\xF6\x2\x15BF");
		sb.Append("\x15BD\x3\x2\x2\x2\x15C0\x15C3\x3\x2\x2\x2\x15C1\x15BF\x3\x2");
		sb.Append("\x2\x2\x15C1\x15C2\x3\x2\x2\x2\x15C2\x225\x3\x2\x2\x2\x15C3");
		sb.Append("\x15C1\x3\x2\x2\x2\x15C4\x15C5\a\x3C1\x2\x2\x15C5\x15CA\x5\x1EE");
		sb.Append("\xF8\x2\x15C6\x15C7\a\x3C3\x2\x2\x15C7\x15C9\x5\x1EE\xF8\x2");
		sb.Append("\x15C8\x15C6\x3\x2\x2\x2\x15C9\x15CC\x3\x2\x2\x2\x15CA\x15C8");
		sb.Append("\x3\x2\x2\x2\x15CA\x15CB\x3\x2\x2\x2\x15CB\x15CD\x3\x2\x2\x2");
		sb.Append("\x15CC\x15CA\x3\x2\x2\x2\x15CD\x15CE\a\x3C2\x2\x2\x15CE\x227");
		sb.Append("\x3\x2\x2\x2\x15CF\x15D4\x5\x250\x129\x2\x15D0\x15D1\a\x3C3");
		sb.Append("\x2\x2\x15D1\x15D3\x5\x250\x129\x2\x15D2\x15D0\x3\x2\x2\x2\x15D3");
		sb.Append("\x15D6\x3\x2\x2\x2\x15D4\x15D2\x3\x2\x2\x2\x15D4\x15D5\x3\x2");
		sb.Append("\x2\x2\x15D5\x229\x3\x2\x2\x2\x15D6\x15D4\x3\x2\x2\x2\x15D7");
		sb.Append("\x15DC\x5\x236\x11C\x2\x15D8\x15D9\a\x3C3\x2\x2\x15D9\x15DB");
		sb.Append("\x5\x236\x11C\x2\x15DA\x15D8\x3\x2\x2\x2\x15DB\x15DE\x3\x2\x2");
		sb.Append("\x2\x15DC\x15DA\x3\x2\x2\x2\x15DC\x15DD\x3\x2\x2\x2\x15DD\x22B");
		sb.Append("\x3\x2\x2\x2\x15DE\x15DC\x3\x2\x2\x2\x15DF\x15E4\x5\x214\x10B");
		sb.Append("\x2\x15E0\x15E1\a\x3C3\x2\x2\x15E1\x15E3\x5\x214\x10B\x2\x15E2");
		sb.Append("\x15E0\x3\x2\x2\x2\x15E3\x15E6\x3\x2\x2\x2\x15E4\x15E2\x3\x2");
		sb.Append("\x2\x2\x15E4\x15E5\x3\x2\x2\x2\x15E5\x22D\x3\x2\x2\x2\x15E6");
		sb.Append("\x15E4\x3\x2\x2\x2\x15E7\x15EC\a\x3D0\x2\x2\x15E8\x15E9\a\x3C3");
		sb.Append("\x2\x2\x15E9\x15EB\a\x3D0\x2\x2\x15EA\x15E8\x3\x2\x2\x2\x15EB");
		sb.Append("\x15EE\x3\x2\x2\x2\x15EC\x15EA\x3\x2\x2\x2\x15EC\x15ED\x3\x2");
		sb.Append("\x2\x2\x15ED\x22F\x3\x2\x2\x2\x15EE\x15EC\x3\x2\x2\x2\x15EF");
		sb.Append("\x15F4\a\x3DB\x2\x2\x15F0\x15F1\a\x3C3\x2\x2\x15F1\x15F3\a\x3DB");
		sb.Append("\x2\x2\x15F2\x15F0\x3\x2\x2\x2\x15F3\x15F6\x3\x2\x2\x2\x15F4");
		sb.Append("\x15F2\x3\x2\x2\x2\x15F4\x15F5\x3\x2\x2\x2\x15F5\x231\x3\x2");
		sb.Append("\x2\x2\x15F6\x15F4\x3\x2\x2\x2\x15F7\x1603\ag\x2\x2\x15F8\x15FA");
		sb.Append("\x5\x256\x12C\x2\x15F9\x15F8\x3\x2\x2\x2\x15F9\x15FA\x3\x2\x2");
		sb.Append("\x2\x15FA\x15FB\x3\x2\x2\x2\x15FB\x1603\x5\x214\x10B\x2\x15FC");
		sb.Append("\x1600\x5\x234\x11B\x2\x15FD\x15FE\ah\x2\x2\x15FE\x15FF\a\xA1");
		sb.Append("\x2\x2\x15FF\x1601\x5\x234\x11B\x2\x1600\x15FD\x3\x2\x2\x2\x1600");
		sb.Append("\x1601\x3\x2\x2\x2\x1601\x1603\x3\x2\x2\x2\x1602\x15F7\x3\x2");
		sb.Append("\x2\x2\x1602\x15F9\x3\x2\x2\x2\x1602\x15FC\x3\x2\x2\x2\x1603");
		sb.Append("\x233\x3\x2\x2\x2\x1604\x160A\t\x64\x2\x2\x1605\x1607\a\x3C1");
		sb.Append("\x2\x2\x1606\x1608\x5\x208\x105\x2\x1607\x1606\x3\x2\x2\x2\x1607");
		sb.Append("\x1608\x3\x2\x2\x2\x1608\x1609\x3\x2\x2\x2\x1609\x160B\a\x3C2");
		sb.Append("\x2\x2\x160A\x1605\x3\x2\x2\x2\x160A\x160B\x3\x2\x2\x2\x160B");
		sb.Append("\x1613\x3\x2\x2\x2\x160C\x160D\a\xF5\x2\x2\x160D\x160F\a\x3C1");
		sb.Append("\x2\x2\x160E\x1610\x5\x208\x105\x2\x160F\x160E\x3\x2\x2\x2\x160F");
		sb.Append("\x1610\x3\x2\x2\x2\x1610\x1611\x3\x2\x2\x2\x1611\x1613\a\x3C2");
		sb.Append("\x2\x2\x1612\x1604\x3\x2\x2\x2\x1612\x160C\x3\x2\x2\x2\x1613");
		sb.Append("\x235\x3\x2\x2\x2\x1614\x1617\x5\x250\x129\x2\x1615\x1617\a");
		sb.Append("\'\x2\x2\x1616\x1614\x3\x2\x2\x2\x1616\x1615\x3\x2\x2\x2\x1617");
		sb.Append("\x237\x3\x2\x2\x2\x1618\x1619\a\x44\x2\x2\x1619\x161A\a\x35");
		sb.Append("\x2\x2\x161A\x239\x3\x2\x2\x2\x161B\x161C\a\x44\x2\x2\x161C");
		sb.Append("\x161D\a\x65\x2\x2\x161D\x161E\a\x35\x2\x2\x161E\x23B\x3\x2");
		sb.Append("\x2\x2\x161F\x1631\x5\x23E\x120\x2\x1620\x1631\x5\x246\x124");
		sb.Append("\x2\x1621\x1622\x5\x248\x125\x2\x1622\x1624\a\x3C1\x2\x2\x1623");
		sb.Append("\x1625\x5\x24C\x127\x2\x1624\x1623\x3\x2\x2\x2\x1624\x1625\x3");
		sb.Append("\x2\x2\x2\x1625\x1626\x3\x2\x2\x2\x1626\x1627\a\x3C2\x2\x2\x1627");
		sb.Append("\x1631\x3\x2\x2\x2\x1628\x1629\x5\x1E8\xF5\x2\x1629\x162B\a");
		sb.Append("\x3C1\x2\x2\x162A\x162C\x5\x24C\x127\x2\x162B\x162A\x3\x2\x2");
		sb.Append("\x2\x162B\x162C\x3\x2\x2\x2\x162C\x162D\x3\x2\x2\x2\x162D\x162E");
		sb.Append("\a\x3C2\x2\x2\x162E\x1631\x3\x2\x2\x2\x162F\x1631\x5\x24A\x126");
		sb.Append("\x2\x1630\x161F\x3\x2\x2\x2\x1630\x1620\x3\x2\x2\x2\x1630\x1621");
		sb.Append("\x3\x2\x2\x2\x1630\x1628\x3\x2\x2\x2\x1630\x162F\x3\x2\x2\x2");
		sb.Append("\x1631\x23D\x3\x2\x2\x2\x1632\x16D0\t\x65\x2\x2\x1633\x1634");
		sb.Append("\a\x1F\x2\x2\x1634\x1635\a\x3C1\x2\x2\x1635\x1636\x5\x250\x129");
		sb.Append("\x2\x1636\x1637\a\x3C3\x2\x2\x1637\x1638\x5\x21A\x10E\x2\x1638");
		sb.Append("\x1639\a\x3C2\x2\x2\x1639\x16D0\x3\x2\x2\x2\x163A\x163B\a\x1F");
		sb.Append("\x2\x2\x163B\x163C\a\x3C1\x2\x2\x163C\x163D\x5\x250\x129\x2");
		sb.Append("\x163D\x163E\a\xA4\x2\x2\x163E\x163F\x5\x1F4\xFB\x2\x163F\x1640");
		sb.Append("\a\x3C2\x2\x2\x1640\x16D0\x3\x2\x2\x2\x1641\x1642\a\x16\x2\x2");
		sb.Append("\x1642\x1643\a\x3C1\x2\x2\x1643\x1644\x5\x250\x129\x2\x1644");
		sb.Append("\x1645\a\r\x2\x2\x1645\x1646\x5\x21A\x10E\x2\x1646\x1647\a\x3C2");
		sb.Append("\x2\x2\x1647\x16D0\x3\x2\x2\x2\x1648\x1649\a\xA5\x2\x2\x1649");
		sb.Append("\x164A\a\x3C1\x2\x2\x164A\x164B\x5\x1EC\xF7\x2\x164B\x164C\a");
		sb.Append("\x3C2\x2\x2\x164C\x16D0\x3\x2\x2\x2\x164D\x164E\a\x15\x2\x2");
		sb.Append("\x164E\x1650\x5\x250\x129\x2\x164F\x1651\x5\x240\x121\x2\x1650");
		sb.Append("\x164F\x3\x2\x2\x2\x1651\x1652\x3\x2\x2\x2\x1652\x1650\x3\x2");
		sb.Append("\x2\x2\x1652\x1653\x3\x2\x2\x2\x1653\x1656\x3\x2\x2\x2\x1654");
		sb.Append("\x1655\a\x31\x2\x2\x1655\x1657\x5\x24E\x128\x2\x1656\x1654\x3");
		sb.Append("\x2\x2\x2\x1656\x1657\x3\x2\x2\x2\x1657\x1658\x3\x2\x2\x2\x1658");
		sb.Append("\x1659\a\x13E\x2\x2\x1659\x16D0\x3\x2\x2\x2\x165A\x165C\a\x15");
		sb.Append("\x2\x2\x165B\x165D\x5\x240\x121\x2\x165C\x165B\x3\x2\x2\x2\x165D");
		sb.Append("\x165E\x3\x2\x2\x2\x165E\x165C\x3\x2\x2\x2\x165E\x165F\x3\x2");
		sb.Append("\x2\x2\x165F\x1662\x3\x2\x2\x2\x1660\x1661\a\x31\x2\x2\x1661");
		sb.Append("\x1663\x5\x24E\x128\x2\x1662\x1660\x3\x2\x2\x2\x1662\x1663\x3");
		sb.Append("\x2\x2\x2\x1663\x1664\x3\x2\x2\x2\x1664\x1665\a\x13E\x2\x2\x1665");
		sb.Append("\x16D0\x3\x2\x2\x2\x1666\x1667\a\xBF\x2\x2\x1667\x1668\a\x3C1");
		sb.Append("\x2\x2\x1668\x166B\x5\x24C\x127\x2\x1669\x166A\a\xA4\x2\x2\x166A");
		sb.Append("\x166C\x5\x1F4\xFB\x2\x166B\x1669\x3\x2\x2\x2\x166B\x166C\x3");
		sb.Append("\x2\x2\x2\x166C\x166D\x3\x2\x2\x2\x166D\x166E\a\x3C2\x2\x2\x166E");
		sb.Append("\x16D0\x3\x2\x2\x2\x166F\x1670\a\xF6\x2\x2\x1670\x1673\a\x3C1");
		sb.Append("\x2\x2\x1671\x1674\x5\x20C\x107\x2\x1672\x1674\x5\x250\x129");
		sb.Append("\x2\x1673\x1671\x3\x2\x2\x2\x1673\x1672\x3\x2\x2\x2\x1674\x1675");
		sb.Append("\x3\x2\x2\x2\x1675\x1678\a\x46\x2\x2\x1676\x1679\x5\x20C\x107");
		sb.Append("\x2\x1677\x1679\x5\x250\x129\x2\x1678\x1676\x3\x2\x2\x2\x1678");
		sb.Append("\x1677\x3\x2\x2\x2\x1679\x167A\x3\x2\x2\x2\x167A\x167B\a\x3C2");
		sb.Append("\x2\x2\x167B\x16D0\x3\x2\x2\x2\x167C\x167D\t\x66\x2\x2\x167D");
		sb.Append("\x1680\a\x3C1\x2\x2\x167E\x1681\x5\x20C\x107\x2\x167F\x1681");
		sb.Append("\x5\x250\x129\x2\x1680\x167E\x3\x2\x2\x2\x1680\x167F\x3\x2\x2");
		sb.Append("\x2\x1681\x1682\x3\x2\x2\x2\x1682\x1685\a=\x2\x2\x1683\x1686");
		sb.Append("\x5\x208\x105\x2\x1684\x1686\x5\x250\x129\x2\x1685\x1683\x3");
		sb.Append("\x2\x2\x2\x1685\x1684\x3\x2\x2\x2\x1686\x168C\x3\x2\x2\x2\x1687");
		sb.Append("\x168A\a:\x2\x2\x1688\x168B\x5\x208\x105\x2\x1689\x168B\x5\x250");
		sb.Append("\x129\x2\x168A\x1688\x3\x2\x2\x2\x168A\x1689\x3\x2\x2\x2\x168B");
		sb.Append("\x168D\x3\x2\x2\x2\x168C\x1687\x3\x2\x2\x2\x168C\x168D\x3\x2");
		sb.Append("\x2\x2\x168D\x168E\x3\x2\x2\x2\x168E\x168F\a\x3C2\x2\x2\x168F");
		sb.Append("\x16D0\x3\x2\x2\x2\x1690\x1691\a\xFA\x2\x2\x1691\x1692\a\x3C1");
		sb.Append("\x2\x2\x1692\x1695\tg\x2\x2\x1693\x1696\x5\x20C\x107\x2\x1694");
		sb.Append("\x1696\x5\x250\x129\x2\x1695\x1693\x3\x2\x2\x2\x1695\x1694\x3");
		sb.Append("\x2\x2\x2\x1695\x1696\x3\x2\x2\x2\x1696\x1697\x3\x2\x2\x2\x1697");
		sb.Append("\x169A\a=\x2\x2\x1698\x169B\x5\x20C\x107\x2\x1699\x169B\x5\x250");
		sb.Append("\x129\x2\x169A\x1698\x3\x2\x2\x2\x169A\x1699\x3\x2\x2\x2\x169B");
		sb.Append("\x169C\x3\x2\x2\x2\x169C\x169D\a\x3C2\x2\x2\x169D\x16D0\x3\x2");
		sb.Append("\x2\x2\x169E\x169F\a\xFA\x2\x2\x169F\x16A2\a\x3C1\x2\x2\x16A0");
		sb.Append("\x16A3\x5\x20C\x107\x2\x16A1\x16A3\x5\x250\x129\x2\x16A2\x16A0");
		sb.Append("\x3\x2\x2\x2\x16A2\x16A1\x3\x2\x2\x2\x16A3\x16A4\x3\x2\x2\x2");
		sb.Append("\x16A4\x16A7\a=\x2\x2\x16A5\x16A8\x5\x20C\x107\x2\x16A6\x16A8");
		sb.Append("\x5\x250\x129\x2\x16A7\x16A5\x3\x2\x2\x2\x16A7\x16A6\x3\x2\x2");
		sb.Append("\x2\x16A8\x16A9\x3\x2\x2\x2\x16A9\x16AA\a\x3C2\x2\x2\x16AA\x16D0");
		sb.Append("\x3\x2\x2\x2\x16AB\x16AC\a\x3A2\x2\x2\x16AC\x16AF\a\x3C1\x2");
		sb.Append("\x2\x16AD\x16B0\x5\x20C\x107\x2\x16AE\x16B0\x5\x250\x129\x2");
		sb.Append("\x16AF\x16AD\x3\x2\x2\x2\x16AF\x16AE\x3\x2\x2\x2\x16B0\x16B7");
		sb.Append("\x3\x2\x2\x2\x16B1\x16B2\a\r\x2\x2\x16B2\x16B3\th\x2\x2\x16B3");
		sb.Append("\x16B4\a\x3C1\x2\x2\x16B4\x16B5\x5\x208\x105\x2\x16B5\x16B6");
		sb.Append("\a\x3C2\x2\x2\x16B6\x16B8\x3\x2\x2\x2\x16B7\x16B1\x3\x2\x2\x2");
		sb.Append("\x16B7\x16B8\x3\x2\x2\x2\x16B8\x16BA\x3\x2\x2\x2\x16B9\x16BB");
		sb.Append("\x5\x242\x122\x2\x16BA\x16B9\x3\x2\x2\x2\x16BA\x16BB\x3\x2\x2");
		sb.Append("\x2\x16BB\x16BC\x3\x2\x2\x2\x16BC\x16BD\a\x3C2\x2\x2\x16BD\x16D0");
		sb.Append("\x3\x2\x2\x2\x16BE\x16BF\a\xF3\x2\x2\x16BF\x16C0\a\x3C1\x2\x2");
		sb.Append("\x16C0\x16C1\x5<\x1F\x2\x16C1\x16C4\a=\x2\x2\x16C2\x16C5\x5");
		sb.Append("\x20C\x107\x2\x16C3\x16C5\x5\x250\x129\x2\x16C4\x16C2\x3\x2");
		sb.Append("\x2\x2\x16C4\x16C3\x3\x2\x2\x2\x16C5\x16C6\x3\x2\x2\x2\x16C6");
		sb.Append("\x16C7\a\x3C2\x2\x2\x16C7\x16D0\x3\x2\x2\x2\x16C8\x16C9\a\x2DB");
		sb.Append("\x2\x2\x16C9\x16CA\a\x3C1\x2\x2\x16CA\x16CB\t\x63\x2\x2\x16CB");
		sb.Append("\x16CC\a\x3C3\x2\x2\x16CC\x16CD\x5\x20C\x107\x2\x16CD\x16CE");
		sb.Append("\a\x3C2\x2\x2\x16CE\x16D0\x3\x2\x2\x2\x16CF\x1632\x3\x2\x2\x2");
		sb.Append("\x16CF\x1633\x3\x2\x2\x2\x16CF\x163A\x3\x2\x2\x2\x16CF\x1641");
		sb.Append("\x3\x2\x2\x2\x16CF\x1648\x3\x2\x2\x2\x16CF\x164D\x3\x2\x2\x2");
		sb.Append("\x16CF\x165A\x3\x2\x2\x2\x16CF\x1666\x3\x2\x2\x2\x16CF\x166F");
		sb.Append("\x3\x2\x2\x2\x16CF\x167C\x3\x2\x2\x2\x16CF\x1690\x3\x2\x2\x2");
		sb.Append("\x16CF\x169E\x3\x2\x2\x2\x16CF\x16AB\x3\x2\x2\x2\x16CF\x16BE");
		sb.Append("\x3\x2\x2\x2\x16CF\x16C8\x3\x2\x2\x2\x16D0\x23F\x3\x2\x2\x2");
		sb.Append("\x16D1\x16D2\a\xA6\x2\x2\x16D2\x16D3\x5\x24E\x128\x2\x16D3\x16D4");
		sb.Append("\a\x97\x2\x2\x16D4\x16D5\x5\x24E\x128\x2\x16D5\x241\x3\x2\x2");
		sb.Append("\x2\x16D6\x16D7\a\x179\x2\x2\x16D7\x16DC\x5\x244\x123\x2\x16D8");
		sb.Append("\x16D9\a\x3C3\x2\x2\x16D9\x16DB\x5\x244\x123\x2\x16DA\x16D8");
		sb.Append("\x3\x2\x2\x2\x16DB\x16DE\x3\x2\x2\x2\x16DC\x16DA\x3\x2\x2\x2");
		sb.Append("\x16DC\x16DD\x3\x2\x2\x2\x16DD\x16E5\x3\x2\x2\x2\x16DE\x16DC");
		sb.Append("\x3\x2\x2\x2\x16DF\x16E0\a\x179\x2\x2\x16E0\x16E1\x5\x208\x105");
		sb.Append("\x2\x16E1\x16E2\a\x3B5\x2\x2\x16E2\x16E3\x5\x208\x105\x2\x16E3");
		sb.Append("\x16E5\x3\x2\x2\x2\x16E4\x16D6\x3\x2\x2\x2\x16E4\x16DF\x3\x2");
		sb.Append("\x2\x2\x16E5\x243\x3\x2\x2\x2\x16E6\x16E8\x5\x208\x105\x2\x16E7");
		sb.Append("\x16E9\ti\x2\x2\x16E8\x16E7\x3\x2\x2\x2\x16E8\x16E9\x3\x2\x2");
		sb.Append("\x2\x16E9\x245\x3\x2\x2\x2\x16EA\x16EB\tj\x2\x2\x16EB\x16ED");
		sb.Append("\a\x3C1\x2\x2\x16EC\x16EE\t\'\x2\x2\x16ED\x16EC\x3\x2\x2\x2");
		sb.Append("\x16ED\x16EE\x3\x2\x2\x2\x16EE\x16EF\x3\x2\x2\x2\x16EF\x16F0");
		sb.Append("\x5\x24E\x128\x2\x16F0\x16F1\a\x3C2\x2\x2\x16F1\x1723\x3\x2");
		sb.Append("\x2\x2\x16F2\x16F3\a\xDF\x2\x2\x16F3\x16F9\a\x3C1\x2\x2\x16F4");
		sb.Append("\x16FA\a\x3B0\x2\x2\x16F5\x16F7\a\b\x2\x2\x16F6\x16F5\x3\x2");
		sb.Append("\x2\x2\x16F6\x16F7\x3\x2\x2\x2\x16F7\x16F8\x3\x2\x2\x2\x16F8");
		sb.Append("\x16FA\x5\x24E\x128\x2\x16F9\x16F4\x3\x2\x2\x2\x16F9\x16F6\x3");
		sb.Append("\x2\x2\x2\x16FA\x16FB\x3\x2\x2\x2\x16FB\x1723\a\x3C2\x2\x2\x16FC");
		sb.Append("\x16FD\a\xDF\x2\x2\x16FD\x16FE\a\x3C1\x2\x2\x16FE\x16FF\a-\x2");
		sb.Append("\x2\x16FF\x1700\x5\x24C\x127\x2\x1700\x1701\a\x3C2\x2\x2\x1701");
		sb.Append("\x1723\x3\x2\x2\x2\x1702\x1703\tk\x2\x2\x1703\x1705\a\x3C1\x2");
		sb.Append("\x2\x1704\x1706\a\b\x2\x2\x1705\x1704\x3\x2\x2\x2\x1705\x1706");
		sb.Append("\x3\x2\x2\x2\x1706\x1707\x3\x2\x2\x2\x1707\x1708\x5\x24E\x128");
		sb.Append("\x2\x1708\x1709\a\x3C2\x2\x2\x1709\x1723\x3\x2\x2\x2\x170A\x170B");
		sb.Append("\a\xE0\x2\x2\x170B\x170D\a\x3C1\x2\x2\x170C\x170E\a-\x2\x2\x170D");
		sb.Append("\x170C\x3\x2\x2\x2\x170D\x170E\x3\x2\x2\x2\x170E\x170F\x3\x2");
		sb.Append("\x2\x2\x170F\x171A\x5\x24C\x127\x2\x1710\x1711\am\x2\x2\x1711");
		sb.Append("\x1712\a\x12\x2\x2\x1712\x1717\x5\xD2j\x2\x1713\x1714\a\x3C3");
		sb.Append("\x2\x2\x1714\x1716\x5\xD2j\x2\x1715\x1713\x3\x2\x2\x2\x1716");
		sb.Append("\x1719\x3\x2\x2\x2\x1717\x1715\x3\x2\x2\x2\x1717\x1718\x3\x2");
		sb.Append("\x2\x2\x1718\x171B\x3\x2\x2\x2\x1719\x1717\x3\x2\x2\x2\x171A");
		sb.Append("\x1710\x3\x2\x2\x2\x171A\x171B\x3\x2\x2\x2\x171B\x171E\x3\x2");
		sb.Append("\x2\x2\x171C\x171D\a\x88\x2\x2\x171D\x171F\a\x3D0\x2\x2\x171E");
		sb.Append("\x171C\x3\x2\x2\x2\x171E\x171F\x3\x2\x2\x2\x171F\x1720\x3\x2");
		sb.Append("\x2\x2\x1720\x1721\a\x3C2\x2\x2\x1721\x1723\x3\x2\x2\x2\x1722");
		sb.Append("\x16EA\x3\x2\x2\x2\x1722\x16F2\x3\x2\x2\x2\x1722\x16FC\x3\x2");
		sb.Append("\x2\x2\x1722\x1702\x3\x2\x2\x2\x1722\x170A\x3\x2\x2\x2\x1723");
		sb.Append("\x247\x3\x2\x2\x2\x1724\x173C\x5\x26C\x137\x2\x1725\x173C\a");
		sb.Append("\x245\x2\x2\x1726\x173C\a\xEF\x2\x2\x1727\x173C\a\xEB\x2\x2");
		sb.Append("\x1728\x173C\a\xEC\x2\x2\x1729\x173C\a\xED\x2\x2\x172A\x173C");
		sb.Append("\a\xF0\x2\x2\x172B\x173C\a\xF1\x2\x2\x172C\x173C\a\xF2\x2\x2");
		sb.Append("\x172D\x173C\a\x44\x2\x2\x172E\x173C\aK\x2\x2\x172F\x173C\a");
		sb.Append("\xEE\x2\x2\x1730\x173C\a\xF4\x2\x2\x1731\x173C\a\x19B\x2\x2");
		sb.Append("\x1732\x173C\a\xF5\x2\x2\x1733\x173C\a}\x2\x2\x1734\x173C\a");
		sb.Append("\xF7\x2\x2\x1735\x173C\a\xF8\x2\x2\x1736\x173C\a\xF9\x2\x2\x1737");
		sb.Append("\x173C\a\xFA\x2\x2\x1738\x173C\a\xFB\x2\x2\x1739\x173C\a\xFC");
		sb.Append("\x2\x2\x173A\x173C\a\xFD\x2\x2\x173B\x1724\x3\x2\x2\x2\x173B");
		sb.Append("\x1725\x3\x2\x2\x2\x173B\x1726\x3\x2\x2\x2\x173B\x1727\x3\x2");
		sb.Append("\x2\x2\x173B\x1728\x3\x2\x2\x2\x173B\x1729\x3\x2\x2\x2\x173B");
		sb.Append("\x172A\x3\x2\x2\x2\x173B\x172B\x3\x2\x2\x2\x173B\x172C\x3\x2");
		sb.Append("\x2\x2\x173B\x172D\x3\x2\x2\x2\x173B\x172E\x3\x2\x2\x2\x173B");
		sb.Append("\x172F\x3\x2\x2\x2\x173B\x1730\x3\x2\x2\x2\x173B\x1731\x3\x2");
		sb.Append("\x2\x2\x173B\x1732\x3\x2\x2\x2\x173B\x1733\x3\x2\x2\x2\x173B");
		sb.Append("\x1734\x3\x2\x2\x2\x173B\x1735\x3\x2\x2\x2\x173B\x1736\x3\x2");
		sb.Append("\x2\x2\x173B\x1737\x3\x2\x2\x2\x173B\x1738\x3\x2\x2\x2\x173B");
		sb.Append("\x1739\x3\x2\x2\x2\x173B\x173A\x3\x2\x2\x2\x173C\x249\x3\x2");
		sb.Append("\x2\x2\x173D\x173E\tl\x2\x2\x173E\x173F\a\x3C1\x2\x2\x173F\x1740");
		sb.Append("\x5\x24E\x128\x2\x1740\x1741\a\x3C2\x2\x2\x1741\x24B\x3\x2\x2");
		sb.Append("\x2\x1742\x1747\x5\x214\x10B\x2\x1743\x1747\x5\x1EC\xF7\x2\x1744");
		sb.Append("\x1747\x5\x23C\x11F\x2\x1745\x1747\x5\x250\x129\x2\x1746\x1742");
		sb.Append("\x3\x2\x2\x2\x1746\x1743\x3\x2\x2\x2\x1746\x1744\x3\x2\x2\x2");
		sb.Append("\x1746\x1745\x3\x2\x2\x2\x1747\x1751\x3\x2\x2\x2\x1748\x174D");
		sb.Append("\a\x3C3\x2\x2\x1749\x174E\x5\x214\x10B\x2\x174A\x174E\x5\x1EC");
		sb.Append("\xF7\x2\x174B\x174E\x5\x23C\x11F\x2\x174C\x174E\x5\x250\x129");
		sb.Append("\x2\x174D\x1749\x3\x2\x2\x2\x174D\x174A\x3\x2\x2\x2\x174D\x174B");
		sb.Append("\x3\x2\x2\x2\x174D\x174C\x3\x2\x2\x2\x174E\x1750\x3\x2\x2\x2");
		sb.Append("\x174F\x1748\x3\x2\x2\x2\x1750\x1753\x3\x2\x2\x2\x1751\x174F");
		sb.Append("\x3\x2\x2\x2\x1751\x1752\x3\x2\x2\x2\x1752\x24D\x3\x2\x2\x2");
		sb.Append("\x1753\x1751\x3\x2\x2\x2\x1754\x1759\x5\x214\x10B\x2\x1755\x1759");
		sb.Append("\x5\x1EC\xF7\x2\x1756\x1759\x5\x23C\x11F\x2\x1757\x1759\x5\x250");
		sb.Append("\x129\x2\x1758\x1754\x3\x2\x2\x2\x1758\x1755\x3\x2\x2\x2\x1758");
		sb.Append("\x1756\x3\x2\x2\x2\x1758\x1757\x3\x2\x2\x2\x1759\x24F\x3\x2");
		sb.Append("\x2\x2\x175A\x175B\b\x129\x1\x2\x175B\x175C\tm\x2\x2\x175C\x1766");
		sb.Append("\x5\x250\x129\x6\x175D\x175E\x5\x252\x12A\x2\x175E\x1760\aN");
		sb.Append("\x2\x2\x175F\x1761\a\x65\x2\x2\x1760\x175F\x3\x2\x2\x2\x1760");
		sb.Append("\x1761\x3\x2\x2\x2\x1761\x1762\x3\x2\x2\x2\x1762\x1763\tn\x2");
		sb.Append("\x2\x1763\x1766\x3\x2\x2\x2\x1764\x1766\x5\x252\x12A\x2\x1765");
		sb.Append("\x175A\x3\x2\x2\x2\x1765\x175D\x3\x2\x2\x2\x1765\x1764\x3\x2");
		sb.Append("\x2\x2\x1766\x176D\x3\x2\x2\x2\x1767\x1768\f\x5\x2\x2\x1768");
		sb.Append("\x1769\x5\x25A\x12E\x2\x1769\x176A\x5\x250\x129\x6\x176A\x176C");
		sb.Append("\x3\x2\x2\x2\x176B\x1767\x3\x2\x2\x2\x176C\x176F\x3\x2\x2\x2");
		sb.Append("\x176D\x176B\x3\x2\x2\x2\x176D\x176E\x3\x2\x2\x2\x176E\x251");
		sb.Append("\x3\x2\x2\x2\x176F\x176D\x3\x2\x2\x2\x1770\x1773\b\x12A\x1\x2");
		sb.Append("\x1771\x1772\a\x3DB\x2\x2\x1772\x1774\a\x3A7\x2\x2\x1773\x1771");
		sb.Append("\x3\x2\x2\x2\x1773\x1774\x3\x2\x2\x2\x1774\x1775\x3\x2\x2\x2");
		sb.Append("\x1775\x1776\x5\x254\x12B\x2\x1776\x17B0\x3\x2\x2\x2\x1777\x1778");
		sb.Append("\f\t\x2\x2\x1778\x1779\x5\x258\x12D\x2\x1779\x177A\x5\x252\x12A");
		sb.Append("\n\x177A\x17AF\x3\x2\x2\x2\x177B\x177D\f\a\x2\x2\x177C\x177E");
		sb.Append("\a\x65\x2\x2\x177D\x177C\x3\x2\x2\x2\x177D\x177E\x3\x2\x2\x2");
		sb.Append("\x177E\x177F\x3\x2\x2\x2\x177F\x1780\a\x10\x2\x2\x1780\x1781");
		sb.Append("\x5\x252\x12A\x2\x1781\x1782\a\f\x2\x2\x1782\x1783\x5\x252\x12A");
		sb.Append("\b\x1783\x17AF\x3\x2\x2\x2\x1784\x1785\f\x6\x2\x2\x1785\x1786");
		sb.Append("\a\x1F6\x2\x2\x1786\x1787\aW\x2\x2\x1787\x17AF\x5\x252\x12A");
		sb.Append("\a\x1788\x178A\f\x4\x2\x2\x1789\x178B\a\x65\x2\x2\x178A\x1789");
		sb.Append("\x3\x2\x2\x2\x178A\x178B\x3\x2\x2\x2\x178B\x178C\x3\x2\x2\x2");
		sb.Append("\x178C\x178D\to\x2\x2\x178D\x17AF\x5\x252\x12A\x5\x178E\x1790");
		sb.Append("\f\v\x2\x2\x178F\x1791\a\x65\x2\x2\x1790\x178F\x3\x2\x2\x2\x1790");
		sb.Append("\x1791\x3\x2\x2\x2\x1791\x1792\x3\x2\x2\x2\x1792\x1793\a\x46");
		sb.Append("\x2\x2\x1793\x1796\a\x3C1\x2\x2\x1794\x1797\x5\xB4[\x2\x1795");
		sb.Append("\x1797\x5\x228\x115\x2\x1796\x1794\x3\x2\x2\x2\x1796\x1795\x3");
		sb.Append("\x2\x2\x2\x1797\x1798\x3\x2\x2\x2\x1798\x1799\a\x3C2\x2\x2\x1799");
		sb.Append("\x17AF\x3\x2\x2\x2\x179A\x179B\f\n\x2\x2\x179B\x179C\aN\x2\x2");
		sb.Append("\x179C\x17AF\x5\x212\x10A\x2\x179D\x179E\f\b\x2\x2\x179E\x179F");
		sb.Append("\x5\x258\x12D\x2\x179F\x17A0\tp\x2\x2\x17A0\x17A1\a\x3C1\x2");
		sb.Append("\x2\x17A1\x17A2\x5\xB4[\x2\x17A2\x17A3\a\x3C2\x2\x2\x17A3\x17AF");
		sb.Append("\x3\x2\x2\x2\x17A4\x17A6\f\x5\x2\x2\x17A5\x17A7\a\x65\x2\x2");
		sb.Append("\x17A6\x17A5\x3\x2\x2\x2\x17A6\x17A7\x3\x2\x2\x2\x17A7\x17A8");
		sb.Append("\x3\x2\x2\x2\x17A8\x17A9\aW\x2\x2\x17A9\x17AC\x5\x252\x12A\x2");
		sb.Append("\x17AA\x17AB\a\x144\x2\x2\x17AB\x17AD\a\x3D0\x2\x2\x17AC\x17AA");
		sb.Append("\x3\x2\x2\x2\x17AC\x17AD\x3\x2\x2\x2\x17AD\x17AF\x3\x2\x2\x2");
		sb.Append("\x17AE\x1777\x3\x2\x2\x2\x17AE\x177B\x3\x2\x2\x2\x17AE\x1784");
		sb.Append("\x3\x2\x2\x2\x17AE\x1788\x3\x2\x2\x2\x17AE\x178E\x3\x2\x2\x2");
		sb.Append("\x17AE\x179A\x3\x2\x2\x2\x17AE\x179D\x3\x2\x2\x2\x17AE\x17A4");
		sb.Append("\x3\x2\x2\x2\x17AF\x17B2\x3\x2\x2\x2\x17B0\x17AE\x3\x2\x2\x2");
		sb.Append("\x17B0\x17B1\x3\x2\x2\x2\x17B1\x253\x3\x2\x2\x2\x17B2\x17B0");
		sb.Append("\x3\x2\x2\x2\x17B3\x17B4\b\x12B\x1\x2\x17B4\x17E1\x5\x214\x10B");
		sb.Append("\x2\x17B5\x17E1\x5\x1EC\xF7\x2\x17B6\x17E1\x5\x23C\x11F\x2\x17B7");
		sb.Append("\x17E1\x5\x1F2\xFA\x2\x17B8\x17B9\x5\x256\x12C\x2\x17B9\x17BA");
		sb.Append("\x5\x254\x12B\v\x17BA\x17E1\x3\x2\x2\x2\x17BB\x17BC\a\xC3\x2");
		sb.Append("\x2\x17BC\x17E1\x5\x254\x12B\n\x17BD\x17BE\a\x3C1\x2\x2\x17BE");
		sb.Append("\x17C3\x5\x250\x129\x2\x17BF\x17C0\a\x3C3\x2\x2\x17C0\x17C2");
		sb.Append("\x5\x250\x129\x2\x17C1\x17BF\x3\x2\x2\x2\x17C2\x17C5\x3\x2\x2");
		sb.Append("\x2\x17C3\x17C1\x3\x2\x2\x2\x17C3\x17C4\x3\x2\x2\x2\x17C4\x17C6");
		sb.Append("\x3\x2\x2\x2\x17C5\x17C3\x3\x2\x2\x2\x17C6\x17C7\a\x3C2\x2\x2");
		sb.Append("\x17C7\x17E1\x3\x2\x2\x2\x17C8\x17C9\a\x1E4\x2\x2\x17C9\x17CA");
		sb.Append("\a\x3C1\x2\x2\x17CA\x17CD\x5\x250\x129\x2\x17CB\x17CC\a\x3C3");
		sb.Append("\x2\x2\x17CC\x17CE\x5\x250\x129\x2\x17CD\x17CB\x3\x2\x2\x2\x17CE");
		sb.Append("\x17CF\x3\x2\x2\x2\x17CF\x17CD\x3\x2\x2\x2\x17CF\x17D0\x3\x2");
		sb.Append("\x2\x2\x17D0\x17D1\x3\x2\x2\x2\x17D1\x17D2\a\x3C2\x2\x2\x17D2");
		sb.Append("\x17E1\x3\x2\x2\x2\x17D3\x17D4\a\x35\x2\x2\x17D4\x17D5\a\x3C1");
		sb.Append("\x2\x2\x17D5\x17D6\x5\xB4[\x2\x17D6\x17D7\a\x3C2\x2\x2\x17D7");
		sb.Append("\x17E1\x3\x2\x2\x2\x17D8\x17D9\a\x3C1\x2\x2\x17D9\x17DA\x5\xB4");
		sb.Append("[\x2\x17DA\x17DB\a\x3C2\x2\x2\x17DB\x17E1\x3\x2\x2\x2\x17DC");
		sb.Append("\x17DD\aL\x2\x2\x17DD\x17DE\x5\x250\x129\x2\x17DE\x17DF\x5<");
		sb.Append("\x1F\x2\x17DF\x17E1\x3\x2\x2\x2\x17E0\x17B3\x3\x2\x2\x2\x17E0");
		sb.Append("\x17B5\x3\x2\x2\x2\x17E0\x17B6\x3\x2\x2\x2\x17E0\x17B7\x3\x2");
		sb.Append("\x2\x2\x17E0\x17B8\x3\x2\x2\x2\x17E0\x17BB\x3\x2\x2\x2\x17E0");
		sb.Append("\x17BD\x3\x2\x2\x2\x17E0\x17C8\x3\x2\x2\x2\x17E0\x17D3\x3\x2");
		sb.Append("\x2\x2\x17E0\x17D8\x3\x2\x2\x2\x17E0\x17DC\x3\x2\x2\x2\x17E1");
		sb.Append("\x17EF\x3\x2\x2\x2\x17E2\x17E3\f\x4\x2\x2\x17E3\x17E4\x5\x25C");
		sb.Append("\x12F\x2\x17E4\x17E5\x5\x254\x12B\x5\x17E5\x17EE\x3\x2\x2\x2");
		sb.Append("\x17E6\x17E7\f\x3\x2\x2\x17E7\x17E8\x5\x25E\x130\x2\x17E8\x17E9");
		sb.Append("\x5\x254\x12B\x4\x17E9\x17EE\x3\x2\x2\x2\x17EA\x17EB\f\r\x2");
		sb.Append("\x2\x17EB\x17EC\a\x1A\x2\x2\x17EC\x17EE\x5\x1F6\xFC\x2\x17ED");
		sb.Append("\x17E2\x3\x2\x2\x2\x17ED\x17E6\x3\x2\x2\x2\x17ED\x17EA\x3\x2");
		sb.Append("\x2\x2\x17EE\x17F1\x3\x2\x2\x2\x17EF\x17ED\x3\x2\x2\x2\x17EF");
		sb.Append("\x17F0\x3\x2\x2\x2\x17F0\x255\x3\x2\x2\x2\x17F1\x17EF\x3\x2");
		sb.Append("\x2\x2\x17F2\x17F3\tq\x2\x2\x17F3\x257\x3\x2\x2\x2\x17F4\x1803");
		sb.Append("\a\x3B8\x2\x2\x17F5\x1803\a\x3B9\x2\x2\x17F6\x1803\a\x3BA\x2");
		sb.Append("\x2\x17F7\x17F8\a\x3BA\x2\x2\x17F8\x1803\a\x3B8\x2\x2\x17F9");
		sb.Append("\x17FA\a\x3B9\x2\x2\x17FA\x1803\a\x3B8\x2\x2\x17FB\x17FC\a\x3BA");
		sb.Append("\x2\x2\x17FC\x1803\a\x3B9\x2\x2\x17FD\x17FE\a\x3BB\x2\x2\x17FE");
		sb.Append("\x1803\a\x3B8\x2\x2\x17FF\x1800\a\x3BA\x2\x2\x1800\x1801\a\x3B8");
		sb.Append("\x2\x2\x1801\x1803\a\x3B9\x2\x2\x1802\x17F4\x3\x2\x2\x2\x1802");
		sb.Append("\x17F5\x3\x2\x2\x2\x1802\x17F6\x3\x2\x2\x2\x1802\x17F7\x3\x2");
		sb.Append("\x2\x2\x1802\x17F9\x3\x2\x2\x2\x1802\x17FB\x3\x2\x2\x2\x1802");
		sb.Append("\x17FD\x3\x2\x2\x2\x1802\x17FF\x3\x2\x2\x2\x1803\x259\x3\x2");
		sb.Append("\x2\x2\x1804\x180C\a\f\x2\x2\x1805\x1806\a\x3BE\x2\x2\x1806");
		sb.Append("\x180C\a\x3BE\x2\x2\x1807\x180C\a\xAB\x2\x2\x1808\x180C\al\x2");
		sb.Append("\x2\x1809\x180A\a\x3BD\x2\x2\x180A\x180C\a\x3BD\x2\x2\x180B");
		sb.Append("\x1804\x3\x2\x2\x2\x180B\x1805\x3\x2\x2\x2\x180B\x1807\x3\x2");
		sb.Append("\x2\x2\x180B\x1808\x3\x2\x2\x2\x180B\x1809\x3\x2\x2\x2\x180C");
		sb.Append("\x25B\x3\x2\x2\x2\x180D\x180E\a\x3BA\x2\x2\x180E\x1815\a\x3BA");
		sb.Append("\x2\x2\x180F\x1810\a\x3B9\x2\x2\x1810\x1815\a\x3B9\x2\x2\x1811");
		sb.Append("\x1815\a\x3BE\x2\x2\x1812\x1815\a\x3BF\x2\x2\x1813\x1815\a\x3BD");
		sb.Append("\x2\x2\x1814\x180D\x3\x2\x2\x2\x1814\x180F\x3\x2\x2\x2\x1814");
		sb.Append("\x1811\x3\x2\x2\x2\x1814\x1812\x3\x2\x2\x2\x1814\x1813\x3\x2");
		sb.Append("\x2\x2\x1815\x25D\x3\x2\x2\x2\x1816\x1817\tr\x2\x2\x1817\x25F");
		sb.Append("\x3\x2\x2\x2\x1818\x1819\ts\x2\x2\x1819\x261\x3\x2\x2\x2\x181A");
		sb.Append("\x181B\tt\x2\x2\x181B\x263\x3\x2\x2\x2\x181C\x181D\tu\x2\x2");
		sb.Append("\x181D\x265\x3\x2\x2\x2\x181E\x181F\tv\x2\x2\x181F\x267\x3\x2");
		sb.Append("\x2\x2\x1820\x1821\tw\x2\x2\x1821\x269\x3\x2\x2\x2\x1822\x1823");
		sb.Append("\tx\x2\x2\x1823\x26B\x3\x2\x2\x2\x1824\x1825\ty\x2\x2\x1825");
		sb.Append("\x26D\x3\x2\x2\x2\x384\x26F\x272\x278\x27B\x27E\x280\x285\x288");
		sb.Append("\x28B\x294\x2BB\x2C7\x2D2\x2E3\x2E8\x2F4\x30F\x315\x31A\x320");
		sb.Append("\x325\x329\x332\x335\x338\x33C\x343\x346\x34B\x353\x358\x35D");
		sb.Append("\x360\x362\x36E\x371\x375\x378\x37C\x37F\x383\x386\x389\x38D");
		sb.Append("\x390\x394\x39A\x3A0\x3A6\x3AD\x3B4\x3BA\x3C0\x3C9\x3DC\x3E3");
		sb.Append("\x3E7\x3F1\x3F5\x3F9\x3FD\x401\x406\x409\x40C\x40F\x412\x418");
		sb.Append("\x41C\x422\x427\x42A\x42D\x42F\x43A\x43E\x441\x44F\x452\x456");
		sb.Append("\x459\x45D\x460\x464\x467\x46B\x46E\x471\x475\x478\x47C\x482");
		sb.Append("\x48F\x496\x49B\x49E\x4A3\x4AB\x4B1\x4B5\x4B8\x4BD\x4C0\x4C4");
		sb.Append("\x4C8\x4CB\x4D3\x4D5\x4DC\x4E2\x4EA\x4ED\x4F4\x4F7\x4F9\x4FF");
		sb.Append("\x505\x516\x51D\x524\x52D\x530\x53D\x54A\x54F\x55F\x567\x571");
		sb.Append("\x577\x581\x584\x589\x596\x59D\x5A2\x5A6\x5A8\x5AD\x5B0\x5B6");
		sb.Append("\x5BB\x5BD\x5C1\x5C4\x5C7\x5CD\x5D2\x5D4\x5D9\x5E0\x5E2\x5E9");
		sb.Append("\x5EE\x5F2\x5F5\x5FD\x605\x607\x60F\x613\x616\x61C\x621\x624");
		sb.Append("\x62A\x62D\x631\x636\x63B\x63F\x644\x647\x64C\x650\x654\x659");
		sb.Append("\x65E\x663\x669\x66E\x673\x679\x67E\x683\x688\x68D\x692\x697");
		sb.Append("\x69C\x6A1\x6A6\x6AB\x6B1\x6B6\x6BC\x6C6\x6CD\x6CF\x6D7\x6DC");
		sb.Append("\x6DF\x6E7\x6ED\x6FD\x709\x70B\x70E\x716\x71C\x722\x72F\x736");
		sb.Append("\x73E\x741\x74C\x754\x757\x763\x76A\x772\x775\x781\x788\x790");
		sb.Append("\x793\x79A\x7A2\x7A5\x7A7\x7AC\x7B4\x7BD\x7C1\x7C5\x7CA\x7D0");
		sb.Append("\x7D6\x7DB\x7E0\x7E5\x7EA\x7ED\x7F2\x7F7\x801\x805\x80C\x811");
		sb.Append("\x814\x819\x81C\x820\x824\x82C\x83F\x842\x845\x849\x853\x860");
		sb.Append("\x867\x86A\x873\x876\x879\x884\x887\x88B\x893\x896\x89B\x8A3");
		sb.Append("\x8A9\x8AD\x8B1\x8B6\x8BB\x8C2\x8C6\x8D1\x8D9\x8DC\x8E2\x8E8");
		sb.Append("\x8EA\x8EF\x8F5\x8FB\x8FD\x901\x904\x907\x90D\x913\x916\x91C");
		sb.Append("\x922\x924\x929\x931\x933\x93C\x941\x949\x94D\x955\x95F\x964");
		sb.Append("\x96B\x96F\x973\x98B\x98F\x99B\x99E\x9A7\x9B8\x9C4\x9CB\x9D2");
		sb.Append("\x9E1\x9EE\x9F4\x9FA\xA00\xA06\xA0C\xA12\xA17\xA1E\xA25\xA2C");
		sb.Append("\xA31\xA34\xA36\xA44\xA4B\xA52\xA58\xA5C\xA60\xA67\xA6A\xA6F");
		sb.Append("\xA76\xA7D\xA81\xA8A\xA93\xA9C\xA9F\xAA3\xAAC\xAB0\xAB3\xAB6");
		sb.Append("\xABE\xAC4\xACD\xAD0\xADB\xADE\xAE3\xAE6\xAEB\xAF5\xAFA\xB00");
		sb.Append("\xB02\xB08\xB0A\xB10\xB18\xB1D\xB25\xB28\xB2D\xB30\xB35\xB3D");
		sb.Append("\xB45\xB4B\xB53\xB58\xB60\xB63\xB67\xB6A\xB72\xB78\xB81\xB84");
		sb.Append("\xB88\xB8C\xB92\xB96\xB9A\xB9C\xB9F\xBA2\xBA5\xBAB\xBAF\xBB2");
		sb.Append("\xBB5\xBB8\xBBB\xBBD\xBC1\xBCF\xBD2\xBD8\xBDC\xBE4\xBE8\xBEB");
		sb.Append("\xBEE\xBF7\xBFB\xBFE\xC02\xC06\xC09\xC0C\xC11\xC17\xC1B\xC25");
		sb.Append("\xC2B\xC2F\xC35\xC39\xC3F\xC42\xC4E\xC52\xC56\xC5E\xC62\xC6A");
		sb.Append("\xC6D\xC71\xC74\xC7C\xC81\xC84\xC87\xC8B\xC8E\xC97\xC9C\xCA5");
		sb.Append("\xCAA\xCB1\xCB8\xCC0\xCC5\xCCD\xCD0\xCD3\xCDA\xCDD\xCE4\xCE7");
		sb.Append("\xCEF\xCF5\xD00\xD03\xD0E\xD14\xD18\xD23\xD28\xD2A\xD2E\xD38");
		sb.Append("\xD42\xD48\xD4D\xD50\xD53\xD56\xD5C\xD61\xD64\xD67\xD6A\xD6C");
		sb.Append("\xD72\xD77\xD7A\xD7D\xD81\xD87\xD8B\xD95\xD99\xD9F\xDA8\xDAB");
		sb.Append("\xDAF\xDB2\xDB6\xDBA\xDBD\xDBF\xDC7\xDD3\xDD9\xDDB\xDE1\xDE3");
		sb.Append("\xDE5\xDEB\xDF3\xDFB\xE01\xE0A\xE0F\xE11\xE15\xE19\xE1F\xE26");
		sb.Append("\xE2A\xE33\xE36\xE3A\xE3E\xE42\xE45\xE48\xE4B\xE4F\xE53\xE56");
		sb.Append("\xE59\xE5C\xE63\xE67\xE76\xE83\xE8B\xE95\xE99\xE9C\xEA2\xEA5");
		sb.Append("\xEA8\xEB1\xEBA\xEC4\xEC8\xED2\xEDC\xEE4\xEE7\xEF0\xEF3\xEF7");
		sb.Append("\xEFC\xF00\xF09\xF0C\xF2B\xF2E\xF31\xF69\xF6E\xF8A\xF98\xF9F");
		sb.Append("\xFA3\xFA9\xFB1\xFB3\xFBE\xFC8\xFCF\xFD5\xFDD\xFE2\xFEA\xFF2");
		sb.Append("\xFFA\x1002\x1008\x100B\x100F\x1014\x1019\x101F\x1021\x102C");
		sb.Append("\x1031\x1038\x103A\x1048\x104E\x1053\x1058\x105E\x1065\x106D");
		sb.Append("\x1075\x107A\x1080\x1083\x108B\x1092\x109B\x109E\x10AF\x10B7");
		sb.Append("\x10BF\x10C3\x10CA\x10D0\x10D8\x10E1\x10E7\x10EE\x10F5\x10FA");
		sb.Append("\x10FD\x10FF\x1105\x1107\x110B\x110D\x1110\x1119\x111F\x1126");
		sb.Append("\x112D\x1132\x1135\x1137\x113D\x113F\x1143\x1145\x1148\x114D");
		sb.Append("\x1154\x115D\x1162\x116B\x1172\x1177\x117A\x117C\x1182\x1184");
		sb.Append("\x1187\x1193\x1199\x11A2\x11AB\x11B0\x11B9\x11BF\x11CA\x11CD");
		sb.Append("\x11D9\x11E0\x11E5\x11F4\x11FF\x1202\x120C\x1216\x1220\x122A");
		sb.Append("\x122E\x1232\x123B\x1256\x1265\x126D\x1278\x127F\x1283\x128A");
		sb.Append("\x128F\x1292\x1295\x129E\x12A2\x12C0\x12C7\x12CB\x12D2\x12D5");
		sb.Append("\x12DF\x12E9\x12ED\x12F3\x12F6\x12FB\x12FF\x1306\x1309\x130F");
		sb.Append("\x1327\x1334\x1337\x1341\x1349\x134D\x1354\x1357\x1360\x1366");
		sb.Append("\x136C\x1376\x1378\x137E\x1381\x1384\x1390\x1393\x1399\x139C");
		sb.Append("\x13A4\x13AC\x13B2\x13B6\x13C4\x13D0\x13D7\x13DA\x13E1\x13E8");
		sb.Append("\x13ED\x13F2\x13FD\x1408\x140E\x1413\x1420\x1422\x1427\x142C");
		sb.Append("\x142E\x1435\x143C\x143F\x1442\x1448\x144C\x1452\x1458\x1467");
		sb.Append("\x146C\x1472\x1479\x147B\x147F\x1485\x1488\x1492\x1496\x14AA");
		sb.Append("\x14B1\x14B3\x14BA\x14BC\x14C0\x14C5\x14D0\x14D5\x14DB\x14DE");
		sb.Append("\x14E2\x14E7\x14EA\x14EE\x14F2\x14F4\x14F9\x14FE\x150B\x150E");
		sb.Append("\x1512\x1515\x151A\x151D\x1521\x1526\x1529\x152E\x1531\x1537");
		sb.Append("\x153A\x153E\x1541\x1544\x1548\x154B\x154E\x1552\x1555\x1558");
		sb.Append("\x155B\x155F\x1562\x1565\x156A\x156F\x1574\x1577\x157A\x1582");
		sb.Append("\x1589\x158D\x1592\x1595\x159A\x159E\x15A0\x15B0\x15B9\x15C1");
		sb.Append("\x15CA\x15D4\x15DC\x15E4\x15EC\x15F4\x15F9\x1600\x1602\x1607");
		sb.Append("\x160A\x160F\x1612\x1616\x1624\x162B\x1630\x1652\x1656\x165E");
		sb.Append("\x1662\x166B\x1673\x1678\x1680\x1685\x168A\x168C\x1695\x169A");
		sb.Append("\x16A2\x16A7\x16AF\x16B7\x16BA\x16C4\x16CF\x16DC\x16E4\x16E8");
		sb.Append("\x16ED\x16F6\x16F9\x1705\x170D\x1717\x171A\x171E\x1722\x173B");
		sb.Append("\x1746\x174D\x1751\x1758\x1760\x1765\x176D\x1773\x177D\x178A");
		sb.Append("\x1790\x1796\x17A6\x17AC\x17AE\x17B0\x17C3\x17CF\x17E0\x17ED");
		sb.Append("\x17EF\x1802\x180B\x1814");
	    return sb.ToString();
	}

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());


}
} // namespace MySQLToCSharp.Parsers.MySql
