//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from /app/MySqlParser.g4 by ANTLR 4.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace MySQLToCsharp.Parsers.MySql {
using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6")]
[System.CLSCompliant(false)]
public partial class MySqlParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		SPACE=1, SPEC_MYSQL_COMMENT=2, COMMENT_INPUT=3, LINE_COMMENT=4, ADD=5, 
		ALL=6, ALTER=7, ALWAYS=8, ANALYZE=9, AND=10, AS=11, ASC=12, BEFORE=13, 
		BETWEEN=14, BOTH=15, BY=16, CALL=17, CASCADE=18, CASE=19, CAST=20, CHANGE=21, 
		CHARACTER=22, CHECK=23, COLLATE=24, COLUMN=25, CONDITION=26, CONSTRAINT=27, 
		CONTINUE=28, CONVERT=29, CREATE=30, CROSS=31, CURRENT_USER=32, CURSOR=33, 
		DATABASE=34, DATABASES=35, DECLARE=36, DEFAULT=37, DELAYED=38, DELETE=39, 
		DESC=40, DESCRIBE=41, DETERMINISTIC=42, DISTINCT=43, DISTINCTROW=44, DROP=45, 
		EACH=46, ELSE=47, ELSEIF=48, ENCLOSED=49, ESCAPED=50, EXISTS=51, EXIT=52, 
		EXPLAIN=53, FALSE=54, FETCH=55, FOR=56, FORCE=57, FOREIGN=58, FROM=59, 
		FULLTEXT=60, GENERATED=61, GRANT=62, GROUP=63, HAVING=64, HIGH_PRIORITY=65, 
		IF=66, IGNORE=67, IN=68, INDEX=69, INFILE=70, INNER=71, INOUT=72, INSERT=73, 
		INTERVAL=74, INTO=75, IS=76, ITERATE=77, JOIN=78, KEY=79, KEYS=80, KILL=81, 
		LEADING=82, LEAVE=83, LEFT=84, LIKE=85, LIMIT=86, LINEAR=87, LINES=88, 
		LOAD=89, LOCK=90, LOOP=91, LOW_PRIORITY=92, MASTER_BIND=93, MASTER_SSL_VERIFY_SERVER_CERT=94, 
		MATCH=95, MAXVALUE=96, MODIFIES=97, NATURAL=98, NOT=99, NO_WRITE_TO_BINLOG=100, 
		NULL_LITERAL=101, ON=102, OPTIMIZE=103, OPTION=104, OPTIONALLY=105, OR=106, 
		ORDER=107, OUT=108, OUTER=109, OUTFILE=110, PARTITION=111, PRIMARY=112, 
		PROCEDURE=113, PURGE=114, RANGE=115, READ=116, READS=117, REFERENCES=118, 
		REGEXP=119, RELEASE=120, RENAME=121, REPEAT=122, REPLACE=123, REQUIRE=124, 
		RESTRICT=125, RETURN=126, REVOKE=127, RIGHT=128, RLIKE=129, SCHEMA=130, 
		SCHEMAS=131, SELECT=132, SET=133, SEPARATOR=134, SHOW=135, SIGNAL=136, 
		SPATIAL=137, SQL=138, SQLEXCEPTION=139, SQLSTATE=140, SQLWARNING=141, 
		SQL_BIG_RESULT=142, SQL_CALC_FOUND_ROWS=143, SQL_SMALL_RESULT=144, SSL=145, 
		STARTING=146, STRAIGHT_JOIN=147, TABLE=148, TERMINATED=149, THEN=150, 
		TO=151, TRAILING=152, TRIGGER=153, TRUE=154, UNDO=155, UNION=156, UNIQUE=157, 
		UNLOCK=158, UNSIGNED=159, UPDATE=160, USAGE=161, USE=162, USING=163, VALUES=164, 
		WHEN=165, WHERE=166, WHILE=167, WITH=168, WRITE=169, XOR=170, ZEROFILL=171, 
		TINYINT=172, SMALLINT=173, MEDIUMINT=174, INT=175, INTEGER=176, BIGINT=177, 
		REAL=178, DOUBLE=179, PRECISION=180, FLOAT=181, DECIMAL=182, DEC=183, 
		NUMERIC=184, DATE=185, TIME=186, TIMESTAMP=187, DATETIME=188, YEAR=189, 
		CHAR=190, VARCHAR=191, NVARCHAR=192, NATIONAL=193, BINARY=194, VARBINARY=195, 
		TINYBLOB=196, BLOB=197, MEDIUMBLOB=198, LONGBLOB=199, TINYTEXT=200, TEXT=201, 
		MEDIUMTEXT=202, LONGTEXT=203, ENUM=204, VARYING=205, SERIAL=206, YEAR_MONTH=207, 
		DAY_HOUR=208, DAY_MINUTE=209, DAY_SECOND=210, HOUR_MINUTE=211, HOUR_SECOND=212, 
		MINUTE_SECOND=213, SECOND_MICROSECOND=214, MINUTE_MICROSECOND=215, HOUR_MICROSECOND=216, 
		DAY_MICROSECOND=217, AVG=218, BIT_AND=219, BIT_OR=220, BIT_XOR=221, COUNT=222, 
		GROUP_CONCAT=223, MAX=224, MIN=225, STD=226, STDDEV=227, STDDEV_POP=228, 
		STDDEV_SAMP=229, SUM=230, VAR_POP=231, VAR_SAMP=232, VARIANCE=233, CURRENT_DATE=234, 
		CURRENT_TIME=235, CURRENT_TIMESTAMP=236, LOCALTIME=237, CURDATE=238, CURTIME=239, 
		DATE_ADD=240, DATE_SUB=241, EXTRACT=242, LOCALTIMESTAMP=243, NOW=244, 
		POSITION=245, SUBSTR=246, SUBSTRING=247, SYSDATE=248, TRIM=249, UTC_DATE=250, 
		UTC_TIME=251, UTC_TIMESTAMP=252, ACCOUNT=253, ACTION=254, AFTER=255, AGGREGATE=256, 
		ALGORITHM=257, ANY=258, AT=259, AUTHORS=260, AUTOCOMMIT=261, AUTOEXTEND_SIZE=262, 
		AUTO_INCREMENT=263, AVG_ROW_LENGTH=264, BEGIN=265, BINLOG=266, BIT=267, 
		BLOCK=268, BOOL=269, BOOLEAN=270, BTREE=271, CACHE=272, CASCADED=273, 
		CHAIN=274, CHANGED=275, CHANNEL=276, CHECKSUM=277, PAGE_CHECKSUM=278, 
		CIPHER=279, CLASS_ORIGIN=280, CLIENT=281, CLOSE=282, COALESCE=283, CODE=284, 
		COLUMNS=285, COLUMN_FORMAT=286, COLUMN_NAME=287, COMMENT=288, COMMIT=289, 
		COMPACT=290, COMPLETION=291, COMPRESSED=292, COMPRESSION=293, CONCURRENT=294, 
		CONNECTION=295, CONSISTENT=296, CONSTRAINT_CATALOG=297, CONSTRAINT_SCHEMA=298, 
		CONSTRAINT_NAME=299, CONTAINS=300, CONTEXT=301, CONTRIBUTORS=302, COPY=303, 
		CPU=304, DATA=305, DATAFILE=306, DEALLOCATE=307, DEFAULT_AUTH=308, DEFINER=309, 
		DELAY_KEY_WRITE=310, DES_KEY_FILE=311, DIRECTORY=312, DISABLE=313, DISCARD=314, 
		DISK=315, DO=316, DUMPFILE=317, DUPLICATE=318, DYNAMIC=319, ENABLE=320, 
		ENCRYPTION=321, END=322, ENDS=323, ENGINE=324, ENGINES=325, ERROR=326, 
		ERRORS=327, ESCAPE=328, EVEN=329, EVENT=330, EVENTS=331, EVERY=332, EXCHANGE=333, 
		EXCLUSIVE=334, EXPIRE=335, EXPORT=336, EXTENDED=337, EXTENT_SIZE=338, 
		FAST=339, FAULTS=340, FIELDS=341, FILE_BLOCK_SIZE=342, FILTER=343, FIRST=344, 
		FIXED=345, FLUSH=346, FOLLOWS=347, FOUND=348, FULL=349, FUNCTION=350, 
		GENERAL=351, GLOBAL=352, GRANTS=353, GROUP_REPLICATION=354, HANDLER=355, 
		HASH=356, HELP=357, HOST=358, HOSTS=359, IDENTIFIED=360, IGNORE_SERVER_IDS=361, 
		IMPORT=362, INDEXES=363, INITIAL_SIZE=364, INPLACE=365, INSERT_METHOD=366, 
		INSTALL=367, INSTANCE=368, INVISIBLE=369, INVOKER=370, IO=371, IO_THREAD=372, 
		IPC=373, ISOLATION=374, ISSUER=375, JSON=376, KEY_BLOCK_SIZE=377, LANGUAGE=378, 
		LAST=379, LEAVES=380, LESS=381, LEVEL=382, LIST=383, LOCAL=384, LOGFILE=385, 
		LOGS=386, MASTER=387, MASTER_AUTO_POSITION=388, MASTER_CONNECT_RETRY=389, 
		MASTER_DELAY=390, MASTER_HEARTBEAT_PERIOD=391, MASTER_HOST=392, MASTER_LOG_FILE=393, 
		MASTER_LOG_POS=394, MASTER_PASSWORD=395, MASTER_PORT=396, MASTER_RETRY_COUNT=397, 
		MASTER_SSL=398, MASTER_SSL_CA=399, MASTER_SSL_CAPATH=400, MASTER_SSL_CERT=401, 
		MASTER_SSL_CIPHER=402, MASTER_SSL_CRL=403, MASTER_SSL_CRLPATH=404, MASTER_SSL_KEY=405, 
		MASTER_TLS_VERSION=406, MASTER_USER=407, MAX_CONNECTIONS_PER_HOUR=408, 
		MAX_QUERIES_PER_HOUR=409, MAX_ROWS=410, MAX_SIZE=411, MAX_UPDATES_PER_HOUR=412, 
		MAX_USER_CONNECTIONS=413, MEDIUM=414, MERGE=415, MESSAGE_TEXT=416, MID=417, 
		MIGRATE=418, MIN_ROWS=419, MODE=420, MODIFY=421, MUTEX=422, MYSQL=423, 
		MYSQL_ERRNO=424, NAME=425, NAMES=426, NCHAR=427, NEVER=428, NEXT=429, 
		NO=430, NODEGROUP=431, NONE=432, OFFLINE=433, OFFSET=434, OJ=435, OLD_PASSWORD=436, 
		ONE=437, ONLINE=438, ONLY=439, OPEN=440, OPTIMIZER_COSTS=441, OPTIONS=442, 
		OWNER=443, PACK_KEYS=444, PAGE=445, PARSER=446, PARTIAL=447, PARTITIONING=448, 
		PARTITIONS=449, PASSWORD=450, PHASE=451, PLUGIN=452, PLUGIN_DIR=453, PLUGINS=454, 
		PORT=455, PRECEDES=456, PREPARE=457, PRESERVE=458, PREV=459, PROCESSLIST=460, 
		PROFILE=461, PROFILES=462, PROXY=463, QUERY=464, QUICK=465, REBUILD=466, 
		RECOVER=467, REDO_BUFFER_SIZE=468, REDUNDANT=469, RELAY=470, RELAY_LOG_FILE=471, 
		RELAY_LOG_POS=472, RELAYLOG=473, REMOVE=474, REORGANIZE=475, REPAIR=476, 
		REPLICATE_DO_DB=477, REPLICATE_DO_TABLE=478, REPLICATE_IGNORE_DB=479, 
		REPLICATE_IGNORE_TABLE=480, REPLICATE_REWRITE_DB=481, REPLICATE_WILD_DO_TABLE=482, 
		REPLICATE_WILD_IGNORE_TABLE=483, REPLICATION=484, RESET=485, RESUME=486, 
		RETURNS=487, ROLLBACK=488, ROLLUP=489, ROTATE=490, ROW=491, ROWS=492, 
		ROW_FORMAT=493, SAVEPOINT=494, SCHEDULE=495, SECURITY=496, SERVER=497, 
		SESSION=498, SHARE=499, SHARED=500, SIGNED=501, SIMPLE=502, SLAVE=503, 
		SLOW=504, SNAPSHOT=505, SOCKET=506, SOME=507, SONAME=508, SOUNDS=509, 
		SOURCE=510, SQL_AFTER_GTIDS=511, SQL_AFTER_MTS_GAPS=512, SQL_BEFORE_GTIDS=513, 
		SQL_BUFFER_RESULT=514, SQL_CACHE=515, SQL_NO_CACHE=516, SQL_THREAD=517, 
		START=518, STARTS=519, STATS_AUTO_RECALC=520, STATS_PERSISTENT=521, STATS_SAMPLE_PAGES=522, 
		STATUS=523, STOP=524, STORAGE=525, STORED=526, STRING=527, SUBCLASS_ORIGIN=528, 
		SUBJECT=529, SUBPARTITION=530, SUBPARTITIONS=531, SUSPEND=532, SWAPS=533, 
		SWITCHES=534, TABLE_NAME=535, TABLESPACE=536, TEMPORARY=537, TEMPTABLE=538, 
		THAN=539, TRADITIONAL=540, TRANSACTION=541, TRIGGERS=542, TRUNCATE=543, 
		UNDEFINED=544, UNDOFILE=545, UNDO_BUFFER_SIZE=546, UNINSTALL=547, UNKNOWN=548, 
		UNTIL=549, UPGRADE=550, USER=551, USE_FRM=552, USER_RESOURCES=553, VALIDATION=554, 
		VALUE=555, VARIABLES=556, VIEW=557, VIRTUAL=558, VISIBLE=559, WAIT=560, 
		WARNINGS=561, WITHOUT=562, WORK=563, WRAPPER=564, X509=565, XA=566, XML=567, 
		EUR=568, USA=569, JIS=570, ISO=571, INTERNAL=572, QUARTER=573, MONTH=574, 
		DAY=575, HOUR=576, MINUTE=577, WEEK=578, SECOND=579, MICROSECOND=580, 
		TABLES=581, ROUTINE=582, EXECUTE=583, FILE=584, PROCESS=585, RELOAD=586, 
		SHUTDOWN=587, SUPER=588, PRIVILEGES=589, SESSION_VARIABLES_ADMIN=590, 
		ARMSCII8=591, ASCII=592, BIG5=593, CP1250=594, CP1251=595, CP1256=596, 
		CP1257=597, CP850=598, CP852=599, CP866=600, CP932=601, DEC8=602, EUCJPMS=603, 
		EUCKR=604, GB2312=605, GBK=606, GEOSTD8=607, GREEK=608, HEBREW=609, HP8=610, 
		KEYBCS2=611, KOI8R=612, KOI8U=613, LATIN1=614, LATIN2=615, LATIN5=616, 
		LATIN7=617, MACCE=618, MACROMAN=619, SJIS=620, SWE7=621, TIS620=622, UCS2=623, 
		UJIS=624, UTF16=625, UTF16LE=626, UTF32=627, UTF8=628, UTF8MB3=629, UTF8MB4=630, 
		ARCHIVE=631, BLACKHOLE=632, CSV=633, FEDERATED=634, INNODB=635, MEMORY=636, 
		MRG_MYISAM=637, MYISAM=638, NDB=639, NDBCLUSTER=640, PERFORMANCE_SCHEMA=641, 
		TOKUDB=642, REPEATABLE=643, COMMITTED=644, UNCOMMITTED=645, SERIALIZABLE=646, 
		GEOMETRYCOLLECTION=647, GEOMCOLLECTION=648, GEOMETRY=649, LINESTRING=650, 
		MULTILINESTRING=651, MULTIPOINT=652, MULTIPOLYGON=653, POINT=654, POLYGON=655, 
		ABS=656, ACOS=657, ADDDATE=658, ADDTIME=659, AES_DECRYPT=660, AES_ENCRYPT=661, 
		AREA=662, ASBINARY=663, ASIN=664, ASTEXT=665, ASWKB=666, ASWKT=667, ASYMMETRIC_DECRYPT=668, 
		ASYMMETRIC_DERIVE=669, ASYMMETRIC_ENCRYPT=670, ASYMMETRIC_SIGN=671, ASYMMETRIC_VERIFY=672, 
		ATAN=673, ATAN2=674, BENCHMARK=675, BIN=676, BIT_COUNT=677, BIT_LENGTH=678, 
		BUFFER=679, CATALOG_NAME=680, CEIL=681, CEILING=682, CENTROID=683, CHARACTER_LENGTH=684, 
		CHARSET=685, CHAR_LENGTH=686, COERCIBILITY=687, COLLATION=688, COMPRESS=689, 
		CONCAT=690, CONCAT_WS=691, CONNECTION_ID=692, CONV=693, CONVERT_TZ=694, 
		COS=695, COT=696, CRC32=697, CREATE_ASYMMETRIC_PRIV_KEY=698, CREATE_ASYMMETRIC_PUB_KEY=699, 
		CREATE_DH_PARAMETERS=700, CREATE_DIGEST=701, CROSSES=702, DATEDIFF=703, 
		DATE_FORMAT=704, DAYNAME=705, DAYOFMONTH=706, DAYOFWEEK=707, DAYOFYEAR=708, 
		DECODE=709, DEGREES=710, DES_DECRYPT=711, DES_ENCRYPT=712, DIMENSION=713, 
		DISJOINT=714, ELT=715, ENCODE=716, ENCRYPT=717, ENDPOINT=718, ENVELOPE=719, 
		EQUALS=720, EXP=721, EXPORT_SET=722, EXTERIORRING=723, EXTRACTVALUE=724, 
		FIELD=725, FIND_IN_SET=726, FLOOR=727, FORMAT=728, FOUND_ROWS=729, FROM_BASE64=730, 
		FROM_DAYS=731, FROM_UNIXTIME=732, GEOMCOLLFROMTEXT=733, GEOMCOLLFROMWKB=734, 
		GEOMETRYCOLLECTIONFROMTEXT=735, GEOMETRYCOLLECTIONFROMWKB=736, GEOMETRYFROMTEXT=737, 
		GEOMETRYFROMWKB=738, GEOMETRYN=739, GEOMETRYTYPE=740, GEOMFROMTEXT=741, 
		GEOMFROMWKB=742, GET_FORMAT=743, GET_LOCK=744, GLENGTH=745, GREATEST=746, 
		GTID_SUBSET=747, GTID_SUBTRACT=748, HEX=749, IFNULL=750, INET6_ATON=751, 
		INET6_NTOA=752, INET_ATON=753, INET_NTOA=754, INSTR=755, INTERIORRINGN=756, 
		INTERSECTS=757, ISCLOSED=758, ISEMPTY=759, ISNULL=760, ISSIMPLE=761, IS_FREE_LOCK=762, 
		IS_IPV4=763, IS_IPV4_COMPAT=764, IS_IPV4_MAPPED=765, IS_IPV6=766, IS_USED_LOCK=767, 
		LAST_INSERT_ID=768, LCASE=769, LEAST=770, LENGTH=771, LINEFROMTEXT=772, 
		LINEFROMWKB=773, LINESTRINGFROMTEXT=774, LINESTRINGFROMWKB=775, LN=776, 
		LOAD_FILE=777, LOCATE=778, LOG=779, LOG10=780, LOG2=781, LOWER=782, LPAD=783, 
		LTRIM=784, MAKEDATE=785, MAKETIME=786, MAKE_SET=787, MASTER_POS_WAIT=788, 
		MBRCONTAINS=789, MBRDISJOINT=790, MBREQUAL=791, MBRINTERSECTS=792, MBROVERLAPS=793, 
		MBRTOUCHES=794, MBRWITHIN=795, MD5=796, MLINEFROMTEXT=797, MLINEFROMWKB=798, 
		MONTHNAME=799, MPOINTFROMTEXT=800, MPOINTFROMWKB=801, MPOLYFROMTEXT=802, 
		MPOLYFROMWKB=803, MULTILINESTRINGFROMTEXT=804, MULTILINESTRINGFROMWKB=805, 
		MULTIPOINTFROMTEXT=806, MULTIPOINTFROMWKB=807, MULTIPOLYGONFROMTEXT=808, 
		MULTIPOLYGONFROMWKB=809, NAME_CONST=810, NULLIF=811, NUMGEOMETRIES=812, 
		NUMINTERIORRINGS=813, NUMPOINTS=814, OCT=815, OCTET_LENGTH=816, ORD=817, 
		OVERLAPS=818, PERIOD_ADD=819, PERIOD_DIFF=820, PI=821, POINTFROMTEXT=822, 
		POINTFROMWKB=823, POINTN=824, POLYFROMTEXT=825, POLYFROMWKB=826, POLYGONFROMTEXT=827, 
		POLYGONFROMWKB=828, POW=829, POWER=830, QUOTE=831, RADIANS=832, RAND=833, 
		RANDOM_BYTES=834, RELEASE_LOCK=835, REVERSE=836, ROUND=837, ROW_COUNT=838, 
		RPAD=839, RTRIM=840, SEC_TO_TIME=841, SESSION_USER=842, SHA=843, SHA1=844, 
		SHA2=845, SCHEMA_NAME=846, SIGN=847, SIN=848, SLEEP=849, SOUNDEX=850, 
		SQL_THREAD_WAIT_AFTER_GTIDS=851, SQRT=852, SRID=853, STARTPOINT=854, STRCMP=855, 
		STR_TO_DATE=856, ST_AREA=857, ST_ASBINARY=858, ST_ASTEXT=859, ST_ASWKB=860, 
		ST_ASWKT=861, ST_BUFFER=862, ST_CENTROID=863, ST_CONTAINS=864, ST_CROSSES=865, 
		ST_DIFFERENCE=866, ST_DIMENSION=867, ST_DISJOINT=868, ST_DISTANCE=869, 
		ST_ENDPOINT=870, ST_ENVELOPE=871, ST_EQUALS=872, ST_EXTERIORRING=873, 
		ST_GEOMCOLLFROMTEXT=874, ST_GEOMCOLLFROMTXT=875, ST_GEOMCOLLFROMWKB=876, 
		ST_GEOMETRYCOLLECTIONFROMTEXT=877, ST_GEOMETRYCOLLECTIONFROMWKB=878, ST_GEOMETRYFROMTEXT=879, 
		ST_GEOMETRYFROMWKB=880, ST_GEOMETRYN=881, ST_GEOMETRYTYPE=882, ST_GEOMFROMTEXT=883, 
		ST_GEOMFROMWKB=884, ST_INTERIORRINGN=885, ST_INTERSECTION=886, ST_INTERSECTS=887, 
		ST_ISCLOSED=888, ST_ISEMPTY=889, ST_ISSIMPLE=890, ST_LINEFROMTEXT=891, 
		ST_LINEFROMWKB=892, ST_LINESTRINGFROMTEXT=893, ST_LINESTRINGFROMWKB=894, 
		ST_NUMGEOMETRIES=895, ST_NUMINTERIORRING=896, ST_NUMINTERIORRINGS=897, 
		ST_NUMPOINTS=898, ST_OVERLAPS=899, ST_POINTFROMTEXT=900, ST_POINTFROMWKB=901, 
		ST_POINTN=902, ST_POLYFROMTEXT=903, ST_POLYFROMWKB=904, ST_POLYGONFROMTEXT=905, 
		ST_POLYGONFROMWKB=906, ST_SRID=907, ST_STARTPOINT=908, ST_SYMDIFFERENCE=909, 
		ST_TOUCHES=910, ST_UNION=911, ST_WITHIN=912, ST_X=913, ST_Y=914, SUBDATE=915, 
		SUBSTRING_INDEX=916, SUBTIME=917, SYSTEM_USER=918, TAN=919, TIMEDIFF=920, 
		TIMESTAMPADD=921, TIMESTAMPDIFF=922, TIME_FORMAT=923, TIME_TO_SEC=924, 
		TOUCHES=925, TO_BASE64=926, TO_DAYS=927, TO_SECONDS=928, UCASE=929, UNCOMPRESS=930, 
		UNCOMPRESSED_LENGTH=931, UNHEX=932, UNIX_TIMESTAMP=933, UPDATEXML=934, 
		UPPER=935, UUID=936, UUID_SHORT=937, VALIDATE_PASSWORD_STRENGTH=938, VERSION=939, 
		WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS=940, WEEKDAY=941, WEEKOFYEAR=942, WEIGHT_STRING=943, 
		WITHIN=944, YEARWEEK=945, Y_FUNCTION=946, X_FUNCTION=947, VAR_ASSIGN=948, 
		PLUS_ASSIGN=949, MINUS_ASSIGN=950, MULT_ASSIGN=951, DIV_ASSIGN=952, MOD_ASSIGN=953, 
		AND_ASSIGN=954, XOR_ASSIGN=955, OR_ASSIGN=956, STAR=957, DIVIDE=958, MODULE=959, 
		PLUS=960, MINUSMINUS=961, MINUS=962, DIV=963, MOD=964, EQUAL_SYMBOL=965, 
		GREATER_SYMBOL=966, LESS_SYMBOL=967, EXCLAMATION_SYMBOL=968, BIT_NOT_OP=969, 
		BIT_OR_OP=970, BIT_AND_OP=971, BIT_XOR_OP=972, DOT=973, LR_BRACKET=974, 
		RR_BRACKET=975, COMMA=976, SEMI=977, AT_SIGN=978, ZERO_DECIMAL=979, ONE_DECIMAL=980, 
		TWO_DECIMAL=981, SINGLE_QUOTE_SYMB=982, DOUBLE_QUOTE_SYMB=983, REVERSE_QUOTE_SYMB=984, 
		COLON_SYMB=985, CHARSET_REVERSE_QOUTE_STRING=986, FILESIZE_LITERAL=987, 
		START_NATIONAL_STRING_LITERAL=988, STRING_LITERAL=989, DECIMAL_LITERAL=990, 
		HEXADECIMAL_LITERAL=991, REAL_LITERAL=992, NULL_SPEC_LITERAL=993, BIT_STRING=994, 
		STRING_CHARSET_NAME=995, DOT_ID=996, ID=997, REVERSE_QUOTE_ID=998, STRING_USER_NAME=999, 
		LOCAL_ID=1000, GLOBAL_ID=1001, ERROR_RECONGNIGION=1002;
	public const int
		RULE_root = 0, RULE_sqlStatements = 1, RULE_sqlStatement = 2, RULE_emptyStatement = 3, 
		RULE_ddlStatement = 4, RULE_dmlStatement = 5, RULE_transactionStatement = 6, 
		RULE_replicationStatement = 7, RULE_preparedStatement = 8, RULE_compoundStatement = 9, 
		RULE_administrationStatement = 10, RULE_utilityStatement = 11, RULE_createDatabase = 12, 
		RULE_createEvent = 13, RULE_createIndex = 14, RULE_createLogfileGroup = 15, 
		RULE_createProcedure = 16, RULE_createFunction = 17, RULE_createServer = 18, 
		RULE_createTable = 19, RULE_createTablespaceInnodb = 20, RULE_createTablespaceNdb = 21, 
		RULE_createTrigger = 22, RULE_createView = 23, RULE_createDatabaseOption = 24, 
		RULE_ownerStatement = 25, RULE_scheduleExpression = 26, RULE_timestampValue = 27, 
		RULE_intervalExpr = 28, RULE_intervalType = 29, RULE_enableType = 30, 
		RULE_indexType = 31, RULE_indexOption = 32, RULE_procedureParameter = 33, 
		RULE_functionParameter = 34, RULE_routineOption = 35, RULE_serverOption = 36, 
		RULE_createDefinitions = 37, RULE_createDefinition = 38, RULE_columnDefinition = 39, 
		RULE_columnConstraint = 40, RULE_tableConstraint = 41, RULE_referenceDefinition = 42, 
		RULE_referenceAction = 43, RULE_referenceControlType = 44, RULE_indexColumnDefinition = 45, 
		RULE_tableOption = 46, RULE_tablespaceStorage = 47, RULE_partitionDefinitions = 48, 
		RULE_partitionFunctionDefinition = 49, RULE_subpartitionFunctionDefinition = 50, 
		RULE_partitionDefinition = 51, RULE_partitionDefinerAtom = 52, RULE_partitionDefinerVector = 53, 
		RULE_subpartitionDefinition = 54, RULE_partitionOption = 55, RULE_alterDatabase = 56, 
		RULE_alterEvent = 57, RULE_alterFunction = 58, RULE_alterInstance = 59, 
		RULE_alterLogfileGroup = 60, RULE_alterProcedure = 61, RULE_alterServer = 62, 
		RULE_alterTable = 63, RULE_alterTablespace = 64, RULE_alterView = 65, 
		RULE_alterSpecification = 66, RULE_dropDatabase = 67, RULE_dropEvent = 68, 
		RULE_dropIndex = 69, RULE_dropLogfileGroup = 70, RULE_dropProcedure = 71, 
		RULE_dropFunction = 72, RULE_dropServer = 73, RULE_dropTable = 74, RULE_dropTablespace = 75, 
		RULE_dropTrigger = 76, RULE_dropView = 77, RULE_renameTable = 78, RULE_renameTableClause = 79, 
		RULE_truncateTable = 80, RULE_callStatement = 81, RULE_deleteStatement = 82, 
		RULE_doStatement = 83, RULE_handlerStatement = 84, RULE_insertStatement = 85, 
		RULE_loadDataStatement = 86, RULE_loadXmlStatement = 87, RULE_replaceStatement = 88, 
		RULE_selectStatement = 89, RULE_updateStatement = 90, RULE_insertStatementValue = 91, 
		RULE_updatedElement = 92, RULE_assignmentField = 93, RULE_lockClause = 94, 
		RULE_singleDeleteStatement = 95, RULE_multipleDeleteStatement = 96, RULE_handlerOpenStatement = 97, 
		RULE_handlerReadIndexStatement = 98, RULE_handlerReadStatement = 99, RULE_handlerCloseStatement = 100, 
		RULE_singleUpdateStatement = 101, RULE_multipleUpdateStatement = 102, 
		RULE_orderByClause = 103, RULE_orderByExpression = 104, RULE_tableSources = 105, 
		RULE_tableSource = 106, RULE_tableSourceItem = 107, RULE_indexHint = 108, 
		RULE_indexHintType = 109, RULE_joinPart = 110, RULE_queryExpression = 111, 
		RULE_queryExpressionNointo = 112, RULE_querySpecification = 113, RULE_querySpecificationNointo = 114, 
		RULE_unionParenthesis = 115, RULE_unionStatement = 116, RULE_selectSpec = 117, 
		RULE_selectElements = 118, RULE_selectElement = 119, RULE_selectIntoExpression = 120, 
		RULE_selectFieldsInto = 121, RULE_selectLinesInto = 122, RULE_fromClause = 123, 
		RULE_groupByItem = 124, RULE_limitClause = 125, RULE_limitClauseAtom = 126, 
		RULE_startTransaction = 127, RULE_beginWork = 128, RULE_commitWork = 129, 
		RULE_rollbackWork = 130, RULE_savepointStatement = 131, RULE_rollbackStatement = 132, 
		RULE_releaseStatement = 133, RULE_lockTables = 134, RULE_unlockTables = 135, 
		RULE_setAutocommitStatement = 136, RULE_setTransactionStatement = 137, 
		RULE_transactionMode = 138, RULE_lockTableElement = 139, RULE_lockAction = 140, 
		RULE_transactionOption = 141, RULE_transactionLevel = 142, RULE_changeMaster = 143, 
		RULE_changeReplicationFilter = 144, RULE_purgeBinaryLogs = 145, RULE_resetMaster = 146, 
		RULE_resetSlave = 147, RULE_startSlave = 148, RULE_stopSlave = 149, RULE_startGroupReplication = 150, 
		RULE_stopGroupReplication = 151, RULE_masterOption = 152, RULE_stringMasterOption = 153, 
		RULE_decimalMasterOption = 154, RULE_boolMasterOption = 155, RULE_channelOption = 156, 
		RULE_replicationFilter = 157, RULE_tablePair = 158, RULE_threadType = 159, 
		RULE_untilOption = 160, RULE_connectionOption = 161, RULE_gtuidSet = 162, 
		RULE_xaStartTransaction = 163, RULE_xaEndTransaction = 164, RULE_xaPrepareStatement = 165, 
		RULE_xaCommitWork = 166, RULE_xaRollbackWork = 167, RULE_xaRecoverWork = 168, 
		RULE_prepareStatement = 169, RULE_executeStatement = 170, RULE_deallocatePrepare = 171, 
		RULE_routineBody = 172, RULE_blockStatement = 173, RULE_caseStatement = 174, 
		RULE_ifStatement = 175, RULE_iterateStatement = 176, RULE_leaveStatement = 177, 
		RULE_loopStatement = 178, RULE_repeatStatement = 179, RULE_returnStatement = 180, 
		RULE_whileStatement = 181, RULE_cursorStatement = 182, RULE_declareVariable = 183, 
		RULE_declareCondition = 184, RULE_declareCursor = 185, RULE_declareHandler = 186, 
		RULE_handlerConditionValue = 187, RULE_procedureSqlStatement = 188, RULE_caseAlternative = 189, 
		RULE_elifAlternative = 190, RULE_alterUser = 191, RULE_createUser = 192, 
		RULE_dropUser = 193, RULE_grantStatement = 194, RULE_grantProxy = 195, 
		RULE_renameUser = 196, RULE_revokeStatement = 197, RULE_revokeProxy = 198, 
		RULE_setPasswordStatement = 199, RULE_userSpecification = 200, RULE_userAuthOption = 201, 
		RULE_tlsOption = 202, RULE_userResourceOption = 203, RULE_userPasswordOption = 204, 
		RULE_userLockOption = 205, RULE_privelegeClause = 206, RULE_privilege = 207, 
		RULE_privilegeLevel = 208, RULE_renameUserClause = 209, RULE_analyzeTable = 210, 
		RULE_checkTable = 211, RULE_checksumTable = 212, RULE_optimizeTable = 213, 
		RULE_repairTable = 214, RULE_checkTableOption = 215, RULE_createUdfunction = 216, 
		RULE_installPlugin = 217, RULE_uninstallPlugin = 218, RULE_setStatement = 219, 
		RULE_showStatement = 220, RULE_variableClause = 221, RULE_showCommonEntity = 222, 
		RULE_showFilter = 223, RULE_showGlobalInfoClause = 224, RULE_showSchemaEntity = 225, 
		RULE_showProfileType = 226, RULE_binlogStatement = 227, RULE_cacheIndexStatement = 228, 
		RULE_flushStatement = 229, RULE_killStatement = 230, RULE_loadIndexIntoCache = 231, 
		RULE_resetStatement = 232, RULE_shutdownStatement = 233, RULE_tableIndexes = 234, 
		RULE_flushOption = 235, RULE_flushTableOption = 236, RULE_loadedTableIndexes = 237, 
		RULE_simpleDescribeStatement = 238, RULE_fullDescribeStatement = 239, 
		RULE_helpStatement = 240, RULE_useStatement = 241, RULE_signalStatement = 242, 
		RULE_signalConditionInformation = 243, RULE_describeObjectClause = 244, 
		RULE_fullId = 245, RULE_tableName = 246, RULE_fullColumnName = 247, RULE_indexColumnName = 248, 
		RULE_userName = 249, RULE_mysqlVariable = 250, RULE_charsetName = 251, 
		RULE_collationName = 252, RULE_engineName = 253, RULE_uuidSet = 254, RULE_xid = 255, 
		RULE_xuidStringId = 256, RULE_authPlugin = 257, RULE_uid = 258, RULE_simpleId = 259, 
		RULE_dottedId = 260, RULE_decimalLiteral = 261, RULE_fileSizeLiteral = 262, 
		RULE_stringLiteral = 263, RULE_booleanLiteral = 264, RULE_hexadecimalLiteral = 265, 
		RULE_nullNotnull = 266, RULE_constant = 267, RULE_dataType = 268, RULE_collectionOptions = 269, 
		RULE_convertedDataType = 270, RULE_lengthOneDimension = 271, RULE_lengthTwoDimension = 272, 
		RULE_lengthTwoOptionalDimension = 273, RULE_uidList = 274, RULE_tables = 275, 
		RULE_indexColumnNames = 276, RULE_expressions = 277, RULE_expressionsWithDefaults = 278, 
		RULE_constants = 279, RULE_simpleStrings = 280, RULE_userVariables = 281, 
		RULE_defaultValue = 282, RULE_currentTimestamp = 283, RULE_expressionOrDefault = 284, 
		RULE_ifExists = 285, RULE_ifNotExists = 286, RULE_functionCall = 287, 
		RULE_specificFunction = 288, RULE_caseFuncAlternative = 289, RULE_levelsInWeightString = 290, 
		RULE_levelInWeightListElement = 291, RULE_aggregateWindowedFunction = 292, 
		RULE_scalarFunctionName = 293, RULE_passwordFunctionClause = 294, RULE_functionArgs = 295, 
		RULE_functionArg = 296, RULE_expression = 297, RULE_predicate = 298, RULE_expressionAtom = 299, 
		RULE_unaryOperator = 300, RULE_comparisonOperator = 301, RULE_logicalOperator = 302, 
		RULE_bitOperator = 303, RULE_mathOperator = 304, RULE_charsetNameBase = 305, 
		RULE_transactionLevelBase = 306, RULE_privilegesBase = 307, RULE_intervalTypeBase = 308, 
		RULE_dataTypeBase = 309, RULE_keywordsCanBeId = 310, RULE_functionNameBase = 311;
	public static readonly string[] ruleNames = {
		"root", "sqlStatements", "sqlStatement", "emptyStatement", "ddlStatement", 
		"dmlStatement", "transactionStatement", "replicationStatement", "preparedStatement", 
		"compoundStatement", "administrationStatement", "utilityStatement", "createDatabase", 
		"createEvent", "createIndex", "createLogfileGroup", "createProcedure", 
		"createFunction", "createServer", "createTable", "createTablespaceInnodb", 
		"createTablespaceNdb", "createTrigger", "createView", "createDatabaseOption", 
		"ownerStatement", "scheduleExpression", "timestampValue", "intervalExpr", 
		"intervalType", "enableType", "indexType", "indexOption", "procedureParameter", 
		"functionParameter", "routineOption", "serverOption", "createDefinitions", 
		"createDefinition", "columnDefinition", "columnConstraint", "tableConstraint", 
		"referenceDefinition", "referenceAction", "referenceControlType", "indexColumnDefinition", 
		"tableOption", "tablespaceStorage", "partitionDefinitions", "partitionFunctionDefinition", 
		"subpartitionFunctionDefinition", "partitionDefinition", "partitionDefinerAtom", 
		"partitionDefinerVector", "subpartitionDefinition", "partitionOption", 
		"alterDatabase", "alterEvent", "alterFunction", "alterInstance", "alterLogfileGroup", 
		"alterProcedure", "alterServer", "alterTable", "alterTablespace", "alterView", 
		"alterSpecification", "dropDatabase", "dropEvent", "dropIndex", "dropLogfileGroup", 
		"dropProcedure", "dropFunction", "dropServer", "dropTable", "dropTablespace", 
		"dropTrigger", "dropView", "renameTable", "renameTableClause", "truncateTable", 
		"callStatement", "deleteStatement", "doStatement", "handlerStatement", 
		"insertStatement", "loadDataStatement", "loadXmlStatement", "replaceStatement", 
		"selectStatement", "updateStatement", "insertStatementValue", "updatedElement", 
		"assignmentField", "lockClause", "singleDeleteStatement", "multipleDeleteStatement", 
		"handlerOpenStatement", "handlerReadIndexStatement", "handlerReadStatement", 
		"handlerCloseStatement", "singleUpdateStatement", "multipleUpdateStatement", 
		"orderByClause", "orderByExpression", "tableSources", "tableSource", "tableSourceItem", 
		"indexHint", "indexHintType", "joinPart", "queryExpression", "queryExpressionNointo", 
		"querySpecification", "querySpecificationNointo", "unionParenthesis", 
		"unionStatement", "selectSpec", "selectElements", "selectElement", "selectIntoExpression", 
		"selectFieldsInto", "selectLinesInto", "fromClause", "groupByItem", "limitClause", 
		"limitClauseAtom", "startTransaction", "beginWork", "commitWork", "rollbackWork", 
		"savepointStatement", "rollbackStatement", "releaseStatement", "lockTables", 
		"unlockTables", "setAutocommitStatement", "setTransactionStatement", "transactionMode", 
		"lockTableElement", "lockAction", "transactionOption", "transactionLevel", 
		"changeMaster", "changeReplicationFilter", "purgeBinaryLogs", "resetMaster", 
		"resetSlave", "startSlave", "stopSlave", "startGroupReplication", "stopGroupReplication", 
		"masterOption", "stringMasterOption", "decimalMasterOption", "boolMasterOption", 
		"channelOption", "replicationFilter", "tablePair", "threadType", "untilOption", 
		"connectionOption", "gtuidSet", "xaStartTransaction", "xaEndTransaction", 
		"xaPrepareStatement", "xaCommitWork", "xaRollbackWork", "xaRecoverWork", 
		"prepareStatement", "executeStatement", "deallocatePrepare", "routineBody", 
		"blockStatement", "caseStatement", "ifStatement", "iterateStatement", 
		"leaveStatement", "loopStatement", "repeatStatement", "returnStatement", 
		"whileStatement", "cursorStatement", "declareVariable", "declareCondition", 
		"declareCursor", "declareHandler", "handlerConditionValue", "procedureSqlStatement", 
		"caseAlternative", "elifAlternative", "alterUser", "createUser", "dropUser", 
		"grantStatement", "grantProxy", "renameUser", "revokeStatement", "revokeProxy", 
		"setPasswordStatement", "userSpecification", "userAuthOption", "tlsOption", 
		"userResourceOption", "userPasswordOption", "userLockOption", "privelegeClause", 
		"privilege", "privilegeLevel", "renameUserClause", "analyzeTable", "checkTable", 
		"checksumTable", "optimizeTable", "repairTable", "checkTableOption", "createUdfunction", 
		"installPlugin", "uninstallPlugin", "setStatement", "showStatement", "variableClause", 
		"showCommonEntity", "showFilter", "showGlobalInfoClause", "showSchemaEntity", 
		"showProfileType", "binlogStatement", "cacheIndexStatement", "flushStatement", 
		"killStatement", "loadIndexIntoCache", "resetStatement", "shutdownStatement", 
		"tableIndexes", "flushOption", "flushTableOption", "loadedTableIndexes", 
		"simpleDescribeStatement", "fullDescribeStatement", "helpStatement", "useStatement", 
		"signalStatement", "signalConditionInformation", "describeObjectClause", 
		"fullId", "tableName", "fullColumnName", "indexColumnName", "userName", 
		"mysqlVariable", "charsetName", "collationName", "engineName", "uuidSet", 
		"xid", "xuidStringId", "authPlugin", "uid", "simpleId", "dottedId", "decimalLiteral", 
		"fileSizeLiteral", "stringLiteral", "booleanLiteral", "hexadecimalLiteral", 
		"nullNotnull", "constant", "dataType", "collectionOptions", "convertedDataType", 
		"lengthOneDimension", "lengthTwoDimension", "lengthTwoOptionalDimension", 
		"uidList", "tables", "indexColumnNames", "expressions", "expressionsWithDefaults", 
		"constants", "simpleStrings", "userVariables", "defaultValue", "currentTimestamp", 
		"expressionOrDefault", "ifExists", "ifNotExists", "functionCall", "specificFunction", 
		"caseFuncAlternative", "levelsInWeightString", "levelInWeightListElement", 
		"aggregateWindowedFunction", "scalarFunctionName", "passwordFunctionClause", 
		"functionArgs", "functionArg", "expression", "predicate", "expressionAtom", 
		"unaryOperator", "comparisonOperator", "logicalOperator", "bitOperator", 
		"mathOperator", "charsetNameBase", "transactionLevelBase", "privilegesBase", 
		"intervalTypeBase", "dataTypeBase", "keywordsCanBeId", "functionNameBase"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, null, "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", 
		"'ANALYZE'", "'AND'", "'AS'", "'ASC'", "'BEFORE'", "'BETWEEN'", "'BOTH'", 
		"'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'", "'CHANGE'", "'CHARACTER'", 
		"'CHECK'", "'COLLATE'", "'COLUMN'", "'CONDITION'", "'CONSTRAINT'", "'CONTINUE'", 
		"'CONVERT'", "'CREATE'", "'CROSS'", "'CURRENT_USER'", "'CURSOR'", "'DATABASE'", 
		"'DATABASES'", "'DECLARE'", "'DEFAULT'", "'DELAYED'", "'DELETE'", "'DESC'", 
		"'DESCRIBE'", "'DETERMINISTIC'", "'DISTINCT'", "'DISTINCTROW'", "'DROP'", 
		"'EACH'", "'ELSE'", "'ELSEIF'", "'ENCLOSED'", "'ESCAPED'", "'EXISTS'", 
		"'EXIT'", "'EXPLAIN'", "'FALSE'", "'FETCH'", "'FOR'", "'FORCE'", "'FOREIGN'", 
		"'FROM'", "'FULLTEXT'", "'GENERATED'", "'GRANT'", "'GROUP'", "'HAVING'", 
		"'HIGH_PRIORITY'", "'IF'", "'IGNORE'", "'IN'", "'INDEX'", "'INFILE'", 
		"'INNER'", "'INOUT'", "'INSERT'", "'INTERVAL'", "'INTO'", "'IS'", "'ITERATE'", 
		"'JOIN'", "'KEY'", "'KEYS'", "'KILL'", "'LEADING'", "'LEAVE'", "'LEFT'", 
		"'LIKE'", "'LIMIT'", "'LINEAR'", "'LINES'", "'LOAD'", "'LOCK'", "'LOOP'", 
		"'LOW_PRIORITY'", "'MASTER_BIND'", "'MASTER_SSL_VERIFY_SERVER_CERT'", 
		"'MATCH'", "'MAXVALUE'", "'MODIFIES'", "'NATURAL'", "'NOT'", "'NO_WRITE_TO_BINLOG'", 
		"'NULL'", "'ON'", "'OPTIMIZE'", "'OPTION'", "'OPTIONALLY'", "'OR'", "'ORDER'", 
		"'OUT'", "'OUTER'", "'OUTFILE'", "'PARTITION'", "'PRIMARY'", "'PROCEDURE'", 
		"'PURGE'", "'RANGE'", "'READ'", "'READS'", "'REFERENCES'", "'REGEXP'", 
		"'RELEASE'", "'RENAME'", "'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESTRICT'", 
		"'RETURN'", "'REVOKE'", "'RIGHT'", "'RLIKE'", "'SCHEMA'", "'SCHEMAS'", 
		"'SELECT'", "'SET'", "'SEPARATOR'", "'SHOW'", "'SIGNAL'", "'SPATIAL'", 
		"'SQL'", "'SQLEXCEPTION'", "'SQLSTATE'", "'SQLWARNING'", "'SQL_BIG_RESULT'", 
		"'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'", "'SSL'", "'STARTING'", 
		"'STRAIGHT_JOIN'", "'TABLE'", "'TERMINATED'", "'THEN'", "'TO'", "'TRAILING'", 
		"'TRIGGER'", "'TRUE'", "'UNDO'", "'UNION'", "'UNIQUE'", "'UNLOCK'", "'UNSIGNED'", 
		"'UPDATE'", "'USAGE'", "'USE'", "'USING'", "'VALUES'", "'WHEN'", "'WHERE'", 
		"'WHILE'", "'WITH'", "'WRITE'", "'XOR'", "'ZEROFILL'", "'TINYINT'", "'SMALLINT'", 
		"'MEDIUMINT'", "'INT'", "'INTEGER'", "'BIGINT'", "'REAL'", "'DOUBLE'", 
		"'PRECISION'", "'FLOAT'", "'DECIMAL'", "'DEC'", "'NUMERIC'", "'DATE'", 
		"'TIME'", "'TIMESTAMP'", "'DATETIME'", "'YEAR'", "'CHAR'", "'VARCHAR'", 
		"'NVARCHAR'", "'NATIONAL'", "'BINARY'", "'VARBINARY'", "'TINYBLOB'", "'BLOB'", 
		"'MEDIUMBLOB'", "'LONGBLOB'", "'TINYTEXT'", "'TEXT'", "'MEDIUMTEXT'", 
		"'LONGTEXT'", "'ENUM'", "'VARYING'", "'SERIAL'", "'YEAR_MONTH'", "'DAY_HOUR'", 
		"'DAY_MINUTE'", "'DAY_SECOND'", "'HOUR_MINUTE'", "'HOUR_SECOND'", "'MINUTE_SECOND'", 
		"'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'", "'HOUR_MICROSECOND'", 
		"'DAY_MICROSECOND'", "'AVG'", "'BIT_AND'", "'BIT_OR'", "'BIT_XOR'", "'COUNT'", 
		"'GROUP_CONCAT'", "'MAX'", "'MIN'", "'STD'", "'STDDEV'", "'STDDEV_POP'", 
		"'STDDEV_SAMP'", "'SUM'", "'VAR_POP'", "'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'", 
		"'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'LOCALTIME'", "'CURDATE'", "'CURTIME'", 
		"'DATE_ADD'", "'DATE_SUB'", "'EXTRACT'", "'LOCALTIMESTAMP'", "'NOW'", 
		"'POSITION'", "'SUBSTR'", "'SUBSTRING'", "'SYSDATE'", "'TRIM'", "'UTC_DATE'", 
		"'UTC_TIME'", "'UTC_TIMESTAMP'", "'ACCOUNT'", "'ACTION'", "'AFTER'", "'AGGREGATE'", 
		"'ALGORITHM'", "'ANY'", "'AT'", "'AUTHORS'", "'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", 
		"'AUTO_INCREMENT'", "'AVG_ROW_LENGTH'", "'BEGIN'", "'BINLOG'", "'BIT'", 
		"'BLOCK'", "'BOOL'", "'BOOLEAN'", "'BTREE'", "'CACHE'", "'CASCADED'", 
		"'CHAIN'", "'CHANGED'", "'CHANNEL'", "'CHECKSUM'", "'PAGE_CHECKSUM'", 
		"'CIPHER'", "'CLASS_ORIGIN'", "'CLIENT'", "'CLOSE'", "'COALESCE'", "'CODE'", 
		"'COLUMNS'", "'COLUMN_FORMAT'", "'COLUMN_NAME'", "'COMMENT'", "'COMMIT'", 
		"'COMPACT'", "'COMPLETION'", "'COMPRESSED'", "'COMPRESSION'", "'CONCURRENT'", 
		"'CONNECTION'", "'CONSISTENT'", "'CONSTRAINT_CATALOG'", "'CONSTRAINT_SCHEMA'", 
		"'CONSTRAINT_NAME'", "'CONTAINS'", "'CONTEXT'", "'CONTRIBUTORS'", "'COPY'", 
		"'CPU'", "'DATA'", "'DATAFILE'", "'DEALLOCATE'", "'DEFAULT_AUTH'", "'DEFINER'", 
		"'DELAY_KEY_WRITE'", "'DES_KEY_FILE'", "'DIRECTORY'", "'DISABLE'", "'DISCARD'", 
		"'DISK'", "'DO'", "'DUMPFILE'", "'DUPLICATE'", "'DYNAMIC'", "'ENABLE'", 
		"'ENCRYPTION'", "'END'", "'ENDS'", "'ENGINE'", "'ENGINES'", "'ERROR'", 
		"'ERRORS'", "'ESCAPE'", "'EVEN'", "'EVENT'", "'EVENTS'", "'EVERY'", "'EXCHANGE'", 
		"'EXCLUSIVE'", "'EXPIRE'", "'EXPORT'", "'EXTENDED'", "'EXTENT_SIZE'", 
		"'FAST'", "'FAULTS'", "'FIELDS'", "'FILE_BLOCK_SIZE'", "'FILTER'", "'FIRST'", 
		"'FIXED'", "'FLUSH'", "'FOLLOWS'", "'FOUND'", "'FULL'", "'FUNCTION'", 
		"'GENERAL'", "'GLOBAL'", "'GRANTS'", "'GROUP_REPLICATION'", "'HANDLER'", 
		"'HASH'", "'HELP'", "'HOST'", "'HOSTS'", "'IDENTIFIED'", "'IGNORE_SERVER_IDS'", 
		"'IMPORT'", "'INDEXES'", "'INITIAL_SIZE'", "'INPLACE'", "'INSERT_METHOD'", 
		"'INSTALL'", "'INSTANCE'", "'INVISIBLE'", "'INVOKER'", "'IO'", "'IO_THREAD'", 
		"'IPC'", "'ISOLATION'", "'ISSUER'", "'JSON'", "'KEY_BLOCK_SIZE'", "'LANGUAGE'", 
		"'LAST'", "'LEAVES'", "'LESS'", "'LEVEL'", "'LIST'", "'LOCAL'", "'LOGFILE'", 
		"'LOGS'", "'MASTER'", "'MASTER_AUTO_POSITION'", "'MASTER_CONNECT_RETRY'", 
		"'MASTER_DELAY'", "'MASTER_HEARTBEAT_PERIOD'", "'MASTER_HOST'", "'MASTER_LOG_FILE'", 
		"'MASTER_LOG_POS'", "'MASTER_PASSWORD'", "'MASTER_PORT'", "'MASTER_RETRY_COUNT'", 
		"'MASTER_SSL'", "'MASTER_SSL_CA'", "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'", 
		"'MASTER_SSL_CIPHER'", "'MASTER_SSL_CRL'", "'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'", 
		"'MASTER_TLS_VERSION'", "'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'", 
		"'MAX_QUERIES_PER_HOUR'", "'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'", 
		"'MAX_USER_CONNECTIONS'", "'MEDIUM'", "'MERGE'", "'MESSAGE_TEXT'", "'MID'", 
		"'MIGRATE'", "'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'", "'MYSQL'", 
		"'MYSQL_ERRNO'", "'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'", "'NEXT'", 
		"'NO'", "'NODEGROUP'", "'NONE'", "'OFFLINE'", "'OFFSET'", "'OJ'", "'OLD_PASSWORD'", 
		"'ONE'", "'ONLINE'", "'ONLY'", "'OPEN'", "'OPTIMIZER_COSTS'", "'OPTIONS'", 
		"'OWNER'", "'PACK_KEYS'", "'PAGE'", "'PARSER'", "'PARTIAL'", "'PARTITIONING'", 
		"'PARTITIONS'", "'PASSWORD'", "'PHASE'", "'PLUGIN'", "'PLUGIN_DIR'", "'PLUGINS'", 
		"'PORT'", "'PRECEDES'", "'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'", 
		"'PROFILE'", "'PROFILES'", "'PROXY'", "'QUERY'", "'QUICK'", "'REBUILD'", 
		"'RECOVER'", "'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'", "'RELAY_LOG_FILE'", 
		"'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'", "'REPAIR'", 
		"'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'", 
		"'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'", 
		"'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'", "'RESET'", "'RESUME'", 
		"'RETURNS'", "'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", 
		"'ROW_FORMAT'", "'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", "'SERVER'", 
		"'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", "'SIMPLE'", "'SLAVE'", 
		"'SLOW'", "'SNAPSHOT'", "'SOCKET'", "'SOME'", "'SONAME'", "'SOUNDS'", 
		"'SOURCE'", "'SQL_AFTER_GTIDS'", "'SQL_AFTER_MTS_GAPS'", "'SQL_BEFORE_GTIDS'", 
		"'SQL_BUFFER_RESULT'", "'SQL_CACHE'", "'SQL_NO_CACHE'", "'SQL_THREAD'", 
		"'START'", "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'", "'STATS_SAMPLE_PAGES'", 
		"'STATUS'", "'STOP'", "'STORAGE'", "'STORED'", "'STRING'", "'SUBCLASS_ORIGIN'", 
		"'SUBJECT'", "'SUBPARTITION'", "'SUBPARTITIONS'", "'SUSPEND'", "'SWAPS'", 
		"'SWITCHES'", "'TABLE_NAME'", "'TABLESPACE'", "'TEMPORARY'", "'TEMPTABLE'", 
		"'THAN'", "'TRADITIONAL'", "'TRANSACTION'", "'TRIGGERS'", "'TRUNCATE'", 
		"'UNDEFINED'", "'UNDOFILE'", "'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'", 
		"'UNTIL'", "'UPGRADE'", "'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'", 
		"'VALUE'", "'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'", 
		"'WARNINGS'", "'WITHOUT'", "'WORK'", "'WRAPPER'", "'X509'", "'XA'", "'XML'", 
		"'EUR'", "'USA'", "'JIS'", "'ISO'", "'INTERNAL'", "'QUARTER'", "'MONTH'", 
		"'DAY'", "'HOUR'", "'MINUTE'", "'WEEK'", "'SECOND'", "'MICROSECOND'", 
		"'TABLES'", "'ROUTINE'", "'EXECUTE'", "'FILE'", "'PROCESS'", "'RELOAD'", 
		"'SHUTDOWN'", "'SUPER'", "'PRIVILEGES'", null, "'ARMSCII8'", "'ASCII'", 
		"'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", "'CP1257'", "'CP850'", "'CP852'", 
		"'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'", "'EUCKR'", "'GB2312'", "'GBK'", 
		"'GEOSTD8'", "'GREEK'", "'HEBREW'", "'HP8'", "'KEYBCS2'", "'KOI8R'", "'KOI8U'", 
		"'LATIN1'", "'LATIN2'", "'LATIN5'", "'LATIN7'", "'MACCE'", "'MACROMAN'", 
		"'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'", "'UTF16'", "'UTF16LE'", 
		"'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'", "'ARCHIVE'", "'BLACKHOLE'", 
		"'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'", "'MRG_MYISAM'", "'MYISAM'", 
		"'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'", "'TOKUDB'", "'REPEATABLE'", 
		"'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'", "'GEOMETRYCOLLECTION'", 
		"'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'", "'MULTILINESTRING'", 
		"'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'", "'ABS'", "'ACOS'", 
		"'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'", "'AREA'", 
		"'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'", "'ASYMMETRIC_DECRYPT'", 
		"'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'", "'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", 
		"'ATAN'", "'ATAN2'", "'BENCHMARK'", "'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", 
		"'BUFFER'", "'CATALOG_NAME'", "'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", 
		"'CHARSET'", "'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", 
		"'CONCAT'", "'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", 
		"'COS'", "'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'", 
		"'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'", 
		"'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'", 
		"'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'", 
		"'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENVELOPE'", 
		"'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'", "'EXTRACTVALUE'", 
		"'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'", "'FOUND_ROWS'", "'FROM_BASE64'", 
		"'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'", "'GEOMCOLLFROMWKB'", 
		"'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'", "'GEOMETRYFROMTEXT'", 
		"'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'", "'GEOMFROMTEXT'", 
		"'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'", "'GREATEST'", 
		"'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'", "'INET6_ATON'", 
		"'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'", "'INTERIORRINGN'", 
		"'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'", "'ISSIMPLE'", "'IS_FREE_LOCK'", 
		"'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'", "'IS_IPV6'", "'IS_USED_LOCK'", 
		"'LAST_INSERT_ID'", "'LCASE'", "'LEAST'", "'LENGTH'", "'LINEFROMTEXT'", 
		"'LINEFROMWKB'", "'LINESTRINGFROMTEXT'", "'LINESTRINGFROMWKB'", "'LN'", 
		"'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'", "'LOG2'", "'LOWER'", "'LPAD'", 
		"'LTRIM'", "'MAKEDATE'", "'MAKETIME'", "'MAKE_SET'", "'MASTER_POS_WAIT'", 
		"'MBRCONTAINS'", "'MBRDISJOINT'", "'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", 
		"'MBRTOUCHES'", "'MBRWITHIN'", "'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'", 
		"'MONTHNAME'", "'MPOINTFROMTEXT'", "'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", 
		"'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'", "'MULTILINESTRINGFROMWKB'", 
		"'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'", "'MULTIPOLYGONFROMTEXT'", 
		"'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'", "'NUMGEOMETRIES'", 
		"'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'", "'ORD'", 
		"'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'", 
		"'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'", 
		"'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'", 
		"'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'", "'ROW_COUNT'", 
		"'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SESSION_USER'", "'SHA'", "'SHA1'", 
		"'SHA2'", "'SCHEMA_NAME'", "'SIGN'", "'SIN'", "'SLEEP'", "'SOUNDEX'", 
		"'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'", "'SRID'", "'STARTPOINT'", "'STRCMP'", 
		"'STR_TO_DATE'", "'ST_AREA'", "'ST_ASBINARY'", "'ST_ASTEXT'", "'ST_ASWKB'", 
		"'ST_ASWKT'", "'ST_BUFFER'", "'ST_CENTROID'", "'ST_CONTAINS'", "'ST_CROSSES'", 
		"'ST_DIFFERENCE'", "'ST_DIMENSION'", "'ST_DISJOINT'", "'ST_DISTANCE'", 
		"'ST_ENDPOINT'", "'ST_ENVELOPE'", "'ST_EQUALS'", "'ST_EXTERIORRING'", 
		"'ST_GEOMCOLLFROMTEXT'", "'ST_GEOMCOLLFROMTXT'", "'ST_GEOMCOLLFROMWKB'", 
		"'ST_GEOMETRYCOLLECTIONFROMTEXT'", "'ST_GEOMETRYCOLLECTIONFROMWKB'", "'ST_GEOMETRYFROMTEXT'", 
		"'ST_GEOMETRYFROMWKB'", "'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", "'ST_GEOMFROMTEXT'", 
		"'ST_GEOMFROMWKB'", "'ST_INTERIORRINGN'", "'ST_INTERSECTION'", "'ST_INTERSECTS'", 
		"'ST_ISCLOSED'", "'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", 
		"'ST_LINEFROMWKB'", "'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", 
		"'ST_NUMGEOMETRIES'", "'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", 
		"'ST_NUMPOINTS'", "'ST_OVERLAPS'", "'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'", 
		"'ST_POINTN'", "'ST_POLYFROMTEXT'", "'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", 
		"'ST_POLYGONFROMWKB'", "'ST_SRID'", "'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", 
		"'ST_TOUCHES'", "'ST_UNION'", "'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'", 
		"'SUBSTRING_INDEX'", "'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", 
		"'TIMESTAMPADD'", "'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", 
		"'TOUCHES'", "'TO_BASE64'", "'TO_DAYS'", "'TO_SECONDS'", "'UCASE'", "'UNCOMPRESS'", 
		"'UNCOMPRESSED_LENGTH'", "'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'", 
		"'UPPER'", "'UUID'", "'UUID_SHORT'", "'VALIDATE_PASSWORD_STRENGTH'", "'VERSION'", 
		"'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'", "'WEEKDAY'", "'WEEKOFYEAR'", "'WEIGHT_STRING'", 
		"'WITHIN'", "'YEARWEEK'", "'Y'", "'X'", "':='", "'+='", "'-='", "'*='", 
		"'/='", "'%='", "'&='", "'^='", "'|='", "'*'", "'/'", "'%'", "'+'", "'--'", 
		"'-'", "'DIV'", "'MOD'", "'='", "'>'", "'<'", "'!'", "'~'", "'|'", "'&'", 
		"'^'", "'.'", "'('", "')'", "','", "';'", "'@'", "'0'", "'1'", "'2'", 
		"'''", "'\"'", "'`'", "':'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT", 
		"ADD", "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "AS", "ASC", "BEFORE", 
		"BETWEEN", "BOTH", "BY", "CALL", "CASCADE", "CASE", "CAST", "CHANGE", 
		"CHARACTER", "CHECK", "COLLATE", "COLUMN", "CONDITION", "CONSTRAINT", 
		"CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT_USER", "CURSOR", "DATABASE", 
		"DATABASES", "DECLARE", "DEFAULT", "DELAYED", "DELETE", "DESC", "DESCRIBE", 
		"DETERMINISTIC", "DISTINCT", "DISTINCTROW", "DROP", "EACH", "ELSE", "ELSEIF", 
		"ENCLOSED", "ESCAPED", "EXISTS", "EXIT", "EXPLAIN", "FALSE", "FETCH", 
		"FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", "GENERATED", "GRANT", "GROUP", 
		"HAVING", "HIGH_PRIORITY", "IF", "IGNORE", "IN", "INDEX", "INFILE", "INNER", 
		"INOUT", "INSERT", "INTERVAL", "INTO", "IS", "ITERATE", "JOIN", "KEY", 
		"KEYS", "KILL", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR", 
		"LINES", "LOAD", "LOCK", "LOOP", "LOW_PRIORITY", "MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT", 
		"MATCH", "MAXVALUE", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG", 
		"NULL_LITERAL", "ON", "OPTIMIZE", "OPTION", "OPTIONALLY", "OR", "ORDER", 
		"OUT", "OUTER", "OUTFILE", "PARTITION", "PRIMARY", "PROCEDURE", "PURGE", 
		"RANGE", "READ", "READS", "REFERENCES", "REGEXP", "RELEASE", "RENAME", 
		"REPEAT", "REPLACE", "REQUIRE", "RESTRICT", "RETURN", "REVOKE", "RIGHT", 
		"RLIKE", "SCHEMA", "SCHEMAS", "SELECT", "SET", "SEPARATOR", "SHOW", "SIGNAL", 
		"SPATIAL", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", 
		"SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT", "SSL", "STARTING", "STRAIGHT_JOIN", 
		"TABLE", "TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", "TRUE", "UNDO", 
		"UNION", "UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE", "USE", "USING", 
		"VALUES", "WHEN", "WHERE", "WHILE", "WITH", "WRITE", "XOR", "ZEROFILL", 
		"TINYINT", "SMALLINT", "MEDIUMINT", "INT", "INTEGER", "BIGINT", "REAL", 
		"DOUBLE", "PRECISION", "FLOAT", "DECIMAL", "DEC", "NUMERIC", "DATE", "TIME", 
		"TIMESTAMP", "DATETIME", "YEAR", "CHAR", "VARCHAR", "NVARCHAR", "NATIONAL", 
		"BINARY", "VARBINARY", "TINYBLOB", "BLOB", "MEDIUMBLOB", "LONGBLOB", "TINYTEXT", 
		"TEXT", "MEDIUMTEXT", "LONGTEXT", "ENUM", "VARYING", "SERIAL", "YEAR_MONTH", 
		"DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "HOUR_MINUTE", "HOUR_SECOND", 
		"MINUTE_SECOND", "SECOND_MICROSECOND", "MINUTE_MICROSECOND", "HOUR_MICROSECOND", 
		"DAY_MICROSECOND", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "COUNT", "GROUP_CONCAT", 
		"MAX", "MIN", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", 
		"VAR_SAMP", "VARIANCE", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", 
		"LOCALTIME", "CURDATE", "CURTIME", "DATE_ADD", "DATE_SUB", "EXTRACT", 
		"LOCALTIMESTAMP", "NOW", "POSITION", "SUBSTR", "SUBSTRING", "SYSDATE", 
		"TRIM", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "ACCOUNT", "ACTION", 
		"AFTER", "AGGREGATE", "ALGORITHM", "ANY", "AT", "AUTHORS", "AUTOCOMMIT", 
		"AUTOEXTEND_SIZE", "AUTO_INCREMENT", "AVG_ROW_LENGTH", "BEGIN", "BINLOG", 
		"BIT", "BLOCK", "BOOL", "BOOLEAN", "BTREE", "CACHE", "CASCADED", "CHAIN", 
		"CHANGED", "CHANNEL", "CHECKSUM", "PAGE_CHECKSUM", "CIPHER", "CLASS_ORIGIN", 
		"CLIENT", "CLOSE", "COALESCE", "CODE", "COLUMNS", "COLUMN_FORMAT", "COLUMN_NAME", 
		"COMMENT", "COMMIT", "COMPACT", "COMPLETION", "COMPRESSED", "COMPRESSION", 
		"CONCURRENT", "CONNECTION", "CONSISTENT", "CONSTRAINT_CATALOG", "CONSTRAINT_SCHEMA", 
		"CONSTRAINT_NAME", "CONTAINS", "CONTEXT", "CONTRIBUTORS", "COPY", "CPU", 
		"DATA", "DATAFILE", "DEALLOCATE", "DEFAULT_AUTH", "DEFINER", "DELAY_KEY_WRITE", 
		"DES_KEY_FILE", "DIRECTORY", "DISABLE", "DISCARD", "DISK", "DO", "DUMPFILE", 
		"DUPLICATE", "DYNAMIC", "ENABLE", "ENCRYPTION", "END", "ENDS", "ENGINE", 
		"ENGINES", "ERROR", "ERRORS", "ESCAPE", "EVEN", "EVENT", "EVENTS", "EVERY", 
		"EXCHANGE", "EXCLUSIVE", "EXPIRE", "EXPORT", "EXTENDED", "EXTENT_SIZE", 
		"FAST", "FAULTS", "FIELDS", "FILE_BLOCK_SIZE", "FILTER", "FIRST", "FIXED", 
		"FLUSH", "FOLLOWS", "FOUND", "FULL", "FUNCTION", "GENERAL", "GLOBAL", 
		"GRANTS", "GROUP_REPLICATION", "HANDLER", "HASH", "HELP", "HOST", "HOSTS", 
		"IDENTIFIED", "IGNORE_SERVER_IDS", "IMPORT", "INDEXES", "INITIAL_SIZE", 
		"INPLACE", "INSERT_METHOD", "INSTALL", "INSTANCE", "INVISIBLE", "INVOKER", 
		"IO", "IO_THREAD", "IPC", "ISOLATION", "ISSUER", "JSON", "KEY_BLOCK_SIZE", 
		"LANGUAGE", "LAST", "LEAVES", "LESS", "LEVEL", "LIST", "LOCAL", "LOGFILE", 
		"LOGS", "MASTER", "MASTER_AUTO_POSITION", "MASTER_CONNECT_RETRY", "MASTER_DELAY", 
		"MASTER_HEARTBEAT_PERIOD", "MASTER_HOST", "MASTER_LOG_FILE", "MASTER_LOG_POS", 
		"MASTER_PASSWORD", "MASTER_PORT", "MASTER_RETRY_COUNT", "MASTER_SSL", 
		"MASTER_SSL_CA", "MASTER_SSL_CAPATH", "MASTER_SSL_CERT", "MASTER_SSL_CIPHER", 
		"MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", "MASTER_SSL_KEY", "MASTER_TLS_VERSION", 
		"MASTER_USER", "MAX_CONNECTIONS_PER_HOUR", "MAX_QUERIES_PER_HOUR", "MAX_ROWS", 
		"MAX_SIZE", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS", "MEDIUM", 
		"MERGE", "MESSAGE_TEXT", "MID", "MIGRATE", "MIN_ROWS", "MODE", "MODIFY", 
		"MUTEX", "MYSQL", "MYSQL_ERRNO", "NAME", "NAMES", "NCHAR", "NEVER", "NEXT", 
		"NO", "NODEGROUP", "NONE", "OFFLINE", "OFFSET", "OJ", "OLD_PASSWORD", 
		"ONE", "ONLINE", "ONLY", "OPEN", "OPTIMIZER_COSTS", "OPTIONS", "OWNER", 
		"PACK_KEYS", "PAGE", "PARSER", "PARTIAL", "PARTITIONING", "PARTITIONS", 
		"PASSWORD", "PHASE", "PLUGIN", "PLUGIN_DIR", "PLUGINS", "PORT", "PRECEDES", 
		"PREPARE", "PRESERVE", "PREV", "PROCESSLIST", "PROFILE", "PROFILES", "PROXY", 
		"QUERY", "QUICK", "REBUILD", "RECOVER", "REDO_BUFFER_SIZE", "REDUNDANT", 
		"RELAY", "RELAY_LOG_FILE", "RELAY_LOG_POS", "RELAYLOG", "REMOVE", "REORGANIZE", 
		"REPAIR", "REPLICATE_DO_DB", "REPLICATE_DO_TABLE", "REPLICATE_IGNORE_DB", 
		"REPLICATE_IGNORE_TABLE", "REPLICATE_REWRITE_DB", "REPLICATE_WILD_DO_TABLE", 
		"REPLICATE_WILD_IGNORE_TABLE", "REPLICATION", "RESET", "RESUME", "RETURNS", 
		"ROLLBACK", "ROLLUP", "ROTATE", "ROW", "ROWS", "ROW_FORMAT", "SAVEPOINT", 
		"SCHEDULE", "SECURITY", "SERVER", "SESSION", "SHARE", "SHARED", "SIGNED", 
		"SIMPLE", "SLAVE", "SLOW", "SNAPSHOT", "SOCKET", "SOME", "SONAME", "SOUNDS", 
		"SOURCE", "SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS", "SQL_BEFORE_GTIDS", 
		"SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_NO_CACHE", "SQL_THREAD", "START", 
		"STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT", "STATS_SAMPLE_PAGES", 
		"STATUS", "STOP", "STORAGE", "STORED", "STRING", "SUBCLASS_ORIGIN", "SUBJECT", 
		"SUBPARTITION", "SUBPARTITIONS", "SUSPEND", "SWAPS", "SWITCHES", "TABLE_NAME", 
		"TABLESPACE", "TEMPORARY", "TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", 
		"TRIGGERS", "TRUNCATE", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE", "UNINSTALL", 
		"UNKNOWN", "UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES", "VALIDATION", 
		"VALUE", "VARIABLES", "VIEW", "VIRTUAL", "VISIBLE", "WAIT", "WARNINGS", 
		"WITHOUT", "WORK", "WRAPPER", "X509", "XA", "XML", "EUR", "USA", "JIS", 
		"ISO", "INTERNAL", "QUARTER", "MONTH", "DAY", "HOUR", "MINUTE", "WEEK", 
		"SECOND", "MICROSECOND", "TABLES", "ROUTINE", "EXECUTE", "FILE", "PROCESS", 
		"RELOAD", "SHUTDOWN", "SUPER", "PRIVILEGES", "SESSION_VARIABLES_ADMIN", 
		"ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256", "CP1257", "CP850", 
		"CP852", "CP866", "CP932", "DEC8", "EUCJPMS", "EUCKR", "GB2312", "GBK", 
		"GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", "KOI8R", "KOI8U", "LATIN1", 
		"LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN", "SJIS", "SWE7", "TIS620", 
		"UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32", "UTF8", "UTF8MB3", "UTF8MB4", 
		"ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED", "INNODB", "MEMORY", "MRG_MYISAM", 
		"MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA", "TOKUDB", "REPEATABLE", 
		"COMMITTED", "UNCOMMITTED", "SERIALIZABLE", "GEOMETRYCOLLECTION", "GEOMCOLLECTION", 
		"GEOMETRY", "LINESTRING", "MULTILINESTRING", "MULTIPOINT", "MULTIPOLYGON", 
		"POINT", "POLYGON", "ABS", "ACOS", "ADDDATE", "ADDTIME", "AES_DECRYPT", 
		"AES_ENCRYPT", "AREA", "ASBINARY", "ASIN", "ASTEXT", "ASWKB", "ASWKT", 
		"ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE", "ASYMMETRIC_ENCRYPT", "ASYMMETRIC_SIGN", 
		"ASYMMETRIC_VERIFY", "ATAN", "ATAN2", "BENCHMARK", "BIN", "BIT_COUNT", 
		"BIT_LENGTH", "BUFFER", "CATALOG_NAME", "CEIL", "CEILING", "CENTROID", 
		"CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH", "COERCIBILITY", "COLLATION", 
		"COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID", "CONV", "CONVERT_TZ", 
		"COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY", "CREATE_ASYMMETRIC_PUB_KEY", 
		"CREATE_DH_PARAMETERS", "CREATE_DIGEST", "CROSSES", "DATEDIFF", "DATE_FORMAT", 
		"DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "DECODE", "DEGREES", 
		"DES_DECRYPT", "DES_ENCRYPT", "DIMENSION", "DISJOINT", "ELT", "ENCODE", 
		"ENCRYPT", "ENDPOINT", "ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", "EXTERIORRING", 
		"EXTRACTVALUE", "FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", 
		"FROM_BASE64", "FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB", 
		"GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT", 
		"GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB", 
		"GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT", 
		"HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA", 
		"INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL", 
		"ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED", 
		"IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH", 
		"LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB", 
		"LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", 
		"LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS", 
		"MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES", 
		"MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT", 
		"MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT", 
		"MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB", "MULTIPOLYGONFROMTEXT", 
		"MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF", "NUMGEOMETRIES", "NUMINTERIORRINGS", 
		"NUMPOINTS", "OCT", "OCTET_LENGTH", "ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", 
		"PI", "POINTFROMTEXT", "POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", 
		"POLYGONFROMTEXT", "POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", 
		"RAND", "RANDOM_BYTES", "RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT", 
		"RPAD", "RTRIM", "SEC_TO_TIME", "SESSION_USER", "SHA", "SHA1", "SHA2", 
		"SCHEMA_NAME", "SIGN", "SIN", "SLEEP", "SOUNDEX", "SQL_THREAD_WAIT_AFTER_GTIDS", 
		"SQRT", "SRID", "STARTPOINT", "STRCMP", "STR_TO_DATE", "ST_AREA", "ST_ASBINARY", 
		"ST_ASTEXT", "ST_ASWKB", "ST_ASWKT", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS", 
		"ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", 
		"ST_ENDPOINT", "ST_ENVELOPE", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT", 
		"ST_GEOMCOLLFROMTXT", "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT", 
		"ST_GEOMETRYCOLLECTIONFROMWKB", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB", 
		"ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB", 
		"ST_INTERIORRINGN", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED", 
		"ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", "ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT", 
		"ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS", 
		"ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINTFROMTEXT", "ST_POINTFROMWKB", 
		"ST_POINTN", "ST_POLYFROMTEXT", "ST_POLYFROMWKB", "ST_POLYGONFROMTEXT", 
		"ST_POLYGONFROMWKB", "ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_TOUCHES", 
		"ST_UNION", "ST_WITHIN", "ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX", 
		"SUBTIME", "SYSTEM_USER", "TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF", 
		"TIME_FORMAT", "TIME_TO_SEC", "TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS", 
		"UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP", 
		"UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH", 
		"VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR", 
		"WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", "X_FUNCTION", "VAR_ASSIGN", 
		"PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", 
		"AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE", "MODULE", "PLUS", 
		"MINUSMINUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", 
		"LESS_SYMBOL", "EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", 
		"BIT_XOR_OP", "DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "AT_SIGN", 
		"ZERO_DECIMAL", "ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB", 
		"REVERSE_QUOTE_SYMB", "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING", "FILESIZE_LITERAL", 
		"START_NATIONAL_STRING_LITERAL", "STRING_LITERAL", "DECIMAL_LITERAL", 
		"HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL", "BIT_STRING", 
		"STRING_CHARSET_NAME", "DOT_ID", "ID", "REVERSE_QUOTE_ID", "STRING_USER_NAME", 
		"LOCAL_ID", "GLOBAL_ID", "ERROR_RECONGNIGION"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "MySqlParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	static MySqlParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

	public MySqlParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}
	public partial class RootContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(MySqlParser.Eof, 0); }
		public SqlStatementsContext sqlStatements() {
			return GetRuleContext<SqlStatementsContext>(0);
		}
		public ITerminalNode MINUSMINUS() { return GetToken(MySqlParser.MINUSMINUS, 0); }
		public RootContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_root; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoot(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoot(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoot(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RootContext root() {
		RootContext _localctx = new RootContext(Context, State);
		EnterRule(_localctx, 0, RULE_root);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 625;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ALTER) | (1L << ANALYZE) | (1L << CALL) | (1L << CHANGE) | (1L << CHECK) | (1L << CREATE) | (1L << DELETE) | (1L << DESC) | (1L << DESCRIBE) | (1L << DROP) | (1L << EXPLAIN) | (1L << GRANT))) != 0) || ((((_la - 73)) & ~0x3f) == 0 && ((1L << (_la - 73)) & ((1L << (INSERT - 73)) | (1L << (KILL - 73)) | (1L << (LOAD - 73)) | (1L << (LOCK - 73)) | (1L << (OPTIMIZE - 73)) | (1L << (PURGE - 73)) | (1L << (RELEASE - 73)) | (1L << (RENAME - 73)) | (1L << (REPLACE - 73)) | (1L << (REVOKE - 73)) | (1L << (SELECT - 73)) | (1L << (SET - 73)) | (1L << (SHOW - 73)) | (1L << (SIGNAL - 73)))) != 0) || ((((_la - 158)) & ~0x3f) == 0 && ((1L << (_la - 158)) & ((1L << (UNLOCK - 158)) | (1L << (UPDATE - 158)) | (1L << (USE - 158)))) != 0) || ((((_la - 265)) & ~0x3f) == 0 && ((1L << (_la - 265)) & ((1L << (BEGIN - 265)) | (1L << (BINLOG - 265)) | (1L << (CACHE - 265)) | (1L << (CHECKSUM - 265)) | (1L << (COMMIT - 265)) | (1L << (DEALLOCATE - 265)) | (1L << (DO - 265)))) != 0) || ((((_la - 346)) & ~0x3f) == 0 && ((1L << (_la - 346)) & ((1L << (FLUSH - 346)) | (1L << (HANDLER - 346)) | (1L << (HELP - 346)) | (1L << (INSTALL - 346)))) != 0) || ((((_la - 457)) & ~0x3f) == 0 && ((1L << (_la - 457)) & ((1L << (PREPARE - 457)) | (1L << (REPAIR - 457)) | (1L << (RESET - 457)) | (1L << (ROLLBACK - 457)) | (1L << (SAVEPOINT - 457)) | (1L << (START - 457)))) != 0) || ((((_la - 524)) & ~0x3f) == 0 && ((1L << (_la - 524)) & ((1L << (STOP - 524)) | (1L << (TRUNCATE - 524)) | (1L << (UNINSTALL - 524)) | (1L << (XA - 524)) | (1L << (EXECUTE - 524)) | (1L << (SHUTDOWN - 524)))) != 0) || _la==LR_BRACKET || _la==SEMI) {
				{
				State = 624; sqlStatements();
				}
			}

			State = 628;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MINUSMINUS) {
				{
				State = 627; Match(MINUSMINUS);
				}
			}

			State = 630; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SqlStatementsContext : ParserRuleContext {
		public SqlStatementContext[] sqlStatement() {
			return GetRuleContexts<SqlStatementContext>();
		}
		public SqlStatementContext sqlStatement(int i) {
			return GetRuleContext<SqlStatementContext>(i);
		}
		public EmptyStatementContext[] emptyStatement() {
			return GetRuleContexts<EmptyStatementContext>();
		}
		public EmptyStatementContext emptyStatement(int i) {
			return GetRuleContext<EmptyStatementContext>(i);
		}
		public ITerminalNode[] SEMI() { return GetTokens(MySqlParser.SEMI); }
		public ITerminalNode SEMI(int i) {
			return GetToken(MySqlParser.SEMI, i);
		}
		public ITerminalNode[] MINUSMINUS() { return GetTokens(MySqlParser.MINUSMINUS); }
		public ITerminalNode MINUSMINUS(int i) {
			return GetToken(MySqlParser.MINUSMINUS, i);
		}
		public SqlStatementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlStatements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSqlStatements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSqlStatements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqlStatements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SqlStatementsContext sqlStatements() {
		SqlStatementsContext _localctx = new SqlStatementsContext(Context, State);
		EnterRule(_localctx, 2, RULE_sqlStatements);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 642;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 640;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ALTER:
					case ANALYZE:
					case CALL:
					case CHANGE:
					case CHECK:
					case CREATE:
					case DELETE:
					case DESC:
					case DESCRIBE:
					case DROP:
					case EXPLAIN:
					case GRANT:
					case INSERT:
					case KILL:
					case LOAD:
					case LOCK:
					case OPTIMIZE:
					case PURGE:
					case RELEASE:
					case RENAME:
					case REPLACE:
					case REVOKE:
					case SELECT:
					case SET:
					case SHOW:
					case SIGNAL:
					case UNLOCK:
					case UPDATE:
					case USE:
					case BEGIN:
					case BINLOG:
					case CACHE:
					case CHECKSUM:
					case COMMIT:
					case DEALLOCATE:
					case DO:
					case FLUSH:
					case HANDLER:
					case HELP:
					case INSTALL:
					case PREPARE:
					case REPAIR:
					case RESET:
					case ROLLBACK:
					case SAVEPOINT:
					case START:
					case STOP:
					case TRUNCATE:
					case UNINSTALL:
					case XA:
					case EXECUTE:
					case SHUTDOWN:
					case LR_BRACKET:
						{
						State = 632; sqlStatement();
						State = 634;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==MINUSMINUS) {
							{
							State = 633; Match(MINUSMINUS);
							}
						}

						State = 637;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
						case 1:
							{
							State = 636; Match(SEMI);
							}
							break;
						}
						}
						break;
					case SEMI:
						{
						State = 639; emptyStatement();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 644;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			}
			State = 653;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALTER:
			case ANALYZE:
			case CALL:
			case CHANGE:
			case CHECK:
			case CREATE:
			case DELETE:
			case DESC:
			case DESCRIBE:
			case DROP:
			case EXPLAIN:
			case GRANT:
			case INSERT:
			case KILL:
			case LOAD:
			case LOCK:
			case OPTIMIZE:
			case PURGE:
			case RELEASE:
			case RENAME:
			case REPLACE:
			case REVOKE:
			case SELECT:
			case SET:
			case SHOW:
			case SIGNAL:
			case UNLOCK:
			case UPDATE:
			case USE:
			case BEGIN:
			case BINLOG:
			case CACHE:
			case CHECKSUM:
			case COMMIT:
			case DEALLOCATE:
			case DO:
			case FLUSH:
			case HANDLER:
			case HELP:
			case INSTALL:
			case PREPARE:
			case REPAIR:
			case RESET:
			case ROLLBACK:
			case SAVEPOINT:
			case START:
			case STOP:
			case TRUNCATE:
			case UNINSTALL:
			case XA:
			case EXECUTE:
			case SHUTDOWN:
			case LR_BRACKET:
				{
				State = 645; sqlStatement();
				State = 650;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,7,Context) ) {
				case 1:
					{
					State = 647;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==MINUSMINUS) {
						{
						State = 646; Match(MINUSMINUS);
						}
					}

					State = 649; Match(SEMI);
					}
					break;
				}
				}
				break;
			case SEMI:
				{
				State = 652; emptyStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SqlStatementContext : ParserRuleContext {
		public DdlStatementContext ddlStatement() {
			return GetRuleContext<DdlStatementContext>(0);
		}
		public DmlStatementContext dmlStatement() {
			return GetRuleContext<DmlStatementContext>(0);
		}
		public TransactionStatementContext transactionStatement() {
			return GetRuleContext<TransactionStatementContext>(0);
		}
		public ReplicationStatementContext replicationStatement() {
			return GetRuleContext<ReplicationStatementContext>(0);
		}
		public PreparedStatementContext preparedStatement() {
			return GetRuleContext<PreparedStatementContext>(0);
		}
		public AdministrationStatementContext administrationStatement() {
			return GetRuleContext<AdministrationStatementContext>(0);
		}
		public UtilityStatementContext utilityStatement() {
			return GetRuleContext<UtilityStatementContext>(0);
		}
		public SqlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSqlStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSqlStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqlStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SqlStatementContext sqlStatement() {
		SqlStatementContext _localctx = new SqlStatementContext(Context, State);
		EnterRule(_localctx, 4, RULE_sqlStatement);
		try {
			State = 662;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,9,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 655; ddlStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 656; dmlStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 657; transactionStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 658; replicationStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 659; preparedStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 660; administrationStatement();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 661; utilityStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EmptyStatementContext : ParserRuleContext {
		public ITerminalNode SEMI() { return GetToken(MySqlParser.SEMI, 0); }
		public EmptyStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_emptyStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterEmptyStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitEmptyStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEmptyStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EmptyStatementContext emptyStatement() {
		EmptyStatementContext _localctx = new EmptyStatementContext(Context, State);
		EnterRule(_localctx, 6, RULE_emptyStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 664; Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DdlStatementContext : ParserRuleContext {
		public CreateDatabaseContext createDatabase() {
			return GetRuleContext<CreateDatabaseContext>(0);
		}
		public CreateEventContext createEvent() {
			return GetRuleContext<CreateEventContext>(0);
		}
		public CreateIndexContext createIndex() {
			return GetRuleContext<CreateIndexContext>(0);
		}
		public CreateLogfileGroupContext createLogfileGroup() {
			return GetRuleContext<CreateLogfileGroupContext>(0);
		}
		public CreateProcedureContext createProcedure() {
			return GetRuleContext<CreateProcedureContext>(0);
		}
		public CreateFunctionContext createFunction() {
			return GetRuleContext<CreateFunctionContext>(0);
		}
		public CreateServerContext createServer() {
			return GetRuleContext<CreateServerContext>(0);
		}
		public CreateTableContext createTable() {
			return GetRuleContext<CreateTableContext>(0);
		}
		public CreateTablespaceInnodbContext createTablespaceInnodb() {
			return GetRuleContext<CreateTablespaceInnodbContext>(0);
		}
		public CreateTablespaceNdbContext createTablespaceNdb() {
			return GetRuleContext<CreateTablespaceNdbContext>(0);
		}
		public CreateTriggerContext createTrigger() {
			return GetRuleContext<CreateTriggerContext>(0);
		}
		public CreateViewContext createView() {
			return GetRuleContext<CreateViewContext>(0);
		}
		public AlterDatabaseContext alterDatabase() {
			return GetRuleContext<AlterDatabaseContext>(0);
		}
		public AlterEventContext alterEvent() {
			return GetRuleContext<AlterEventContext>(0);
		}
		public AlterFunctionContext alterFunction() {
			return GetRuleContext<AlterFunctionContext>(0);
		}
		public AlterInstanceContext alterInstance() {
			return GetRuleContext<AlterInstanceContext>(0);
		}
		public AlterLogfileGroupContext alterLogfileGroup() {
			return GetRuleContext<AlterLogfileGroupContext>(0);
		}
		public AlterProcedureContext alterProcedure() {
			return GetRuleContext<AlterProcedureContext>(0);
		}
		public AlterServerContext alterServer() {
			return GetRuleContext<AlterServerContext>(0);
		}
		public AlterTableContext alterTable() {
			return GetRuleContext<AlterTableContext>(0);
		}
		public AlterTablespaceContext alterTablespace() {
			return GetRuleContext<AlterTablespaceContext>(0);
		}
		public AlterViewContext alterView() {
			return GetRuleContext<AlterViewContext>(0);
		}
		public DropDatabaseContext dropDatabase() {
			return GetRuleContext<DropDatabaseContext>(0);
		}
		public DropEventContext dropEvent() {
			return GetRuleContext<DropEventContext>(0);
		}
		public DropIndexContext dropIndex() {
			return GetRuleContext<DropIndexContext>(0);
		}
		public DropLogfileGroupContext dropLogfileGroup() {
			return GetRuleContext<DropLogfileGroupContext>(0);
		}
		public DropProcedureContext dropProcedure() {
			return GetRuleContext<DropProcedureContext>(0);
		}
		public DropFunctionContext dropFunction() {
			return GetRuleContext<DropFunctionContext>(0);
		}
		public DropServerContext dropServer() {
			return GetRuleContext<DropServerContext>(0);
		}
		public DropTableContext dropTable() {
			return GetRuleContext<DropTableContext>(0);
		}
		public DropTablespaceContext dropTablespace() {
			return GetRuleContext<DropTablespaceContext>(0);
		}
		public DropTriggerContext dropTrigger() {
			return GetRuleContext<DropTriggerContext>(0);
		}
		public DropViewContext dropView() {
			return GetRuleContext<DropViewContext>(0);
		}
		public RenameTableContext renameTable() {
			return GetRuleContext<RenameTableContext>(0);
		}
		public TruncateTableContext truncateTable() {
			return GetRuleContext<TruncateTableContext>(0);
		}
		public DdlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ddlStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDdlStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDdlStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDdlStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DdlStatementContext ddlStatement() {
		DdlStatementContext _localctx = new DdlStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_ddlStatement);
		try {
			State = 701;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 666; createDatabase();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 667; createEvent();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 668; createIndex();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 669; createLogfileGroup();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 670; createProcedure();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 671; createFunction();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 672; createServer();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 673; createTable();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 674; createTablespaceInnodb();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 675; createTablespaceNdb();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 676; createTrigger();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 677; createView();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 678; alterDatabase();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 679; alterEvent();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 680; alterFunction();
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 681; alterInstance();
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 682; alterLogfileGroup();
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 683; alterProcedure();
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 684; alterServer();
				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 685; alterTable();
				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 686; alterTablespace();
				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 687; alterView();
				}
				break;
			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 688; dropDatabase();
				}
				break;
			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 689; dropEvent();
				}
				break;
			case 25:
				EnterOuterAlt(_localctx, 25);
				{
				State = 690; dropIndex();
				}
				break;
			case 26:
				EnterOuterAlt(_localctx, 26);
				{
				State = 691; dropLogfileGroup();
				}
				break;
			case 27:
				EnterOuterAlt(_localctx, 27);
				{
				State = 692; dropProcedure();
				}
				break;
			case 28:
				EnterOuterAlt(_localctx, 28);
				{
				State = 693; dropFunction();
				}
				break;
			case 29:
				EnterOuterAlt(_localctx, 29);
				{
				State = 694; dropServer();
				}
				break;
			case 30:
				EnterOuterAlt(_localctx, 30);
				{
				State = 695; dropTable();
				}
				break;
			case 31:
				EnterOuterAlt(_localctx, 31);
				{
				State = 696; dropTablespace();
				}
				break;
			case 32:
				EnterOuterAlt(_localctx, 32);
				{
				State = 697; dropTrigger();
				}
				break;
			case 33:
				EnterOuterAlt(_localctx, 33);
				{
				State = 698; dropView();
				}
				break;
			case 34:
				EnterOuterAlt(_localctx, 34);
				{
				State = 699; renameTable();
				}
				break;
			case 35:
				EnterOuterAlt(_localctx, 35);
				{
				State = 700; truncateTable();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DmlStatementContext : ParserRuleContext {
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public InsertStatementContext insertStatement() {
			return GetRuleContext<InsertStatementContext>(0);
		}
		public UpdateStatementContext updateStatement() {
			return GetRuleContext<UpdateStatementContext>(0);
		}
		public DeleteStatementContext deleteStatement() {
			return GetRuleContext<DeleteStatementContext>(0);
		}
		public ReplaceStatementContext replaceStatement() {
			return GetRuleContext<ReplaceStatementContext>(0);
		}
		public CallStatementContext callStatement() {
			return GetRuleContext<CallStatementContext>(0);
		}
		public LoadDataStatementContext loadDataStatement() {
			return GetRuleContext<LoadDataStatementContext>(0);
		}
		public LoadXmlStatementContext loadXmlStatement() {
			return GetRuleContext<LoadXmlStatementContext>(0);
		}
		public DoStatementContext doStatement() {
			return GetRuleContext<DoStatementContext>(0);
		}
		public HandlerStatementContext handlerStatement() {
			return GetRuleContext<HandlerStatementContext>(0);
		}
		public DmlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dmlStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDmlStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDmlStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDmlStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DmlStatementContext dmlStatement() {
		DmlStatementContext _localctx = new DmlStatementContext(Context, State);
		EnterRule(_localctx, 10, RULE_dmlStatement);
		try {
			State = 713;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 703; selectStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 704; insertStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 705; updateStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 706; deleteStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 707; replaceStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 708; callStatement();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 709; loadDataStatement();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 710; loadXmlStatement();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 711; doStatement();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 712; handlerStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TransactionStatementContext : ParserRuleContext {
		public StartTransactionContext startTransaction() {
			return GetRuleContext<StartTransactionContext>(0);
		}
		public BeginWorkContext beginWork() {
			return GetRuleContext<BeginWorkContext>(0);
		}
		public CommitWorkContext commitWork() {
			return GetRuleContext<CommitWorkContext>(0);
		}
		public RollbackWorkContext rollbackWork() {
			return GetRuleContext<RollbackWorkContext>(0);
		}
		public SavepointStatementContext savepointStatement() {
			return GetRuleContext<SavepointStatementContext>(0);
		}
		public RollbackStatementContext rollbackStatement() {
			return GetRuleContext<RollbackStatementContext>(0);
		}
		public ReleaseStatementContext releaseStatement() {
			return GetRuleContext<ReleaseStatementContext>(0);
		}
		public LockTablesContext lockTables() {
			return GetRuleContext<LockTablesContext>(0);
		}
		public UnlockTablesContext unlockTables() {
			return GetRuleContext<UnlockTablesContext>(0);
		}
		public TransactionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transactionStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTransactionStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTransactionStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTransactionStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TransactionStatementContext transactionStatement() {
		TransactionStatementContext _localctx = new TransactionStatementContext(Context, State);
		EnterRule(_localctx, 12, RULE_transactionStatement);
		try {
			State = 724;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 715; startTransaction();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 716; beginWork();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 717; commitWork();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 718; rollbackWork();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 719; savepointStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 720; rollbackStatement();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 721; releaseStatement();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 722; lockTables();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 723; unlockTables();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReplicationStatementContext : ParserRuleContext {
		public ChangeMasterContext changeMaster() {
			return GetRuleContext<ChangeMasterContext>(0);
		}
		public ChangeReplicationFilterContext changeReplicationFilter() {
			return GetRuleContext<ChangeReplicationFilterContext>(0);
		}
		public PurgeBinaryLogsContext purgeBinaryLogs() {
			return GetRuleContext<PurgeBinaryLogsContext>(0);
		}
		public ResetMasterContext resetMaster() {
			return GetRuleContext<ResetMasterContext>(0);
		}
		public ResetSlaveContext resetSlave() {
			return GetRuleContext<ResetSlaveContext>(0);
		}
		public StartSlaveContext startSlave() {
			return GetRuleContext<StartSlaveContext>(0);
		}
		public StopSlaveContext stopSlave() {
			return GetRuleContext<StopSlaveContext>(0);
		}
		public StartGroupReplicationContext startGroupReplication() {
			return GetRuleContext<StartGroupReplicationContext>(0);
		}
		public StopGroupReplicationContext stopGroupReplication() {
			return GetRuleContext<StopGroupReplicationContext>(0);
		}
		public XaStartTransactionContext xaStartTransaction() {
			return GetRuleContext<XaStartTransactionContext>(0);
		}
		public XaEndTransactionContext xaEndTransaction() {
			return GetRuleContext<XaEndTransactionContext>(0);
		}
		public XaPrepareStatementContext xaPrepareStatement() {
			return GetRuleContext<XaPrepareStatementContext>(0);
		}
		public XaCommitWorkContext xaCommitWork() {
			return GetRuleContext<XaCommitWorkContext>(0);
		}
		public XaRollbackWorkContext xaRollbackWork() {
			return GetRuleContext<XaRollbackWorkContext>(0);
		}
		public XaRecoverWorkContext xaRecoverWork() {
			return GetRuleContext<XaRecoverWorkContext>(0);
		}
		public ReplicationStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_replicationStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReplicationStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReplicationStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReplicationStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReplicationStatementContext replicationStatement() {
		ReplicationStatementContext _localctx = new ReplicationStatementContext(Context, State);
		EnterRule(_localctx, 14, RULE_replicationStatement);
		try {
			State = 741;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,13,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 726; changeMaster();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 727; changeReplicationFilter();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 728; purgeBinaryLogs();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 729; resetMaster();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 730; resetSlave();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 731; startSlave();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 732; stopSlave();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 733; startGroupReplication();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 734; stopGroupReplication();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 735; xaStartTransaction();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 736; xaEndTransaction();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 737; xaPrepareStatement();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 738; xaCommitWork();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 739; xaRollbackWork();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 740; xaRecoverWork();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PreparedStatementContext : ParserRuleContext {
		public PrepareStatementContext prepareStatement() {
			return GetRuleContext<PrepareStatementContext>(0);
		}
		public ExecuteStatementContext executeStatement() {
			return GetRuleContext<ExecuteStatementContext>(0);
		}
		public DeallocatePrepareContext deallocatePrepare() {
			return GetRuleContext<DeallocatePrepareContext>(0);
		}
		public PreparedStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_preparedStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPreparedStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPreparedStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreparedStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PreparedStatementContext preparedStatement() {
		PreparedStatementContext _localctx = new PreparedStatementContext(Context, State);
		EnterRule(_localctx, 16, RULE_preparedStatement);
		try {
			State = 746;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PREPARE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 743; prepareStatement();
				}
				break;
			case EXECUTE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 744; executeStatement();
				}
				break;
			case DROP:
			case DEALLOCATE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 745; deallocatePrepare();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompoundStatementContext : ParserRuleContext {
		public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		public CaseStatementContext caseStatement() {
			return GetRuleContext<CaseStatementContext>(0);
		}
		public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		public LeaveStatementContext leaveStatement() {
			return GetRuleContext<LeaveStatementContext>(0);
		}
		public LoopStatementContext loopStatement() {
			return GetRuleContext<LoopStatementContext>(0);
		}
		public RepeatStatementContext repeatStatement() {
			return GetRuleContext<RepeatStatementContext>(0);
		}
		public WhileStatementContext whileStatement() {
			return GetRuleContext<WhileStatementContext>(0);
		}
		public IterateStatementContext iterateStatement() {
			return GetRuleContext<IterateStatementContext>(0);
		}
		public ReturnStatementContext returnStatement() {
			return GetRuleContext<ReturnStatementContext>(0);
		}
		public CursorStatementContext cursorStatement() {
			return GetRuleContext<CursorStatementContext>(0);
		}
		public CompoundStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compoundStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCompoundStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCompoundStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompoundStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompoundStatementContext compoundStatement() {
		CompoundStatementContext _localctx = new CompoundStatementContext(Context, State);
		EnterRule(_localctx, 18, RULE_compoundStatement);
		try {
			State = 758;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 748; blockStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 749; caseStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 750; ifStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 751; leaveStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 752; loopStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 753; repeatStatement();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 754; whileStatement();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 755; iterateStatement();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 756; returnStatement();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 757; cursorStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AdministrationStatementContext : ParserRuleContext {
		public AlterUserContext alterUser() {
			return GetRuleContext<AlterUserContext>(0);
		}
		public CreateUserContext createUser() {
			return GetRuleContext<CreateUserContext>(0);
		}
		public DropUserContext dropUser() {
			return GetRuleContext<DropUserContext>(0);
		}
		public GrantStatementContext grantStatement() {
			return GetRuleContext<GrantStatementContext>(0);
		}
		public GrantProxyContext grantProxy() {
			return GetRuleContext<GrantProxyContext>(0);
		}
		public RenameUserContext renameUser() {
			return GetRuleContext<RenameUserContext>(0);
		}
		public RevokeStatementContext revokeStatement() {
			return GetRuleContext<RevokeStatementContext>(0);
		}
		public RevokeProxyContext revokeProxy() {
			return GetRuleContext<RevokeProxyContext>(0);
		}
		public AnalyzeTableContext analyzeTable() {
			return GetRuleContext<AnalyzeTableContext>(0);
		}
		public CheckTableContext checkTable() {
			return GetRuleContext<CheckTableContext>(0);
		}
		public ChecksumTableContext checksumTable() {
			return GetRuleContext<ChecksumTableContext>(0);
		}
		public OptimizeTableContext optimizeTable() {
			return GetRuleContext<OptimizeTableContext>(0);
		}
		public RepairTableContext repairTable() {
			return GetRuleContext<RepairTableContext>(0);
		}
		public CreateUdfunctionContext createUdfunction() {
			return GetRuleContext<CreateUdfunctionContext>(0);
		}
		public InstallPluginContext installPlugin() {
			return GetRuleContext<InstallPluginContext>(0);
		}
		public UninstallPluginContext uninstallPlugin() {
			return GetRuleContext<UninstallPluginContext>(0);
		}
		public SetStatementContext setStatement() {
			return GetRuleContext<SetStatementContext>(0);
		}
		public ShowStatementContext showStatement() {
			return GetRuleContext<ShowStatementContext>(0);
		}
		public BinlogStatementContext binlogStatement() {
			return GetRuleContext<BinlogStatementContext>(0);
		}
		public CacheIndexStatementContext cacheIndexStatement() {
			return GetRuleContext<CacheIndexStatementContext>(0);
		}
		public FlushStatementContext flushStatement() {
			return GetRuleContext<FlushStatementContext>(0);
		}
		public KillStatementContext killStatement() {
			return GetRuleContext<KillStatementContext>(0);
		}
		public LoadIndexIntoCacheContext loadIndexIntoCache() {
			return GetRuleContext<LoadIndexIntoCacheContext>(0);
		}
		public ResetStatementContext resetStatement() {
			return GetRuleContext<ResetStatementContext>(0);
		}
		public ShutdownStatementContext shutdownStatement() {
			return GetRuleContext<ShutdownStatementContext>(0);
		}
		public AdministrationStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_administrationStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAdministrationStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAdministrationStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdministrationStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AdministrationStatementContext administrationStatement() {
		AdministrationStatementContext _localctx = new AdministrationStatementContext(Context, State);
		EnterRule(_localctx, 20, RULE_administrationStatement);
		try {
			State = 785;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 760; alterUser();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 761; createUser();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 762; dropUser();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 763; grantStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 764; grantProxy();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 765; renameUser();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 766; revokeStatement();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 767; revokeProxy();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 768; analyzeTable();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 769; checkTable();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 770; checksumTable();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 771; optimizeTable();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 772; repairTable();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 773; createUdfunction();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 774; installPlugin();
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 775; uninstallPlugin();
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 776; setStatement();
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 777; showStatement();
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 778; binlogStatement();
				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 779; cacheIndexStatement();
				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 780; flushStatement();
				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 781; killStatement();
				}
				break;
			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 782; loadIndexIntoCache();
				}
				break;
			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 783; resetStatement();
				}
				break;
			case 25:
				EnterOuterAlt(_localctx, 25);
				{
				State = 784; shutdownStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UtilityStatementContext : ParserRuleContext {
		public SimpleDescribeStatementContext simpleDescribeStatement() {
			return GetRuleContext<SimpleDescribeStatementContext>(0);
		}
		public FullDescribeStatementContext fullDescribeStatement() {
			return GetRuleContext<FullDescribeStatementContext>(0);
		}
		public HelpStatementContext helpStatement() {
			return GetRuleContext<HelpStatementContext>(0);
		}
		public UseStatementContext useStatement() {
			return GetRuleContext<UseStatementContext>(0);
		}
		public SignalStatementContext signalStatement() {
			return GetRuleContext<SignalStatementContext>(0);
		}
		public UtilityStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_utilityStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUtilityStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUtilityStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUtilityStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UtilityStatementContext utilityStatement() {
		UtilityStatementContext _localctx = new UtilityStatementContext(Context, State);
		EnterRule(_localctx, 22, RULE_utilityStatement);
		try {
			State = 792;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 787; simpleDescribeStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 788; fullDescribeStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 789; helpStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 790; useStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 791; signalStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateDatabaseContext : ParserRuleContext {
		public IToken dbFormat;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(MySqlParser.SCHEMA, 0); }
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public CreateDatabaseOptionContext[] createDatabaseOption() {
			return GetRuleContexts<CreateDatabaseOptionContext>();
		}
		public CreateDatabaseOptionContext createDatabaseOption(int i) {
			return GetRuleContext<CreateDatabaseOptionContext>(i);
		}
		public CreateDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createDatabase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateDatabase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateDatabase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateDatabase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateDatabaseContext createDatabase() {
		CreateDatabaseContext _localctx = new CreateDatabaseContext(Context, State);
		EnterRule(_localctx, 24, RULE_createDatabase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 794; Match(CREATE);
			State = 795;
			_localctx.dbFormat = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DATABASE || _la==SCHEMA) ) {
				_localctx.dbFormat = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 797;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 796; ifNotExists();
				}
			}

			State = 799; uid();
			State = 803;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << CHARACTER) | (1L << COLLATE) | (1L << DEFAULT))) != 0) || _la==CHARSET) {
				{
				{
				State = 800; createDatabaseOption();
				}
				}
				State = 805;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateEventContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode EVENT() { return GetToken(MySqlParser.EVENT, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode[] ON() { return GetTokens(MySqlParser.ON); }
		public ITerminalNode ON(int i) {
			return GetToken(MySqlParser.ON, i);
		}
		public ITerminalNode SCHEDULE() { return GetToken(MySqlParser.SCHEDULE, 0); }
		public ScheduleExpressionContext scheduleExpression() {
			return GetRuleContext<ScheduleExpressionContext>(0);
		}
		public ITerminalNode DO() { return GetToken(MySqlParser.DO, 0); }
		public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public ITerminalNode COMPLETION() { return GetToken(MySqlParser.COMPLETION, 0); }
		public ITerminalNode PRESERVE() { return GetToken(MySqlParser.PRESERVE, 0); }
		public EnableTypeContext enableType() {
			return GetRuleContext<EnableTypeContext>(0);
		}
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public CreateEventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createEvent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateEvent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateEvent(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateEvent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateEventContext createEvent() {
		CreateEventContext _localctx = new CreateEventContext(Context, State);
		EnterRule(_localctx, 26, RULE_createEvent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 806; Match(CREATE);
			State = 808;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 807; ownerStatement();
				}
			}

			State = 810; Match(EVENT);
			State = 812;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 811; ifNotExists();
				}
			}

			State = 814; fullId();
			State = 815; Match(ON);
			State = 816; Match(SCHEDULE);
			State = 817; scheduleExpression();
			State = 824;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 818; Match(ON);
				State = 819; Match(COMPLETION);
				State = 821;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 820; Match(NOT);
					}
				}

				State = 823; Match(PRESERVE);
				}
			}

			State = 827;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DISABLE || _la==ENABLE) {
				{
				State = 826; enableType();
				}
			}

			State = 831;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMENT) {
				{
				State = 829; Match(COMMENT);
				State = 830; Match(STRING_LITERAL);
				}
			}

			State = 833; Match(DO);
			State = 834; routineBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateIndexContext : ParserRuleContext {
		public IToken intimeAction;
		public IToken indexCategory;
		public IToken algType;
		public IToken lockType;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public ITerminalNode[] ALGORITHM() { return GetTokens(MySqlParser.ALGORITHM); }
		public ITerminalNode ALGORITHM(int i) {
			return GetToken(MySqlParser.ALGORITHM, i);
		}
		public ITerminalNode[] LOCK() { return GetTokens(MySqlParser.LOCK); }
		public ITerminalNode LOCK(int i) {
			return GetToken(MySqlParser.LOCK, i);
		}
		public ITerminalNode ONLINE() { return GetToken(MySqlParser.ONLINE, 0); }
		public ITerminalNode OFFLINE() { return GetToken(MySqlParser.OFFLINE, 0); }
		public ITerminalNode UNIQUE() { return GetToken(MySqlParser.UNIQUE, 0); }
		public ITerminalNode FULLTEXT() { return GetToken(MySqlParser.FULLTEXT, 0); }
		public ITerminalNode SPATIAL() { return GetToken(MySqlParser.SPATIAL, 0); }
		public ITerminalNode[] DEFAULT() { return GetTokens(MySqlParser.DEFAULT); }
		public ITerminalNode DEFAULT(int i) {
			return GetToken(MySqlParser.DEFAULT, i);
		}
		public ITerminalNode[] INPLACE() { return GetTokens(MySqlParser.INPLACE); }
		public ITerminalNode INPLACE(int i) {
			return GetToken(MySqlParser.INPLACE, i);
		}
		public ITerminalNode[] COPY() { return GetTokens(MySqlParser.COPY); }
		public ITerminalNode COPY(int i) {
			return GetToken(MySqlParser.COPY, i);
		}
		public ITerminalNode[] NONE() { return GetTokens(MySqlParser.NONE); }
		public ITerminalNode NONE(int i) {
			return GetToken(MySqlParser.NONE, i);
		}
		public ITerminalNode[] SHARED() { return GetTokens(MySqlParser.SHARED); }
		public ITerminalNode SHARED(int i) {
			return GetToken(MySqlParser.SHARED, i);
		}
		public ITerminalNode[] EXCLUSIVE() { return GetTokens(MySqlParser.EXCLUSIVE); }
		public ITerminalNode EXCLUSIVE(int i) {
			return GetToken(MySqlParser.EXCLUSIVE, i);
		}
		public CreateIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createIndex; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateIndex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateIndex(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateIndex(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateIndexContext createIndex() {
		CreateIndexContext _localctx = new CreateIndexContext(Context, State);
		EnterRule(_localctx, 28, RULE_createIndex);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 836; Match(CREATE);
			State = 838;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OFFLINE || _la==ONLINE) {
				{
				State = 837;
				_localctx.intimeAction = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==OFFLINE || _la==ONLINE) ) {
					_localctx.intimeAction = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 841;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FULLTEXT || _la==SPATIAL || _la==UNIQUE) {
				{
				State = 840;
				_localctx.indexCategory = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FULLTEXT || _la==SPATIAL || _la==UNIQUE) ) {
					_localctx.indexCategory = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 843; Match(INDEX);
			State = 844; uid();
			State = 846;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 845; indexType();
				}
			}

			State = 848; Match(ON);
			State = 849; tableName();
			State = 850; indexColumnNames();
			State = 854;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==USING || _la==WITH || _la==COMMENT || _la==INVISIBLE || _la==KEY_BLOCK_SIZE || _la==VISIBLE) {
				{
				{
				State = 851; indexOption();
				}
				}
				State = 856;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 869;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 867;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ALGORITHM:
						{
						State = 857; Match(ALGORITHM);
						State = 859;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==EQUAL_SYMBOL) {
							{
							State = 858; Match(EQUAL_SYMBOL);
							}
						}

						State = 861;
						_localctx.algType = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==DEFAULT || _la==COPY || _la==INPLACE) ) {
							_localctx.algType = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					case LOCK:
						{
						State = 862; Match(LOCK);
						State = 864;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==EQUAL_SYMBOL) {
							{
							State = 863; Match(EQUAL_SYMBOL);
							}
						}

						State = 866;
						_localctx.lockType = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==DEFAULT || _la==EXCLUSIVE || _la==NONE || _la==SHARED) ) {
							_localctx.lockType = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 871;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateLogfileGroupContext : ParserRuleContext {
		public IToken undoFile;
		public FileSizeLiteralContext initSize;
		public FileSizeLiteralContext undoSize;
		public FileSizeLiteralContext redoSize;
		public IToken comment;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode LOGFILE() { return GetToken(MySqlParser.LOGFILE, 0); }
		public ITerminalNode GROUP() { return GetToken(MySqlParser.GROUP, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode UNDOFILE() { return GetToken(MySqlParser.UNDOFILE, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(MySqlParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(MySqlParser.STRING_LITERAL, i);
		}
		public ITerminalNode INITIAL_SIZE() { return GetToken(MySqlParser.INITIAL_SIZE, 0); }
		public ITerminalNode UNDO_BUFFER_SIZE() { return GetToken(MySqlParser.UNDO_BUFFER_SIZE, 0); }
		public ITerminalNode REDO_BUFFER_SIZE() { return GetToken(MySqlParser.REDO_BUFFER_SIZE, 0); }
		public ITerminalNode NODEGROUP() { return GetToken(MySqlParser.NODEGROUP, 0); }
		public ITerminalNode WAIT() { return GetToken(MySqlParser.WAIT, 0); }
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public FileSizeLiteralContext[] fileSizeLiteral() {
			return GetRuleContexts<FileSizeLiteralContext>();
		}
		public FileSizeLiteralContext fileSizeLiteral(int i) {
			return GetRuleContext<FileSizeLiteralContext>(i);
		}
		public CreateLogfileGroupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createLogfileGroup; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateLogfileGroup(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateLogfileGroup(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateLogfileGroup(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateLogfileGroupContext createLogfileGroup() {
		CreateLogfileGroupContext _localctx = new CreateLogfileGroupContext(Context, State);
		EnterRule(_localctx, 30, RULE_createLogfileGroup);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 872; Match(CREATE);
			State = 873; Match(LOGFILE);
			State = 874; Match(GROUP);
			State = 875; uid();
			State = 876; Match(ADD);
			State = 877; Match(UNDOFILE);
			State = 878; _localctx.undoFile = Match(STRING_LITERAL);
			State = 884;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INITIAL_SIZE) {
				{
				State = 879; Match(INITIAL_SIZE);
				State = 881;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 880; Match(EQUAL_SYMBOL);
					}
				}

				State = 883; _localctx.initSize = fileSizeLiteral();
				}
			}

			State = 891;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNDO_BUFFER_SIZE) {
				{
				State = 886; Match(UNDO_BUFFER_SIZE);
				State = 888;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 887; Match(EQUAL_SYMBOL);
					}
				}

				State = 890; _localctx.undoSize = fileSizeLiteral();
				}
			}

			State = 898;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REDO_BUFFER_SIZE) {
				{
				State = 893; Match(REDO_BUFFER_SIZE);
				State = 895;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 894; Match(EQUAL_SYMBOL);
					}
				}

				State = 897; _localctx.redoSize = fileSizeLiteral();
				}
			}

			State = 905;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NODEGROUP) {
				{
				State = 900; Match(NODEGROUP);
				State = 902;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 901; Match(EQUAL_SYMBOL);
					}
				}

				State = 904; uid();
				}
			}

			State = 908;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WAIT) {
				{
				State = 907; Match(WAIT);
				}
			}

			State = 915;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMENT) {
				{
				State = 910; Match(COMMENT);
				State = 912;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 911; Match(EQUAL_SYMBOL);
					}
				}

				State = 914; _localctx.comment = Match(STRING_LITERAL);
				}
			}

			State = 917; Match(ENGINE);
			State = 919;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQUAL_SYMBOL) {
				{
				State = 918; Match(EQUAL_SYMBOL);
				}
			}

			State = 921; engineName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateProcedureContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public ProcedureParameterContext[] procedureParameter() {
			return GetRuleContexts<ProcedureParameterContext>();
		}
		public ProcedureParameterContext procedureParameter(int i) {
			return GetRuleContext<ProcedureParameterContext>(i);
		}
		public RoutineOptionContext[] routineOption() {
			return GetRuleContexts<RoutineOptionContext>();
		}
		public RoutineOptionContext routineOption(int i) {
			return GetRuleContext<RoutineOptionContext>(i);
		}
		public CreateProcedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createProcedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateProcedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateProcedure(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateProcedure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateProcedureContext createProcedure() {
		CreateProcedureContext _localctx = new CreateProcedureContext(Context, State);
		EnterRule(_localctx, 32, RULE_createProcedure);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 923; Match(CREATE);
			State = 925;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 924; ownerStatement();
				}
			}

			State = 927; Match(PROCEDURE);
			State = 928; fullId();
			State = 929; Match(LR_BRACKET);
			State = 931;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || ((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (IN - 68)) | (1L << (INOUT - 68)) | (1L << (LEFT - 68)) | (1L << (OUT - 68)) | (1L << (RIGHT - 68)))) != 0) || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
				{
				State = 930; procedureParameter();
				}
			}

			State = 937;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 933; Match(COMMA);
				State = 934; procedureParameter();
				}
				}
				State = 939;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 940; Match(RR_BRACKET);
			State = 944;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 941; routineOption();
					}
					} 
				}
				State = 946;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			}
			State = 947; routineBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateFunctionContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode RETURNS() { return GetToken(MySqlParser.RETURNS, 0); }
		public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		public ReturnStatementContext returnStatement() {
			return GetRuleContext<ReturnStatementContext>(0);
		}
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public FunctionParameterContext[] functionParameter() {
			return GetRuleContexts<FunctionParameterContext>();
		}
		public FunctionParameterContext functionParameter(int i) {
			return GetRuleContext<FunctionParameterContext>(i);
		}
		public RoutineOptionContext[] routineOption() {
			return GetRuleContexts<RoutineOptionContext>();
		}
		public RoutineOptionContext routineOption(int i) {
			return GetRuleContext<RoutineOptionContext>(i);
		}
		public CreateFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateFunctionContext createFunction() {
		CreateFunctionContext _localctx = new CreateFunctionContext(Context, State);
		EnterRule(_localctx, 34, RULE_createFunction);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 949; Match(CREATE);
			State = 951;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 950; ownerStatement();
				}
			}

			State = 953; Match(FUNCTION);
			State = 954; fullId();
			State = 955; Match(LR_BRACKET);
			State = 957;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
				{
				State = 956; functionParameter();
				}
			}

			State = 963;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 959; Match(COMMA);
				State = 960; functionParameter();
				}
				}
				State = 965;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 966; Match(RR_BRACKET);
			State = 967; Match(RETURNS);
			State = 968; dataType();
			State = 972;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,53,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 969; routineOption();
					}
					} 
				}
				State = 974;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,53,Context);
			}
			State = 977;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALTER:
			case ANALYZE:
			case CALL:
			case CHANGE:
			case CHECK:
			case CREATE:
			case DATABASE:
			case DELETE:
			case DESC:
			case DESCRIBE:
			case DROP:
			case EXPLAIN:
			case GRANT:
			case INSERT:
			case KILL:
			case LEFT:
			case LOAD:
			case LOCK:
			case OPTIMIZE:
			case PURGE:
			case RELEASE:
			case RENAME:
			case REPLACE:
			case REVOKE:
			case RIGHT:
			case SELECT:
			case SET:
			case SHOW:
			case SIGNAL:
			case UNLOCK:
			case UPDATE:
			case USE:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case TEXT:
			case ENUM:
			case SERIAL:
			case COUNT:
			case POSITION:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLASS_ORIGIN:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COLUMN_NAME:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONSTRAINT_CATALOG:
			case CONSTRAINT_SCHEMA:
			case CONSTRAINT_NAME:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVISIBLE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MESSAGE_TEXT:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case MYSQL_ERRNO:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBCLASS_ORIGIN:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLE_NAME:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case VISIBLE:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case SESSION_VARIABLES_ADMIN:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CATALOG_NAME:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SCHEMA_NAME:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case LR_BRACKET:
			case CHARSET_REVERSE_QOUTE_STRING:
			case STRING_LITERAL:
			case ID:
			case REVERSE_QUOTE_ID:
				{
				State = 975; routineBody();
				}
				break;
			case RETURN:
				{
				State = 976; returnStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateServerContext : ParserRuleContext {
		public IToken wrapperName;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode SERVER() { return GetToken(MySqlParser.SERVER, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode FOREIGN() { return GetToken(MySqlParser.FOREIGN, 0); }
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode WRAPPER() { return GetToken(MySqlParser.WRAPPER, 0); }
		public ITerminalNode OPTIONS() { return GetToken(MySqlParser.OPTIONS, 0); }
		public ServerOptionContext[] serverOption() {
			return GetRuleContexts<ServerOptionContext>();
		}
		public ServerOptionContext serverOption(int i) {
			return GetRuleContext<ServerOptionContext>(i);
		}
		public ITerminalNode MYSQL() { return GetToken(MySqlParser.MYSQL, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public CreateServerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createServer; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateServer(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateServer(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateServer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateServerContext createServer() {
		CreateServerContext _localctx = new CreateServerContext(Context, State);
		EnterRule(_localctx, 36, RULE_createServer);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 979; Match(CREATE);
			State = 980; Match(SERVER);
			State = 981; uid();
			State = 982; Match(FOREIGN);
			State = 983; Match(DATA);
			State = 984; Match(WRAPPER);
			State = 985;
			_localctx.wrapperName = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==MYSQL || _la==STRING_LITERAL) ) {
				_localctx.wrapperName = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 986; Match(OPTIONS);
			State = 987; Match(LR_BRACKET);
			State = 988; serverOption();
			State = 993;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 989; Match(COMMA);
				State = 990; serverOption();
				}
				}
				State = 995;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 996; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTableContext : ParserRuleContext {
		public CreateTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTable; } }
	 
		public CreateTableContext() { }
		public virtual void CopyFrom(CreateTableContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CopyCreateTableContext : CreateTableContext {
		public TableNameContext parenthesisTable;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext[] tableName() {
			return GetRuleContexts<TableNameContext>();
		}
		public TableNameContext tableName(int i) {
			return GetRuleContext<TableNameContext>(i);
		}
		public ITerminalNode LIKE() { return GetToken(MySqlParser.LIKE, 0); }
		public ITerminalNode TEMPORARY() { return GetToken(MySqlParser.TEMPORARY, 0); }
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public CopyCreateTableContext(CreateTableContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCopyCreateTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCopyCreateTable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCopyCreateTable(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ColumnCreateTableContext : CreateTableContext {
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public CreateDefinitionsContext createDefinitions() {
			return GetRuleContext<CreateDefinitionsContext>(0);
		}
		public ITerminalNode TEMPORARY() { return GetToken(MySqlParser.TEMPORARY, 0); }
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public TableOptionContext[] tableOption() {
			return GetRuleContexts<TableOptionContext>();
		}
		public TableOptionContext tableOption(int i) {
			return GetRuleContext<TableOptionContext>(i);
		}
		public PartitionDefinitionsContext partitionDefinitions() {
			return GetRuleContext<PartitionDefinitionsContext>(0);
		}
		public ColumnCreateTableContext(CreateTableContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterColumnCreateTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitColumnCreateTable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumnCreateTable(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class QueryCreateTableContext : CreateTableContext {
		public IToken keyViolate;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ITerminalNode TEMPORARY() { return GetToken(MySqlParser.TEMPORARY, 0); }
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public CreateDefinitionsContext createDefinitions() {
			return GetRuleContext<CreateDefinitionsContext>(0);
		}
		public TableOptionContext[] tableOption() {
			return GetRuleContexts<TableOptionContext>();
		}
		public TableOptionContext tableOption(int i) {
			return GetRuleContext<TableOptionContext>(i);
		}
		public PartitionDefinitionsContext partitionDefinitions() {
			return GetRuleContext<PartitionDefinitionsContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode REPLACE() { return GetToken(MySqlParser.REPLACE, 0); }
		public QueryCreateTableContext(CreateTableContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterQueryCreateTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitQueryCreateTable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryCreateTable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateTableContext createTable() {
		CreateTableContext _localctx = new CreateTableContext(Context, State);
		EnterRule(_localctx, 38, RULE_createTable);
		int _la;
		try {
			int _alt;
			State = 1076;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,74,Context) ) {
			case 1:
				_localctx = new CopyCreateTableContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 998; Match(CREATE);
				State = 1000;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==TEMPORARY) {
					{
					State = 999; Match(TEMPORARY);
					}
				}

				State = 1002; Match(TABLE);
				State = 1004;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IF) {
					{
					State = 1003; ifNotExists();
					}
				}

				State = 1006; tableName();
				State = 1014;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case LIKE:
					{
					State = 1007; Match(LIKE);
					State = 1008; tableName();
					}
					break;
				case LR_BRACKET:
					{
					State = 1009; Match(LR_BRACKET);
					State = 1010; Match(LIKE);
					State = 1011; ((CopyCreateTableContext)_localctx).parenthesisTable = tableName();
					State = 1012; Match(RR_BRACKET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				_localctx = new QueryCreateTableContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1016; Match(CREATE);
				State = 1018;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==TEMPORARY) {
					{
					State = 1017; Match(TEMPORARY);
					}
				}

				State = 1020; Match(TABLE);
				State = 1022;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IF) {
					{
					State = 1021; ifNotExists();
					}
				}

				State = 1024; tableName();
				State = 1026;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,61,Context) ) {
				case 1:
					{
					State = 1025; createDefinitions();
					}
					break;
				}
				State = 1038;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 22)) & ~0x3f) == 0 && ((1L << (_la - 22)) & ((1L << (CHARACTER - 22)) | (1L << (COLLATE - 22)) | (1L << (DEFAULT - 22)) | (1L << (INDEX - 22)))) != 0) || _la==UNION || ((((_la - 263)) & ~0x3f) == 0 && ((1L << (_la - 263)) & ((1L << (AUTO_INCREMENT - 263)) | (1L << (AVG_ROW_LENGTH - 263)) | (1L << (CHECKSUM - 263)) | (1L << (PAGE_CHECKSUM - 263)) | (1L << (COMMENT - 263)) | (1L << (COMPRESSION - 263)) | (1L << (CONNECTION - 263)) | (1L << (DATA - 263)) | (1L << (DELAY_KEY_WRITE - 263)) | (1L << (ENCRYPTION - 263)) | (1L << (ENGINE - 263)))) != 0) || ((((_la - 366)) & ~0x3f) == 0 && ((1L << (_la - 366)) & ((1L << (INSERT_METHOD - 366)) | (1L << (KEY_BLOCK_SIZE - 366)) | (1L << (MAX_ROWS - 366)) | (1L << (MIN_ROWS - 366)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PACK_KEYS - 444)) | (1L << (PASSWORD - 444)) | (1L << (ROW_FORMAT - 444)))) != 0) || ((((_la - 520)) & ~0x3f) == 0 && ((1L << (_la - 520)) & ((1L << (STATS_AUTO_RECALC - 520)) | (1L << (STATS_PERSISTENT - 520)) | (1L << (STATS_SAMPLE_PAGES - 520)) | (1L << (STORAGE - 520)) | (1L << (TABLESPACE - 520)))) != 0) || _la==CHARSET) {
					{
					State = 1028; tableOption();
					State = 1035;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (((((_la - 22)) & ~0x3f) == 0 && ((1L << (_la - 22)) & ((1L << (CHARACTER - 22)) | (1L << (COLLATE - 22)) | (1L << (DEFAULT - 22)) | (1L << (INDEX - 22)))) != 0) || _la==UNION || ((((_la - 263)) & ~0x3f) == 0 && ((1L << (_la - 263)) & ((1L << (AUTO_INCREMENT - 263)) | (1L << (AVG_ROW_LENGTH - 263)) | (1L << (CHECKSUM - 263)) | (1L << (PAGE_CHECKSUM - 263)) | (1L << (COMMENT - 263)) | (1L << (COMPRESSION - 263)) | (1L << (CONNECTION - 263)) | (1L << (DATA - 263)) | (1L << (DELAY_KEY_WRITE - 263)) | (1L << (ENCRYPTION - 263)) | (1L << (ENGINE - 263)))) != 0) || ((((_la - 366)) & ~0x3f) == 0 && ((1L << (_la - 366)) & ((1L << (INSERT_METHOD - 366)) | (1L << (KEY_BLOCK_SIZE - 366)) | (1L << (MAX_ROWS - 366)) | (1L << (MIN_ROWS - 366)))) != 0) || ((((_la - 444)) & ~0x3f) == 0 && ((1L << (_la - 444)) & ((1L << (PACK_KEYS - 444)) | (1L << (PASSWORD - 444)) | (1L << (ROW_FORMAT - 444)))) != 0) || ((((_la - 520)) & ~0x3f) == 0 && ((1L << (_la - 520)) & ((1L << (STATS_AUTO_RECALC - 520)) | (1L << (STATS_PERSISTENT - 520)) | (1L << (STATS_SAMPLE_PAGES - 520)) | (1L << (STORAGE - 520)) | (1L << (TABLESPACE - 520)))) != 0) || _la==CHARSET || _la==COMMA) {
						{
						{
						State = 1030;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 1029; Match(COMMA);
							}
						}

						State = 1032; tableOption();
						}
						}
						State = 1037;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 1041;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PARTITION) {
					{
					State = 1040; partitionDefinitions();
					}
				}

				State = 1044;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IGNORE || _la==REPLACE) {
					{
					State = 1043;
					((QueryCreateTableContext)_localctx).keyViolate = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==IGNORE || _la==REPLACE) ) {
						((QueryCreateTableContext)_localctx).keyViolate = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1047;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 1046; Match(AS);
					}
				}

				State = 1049; selectStatement();
				}
				break;
			case 3:
				_localctx = new ColumnCreateTableContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1051; Match(CREATE);
				State = 1053;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==TEMPORARY) {
					{
					State = 1052; Match(TEMPORARY);
					}
				}

				State = 1055; Match(TABLE);
				State = 1057;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IF) {
					{
					State = 1056; ifNotExists();
					}
				}

				State = 1059; tableName();
				State = 1060; createDefinitions();
				State = 1071;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,72,Context) ) {
				case 1:
					{
					State = 1061; tableOption();
					State = 1068;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,71,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 1063;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (_la==COMMA) {
								{
								State = 1062; Match(COMMA);
								}
							}

							State = 1065; tableOption();
							}
							} 
						}
						State = 1070;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,71,Context);
					}
					}
					break;
				}
				State = 1074;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PARTITION) {
					{
					State = 1073; partitionDefinitions();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTablespaceInnodbContext : ParserRuleContext {
		public IToken datafile;
		public FileSizeLiteralContext fileBlockSize;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode DATAFILE() { return GetToken(MySqlParser.DATAFILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode FILE_BLOCK_SIZE() { return GetToken(MySqlParser.FILE_BLOCK_SIZE, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public FileSizeLiteralContext fileSizeLiteral() {
			return GetRuleContext<FileSizeLiteralContext>(0);
		}
		public CreateTablespaceInnodbContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTablespaceInnodb; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateTablespaceInnodb(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateTablespaceInnodb(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateTablespaceInnodb(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateTablespaceInnodbContext createTablespaceInnodb() {
		CreateTablespaceInnodbContext _localctx = new CreateTablespaceInnodbContext(Context, State);
		EnterRule(_localctx, 40, RULE_createTablespaceInnodb);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1078; Match(CREATE);
			State = 1079; Match(TABLESPACE);
			State = 1080; uid();
			State = 1081; Match(ADD);
			State = 1082; Match(DATAFILE);
			State = 1083; _localctx.datafile = Match(STRING_LITERAL);
			State = 1087;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FILE_BLOCK_SIZE) {
				{
				State = 1084; Match(FILE_BLOCK_SIZE);
				State = 1085; Match(EQUAL_SYMBOL);
				State = 1086; _localctx.fileBlockSize = fileSizeLiteral();
				}
			}

			State = 1094;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ENGINE) {
				{
				State = 1089; Match(ENGINE);
				State = 1091;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1090; Match(EQUAL_SYMBOL);
					}
				}

				State = 1093; engineName();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTablespaceNdbContext : ParserRuleContext {
		public IToken datafile;
		public FileSizeLiteralContext extentSize;
		public FileSizeLiteralContext initialSize;
		public FileSizeLiteralContext autoextendSize;
		public FileSizeLiteralContext maxSize;
		public IToken comment;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode DATAFILE() { return GetToken(MySqlParser.DATAFILE, 0); }
		public ITerminalNode USE() { return GetToken(MySqlParser.USE, 0); }
		public ITerminalNode LOGFILE() { return GetToken(MySqlParser.LOGFILE, 0); }
		public ITerminalNode GROUP() { return GetToken(MySqlParser.GROUP, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(MySqlParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(MySqlParser.STRING_LITERAL, i);
		}
		public ITerminalNode EXTENT_SIZE() { return GetToken(MySqlParser.EXTENT_SIZE, 0); }
		public ITerminalNode INITIAL_SIZE() { return GetToken(MySqlParser.INITIAL_SIZE, 0); }
		public ITerminalNode AUTOEXTEND_SIZE() { return GetToken(MySqlParser.AUTOEXTEND_SIZE, 0); }
		public ITerminalNode MAX_SIZE() { return GetToken(MySqlParser.MAX_SIZE, 0); }
		public ITerminalNode NODEGROUP() { return GetToken(MySqlParser.NODEGROUP, 0); }
		public ITerminalNode WAIT() { return GetToken(MySqlParser.WAIT, 0); }
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public FileSizeLiteralContext[] fileSizeLiteral() {
			return GetRuleContexts<FileSizeLiteralContext>();
		}
		public FileSizeLiteralContext fileSizeLiteral(int i) {
			return GetRuleContext<FileSizeLiteralContext>(i);
		}
		public CreateTablespaceNdbContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTablespaceNdb; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateTablespaceNdb(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateTablespaceNdb(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateTablespaceNdb(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateTablespaceNdbContext createTablespaceNdb() {
		CreateTablespaceNdbContext _localctx = new CreateTablespaceNdbContext(Context, State);
		EnterRule(_localctx, 42, RULE_createTablespaceNdb);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1096; Match(CREATE);
			State = 1097; Match(TABLESPACE);
			State = 1098; uid();
			State = 1099; Match(ADD);
			State = 1100; Match(DATAFILE);
			State = 1101; _localctx.datafile = Match(STRING_LITERAL);
			State = 1102; Match(USE);
			State = 1103; Match(LOGFILE);
			State = 1104; Match(GROUP);
			State = 1105; uid();
			State = 1111;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXTENT_SIZE) {
				{
				State = 1106; Match(EXTENT_SIZE);
				State = 1108;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1107; Match(EQUAL_SYMBOL);
					}
				}

				State = 1110; _localctx.extentSize = fileSizeLiteral();
				}
			}

			State = 1118;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INITIAL_SIZE) {
				{
				State = 1113; Match(INITIAL_SIZE);
				State = 1115;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1114; Match(EQUAL_SYMBOL);
					}
				}

				State = 1117; _localctx.initialSize = fileSizeLiteral();
				}
			}

			State = 1125;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AUTOEXTEND_SIZE) {
				{
				State = 1120; Match(AUTOEXTEND_SIZE);
				State = 1122;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1121; Match(EQUAL_SYMBOL);
					}
				}

				State = 1124; _localctx.autoextendSize = fileSizeLiteral();
				}
			}

			State = 1132;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MAX_SIZE) {
				{
				State = 1127; Match(MAX_SIZE);
				State = 1129;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1128; Match(EQUAL_SYMBOL);
					}
				}

				State = 1131; _localctx.maxSize = fileSizeLiteral();
				}
			}

			State = 1139;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NODEGROUP) {
				{
				State = 1134; Match(NODEGROUP);
				State = 1136;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1135; Match(EQUAL_SYMBOL);
					}
				}

				State = 1138; uid();
				}
			}

			State = 1142;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WAIT) {
				{
				State = 1141; Match(WAIT);
				}
			}

			State = 1149;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMENT) {
				{
				State = 1144; Match(COMMENT);
				State = 1146;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1145; Match(EQUAL_SYMBOL);
					}
				}

				State = 1148; _localctx.comment = Match(STRING_LITERAL);
				}
			}

			State = 1151; Match(ENGINE);
			State = 1153;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQUAL_SYMBOL) {
				{
				State = 1152; Match(EQUAL_SYMBOL);
				}
			}

			State = 1155; engineName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTriggerContext : ParserRuleContext {
		public FullIdContext thisTrigger;
		public IToken triggerTime;
		public IToken triggerEvent;
		public IToken triggerPlace;
		public FullIdContext otherTrigger;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TRIGGER() { return GetToken(MySqlParser.TRIGGER, 0); }
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode EACH() { return GetToken(MySqlParser.EACH, 0); }
		public ITerminalNode ROW() { return GetToken(MySqlParser.ROW, 0); }
		public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		public FullIdContext[] fullId() {
			return GetRuleContexts<FullIdContext>();
		}
		public FullIdContext fullId(int i) {
			return GetRuleContext<FullIdContext>(i);
		}
		public ITerminalNode BEFORE() { return GetToken(MySqlParser.BEFORE, 0); }
		public ITerminalNode AFTER() { return GetToken(MySqlParser.AFTER, 0); }
		public ITerminalNode INSERT() { return GetToken(MySqlParser.INSERT, 0); }
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public ITerminalNode DELETE() { return GetToken(MySqlParser.DELETE, 0); }
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public ITerminalNode FOLLOWS() { return GetToken(MySqlParser.FOLLOWS, 0); }
		public ITerminalNode PRECEDES() { return GetToken(MySqlParser.PRECEDES, 0); }
		public CreateTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTrigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateTrigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateTrigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateTrigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateTriggerContext createTrigger() {
		CreateTriggerContext _localctx = new CreateTriggerContext(Context, State);
		EnterRule(_localctx, 44, RULE_createTrigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1157; Match(CREATE);
			State = 1159;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 1158; ownerStatement();
				}
			}

			State = 1161; Match(TRIGGER);
			State = 1162; _localctx.thisTrigger = fullId();
			State = 1163;
			_localctx.triggerTime = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==BEFORE || _la==AFTER) ) {
				_localctx.triggerTime = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1164;
			_localctx.triggerEvent = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DELETE || _la==INSERT || _la==UPDATE) ) {
				_localctx.triggerEvent = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1165; Match(ON);
			State = 1166; tableName();
			State = 1167; Match(FOR);
			State = 1168; Match(EACH);
			State = 1169; Match(ROW);
			State = 1172;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,93,Context) ) {
			case 1:
				{
				State = 1170;
				_localctx.triggerPlace = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FOLLOWS || _la==PRECEDES) ) {
					_localctx.triggerPlace = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1171; _localctx.otherTrigger = fullId();
				}
				break;
			}
			State = 1174; routineBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateViewContext : ParserRuleContext {
		public IToken algType;
		public IToken secContext;
		public IToken checkOption;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode VIEW() { return GetToken(MySqlParser.VIEW, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ITerminalNode OR() { return GetToken(MySqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(MySqlParser.REPLACE, 0); }
		public ITerminalNode ALGORITHM() { return GetToken(MySqlParser.ALGORITHM, 0); }
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public ITerminalNode SQL() { return GetToken(MySqlParser.SQL, 0); }
		public ITerminalNode SECURITY() { return GetToken(MySqlParser.SECURITY, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode CHECK() { return GetToken(MySqlParser.CHECK, 0); }
		public ITerminalNode OPTION() { return GetToken(MySqlParser.OPTION, 0); }
		public ITerminalNode UNDEFINED() { return GetToken(MySqlParser.UNDEFINED, 0); }
		public ITerminalNode MERGE() { return GetToken(MySqlParser.MERGE, 0); }
		public ITerminalNode TEMPTABLE() { return GetToken(MySqlParser.TEMPTABLE, 0); }
		public ITerminalNode DEFINER() { return GetToken(MySqlParser.DEFINER, 0); }
		public ITerminalNode INVOKER() { return GetToken(MySqlParser.INVOKER, 0); }
		public ITerminalNode CASCADED() { return GetToken(MySqlParser.CASCADED, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public CreateViewContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createView; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateView(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateView(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateView(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateViewContext createView() {
		CreateViewContext _localctx = new CreateViewContext(Context, State);
		EnterRule(_localctx, 46, RULE_createView);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1176; Match(CREATE);
			State = 1179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 1177; Match(OR);
				State = 1178; Match(REPLACE);
				}
			}

			State = 1184;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALGORITHM) {
				{
				State = 1181; Match(ALGORITHM);
				State = 1182; Match(EQUAL_SYMBOL);
				State = 1183;
				_localctx.algType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==MERGE || _la==TEMPTABLE || _la==UNDEFINED) ) {
					_localctx.algType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 1187;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 1186; ownerStatement();
				}
			}

			State = 1192;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SQL) {
				{
				State = 1189; Match(SQL);
				State = 1190; Match(SECURITY);
				State = 1191;
				_localctx.secContext = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFINER || _la==INVOKER) ) {
					_localctx.secContext = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 1194; Match(VIEW);
			State = 1195; fullId();
			State = 1200;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LR_BRACKET) {
				{
				State = 1196; Match(LR_BRACKET);
				State = 1197; uidList();
				State = 1198; Match(RR_BRACKET);
				}
			}

			State = 1202; Match(AS);
			State = 1203; selectStatement();
			State = 1210;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 1204; Match(WITH);
				State = 1206;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CASCADED || _la==LOCAL) {
					{
					State = 1205;
					_localctx.checkOption = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==CASCADED || _la==LOCAL) ) {
						_localctx.checkOption = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1208; Match(CHECK);
				State = 1209; Match(OPTION);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateDatabaseOptionContext : ParserRuleContext {
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode[] DEFAULT() { return GetTokens(MySqlParser.DEFAULT); }
		public ITerminalNode DEFAULT(int i) {
			return GetToken(MySqlParser.DEFAULT, i);
		}
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public CreateDatabaseOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createDatabaseOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateDatabaseOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateDatabaseOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateDatabaseOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateDatabaseOptionContext createDatabaseOption() {
		CreateDatabaseOptionContext _localctx = new CreateDatabaseOptionContext(Context, State);
		EnterRule(_localctx, 48, RULE_createDatabaseOption);
		int _la;
		try {
			State = 1235;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,107,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1213;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 1212; Match(DEFAULT);
					}
				}

				State = 1218;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case CHARACTER:
					{
					State = 1215; Match(CHARACTER);
					State = 1216; Match(SET);
					}
					break;
				case CHARSET:
					{
					State = 1217; Match(CHARSET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1221;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1220; Match(EQUAL_SYMBOL);
					}
				}

				State = 1225;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case BINARY:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
					{
					State = 1223; charsetName();
					}
					break;
				case DEFAULT:
					{
					State = 1224; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1228;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 1227; Match(DEFAULT);
					}
				}

				State = 1230; Match(COLLATE);
				State = 1232;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1231; Match(EQUAL_SYMBOL);
					}
				}

				State = 1234; collationName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OwnerStatementContext : ParserRuleContext {
		public ITerminalNode DEFINER() { return GetToken(MySqlParser.DEFINER, 0); }
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public ITerminalNode CURRENT_USER() { return GetToken(MySqlParser.CURRENT_USER, 0); }
		public OwnerStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ownerStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterOwnerStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitOwnerStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOwnerStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OwnerStatementContext ownerStatement() {
		OwnerStatementContext _localctx = new OwnerStatementContext(Context, State);
		EnterRule(_localctx, 50, RULE_ownerStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1237; Match(DEFINER);
			State = 1238; Match(EQUAL_SYMBOL);
			State = 1245;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STRING_LITERAL:
			case ID:
			case STRING_USER_NAME:
				{
				State = 1239; userName();
				}
				break;
			case CURRENT_USER:
				{
				State = 1240; Match(CURRENT_USER);
				State = 1243;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LR_BRACKET) {
					{
					State = 1241; Match(LR_BRACKET);
					State = 1242; Match(RR_BRACKET);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScheduleExpressionContext : ParserRuleContext {
		public ScheduleExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scheduleExpression; } }
	 
		public ScheduleExpressionContext() { }
		public virtual void CopyFrom(ScheduleExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PreciseScheduleContext : ScheduleExpressionContext {
		public ITerminalNode AT() { return GetToken(MySqlParser.AT, 0); }
		public TimestampValueContext timestampValue() {
			return GetRuleContext<TimestampValueContext>(0);
		}
		public IntervalExprContext[] intervalExpr() {
			return GetRuleContexts<IntervalExprContext>();
		}
		public IntervalExprContext intervalExpr(int i) {
			return GetRuleContext<IntervalExprContext>(i);
		}
		public PreciseScheduleContext(ScheduleExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPreciseSchedule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPreciseSchedule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreciseSchedule(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IntervalScheduleContext : ScheduleExpressionContext {
		public TimestampValueContext startTimestamp;
		public IntervalExprContext _intervalExpr;
		public IList<IntervalExprContext> _startIntervals = new List<IntervalExprContext>();
		public TimestampValueContext endTimestamp;
		public IList<IntervalExprContext> _endIntervals = new List<IntervalExprContext>();
		public ITerminalNode EVERY() { return GetToken(MySqlParser.EVERY, 0); }
		public IntervalTypeContext intervalType() {
			return GetRuleContext<IntervalTypeContext>(0);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode STARTS() { return GetToken(MySqlParser.STARTS, 0); }
		public ITerminalNode ENDS() { return GetToken(MySqlParser.ENDS, 0); }
		public TimestampValueContext[] timestampValue() {
			return GetRuleContexts<TimestampValueContext>();
		}
		public TimestampValueContext timestampValue(int i) {
			return GetRuleContext<TimestampValueContext>(i);
		}
		public IntervalExprContext[] intervalExpr() {
			return GetRuleContexts<IntervalExprContext>();
		}
		public IntervalExprContext intervalExpr(int i) {
			return GetRuleContext<IntervalExprContext>(i);
		}
		public IntervalScheduleContext(ScheduleExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIntervalSchedule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIntervalSchedule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntervalSchedule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScheduleExpressionContext scheduleExpression() {
		ScheduleExpressionContext _localctx = new ScheduleExpressionContext(Context, State);
		EnterRule(_localctx, 52, RULE_scheduleExpression);
		int _la;
		try {
			State = 1281;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AT:
				_localctx = new PreciseScheduleContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1247; Match(AT);
				State = 1248; timestampValue();
				State = 1252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==PLUS) {
					{
					{
					State = 1249; intervalExpr();
					}
					}
					State = 1254;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case EVERY:
				_localctx = new IntervalScheduleContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1255; Match(EVERY);
				State = 1258;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,111,Context) ) {
				case 1:
					{
					State = 1256; decimalLiteral();
					}
					break;
				case 2:
					{
					State = 1257; expression(0);
					}
					break;
				}
				State = 1260; intervalType();
				State = 1269;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==STARTS) {
					{
					State = 1261; Match(STARTS);
					State = 1262; ((IntervalScheduleContext)_localctx).startTimestamp = timestampValue();
					State = 1266;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==PLUS) {
						{
						{
						State = 1263; ((IntervalScheduleContext)_localctx)._intervalExpr = intervalExpr();
						((IntervalScheduleContext)_localctx)._startIntervals.Add(((IntervalScheduleContext)_localctx)._intervalExpr);
						}
						}
						State = 1268;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 1279;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ENDS) {
					{
					State = 1271; Match(ENDS);
					State = 1272; ((IntervalScheduleContext)_localctx).endTimestamp = timestampValue();
					State = 1276;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==PLUS) {
						{
						{
						State = 1273; ((IntervalScheduleContext)_localctx)._intervalExpr = intervalExpr();
						((IntervalScheduleContext)_localctx)._endIntervals.Add(((IntervalScheduleContext)_localctx)._intervalExpr);
						}
						}
						State = 1278;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimestampValueContext : ParserRuleContext {
		public ITerminalNode CURRENT_TIMESTAMP() { return GetToken(MySqlParser.CURRENT_TIMESTAMP, 0); }
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public TimestampValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timestampValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTimestampValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTimestampValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTimestampValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TimestampValueContext timestampValue() {
		TimestampValueContext _localctx = new TimestampValueContext(Context, State);
		EnterRule(_localctx, 54, RULE_timestampValue);
		try {
			State = 1287;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,117,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1283; Match(CURRENT_TIMESTAMP);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1284; stringLiteral();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1285; decimalLiteral();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1286; expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalExprContext : ParserRuleContext {
		public ITerminalNode INTERVAL() { return GetToken(MySqlParser.INTERVAL, 0); }
		public IntervalTypeContext intervalType() {
			return GetRuleContext<IntervalTypeContext>(0);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public IntervalExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIntervalExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIntervalExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntervalExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntervalExprContext intervalExpr() {
		IntervalExprContext _localctx = new IntervalExprContext(Context, State);
		EnterRule(_localctx, 56, RULE_intervalExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1289; Match(PLUS);
			State = 1290; Match(INTERVAL);
			State = 1293;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,118,Context) ) {
			case 1:
				{
				State = 1291; decimalLiteral();
				}
				break;
			case 2:
				{
				State = 1292; expression(0);
				}
				break;
			}
			State = 1295; intervalType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalTypeContext : ParserRuleContext {
		public IntervalTypeBaseContext intervalTypeBase() {
			return GetRuleContext<IntervalTypeBaseContext>(0);
		}
		public ITerminalNode YEAR() { return GetToken(MySqlParser.YEAR, 0); }
		public ITerminalNode YEAR_MONTH() { return GetToken(MySqlParser.YEAR_MONTH, 0); }
		public ITerminalNode DAY_HOUR() { return GetToken(MySqlParser.DAY_HOUR, 0); }
		public ITerminalNode DAY_MINUTE() { return GetToken(MySqlParser.DAY_MINUTE, 0); }
		public ITerminalNode DAY_SECOND() { return GetToken(MySqlParser.DAY_SECOND, 0); }
		public ITerminalNode HOUR_MINUTE() { return GetToken(MySqlParser.HOUR_MINUTE, 0); }
		public ITerminalNode HOUR_SECOND() { return GetToken(MySqlParser.HOUR_SECOND, 0); }
		public ITerminalNode MINUTE_SECOND() { return GetToken(MySqlParser.MINUTE_SECOND, 0); }
		public ITerminalNode SECOND_MICROSECOND() { return GetToken(MySqlParser.SECOND_MICROSECOND, 0); }
		public ITerminalNode MINUTE_MICROSECOND() { return GetToken(MySqlParser.MINUTE_MICROSECOND, 0); }
		public ITerminalNode HOUR_MICROSECOND() { return GetToken(MySqlParser.HOUR_MICROSECOND, 0); }
		public ITerminalNode DAY_MICROSECOND() { return GetToken(MySqlParser.DAY_MICROSECOND, 0); }
		public IntervalTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIntervalType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIntervalType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntervalType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntervalTypeContext intervalType() {
		IntervalTypeContext _localctx = new IntervalTypeContext(Context, State);
		EnterRule(_localctx, 58, RULE_intervalType);
		try {
			State = 1310;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1297; intervalTypeBase();
				}
				break;
			case YEAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1298; Match(YEAR);
				}
				break;
			case YEAR_MONTH:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1299; Match(YEAR_MONTH);
				}
				break;
			case DAY_HOUR:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1300; Match(DAY_HOUR);
				}
				break;
			case DAY_MINUTE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1301; Match(DAY_MINUTE);
				}
				break;
			case DAY_SECOND:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1302; Match(DAY_SECOND);
				}
				break;
			case HOUR_MINUTE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1303; Match(HOUR_MINUTE);
				}
				break;
			case HOUR_SECOND:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1304; Match(HOUR_SECOND);
				}
				break;
			case MINUTE_SECOND:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1305; Match(MINUTE_SECOND);
				}
				break;
			case SECOND_MICROSECOND:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1306; Match(SECOND_MICROSECOND);
				}
				break;
			case MINUTE_MICROSECOND:
				EnterOuterAlt(_localctx, 11);
				{
				State = 1307; Match(MINUTE_MICROSECOND);
				}
				break;
			case HOUR_MICROSECOND:
				EnterOuterAlt(_localctx, 12);
				{
				State = 1308; Match(HOUR_MICROSECOND);
				}
				break;
			case DAY_MICROSECOND:
				EnterOuterAlt(_localctx, 13);
				{
				State = 1309; Match(DAY_MICROSECOND);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnableTypeContext : ParserRuleContext {
		public ITerminalNode ENABLE() { return GetToken(MySqlParser.ENABLE, 0); }
		public ITerminalNode DISABLE() { return GetToken(MySqlParser.DISABLE, 0); }
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public EnableTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enableType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterEnableType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitEnableType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnableType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EnableTypeContext enableType() {
		EnableTypeContext _localctx = new EnableTypeContext(Context, State);
		EnterRule(_localctx, 60, RULE_enableType);
		try {
			State = 1317;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,120,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1312; Match(ENABLE);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1313; Match(DISABLE);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1314; Match(DISABLE);
				State = 1315; Match(ON);
				State = 1316; Match(SLAVE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexTypeContext : ParserRuleContext {
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public ITerminalNode BTREE() { return GetToken(MySqlParser.BTREE, 0); }
		public ITerminalNode HASH() { return GetToken(MySqlParser.HASH, 0); }
		public IndexTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexTypeContext indexType() {
		IndexTypeContext _localctx = new IndexTypeContext(Context, State);
		EnterRule(_localctx, 62, RULE_indexType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1319; Match(USING);
			State = 1320;
			_la = TokenStream.LA(1);
			if ( !(_la==BTREE || _la==HASH) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexOptionContext : ParserRuleContext {
		public ITerminalNode KEY_BLOCK_SIZE() { return GetToken(MySqlParser.KEY_BLOCK_SIZE, 0); }
		public FileSizeLiteralContext fileSizeLiteral() {
			return GetRuleContext<FileSizeLiteralContext>(0);
		}
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode PARSER() { return GetToken(MySqlParser.PARSER, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode INVISIBLE() { return GetToken(MySqlParser.INVISIBLE, 0); }
		public ITerminalNode VISIBLE() { return GetToken(MySqlParser.VISIBLE, 0); }
		public IndexOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexOptionContext indexOption() {
		IndexOptionContext _localctx = new IndexOptionContext(Context, State);
		EnterRule(_localctx, 64, RULE_indexOption);
		int _la;
		try {
			State = 1335;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case KEY_BLOCK_SIZE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1322; Match(KEY_BLOCK_SIZE);
				State = 1324;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1323; Match(EQUAL_SYMBOL);
					}
				}

				State = 1326; fileSizeLiteral();
				}
				break;
			case USING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1327; indexType();
				}
				break;
			case WITH:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1328; Match(WITH);
				State = 1329; Match(PARSER);
				State = 1330; uid();
				}
				break;
			case COMMENT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1331; Match(COMMENT);
				State = 1332; Match(STRING_LITERAL);
				}
				break;
			case INVISIBLE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1333; Match(INVISIBLE);
				}
				break;
			case VISIBLE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1334; Match(VISIBLE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureParameterContext : ParserRuleContext {
		public IToken direction;
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public ITerminalNode OUT() { return GetToken(MySqlParser.OUT, 0); }
		public ITerminalNode INOUT() { return GetToken(MySqlParser.INOUT, 0); }
		public ProcedureParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureParameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterProcedureParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitProcedureParameter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedureParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureParameterContext procedureParameter() {
		ProcedureParameterContext _localctx = new ProcedureParameterContext(Context, State);
		EnterRule(_localctx, 66, RULE_procedureParameter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1338;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (IN - 68)) | (1L << (INOUT - 68)) | (1L << (OUT - 68)))) != 0)) {
				{
				State = 1337;
				_localctx.direction = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (IN - 68)) | (1L << (INOUT - 68)) | (1L << (OUT - 68)))) != 0)) ) {
					_localctx.direction = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 1340; uid();
			State = 1341; dataType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionParameterContext : ParserRuleContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		public FunctionParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionParameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFunctionParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFunctionParameter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionParameterContext functionParameter() {
		FunctionParameterContext _localctx = new FunctionParameterContext(Context, State);
		EnterRule(_localctx, 68, RULE_functionParameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1343; uid();
			State = 1344; dataType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RoutineOptionContext : ParserRuleContext {
		public RoutineOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routineOption; } }
	 
		public RoutineOptionContext() { }
		public virtual void CopyFrom(RoutineOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class RoutineBehaviorContext : RoutineOptionContext {
		public ITerminalNode DETERMINISTIC() { return GetToken(MySqlParser.DETERMINISTIC, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public RoutineBehaviorContext(RoutineOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoutineBehavior(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoutineBehavior(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoutineBehavior(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RoutineLanguageContext : RoutineOptionContext {
		public ITerminalNode LANGUAGE() { return GetToken(MySqlParser.LANGUAGE, 0); }
		public ITerminalNode SQL() { return GetToken(MySqlParser.SQL, 0); }
		public RoutineLanguageContext(RoutineOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoutineLanguage(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoutineLanguage(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoutineLanguage(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RoutineCommentContext : RoutineOptionContext {
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public RoutineCommentContext(RoutineOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoutineComment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoutineComment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoutineComment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RoutineSecurityContext : RoutineOptionContext {
		public IToken context;
		public ITerminalNode SQL() { return GetToken(MySqlParser.SQL, 0); }
		public ITerminalNode SECURITY() { return GetToken(MySqlParser.SECURITY, 0); }
		public ITerminalNode DEFINER() { return GetToken(MySqlParser.DEFINER, 0); }
		public ITerminalNode INVOKER() { return GetToken(MySqlParser.INVOKER, 0); }
		public RoutineSecurityContext(RoutineOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoutineSecurity(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoutineSecurity(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoutineSecurity(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RoutineDataContext : RoutineOptionContext {
		public ITerminalNode CONTAINS() { return GetToken(MySqlParser.CONTAINS, 0); }
		public ITerminalNode SQL() { return GetToken(MySqlParser.SQL, 0); }
		public ITerminalNode NO() { return GetToken(MySqlParser.NO, 0); }
		public ITerminalNode READS() { return GetToken(MySqlParser.READS, 0); }
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode MODIFIES() { return GetToken(MySqlParser.MODIFIES, 0); }
		public RoutineDataContext(RoutineOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoutineData(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoutineData(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoutineData(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RoutineOptionContext routineOption() {
		RoutineOptionContext _localctx = new RoutineOptionContext(Context, State);
		EnterRule(_localctx, 70, RULE_routineOption);
		int _la;
		try {
			State = 1369;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMMENT:
				_localctx = new RoutineCommentContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1346; Match(COMMENT);
				State = 1347; Match(STRING_LITERAL);
				}
				break;
			case LANGUAGE:
				_localctx = new RoutineLanguageContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1348; Match(LANGUAGE);
				State = 1349; Match(SQL);
				}
				break;
			case DETERMINISTIC:
			case NOT:
				_localctx = new RoutineBehaviorContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1351;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 1350; Match(NOT);
					}
				}

				State = 1353; Match(DETERMINISTIC);
				}
				break;
			case MODIFIES:
			case READS:
			case CONTAINS:
			case NO:
				_localctx = new RoutineDataContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1364;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case CONTAINS:
					{
					State = 1354; Match(CONTAINS);
					State = 1355; Match(SQL);
					}
					break;
				case NO:
					{
					State = 1356; Match(NO);
					State = 1357; Match(SQL);
					}
					break;
				case READS:
					{
					State = 1358; Match(READS);
					State = 1359; Match(SQL);
					State = 1360; Match(DATA);
					}
					break;
				case MODIFIES:
					{
					State = 1361; Match(MODIFIES);
					State = 1362; Match(SQL);
					State = 1363; Match(DATA);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case SQL:
				_localctx = new RoutineSecurityContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1366; Match(SQL);
				State = 1367; Match(SECURITY);
				State = 1368;
				((RoutineSecurityContext)_localctx).context = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFINER || _la==INVOKER) ) {
					((RoutineSecurityContext)_localctx).context = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ServerOptionContext : ParserRuleContext {
		public ITerminalNode HOST() { return GetToken(MySqlParser.HOST, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode SOCKET() { return GetToken(MySqlParser.SOCKET, 0); }
		public ITerminalNode OWNER() { return GetToken(MySqlParser.OWNER, 0); }
		public ITerminalNode PORT() { return GetToken(MySqlParser.PORT, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ServerOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_serverOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterServerOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitServerOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitServerOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ServerOptionContext serverOption() {
		ServerOptionContext _localctx = new ServerOptionContext(Context, State);
		EnterRule(_localctx, 72, RULE_serverOption);
		try {
			State = 1385;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case HOST:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1371; Match(HOST);
				State = 1372; Match(STRING_LITERAL);
				}
				break;
			case DATABASE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1373; Match(DATABASE);
				State = 1374; Match(STRING_LITERAL);
				}
				break;
			case USER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1375; Match(USER);
				State = 1376; Match(STRING_LITERAL);
				}
				break;
			case PASSWORD:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1377; Match(PASSWORD);
				State = 1378; Match(STRING_LITERAL);
				}
				break;
			case SOCKET:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1379; Match(SOCKET);
				State = 1380; Match(STRING_LITERAL);
				}
				break;
			case OWNER:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1381; Match(OWNER);
				State = 1382; Match(STRING_LITERAL);
				}
				break;
			case PORT:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1383; Match(PORT);
				State = 1384; decimalLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateDefinitionsContext : ParserRuleContext {
		public CreateDefinitionContext[] createDefinition() {
			return GetRuleContexts<CreateDefinitionContext>();
		}
		public CreateDefinitionContext createDefinition(int i) {
			return GetRuleContext<CreateDefinitionContext>(i);
		}
		public CreateDefinitionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createDefinitions; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateDefinitions(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateDefinitions(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateDefinitions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateDefinitionsContext createDefinitions() {
		CreateDefinitionsContext _localctx = new CreateDefinitionsContext(Context, State);
		EnterRule(_localctx, 74, RULE_createDefinitions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1387; Match(LR_BRACKET);
			State = 1388; createDefinition();
			State = 1393;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1389; Match(COMMA);
				State = 1390; createDefinition();
				}
				}
				State = 1395;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1396; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateDefinitionContext : ParserRuleContext {
		public CreateDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createDefinition; } }
	 
		public CreateDefinitionContext() { }
		public virtual void CopyFrom(CreateDefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ColumnDeclarationContext : CreateDefinitionContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ColumnDefinitionContext columnDefinition() {
			return GetRuleContext<ColumnDefinitionContext>(0);
		}
		public ColumnDeclarationContext(CreateDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterColumnDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitColumnDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumnDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConstraintDeclarationContext : CreateDefinitionContext {
		public TableConstraintContext tableConstraint() {
			return GetRuleContext<TableConstraintContext>(0);
		}
		public ConstraintDeclarationContext(CreateDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterConstraintDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitConstraintDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstraintDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IndexDeclarationContext : CreateDefinitionContext {
		public IndexColumnDefinitionContext indexColumnDefinition() {
			return GetRuleContext<IndexColumnDefinitionContext>(0);
		}
		public IndexDeclarationContext(CreateDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateDefinitionContext createDefinition() {
		CreateDefinitionContext _localctx = new CreateDefinitionContext(Context, State);
		EnterRule(_localctx, 76, RULE_createDefinition);
		try {
			State = 1403;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DATABASE:
			case LEFT:
			case RIGHT:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case TEXT:
			case ENUM:
			case SERIAL:
			case COUNT:
			case POSITION:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLASS_ORIGIN:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COLUMN_NAME:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONSTRAINT_CATALOG:
			case CONSTRAINT_SCHEMA:
			case CONSTRAINT_NAME:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVISIBLE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MESSAGE_TEXT:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case MYSQL_ERRNO:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBCLASS_ORIGIN:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLE_NAME:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case VISIBLE:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case SESSION_VARIABLES_ADMIN:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CATALOG_NAME:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SCHEMA_NAME:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case CHARSET_REVERSE_QOUTE_STRING:
			case STRING_LITERAL:
			case ID:
			case REVERSE_QUOTE_ID:
				_localctx = new ColumnDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1398; uid();
				State = 1399; columnDefinition();
				}
				break;
			case CHECK:
			case CONSTRAINT:
			case FOREIGN:
			case PRIMARY:
			case UNIQUE:
				_localctx = new ConstraintDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1401; tableConstraint();
				}
				break;
			case FULLTEXT:
			case INDEX:
			case KEY:
			case SPATIAL:
				_localctx = new IndexDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1402; indexColumnDefinition();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnDefinitionContext : ParserRuleContext {
		public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		public ColumnConstraintContext[] columnConstraint() {
			return GetRuleContexts<ColumnConstraintContext>();
		}
		public ColumnConstraintContext columnConstraint(int i) {
			return GetRuleContext<ColumnConstraintContext>(i);
		}
		public ColumnDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnDefinition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterColumnDefinition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitColumnDefinition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumnDefinition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ColumnDefinitionContext columnDefinition() {
		ColumnDefinitionContext _localctx = new ColumnDefinitionContext(Context, State);
		EnterRule(_localctx, 78, RULE_columnDefinition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1405; dataType();
			State = 1409;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AS) | (1L << COLLATE) | (1L << DEFAULT) | (1L << GENERATED))) != 0) || ((((_la - 79)) & ~0x3f) == 0 && ((1L << (_la - 79)) & ((1L << (KEY - 79)) | (1L << (NOT - 79)) | (1L << (NULL_LITERAL - 79)) | (1L << (ON - 79)) | (1L << (PRIMARY - 79)) | (1L << (REFERENCES - 79)))) != 0) || _la==UNIQUE || _la==SERIAL || ((((_la - 263)) & ~0x3f) == 0 && ((1L << (_la - 263)) & ((1L << (AUTO_INCREMENT - 263)) | (1L << (COLUMN_FORMAT - 263)) | (1L << (COMMENT - 263)))) != 0) || _la==STORAGE || _la==NULL_SPEC_LITERAL) {
				{
				{
				State = 1406; columnConstraint();
				}
				}
				State = 1411;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnConstraintContext : ParserRuleContext {
		public ColumnConstraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnConstraint; } }
	 
		public ColumnConstraintContext() { }
		public virtual void CopyFrom(ColumnConstraintContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class StorageColumnConstraintContext : ColumnConstraintContext {
		public IToken storageval;
		public ITerminalNode STORAGE() { return GetToken(MySqlParser.STORAGE, 0); }
		public ITerminalNode DISK() { return GetToken(MySqlParser.DISK, 0); }
		public ITerminalNode MEMORY() { return GetToken(MySqlParser.MEMORY, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public StorageColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStorageColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStorageColumnConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStorageColumnConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FormatColumnConstraintContext : ColumnConstraintContext {
		public IToken colformat;
		public ITerminalNode COLUMN_FORMAT() { return GetToken(MySqlParser.COLUMN_FORMAT, 0); }
		public ITerminalNode FIXED() { return GetToken(MySqlParser.FIXED, 0); }
		public ITerminalNode DYNAMIC() { return GetToken(MySqlParser.DYNAMIC, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public FormatColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFormatColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFormatColumnConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFormatColumnConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CollateColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public CollateColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCollateColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCollateColumnConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollateColumnConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AutoIncrementColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode AUTO_INCREMENT() { return GetToken(MySqlParser.AUTO_INCREMENT, 0); }
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public CurrentTimestampContext currentTimestamp() {
			return GetRuleContext<CurrentTimestampContext>(0);
		}
		public AutoIncrementColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAutoIncrementColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAutoIncrementColumnConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAutoIncrementColumnConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CommentColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public CommentColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCommentColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCommentColumnConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommentColumnConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PrimaryKeyColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public ITerminalNode PRIMARY() { return GetToken(MySqlParser.PRIMARY, 0); }
		public PrimaryKeyColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPrimaryKeyColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPrimaryKeyColumnConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryKeyColumnConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UniqueKeyColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode UNIQUE() { return GetToken(MySqlParser.UNIQUE, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UniqueKeyColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUniqueKeyColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUniqueKeyColumnConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUniqueKeyColumnConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SerialDefaultColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode SERIAL() { return GetToken(MySqlParser.SERIAL, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode VALUE() { return GetToken(MySqlParser.VALUE, 0); }
		public SerialDefaultColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSerialDefaultColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSerialDefaultColumnConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSerialDefaultColumnConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NullColumnConstraintContext : ColumnConstraintContext {
		public NullNotnullContext nullNotnull() {
			return GetRuleContext<NullNotnullContext>(0);
		}
		public NullColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNullColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNullColumnConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNullColumnConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DefaultColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public DefaultValueContext defaultValue() {
			return GetRuleContext<DefaultValueContext>(0);
		}
		public DefaultColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDefaultColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDefaultColumnConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefaultColumnConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ReferenceColumnConstraintContext : ColumnConstraintContext {
		public ReferenceDefinitionContext referenceDefinition() {
			return GetRuleContext<ReferenceDefinitionContext>(0);
		}
		public ReferenceColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReferenceColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReferenceColumnConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReferenceColumnConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class GeneratedColumnConstraintContext : ColumnConstraintContext {
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode GENERATED() { return GetToken(MySqlParser.GENERATED, 0); }
		public ITerminalNode ALWAYS() { return GetToken(MySqlParser.ALWAYS, 0); }
		public ITerminalNode VIRTUAL() { return GetToken(MySqlParser.VIRTUAL, 0); }
		public ITerminalNode STORED() { return GetToken(MySqlParser.STORED, 0); }
		public GeneratedColumnConstraintContext(ColumnConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGeneratedColumnConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGeneratedColumnConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGeneratedColumnConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ColumnConstraintContext columnConstraint() {
		ColumnConstraintContext _localctx = new ColumnConstraintContext(Context, State);
		EnterRule(_localctx, 80, RULE_columnConstraint);
		int _la;
		try {
			State = 1452;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOT:
			case NULL_LITERAL:
			case NULL_SPEC_LITERAL:
				_localctx = new NullColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1412; nullNotnull();
				}
				break;
			case DEFAULT:
				_localctx = new DefaultColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1413; Match(DEFAULT);
				State = 1414; defaultValue();
				}
				break;
			case ON:
			case AUTO_INCREMENT:
				_localctx = new AutoIncrementColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1419;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case AUTO_INCREMENT:
					{
					State = 1415; Match(AUTO_INCREMENT);
					}
					break;
				case ON:
					{
					State = 1416; Match(ON);
					State = 1417; Match(UPDATE);
					State = 1418; currentTimestamp();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case KEY:
			case PRIMARY:
				_localctx = new PrimaryKeyColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1422;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PRIMARY) {
					{
					State = 1421; Match(PRIMARY);
					}
				}

				State = 1424; Match(KEY);
				}
				break;
			case UNIQUE:
				_localctx = new UniqueKeyColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1425; Match(UNIQUE);
				State = 1427;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,133,Context) ) {
				case 1:
					{
					State = 1426; Match(KEY);
					}
					break;
				}
				}
				break;
			case COMMENT:
				_localctx = new CommentColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 1429; Match(COMMENT);
				State = 1430; Match(STRING_LITERAL);
				}
				break;
			case COLUMN_FORMAT:
				_localctx = new FormatColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 1431; Match(COLUMN_FORMAT);
				State = 1432;
				((FormatColumnConstraintContext)_localctx).colformat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==DYNAMIC || _la==FIXED) ) {
					((FormatColumnConstraintContext)_localctx).colformat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case STORAGE:
				_localctx = new StorageColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 1433; Match(STORAGE);
				State = 1434;
				((StorageColumnConstraintContext)_localctx).storageval = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==DISK || _la==MEMORY) ) {
					((StorageColumnConstraintContext)_localctx).storageval = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case REFERENCES:
				_localctx = new ReferenceColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 1435; referenceDefinition();
				}
				break;
			case COLLATE:
				_localctx = new CollateColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 1436; Match(COLLATE);
				State = 1437; collationName();
				}
				break;
			case AS:
			case GENERATED:
				_localctx = new GeneratedColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 1440;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==GENERATED) {
					{
					State = 1438; Match(GENERATED);
					State = 1439; Match(ALWAYS);
					}
				}

				State = 1442; Match(AS);
				State = 1443; Match(LR_BRACKET);
				State = 1444; expression(0);
				State = 1445; Match(RR_BRACKET);
				State = 1447;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==STORED || _la==VIRTUAL) {
					{
					State = 1446;
					_la = TokenStream.LA(1);
					if ( !(_la==STORED || _la==VIRTUAL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case SERIAL:
				_localctx = new SerialDefaultColumnConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 1449; Match(SERIAL);
				State = 1450; Match(DEFAULT);
				State = 1451; Match(VALUE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableConstraintContext : ParserRuleContext {
		public TableConstraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableConstraint; } }
	 
		public TableConstraintContext() { }
		public virtual void CopyFrom(TableConstraintContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class UniqueKeyTableConstraintContext : TableConstraintContext {
		public UidContext name;
		public IToken indexFormat;
		public UidContext index;
		public ITerminalNode UNIQUE() { return GetToken(MySqlParser.UNIQUE, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UniqueKeyTableConstraintContext(TableConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUniqueKeyTableConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUniqueKeyTableConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUniqueKeyTableConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CheckTableConstraintContext : TableConstraintContext {
		public UidContext name;
		public ITerminalNode CHECK() { return GetToken(MySqlParser.CHECK, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public CheckTableConstraintContext(TableConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCheckTableConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCheckTableConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCheckTableConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PrimaryKeyTableConstraintContext : TableConstraintContext {
		public UidContext name;
		public UidContext index;
		public ITerminalNode PRIMARY() { return GetToken(MySqlParser.PRIMARY, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public PrimaryKeyTableConstraintContext(TableConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPrimaryKeyTableConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPrimaryKeyTableConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryKeyTableConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ForeignKeyTableConstraintContext : TableConstraintContext {
		public UidContext name;
		public UidContext index;
		public ITerminalNode FOREIGN() { return GetToken(MySqlParser.FOREIGN, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ReferenceDefinitionContext referenceDefinition() {
			return GetRuleContext<ReferenceDefinitionContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ForeignKeyTableConstraintContext(TableConstraintContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterForeignKeyTableConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitForeignKeyTableConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForeignKeyTableConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TableConstraintContext tableConstraint() {
		TableConstraintContext _localctx = new TableConstraintContext(Context, State);
		EnterRule(_localctx, 82, RULE_tableConstraint);
		int _la;
		try {
			State = 1523;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,153,Context) ) {
			case 1:
				_localctx = new PrimaryKeyTableConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1458;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 1454; Match(CONSTRAINT);
					State = 1456;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
						{
						State = 1455; ((PrimaryKeyTableConstraintContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 1460; Match(PRIMARY);
				State = 1461; Match(KEY);
				State = 1463;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
					{
					State = 1462; ((PrimaryKeyTableConstraintContext)_localctx).index = uid();
					}
				}

				State = 1466;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 1465; indexType();
					}
				}

				State = 1468; indexColumnNames();
				State = 1472;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==INVISIBLE || _la==KEY_BLOCK_SIZE || _la==VISIBLE) {
					{
					{
					State = 1469; indexOption();
					}
					}
					State = 1474;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new UniqueKeyTableConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1479;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 1475; Match(CONSTRAINT);
					State = 1477;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
						{
						State = 1476; ((UniqueKeyTableConstraintContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 1481; Match(UNIQUE);
				State = 1483;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDEX || _la==KEY) {
					{
					State = 1482;
					((UniqueKeyTableConstraintContext)_localctx).indexFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==INDEX || _la==KEY) ) {
						((UniqueKeyTableConstraintContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1486;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
					{
					State = 1485; ((UniqueKeyTableConstraintContext)_localctx).index = uid();
					}
				}

				State = 1489;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 1488; indexType();
					}
				}

				State = 1491; indexColumnNames();
				State = 1495;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==INVISIBLE || _la==KEY_BLOCK_SIZE || _la==VISIBLE) {
					{
					{
					State = 1492; indexOption();
					}
					}
					State = 1497;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 3:
				_localctx = new ForeignKeyTableConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1502;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 1498; Match(CONSTRAINT);
					State = 1500;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
						{
						State = 1499; ((ForeignKeyTableConstraintContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 1504; Match(FOREIGN);
				State = 1505; Match(KEY);
				State = 1507;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
					{
					State = 1506; ((ForeignKeyTableConstraintContext)_localctx).index = uid();
					}
				}

				State = 1509; indexColumnNames();
				State = 1510; referenceDefinition();
				}
				break;
			case 4:
				_localctx = new CheckTableConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1516;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 1512; Match(CONSTRAINT);
					State = 1514;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
						{
						State = 1513; ((CheckTableConstraintContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 1518; Match(CHECK);
				State = 1519; Match(LR_BRACKET);
				State = 1520; expression(0);
				State = 1521; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReferenceDefinitionContext : ParserRuleContext {
		public IToken matchType;
		public ITerminalNode REFERENCES() { return GetToken(MySqlParser.REFERENCES, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode MATCH() { return GetToken(MySqlParser.MATCH, 0); }
		public ReferenceActionContext referenceAction() {
			return GetRuleContext<ReferenceActionContext>(0);
		}
		public ITerminalNode FULL() { return GetToken(MySqlParser.FULL, 0); }
		public ITerminalNode PARTIAL() { return GetToken(MySqlParser.PARTIAL, 0); }
		public ITerminalNode SIMPLE() { return GetToken(MySqlParser.SIMPLE, 0); }
		public ReferenceDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referenceDefinition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReferenceDefinition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReferenceDefinition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReferenceDefinition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReferenceDefinitionContext referenceDefinition() {
		ReferenceDefinitionContext _localctx = new ReferenceDefinitionContext(Context, State);
		EnterRule(_localctx, 84, RULE_referenceDefinition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1525; Match(REFERENCES);
			State = 1526; tableName();
			State = 1528;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,154,Context) ) {
			case 1:
				{
				State = 1527; indexColumnNames();
				}
				break;
			}
			State = 1532;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MATCH) {
				{
				State = 1530; Match(MATCH);
				State = 1531;
				_localctx.matchType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FULL || _la==PARTIAL || _la==SIMPLE) ) {
					_localctx.matchType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 1535;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,156,Context) ) {
			case 1:
				{
				State = 1534; referenceAction();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReferenceActionContext : ParserRuleContext {
		public ReferenceControlTypeContext onDelete;
		public ReferenceControlTypeContext onUpdate;
		public ITerminalNode[] ON() { return GetTokens(MySqlParser.ON); }
		public ITerminalNode ON(int i) {
			return GetToken(MySqlParser.ON, i);
		}
		public ITerminalNode DELETE() { return GetToken(MySqlParser.DELETE, 0); }
		public ReferenceControlTypeContext[] referenceControlType() {
			return GetRuleContexts<ReferenceControlTypeContext>();
		}
		public ReferenceControlTypeContext referenceControlType(int i) {
			return GetRuleContext<ReferenceControlTypeContext>(i);
		}
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public ReferenceActionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referenceAction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReferenceAction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReferenceAction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReferenceAction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReferenceActionContext referenceAction() {
		ReferenceActionContext _localctx = new ReferenceActionContext(Context, State);
		EnterRule(_localctx, 86, RULE_referenceAction);
		try {
			State = 1553;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,159,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1537; Match(ON);
				State = 1538; Match(DELETE);
				State = 1539; _localctx.onDelete = referenceControlType();
				State = 1543;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,157,Context) ) {
				case 1:
					{
					State = 1540; Match(ON);
					State = 1541; Match(UPDATE);
					State = 1542; _localctx.onUpdate = referenceControlType();
					}
					break;
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1545; Match(ON);
				State = 1546; Match(UPDATE);
				State = 1547; _localctx.onUpdate = referenceControlType();
				State = 1551;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,158,Context) ) {
				case 1:
					{
					State = 1548; Match(ON);
					State = 1549; Match(DELETE);
					State = 1550; _localctx.onDelete = referenceControlType();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReferenceControlTypeContext : ParserRuleContext {
		public ITerminalNode RESTRICT() { return GetToken(MySqlParser.RESTRICT, 0); }
		public ITerminalNode CASCADE() { return GetToken(MySqlParser.CASCADE, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode NULL_LITERAL() { return GetToken(MySqlParser.NULL_LITERAL, 0); }
		public ITerminalNode NO() { return GetToken(MySqlParser.NO, 0); }
		public ITerminalNode ACTION() { return GetToken(MySqlParser.ACTION, 0); }
		public ReferenceControlTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referenceControlType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReferenceControlType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReferenceControlType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReferenceControlType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReferenceControlTypeContext referenceControlType() {
		ReferenceControlTypeContext _localctx = new ReferenceControlTypeContext(Context, State);
		EnterRule(_localctx, 88, RULE_referenceControlType);
		try {
			State = 1561;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case RESTRICT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1555; Match(RESTRICT);
				}
				break;
			case CASCADE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1556; Match(CASCADE);
				}
				break;
			case SET:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1557; Match(SET);
				State = 1558; Match(NULL_LITERAL);
				}
				break;
			case NO:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1559; Match(NO);
				State = 1560; Match(ACTION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexColumnDefinitionContext : ParserRuleContext {
		public IndexColumnDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexColumnDefinition; } }
	 
		public IndexColumnDefinitionContext() { }
		public virtual void CopyFrom(IndexColumnDefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SpecialIndexDeclarationContext : IndexColumnDefinitionContext {
		public IToken indexFormat;
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode FULLTEXT() { return GetToken(MySqlParser.FULLTEXT, 0); }
		public ITerminalNode SPATIAL() { return GetToken(MySqlParser.SPATIAL, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public SpecialIndexDeclarationContext(IndexColumnDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSpecialIndexDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSpecialIndexDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecialIndexDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SimpleIndexDeclarationContext : IndexColumnDefinitionContext {
		public IToken indexFormat;
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public SimpleIndexDeclarationContext(IndexColumnDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleIndexDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleIndexDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleIndexDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexColumnDefinitionContext indexColumnDefinition() {
		IndexColumnDefinitionContext _localctx = new IndexColumnDefinitionContext(Context, State);
		EnterRule(_localctx, 90, RULE_indexColumnDefinition);
		int _la;
		try {
			State = 1591;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INDEX:
			case KEY:
				_localctx = new SimpleIndexDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1563;
				((SimpleIndexDeclarationContext)_localctx).indexFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==INDEX || _la==KEY) ) {
					((SimpleIndexDeclarationContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1565;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
					{
					State = 1564; uid();
					}
				}

				State = 1568;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 1567; indexType();
					}
				}

				State = 1570; indexColumnNames();
				State = 1574;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==INVISIBLE || _la==KEY_BLOCK_SIZE || _la==VISIBLE) {
					{
					{
					State = 1571; indexOption();
					}
					}
					State = 1576;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case FULLTEXT:
			case SPATIAL:
				_localctx = new SpecialIndexDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1577;
				_la = TokenStream.LA(1);
				if ( !(_la==FULLTEXT || _la==SPATIAL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1579;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDEX || _la==KEY) {
					{
					State = 1578;
					((SpecialIndexDeclarationContext)_localctx).indexFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==INDEX || _la==KEY) ) {
						((SpecialIndexDeclarationContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1582;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
					{
					State = 1581; uid();
					}
				}

				State = 1584; indexColumnNames();
				State = 1588;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==INVISIBLE || _la==KEY_BLOCK_SIZE || _la==VISIBLE) {
					{
					{
					State = 1585; indexOption();
					}
					}
					State = 1590;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableOptionContext : ParserRuleContext {
		public TableOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableOption; } }
	 
		public TableOptionContext() { }
		public virtual void CopyFrom(TableOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TableOptionEngineContext : TableOptionContext {
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public TableOptionEngineContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionEngine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionEngine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionEngine(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionMaxRowsContext : TableOptionContext {
		public ITerminalNode MAX_ROWS() { return GetToken(MySqlParser.MAX_ROWS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public TableOptionMaxRowsContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionMaxRows(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionMaxRows(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionMaxRows(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionCollateContext : TableOptionContext {
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public TableOptionCollateContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionCollate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionCollate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionCollate(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionPersistentContext : TableOptionContext {
		public IToken extBoolValue;
		public ITerminalNode STATS_PERSISTENT() { return GetToken(MySqlParser.STATS_PERSISTENT, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public TableOptionPersistentContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionPersistent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionPersistent(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionPersistent(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionTablespaceContext : TableOptionContext {
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public TablespaceStorageContext tablespaceStorage() {
			return GetRuleContext<TablespaceStorageContext>(0);
		}
		public TableOptionTablespaceContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionTablespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionTablespace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionTablespace(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionPackKeysContext : TableOptionContext {
		public IToken extBoolValue;
		public ITerminalNode PACK_KEYS() { return GetToken(MySqlParser.PACK_KEYS, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public TableOptionPackKeysContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionPackKeys(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionPackKeys(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionPackKeys(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionPasswordContext : TableOptionContext {
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public TableOptionPasswordContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionPassword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionPassword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionPassword(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionUnionContext : TableOptionContext {
		public ITerminalNode UNION() { return GetToken(MySqlParser.UNION, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public TableOptionUnionContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionUnion(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionUnion(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionUnion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionSamplePageContext : TableOptionContext {
		public ITerminalNode STATS_SAMPLE_PAGES() { return GetToken(MySqlParser.STATS_SAMPLE_PAGES, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public TableOptionSamplePageContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionSamplePage(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionSamplePage(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionSamplePage(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionCharsetContext : TableOptionContext {
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode[] DEFAULT() { return GetTokens(MySqlParser.DEFAULT); }
		public ITerminalNode DEFAULT(int i) {
			return GetToken(MySqlParser.DEFAULT, i);
		}
		public TableOptionCharsetContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionCharset(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionCharset(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionCharset(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionIndexDirectoryContext : TableOptionContext {
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(MySqlParser.DIRECTORY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public TableOptionIndexDirectoryContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionIndexDirectory(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionIndexDirectory(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionIndexDirectory(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionKeyBlockSizeContext : TableOptionContext {
		public ITerminalNode KEY_BLOCK_SIZE() { return GetToken(MySqlParser.KEY_BLOCK_SIZE, 0); }
		public FileSizeLiteralContext fileSizeLiteral() {
			return GetRuleContext<FileSizeLiteralContext>(0);
		}
		public TableOptionKeyBlockSizeContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionKeyBlockSize(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionKeyBlockSize(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionKeyBlockSize(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionEncryptionContext : TableOptionContext {
		public ITerminalNode ENCRYPTION() { return GetToken(MySqlParser.ENCRYPTION, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public TableOptionEncryptionContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionEncryption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionEncryption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionEncryption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionDataDirectoryContext : TableOptionContext {
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(MySqlParser.DIRECTORY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public TableOptionDataDirectoryContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionDataDirectory(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionDataDirectory(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionDataDirectory(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionRecalculationContext : TableOptionContext {
		public IToken extBoolValue;
		public ITerminalNode STATS_AUTO_RECALC() { return GetToken(MySqlParser.STATS_AUTO_RECALC, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public TableOptionRecalculationContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionRecalculation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionRecalculation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionRecalculation(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionAutoIncrementContext : TableOptionContext {
		public ITerminalNode AUTO_INCREMENT() { return GetToken(MySqlParser.AUTO_INCREMENT, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public TableOptionAutoIncrementContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionAutoIncrement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionAutoIncrement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionAutoIncrement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionChecksumContext : TableOptionContext {
		public IToken boolValue;
		public ITerminalNode CHECKSUM() { return GetToken(MySqlParser.CHECKSUM, 0); }
		public ITerminalNode PAGE_CHECKSUM() { return GetToken(MySqlParser.PAGE_CHECKSUM, 0); }
		public TableOptionChecksumContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionChecksum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionChecksum(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionChecksum(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionDelayContext : TableOptionContext {
		public IToken boolValue;
		public ITerminalNode DELAY_KEY_WRITE() { return GetToken(MySqlParser.DELAY_KEY_WRITE, 0); }
		public TableOptionDelayContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionDelay(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionDelay(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionDelay(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionConnectionContext : TableOptionContext {
		public ITerminalNode CONNECTION() { return GetToken(MySqlParser.CONNECTION, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public TableOptionConnectionContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionConnection(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionConnection(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionConnection(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionCommentContext : TableOptionContext {
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public TableOptionCommentContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionComment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionComment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionComment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionAverageContext : TableOptionContext {
		public ITerminalNode AVG_ROW_LENGTH() { return GetToken(MySqlParser.AVG_ROW_LENGTH, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public TableOptionAverageContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionAverage(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionAverage(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionAverage(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionRowFormatContext : TableOptionContext {
		public IToken rowFormat;
		public ITerminalNode ROW_FORMAT() { return GetToken(MySqlParser.ROW_FORMAT, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode DYNAMIC() { return GetToken(MySqlParser.DYNAMIC, 0); }
		public ITerminalNode FIXED() { return GetToken(MySqlParser.FIXED, 0); }
		public ITerminalNode COMPRESSED() { return GetToken(MySqlParser.COMPRESSED, 0); }
		public ITerminalNode REDUNDANT() { return GetToken(MySqlParser.REDUNDANT, 0); }
		public ITerminalNode COMPACT() { return GetToken(MySqlParser.COMPACT, 0); }
		public TableOptionRowFormatContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionRowFormat(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionRowFormat(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionRowFormat(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionCompressionContext : TableOptionContext {
		public ITerminalNode COMPRESSION() { return GetToken(MySqlParser.COMPRESSION, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode ID() { return GetToken(MySqlParser.ID, 0); }
		public TableOptionCompressionContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionCompression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionCompression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionCompression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionInsertMethodContext : TableOptionContext {
		public IToken insertMethod;
		public ITerminalNode INSERT_METHOD() { return GetToken(MySqlParser.INSERT_METHOD, 0); }
		public ITerminalNode NO() { return GetToken(MySqlParser.NO, 0); }
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(MySqlParser.LAST, 0); }
		public TableOptionInsertMethodContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionInsertMethod(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionInsertMethod(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionInsertMethod(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableOptionMinRowsContext : TableOptionContext {
		public ITerminalNode MIN_ROWS() { return GetToken(MySqlParser.MIN_ROWS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public TableOptionMinRowsContext(TableOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableOptionMinRows(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableOptionMinRows(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableOptionMinRows(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TableOptionContext tableOption() {
		TableOptionContext _localctx = new TableOptionContext(Context, State);
		EnterRule(_localctx, 92, RULE_tableOption);
		int _la;
		try {
			State = 1737;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,197,Context) ) {
			case 1:
				_localctx = new TableOptionEngineContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1593; Match(ENGINE);
				State = 1595;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1594; Match(EQUAL_SYMBOL);
					}
				}

				State = 1597; engineName();
				}
				break;
			case 2:
				_localctx = new TableOptionAutoIncrementContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1598; Match(AUTO_INCREMENT);
				State = 1600;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1599; Match(EQUAL_SYMBOL);
					}
				}

				State = 1602; decimalLiteral();
				}
				break;
			case 3:
				_localctx = new TableOptionAverageContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1603; Match(AVG_ROW_LENGTH);
				State = 1605;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1604; Match(EQUAL_SYMBOL);
					}
				}

				State = 1607; decimalLiteral();
				}
				break;
			case 4:
				_localctx = new TableOptionCharsetContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1609;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 1608; Match(DEFAULT);
					}
				}

				State = 1614;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case CHARACTER:
					{
					State = 1611; Match(CHARACTER);
					State = 1612; Match(SET);
					}
					break;
				case CHARSET:
					{
					State = 1613; Match(CHARSET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1617;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1616; Match(EQUAL_SYMBOL);
					}
				}

				State = 1621;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case BINARY:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
					{
					State = 1619; charsetName();
					}
					break;
				case DEFAULT:
					{
					State = 1620; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 5:
				_localctx = new TableOptionChecksumContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1623;
				_la = TokenStream.LA(1);
				if ( !(_la==CHECKSUM || _la==PAGE_CHECKSUM) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1625;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1624; Match(EQUAL_SYMBOL);
					}
				}

				State = 1627;
				((TableOptionChecksumContext)_localctx).boolValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
					((TableOptionChecksumContext)_localctx).boolValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 6:
				_localctx = new TableOptionCollateContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 1629;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 1628; Match(DEFAULT);
					}
				}

				State = 1631; Match(COLLATE);
				State = 1633;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1632; Match(EQUAL_SYMBOL);
					}
				}

				State = 1635; collationName();
				}
				break;
			case 7:
				_localctx = new TableOptionCommentContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 1636; Match(COMMENT);
				State = 1638;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1637; Match(EQUAL_SYMBOL);
					}
				}

				State = 1640; Match(STRING_LITERAL);
				}
				break;
			case 8:
				_localctx = new TableOptionCompressionContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 1641; Match(COMPRESSION);
				State = 1643;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1642; Match(EQUAL_SYMBOL);
					}
				}

				State = 1645;
				_la = TokenStream.LA(1);
				if ( !(_la==STRING_LITERAL || _la==ID) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 9:
				_localctx = new TableOptionConnectionContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 1646; Match(CONNECTION);
				State = 1648;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1647; Match(EQUAL_SYMBOL);
					}
				}

				State = 1650; Match(STRING_LITERAL);
				}
				break;
			case 10:
				_localctx = new TableOptionDataDirectoryContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 1651; Match(DATA);
				State = 1652; Match(DIRECTORY);
				State = 1654;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1653; Match(EQUAL_SYMBOL);
					}
				}

				State = 1656; Match(STRING_LITERAL);
				}
				break;
			case 11:
				_localctx = new TableOptionDelayContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 1657; Match(DELAY_KEY_WRITE);
				State = 1659;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1658; Match(EQUAL_SYMBOL);
					}
				}

				State = 1661;
				((TableOptionDelayContext)_localctx).boolValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
					((TableOptionDelayContext)_localctx).boolValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 12:
				_localctx = new TableOptionEncryptionContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 1662; Match(ENCRYPTION);
				State = 1664;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1663; Match(EQUAL_SYMBOL);
					}
				}

				State = 1666; Match(STRING_LITERAL);
				}
				break;
			case 13:
				_localctx = new TableOptionIndexDirectoryContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 1667; Match(INDEX);
				State = 1668; Match(DIRECTORY);
				State = 1670;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1669; Match(EQUAL_SYMBOL);
					}
				}

				State = 1672; Match(STRING_LITERAL);
				}
				break;
			case 14:
				_localctx = new TableOptionInsertMethodContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 1673; Match(INSERT_METHOD);
				State = 1675;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1674; Match(EQUAL_SYMBOL);
					}
				}

				State = 1677;
				((TableOptionInsertMethodContext)_localctx).insertMethod = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FIRST || _la==LAST || _la==NO) ) {
					((TableOptionInsertMethodContext)_localctx).insertMethod = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 15:
				_localctx = new TableOptionKeyBlockSizeContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 1678; Match(KEY_BLOCK_SIZE);
				State = 1680;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1679; Match(EQUAL_SYMBOL);
					}
				}

				State = 1682; fileSizeLiteral();
				}
				break;
			case 16:
				_localctx = new TableOptionMaxRowsContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 1683; Match(MAX_ROWS);
				State = 1685;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1684; Match(EQUAL_SYMBOL);
					}
				}

				State = 1687; decimalLiteral();
				}
				break;
			case 17:
				_localctx = new TableOptionMinRowsContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 1688; Match(MIN_ROWS);
				State = 1690;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1689; Match(EQUAL_SYMBOL);
					}
				}

				State = 1692; decimalLiteral();
				}
				break;
			case 18:
				_localctx = new TableOptionPackKeysContext(_localctx);
				EnterOuterAlt(_localctx, 18);
				{
				State = 1693; Match(PACK_KEYS);
				State = 1695;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1694; Match(EQUAL_SYMBOL);
					}
				}

				State = 1697;
				((TableOptionPackKeysContext)_localctx).extBoolValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
					((TableOptionPackKeysContext)_localctx).extBoolValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 19:
				_localctx = new TableOptionPasswordContext(_localctx);
				EnterOuterAlt(_localctx, 19);
				{
				State = 1698; Match(PASSWORD);
				State = 1700;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1699; Match(EQUAL_SYMBOL);
					}
				}

				State = 1702; Match(STRING_LITERAL);
				}
				break;
			case 20:
				_localctx = new TableOptionRowFormatContext(_localctx);
				EnterOuterAlt(_localctx, 20);
				{
				State = 1703; Match(ROW_FORMAT);
				State = 1705;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1704; Match(EQUAL_SYMBOL);
					}
				}

				State = 1707;
				((TableOptionRowFormatContext)_localctx).rowFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || ((((_la - 290)) & ~0x3f) == 0 && ((1L << (_la - 290)) & ((1L << (COMPACT - 290)) | (1L << (COMPRESSED - 290)) | (1L << (DYNAMIC - 290)) | (1L << (FIXED - 290)))) != 0) || _la==REDUNDANT) ) {
					((TableOptionRowFormatContext)_localctx).rowFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 21:
				_localctx = new TableOptionRecalculationContext(_localctx);
				EnterOuterAlt(_localctx, 21);
				{
				State = 1708; Match(STATS_AUTO_RECALC);
				State = 1710;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1709; Match(EQUAL_SYMBOL);
					}
				}

				State = 1712;
				((TableOptionRecalculationContext)_localctx).extBoolValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
					((TableOptionRecalculationContext)_localctx).extBoolValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 22:
				_localctx = new TableOptionPersistentContext(_localctx);
				EnterOuterAlt(_localctx, 22);
				{
				State = 1713; Match(STATS_PERSISTENT);
				State = 1715;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1714; Match(EQUAL_SYMBOL);
					}
				}

				State = 1717;
				((TableOptionPersistentContext)_localctx).extBoolValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
					((TableOptionPersistentContext)_localctx).extBoolValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 23:
				_localctx = new TableOptionSamplePageContext(_localctx);
				EnterOuterAlt(_localctx, 23);
				{
				State = 1718; Match(STATS_SAMPLE_PAGES);
				State = 1720;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1719; Match(EQUAL_SYMBOL);
					}
				}

				State = 1722; decimalLiteral();
				}
				break;
			case 24:
				_localctx = new TableOptionTablespaceContext(_localctx);
				EnterOuterAlt(_localctx, 24);
				{
				State = 1723; Match(TABLESPACE);
				State = 1724; uid();
				State = 1726;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,195,Context) ) {
				case 1:
					{
					State = 1725; tablespaceStorage();
					}
					break;
				}
				}
				break;
			case 25:
				_localctx = new TableOptionTablespaceContext(_localctx);
				EnterOuterAlt(_localctx, 25);
				{
				State = 1728; tablespaceStorage();
				}
				break;
			case 26:
				_localctx = new TableOptionUnionContext(_localctx);
				EnterOuterAlt(_localctx, 26);
				{
				State = 1729; Match(UNION);
				State = 1731;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 1730; Match(EQUAL_SYMBOL);
					}
				}

				State = 1733; Match(LR_BRACKET);
				State = 1734; tables();
				State = 1735; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablespaceStorageContext : ParserRuleContext {
		public ITerminalNode STORAGE() { return GetToken(MySqlParser.STORAGE, 0); }
		public ITerminalNode DISK() { return GetToken(MySqlParser.DISK, 0); }
		public ITerminalNode MEMORY() { return GetToken(MySqlParser.MEMORY, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public TablespaceStorageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablespaceStorage; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTablespaceStorage(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTablespaceStorage(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTablespaceStorage(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TablespaceStorageContext tablespaceStorage() {
		TablespaceStorageContext _localctx = new TablespaceStorageContext(Context, State);
		EnterRule(_localctx, 94, RULE_tablespaceStorage);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1739; Match(STORAGE);
			State = 1740;
			_la = TokenStream.LA(1);
			if ( !(_la==DEFAULT || _la==DISK || _la==MEMORY) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionDefinitionsContext : ParserRuleContext {
		public DecimalLiteralContext count;
		public DecimalLiteralContext subCount;
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public ITerminalNode[] BY() { return GetTokens(MySqlParser.BY); }
		public ITerminalNode BY(int i) {
			return GetToken(MySqlParser.BY, i);
		}
		public PartitionFunctionDefinitionContext partitionFunctionDefinition() {
			return GetRuleContext<PartitionFunctionDefinitionContext>(0);
		}
		public ITerminalNode PARTITIONS() { return GetToken(MySqlParser.PARTITIONS, 0); }
		public ITerminalNode SUBPARTITION() { return GetToken(MySqlParser.SUBPARTITION, 0); }
		public SubpartitionFunctionDefinitionContext subpartitionFunctionDefinition() {
			return GetRuleContext<SubpartitionFunctionDefinitionContext>(0);
		}
		public PartitionDefinitionContext[] partitionDefinition() {
			return GetRuleContexts<PartitionDefinitionContext>();
		}
		public PartitionDefinitionContext partitionDefinition(int i) {
			return GetRuleContext<PartitionDefinitionContext>(i);
		}
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public ITerminalNode SUBPARTITIONS() { return GetToken(MySqlParser.SUBPARTITIONS, 0); }
		public PartitionDefinitionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionDefinitions; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionDefinitions(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionDefinitions(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionDefinitions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PartitionDefinitionsContext partitionDefinitions() {
		PartitionDefinitionsContext _localctx = new PartitionDefinitionsContext(Context, State);
		EnterRule(_localctx, 96, RULE_partitionDefinitions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1742; Match(PARTITION);
			State = 1743; Match(BY);
			State = 1744; partitionFunctionDefinition();
			State = 1747;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITIONS) {
				{
				State = 1745; Match(PARTITIONS);
				State = 1746; _localctx.count = decimalLiteral();
				}
			}

			State = 1756;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SUBPARTITION) {
				{
				State = 1749; Match(SUBPARTITION);
				State = 1750; Match(BY);
				State = 1751; subpartitionFunctionDefinition();
				State = 1754;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SUBPARTITIONS) {
					{
					State = 1752; Match(SUBPARTITIONS);
					State = 1753; _localctx.subCount = decimalLiteral();
					}
				}

				}
			}

			State = 1769;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,202,Context) ) {
			case 1:
				{
				State = 1758; Match(LR_BRACKET);
				State = 1759; partitionDefinition();
				State = 1764;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1760; Match(COMMA);
					State = 1761; partitionDefinition();
					}
					}
					State = 1766;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1767; Match(RR_BRACKET);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionFunctionDefinitionContext : ParserRuleContext {
		public PartitionFunctionDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionFunctionDefinition; } }
	 
		public PartitionFunctionDefinitionContext() { }
		public virtual void CopyFrom(PartitionFunctionDefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PartitionFunctionKeyContext : PartitionFunctionDefinitionContext {
		public IToken algType;
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode LINEAR() { return GetToken(MySqlParser.LINEAR, 0); }
		public ITerminalNode ALGORITHM() { return GetToken(MySqlParser.ALGORITHM, 0); }
		public PartitionFunctionKeyContext(PartitionFunctionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionFunctionKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionFunctionKey(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionFunctionKey(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PartitionFunctionHashContext : PartitionFunctionDefinitionContext {
		public ITerminalNode HASH() { return GetToken(MySqlParser.HASH, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LINEAR() { return GetToken(MySqlParser.LINEAR, 0); }
		public PartitionFunctionHashContext(PartitionFunctionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionFunctionHash(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionFunctionHash(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionFunctionHash(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PartitionFunctionListContext : PartitionFunctionDefinitionContext {
		public ITerminalNode LIST() { return GetToken(MySqlParser.LIST, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode COLUMNS() { return GetToken(MySqlParser.COLUMNS, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public PartitionFunctionListContext(PartitionFunctionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionFunctionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionFunctionList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionFunctionList(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PartitionFunctionRangeContext : PartitionFunctionDefinitionContext {
		public ITerminalNode RANGE() { return GetToken(MySqlParser.RANGE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode COLUMNS() { return GetToken(MySqlParser.COLUMNS, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public PartitionFunctionRangeContext(PartitionFunctionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionFunctionRange(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionFunctionRange(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionFunctionRange(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PartitionFunctionDefinitionContext partitionFunctionDefinition() {
		PartitionFunctionDefinitionContext _localctx = new PartitionFunctionDefinitionContext(Context, State);
		EnterRule(_localctx, 98, RULE_partitionFunctionDefinition);
		int _la;
		try {
			State = 1816;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,208,Context) ) {
			case 1:
				_localctx = new PartitionFunctionHashContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1772;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LINEAR) {
					{
					State = 1771; Match(LINEAR);
					}
				}

				State = 1774; Match(HASH);
				State = 1775; Match(LR_BRACKET);
				State = 1776; expression(0);
				State = 1777; Match(RR_BRACKET);
				}
				break;
			case 2:
				_localctx = new PartitionFunctionKeyContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1780;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LINEAR) {
					{
					State = 1779; Match(LINEAR);
					}
				}

				State = 1782; Match(KEY);
				State = 1786;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALGORITHM) {
					{
					State = 1783; Match(ALGORITHM);
					State = 1784; Match(EQUAL_SYMBOL);
					State = 1785;
					((PartitionFunctionKeyContext)_localctx).algType = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==ONE_DECIMAL || _la==TWO_DECIMAL) ) {
						((PartitionFunctionKeyContext)_localctx).algType = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1788; Match(LR_BRACKET);
				State = 1789; uidList();
				State = 1790; Match(RR_BRACKET);
				}
				break;
			case 3:
				_localctx = new PartitionFunctionRangeContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1792; Match(RANGE);
				State = 1802;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case LR_BRACKET:
					{
					State = 1793; Match(LR_BRACKET);
					State = 1794; expression(0);
					State = 1795; Match(RR_BRACKET);
					}
					break;
				case COLUMNS:
					{
					State = 1797; Match(COLUMNS);
					State = 1798; Match(LR_BRACKET);
					State = 1799; uidList();
					State = 1800; Match(RR_BRACKET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 4:
				_localctx = new PartitionFunctionListContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1804; Match(LIST);
				State = 1814;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case LR_BRACKET:
					{
					State = 1805; Match(LR_BRACKET);
					State = 1806; expression(0);
					State = 1807; Match(RR_BRACKET);
					}
					break;
				case COLUMNS:
					{
					State = 1809; Match(COLUMNS);
					State = 1810; Match(LR_BRACKET);
					State = 1811; uidList();
					State = 1812; Match(RR_BRACKET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubpartitionFunctionDefinitionContext : ParserRuleContext {
		public SubpartitionFunctionDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartitionFunctionDefinition; } }
	 
		public SubpartitionFunctionDefinitionContext() { }
		public virtual void CopyFrom(SubpartitionFunctionDefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SubPartitionFunctionHashContext : SubpartitionFunctionDefinitionContext {
		public ITerminalNode HASH() { return GetToken(MySqlParser.HASH, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LINEAR() { return GetToken(MySqlParser.LINEAR, 0); }
		public SubPartitionFunctionHashContext(SubpartitionFunctionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubPartitionFunctionHash(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubPartitionFunctionHash(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubPartitionFunctionHash(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SubPartitionFunctionKeyContext : SubpartitionFunctionDefinitionContext {
		public IToken algType;
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode LINEAR() { return GetToken(MySqlParser.LINEAR, 0); }
		public ITerminalNode ALGORITHM() { return GetToken(MySqlParser.ALGORITHM, 0); }
		public SubPartitionFunctionKeyContext(SubpartitionFunctionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubPartitionFunctionKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubPartitionFunctionKey(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubPartitionFunctionKey(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubpartitionFunctionDefinitionContext subpartitionFunctionDefinition() {
		SubpartitionFunctionDefinitionContext _localctx = new SubpartitionFunctionDefinitionContext(Context, State);
		EnterRule(_localctx, 100, RULE_subpartitionFunctionDefinition);
		int _la;
		try {
			State = 1839;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,212,Context) ) {
			case 1:
				_localctx = new SubPartitionFunctionHashContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1819;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LINEAR) {
					{
					State = 1818; Match(LINEAR);
					}
				}

				State = 1821; Match(HASH);
				State = 1822; Match(LR_BRACKET);
				State = 1823; expression(0);
				State = 1824; Match(RR_BRACKET);
				}
				break;
			case 2:
				_localctx = new SubPartitionFunctionKeyContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1827;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LINEAR) {
					{
					State = 1826; Match(LINEAR);
					}
				}

				State = 1829; Match(KEY);
				State = 1833;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALGORITHM) {
					{
					State = 1830; Match(ALGORITHM);
					State = 1831; Match(EQUAL_SYMBOL);
					State = 1832;
					((SubPartitionFunctionKeyContext)_localctx).algType = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==ONE_DECIMAL || _la==TWO_DECIMAL) ) {
						((SubPartitionFunctionKeyContext)_localctx).algType = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1835; Match(LR_BRACKET);
				State = 1836; uidList();
				State = 1837; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionDefinitionContext : ParserRuleContext {
		public PartitionDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionDefinition; } }
	 
		public PartitionDefinitionContext() { }
		public virtual void CopyFrom(PartitionDefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PartitionComparisionContext : PartitionDefinitionContext {
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode VALUES() { return GetToken(MySqlParser.VALUES, 0); }
		public ITerminalNode LESS() { return GetToken(MySqlParser.LESS, 0); }
		public ITerminalNode THAN() { return GetToken(MySqlParser.THAN, 0); }
		public PartitionDefinerAtomContext[] partitionDefinerAtom() {
			return GetRuleContexts<PartitionDefinerAtomContext>();
		}
		public PartitionDefinerAtomContext partitionDefinerAtom(int i) {
			return GetRuleContext<PartitionDefinerAtomContext>(i);
		}
		public PartitionOptionContext[] partitionOption() {
			return GetRuleContexts<PartitionOptionContext>();
		}
		public PartitionOptionContext partitionOption(int i) {
			return GetRuleContext<PartitionOptionContext>(i);
		}
		public SubpartitionDefinitionContext[] subpartitionDefinition() {
			return GetRuleContexts<SubpartitionDefinitionContext>();
		}
		public SubpartitionDefinitionContext subpartitionDefinition(int i) {
			return GetRuleContext<SubpartitionDefinitionContext>(i);
		}
		public PartitionComparisionContext(PartitionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionComparision(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionComparision(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionComparision(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PartitionListAtomContext : PartitionDefinitionContext {
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode VALUES() { return GetToken(MySqlParser.VALUES, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public PartitionDefinerAtomContext[] partitionDefinerAtom() {
			return GetRuleContexts<PartitionDefinerAtomContext>();
		}
		public PartitionDefinerAtomContext partitionDefinerAtom(int i) {
			return GetRuleContext<PartitionDefinerAtomContext>(i);
		}
		public PartitionOptionContext[] partitionOption() {
			return GetRuleContexts<PartitionOptionContext>();
		}
		public PartitionOptionContext partitionOption(int i) {
			return GetRuleContext<PartitionOptionContext>(i);
		}
		public SubpartitionDefinitionContext[] subpartitionDefinition() {
			return GetRuleContexts<SubpartitionDefinitionContext>();
		}
		public SubpartitionDefinitionContext subpartitionDefinition(int i) {
			return GetRuleContext<SubpartitionDefinitionContext>(i);
		}
		public PartitionListAtomContext(PartitionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionListAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionListAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionListAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PartitionListVectorContext : PartitionDefinitionContext {
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode VALUES() { return GetToken(MySqlParser.VALUES, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public PartitionDefinerVectorContext[] partitionDefinerVector() {
			return GetRuleContexts<PartitionDefinerVectorContext>();
		}
		public PartitionDefinerVectorContext partitionDefinerVector(int i) {
			return GetRuleContext<PartitionDefinerVectorContext>(i);
		}
		public PartitionOptionContext[] partitionOption() {
			return GetRuleContexts<PartitionOptionContext>();
		}
		public PartitionOptionContext partitionOption(int i) {
			return GetRuleContext<PartitionOptionContext>(i);
		}
		public SubpartitionDefinitionContext[] subpartitionDefinition() {
			return GetRuleContexts<SubpartitionDefinitionContext>();
		}
		public SubpartitionDefinitionContext subpartitionDefinition(int i) {
			return GetRuleContext<SubpartitionDefinitionContext>(i);
		}
		public PartitionListVectorContext(PartitionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionListVector(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionListVector(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionListVector(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PartitionSimpleContext : PartitionDefinitionContext {
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public PartitionOptionContext[] partitionOption() {
			return GetRuleContexts<PartitionOptionContext>();
		}
		public PartitionOptionContext partitionOption(int i) {
			return GetRuleContext<PartitionOptionContext>(i);
		}
		public SubpartitionDefinitionContext[] subpartitionDefinition() {
			return GetRuleContexts<SubpartitionDefinitionContext>();
		}
		public SubpartitionDefinitionContext subpartitionDefinition(int i) {
			return GetRuleContext<SubpartitionDefinitionContext>(i);
		}
		public PartitionSimpleContext(PartitionDefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionSimple(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionSimple(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionSimple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PartitionDefinitionContext partitionDefinition() {
		PartitionDefinitionContext _localctx = new PartitionDefinitionContext(Context, State);
		EnterRule(_localctx, 102, RULE_partitionDefinition);
		int _la;
		try {
			int _alt;
			State = 1972;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,231,Context) ) {
			case 1:
				_localctx = new PartitionComparisionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1841; Match(PARTITION);
				State = 1842; uid();
				State = 1843; Match(VALUES);
				State = 1844; Match(LESS);
				State = 1845; Match(THAN);
				State = 1846; Match(LR_BRACKET);
				State = 1847; partitionDefinerAtom();
				State = 1852;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1848; Match(COMMA);
					State = 1849; partitionDefinerAtom();
					}
					}
					State = 1854;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1855; Match(RR_BRACKET);
				State = 1859;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==INDEX || ((((_la - 288)) & ~0x3f) == 0 && ((1L << (_la - 288)) & ((1L << (COMMENT - 288)) | (1L << (DATA - 288)) | (1L << (ENGINE - 288)))) != 0) || ((((_la - 410)) & ~0x3f) == 0 && ((1L << (_la - 410)) & ((1L << (MAX_ROWS - 410)) | (1L << (MIN_ROWS - 410)) | (1L << (NODEGROUP - 410)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
					{
					{
					State = 1856; partitionOption();
					}
					}
					State = 1861;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1870;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SUBPARTITION) {
					{
					State = 1862; subpartitionDefinition();
					State = 1867;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,215,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 1863; Match(COMMA);
							State = 1864; subpartitionDefinition();
							}
							} 
						}
						State = 1869;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,215,Context);
					}
					}
				}

				}
				break;
			case 2:
				_localctx = new PartitionComparisionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1872; Match(PARTITION);
				State = 1873; uid();
				State = 1874; Match(VALUES);
				State = 1875; Match(LESS);
				State = 1876; Match(THAN);
				State = 1877; partitionDefinerAtom();
				State = 1881;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==INDEX || ((((_la - 288)) & ~0x3f) == 0 && ((1L << (_la - 288)) & ((1L << (COMMENT - 288)) | (1L << (DATA - 288)) | (1L << (ENGINE - 288)))) != 0) || ((((_la - 410)) & ~0x3f) == 0 && ((1L << (_la - 410)) & ((1L << (MAX_ROWS - 410)) | (1L << (MIN_ROWS - 410)) | (1L << (NODEGROUP - 410)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
					{
					{
					State = 1878; partitionOption();
					}
					}
					State = 1883;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1892;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SUBPARTITION) {
					{
					State = 1884; subpartitionDefinition();
					State = 1889;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,218,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 1885; Match(COMMA);
							State = 1886; subpartitionDefinition();
							}
							} 
						}
						State = 1891;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,218,Context);
					}
					}
				}

				}
				break;
			case 3:
				_localctx = new PartitionListAtomContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1894; Match(PARTITION);
				State = 1895; uid();
				State = 1896; Match(VALUES);
				State = 1897; Match(IN);
				State = 1898; Match(LR_BRACKET);
				State = 1899; partitionDefinerAtom();
				State = 1904;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1900; Match(COMMA);
					State = 1901; partitionDefinerAtom();
					}
					}
					State = 1906;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1907; Match(RR_BRACKET);
				State = 1911;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==INDEX || ((((_la - 288)) & ~0x3f) == 0 && ((1L << (_la - 288)) & ((1L << (COMMENT - 288)) | (1L << (DATA - 288)) | (1L << (ENGINE - 288)))) != 0) || ((((_la - 410)) & ~0x3f) == 0 && ((1L << (_la - 410)) & ((1L << (MAX_ROWS - 410)) | (1L << (MIN_ROWS - 410)) | (1L << (NODEGROUP - 410)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
					{
					{
					State = 1908; partitionOption();
					}
					}
					State = 1913;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1922;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SUBPARTITION) {
					{
					State = 1914; subpartitionDefinition();
					State = 1919;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,222,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 1915; Match(COMMA);
							State = 1916; subpartitionDefinition();
							}
							} 
						}
						State = 1921;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,222,Context);
					}
					}
				}

				}
				break;
			case 4:
				_localctx = new PartitionListVectorContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1924; Match(PARTITION);
				State = 1925; uid();
				State = 1926; Match(VALUES);
				State = 1927; Match(IN);
				State = 1928; Match(LR_BRACKET);
				State = 1929; partitionDefinerVector();
				State = 1934;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1930; Match(COMMA);
					State = 1931; partitionDefinerVector();
					}
					}
					State = 1936;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1937; Match(RR_BRACKET);
				State = 1941;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==INDEX || ((((_la - 288)) & ~0x3f) == 0 && ((1L << (_la - 288)) & ((1L << (COMMENT - 288)) | (1L << (DATA - 288)) | (1L << (ENGINE - 288)))) != 0) || ((((_la - 410)) & ~0x3f) == 0 && ((1L << (_la - 410)) & ((1L << (MAX_ROWS - 410)) | (1L << (MIN_ROWS - 410)) | (1L << (NODEGROUP - 410)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
					{
					{
					State = 1938; partitionOption();
					}
					}
					State = 1943;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1952;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SUBPARTITION) {
					{
					State = 1944; subpartitionDefinition();
					State = 1949;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,226,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 1945; Match(COMMA);
							State = 1946; subpartitionDefinition();
							}
							} 
						}
						State = 1951;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,226,Context);
					}
					}
				}

				}
				break;
			case 5:
				_localctx = new PartitionSimpleContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1954; Match(PARTITION);
				State = 1955; uid();
				State = 1959;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==INDEX || ((((_la - 288)) & ~0x3f) == 0 && ((1L << (_la - 288)) & ((1L << (COMMENT - 288)) | (1L << (DATA - 288)) | (1L << (ENGINE - 288)))) != 0) || ((((_la - 410)) & ~0x3f) == 0 && ((1L << (_la - 410)) & ((1L << (MAX_ROWS - 410)) | (1L << (MIN_ROWS - 410)) | (1L << (NODEGROUP - 410)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
					{
					{
					State = 1956; partitionOption();
					}
					}
					State = 1961;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1970;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SUBPARTITION) {
					{
					State = 1962; subpartitionDefinition();
					State = 1967;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,229,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 1963; Match(COMMA);
							State = 1964; subpartitionDefinition();
							}
							} 
						}
						State = 1969;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,229,Context);
					}
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionDefinerAtomContext : ParserRuleContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode MAXVALUE() { return GetToken(MySqlParser.MAXVALUE, 0); }
		public PartitionDefinerAtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionDefinerAtom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionDefinerAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionDefinerAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionDefinerAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PartitionDefinerAtomContext partitionDefinerAtom() {
		PartitionDefinerAtomContext _localctx = new PartitionDefinerAtomContext(Context, State);
		EnterRule(_localctx, 104, RULE_partitionDefinerAtom);
		try {
			State = 1977;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,232,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1974; constant();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1975; expression(0);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1976; Match(MAXVALUE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionDefinerVectorContext : ParserRuleContext {
		public PartitionDefinerAtomContext[] partitionDefinerAtom() {
			return GetRuleContexts<PartitionDefinerAtomContext>();
		}
		public PartitionDefinerAtomContext partitionDefinerAtom(int i) {
			return GetRuleContext<PartitionDefinerAtomContext>(i);
		}
		public PartitionDefinerVectorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionDefinerVector; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionDefinerVector(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionDefinerVector(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionDefinerVector(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PartitionDefinerVectorContext partitionDefinerVector() {
		PartitionDefinerVectorContext _localctx = new PartitionDefinerVectorContext(Context, State);
		EnterRule(_localctx, 106, RULE_partitionDefinerVector);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1979; Match(LR_BRACKET);
			State = 1980; partitionDefinerAtom();
			State = 1983;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 1981; Match(COMMA);
				State = 1982; partitionDefinerAtom();
				}
				}
				State = 1985;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COMMA );
			State = 1987; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubpartitionDefinitionContext : ParserRuleContext {
		public ITerminalNode SUBPARTITION() { return GetToken(MySqlParser.SUBPARTITION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public PartitionOptionContext[] partitionOption() {
			return GetRuleContexts<PartitionOptionContext>();
		}
		public PartitionOptionContext partitionOption(int i) {
			return GetRuleContext<PartitionOptionContext>(i);
		}
		public SubpartitionDefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subpartitionDefinition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubpartitionDefinition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubpartitionDefinition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubpartitionDefinition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubpartitionDefinitionContext subpartitionDefinition() {
		SubpartitionDefinitionContext _localctx = new SubpartitionDefinitionContext(Context, State);
		EnterRule(_localctx, 108, RULE_subpartitionDefinition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1989; Match(SUBPARTITION);
			State = 1990; uid();
			State = 1994;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==INDEX || ((((_la - 288)) & ~0x3f) == 0 && ((1L << (_la - 288)) & ((1L << (COMMENT - 288)) | (1L << (DATA - 288)) | (1L << (ENGINE - 288)))) != 0) || ((((_la - 410)) & ~0x3f) == 0 && ((1L << (_la - 410)) & ((1L << (MAX_ROWS - 410)) | (1L << (MIN_ROWS - 410)) | (1L << (NODEGROUP - 410)))) != 0) || _la==STORAGE || _la==TABLESPACE) {
				{
				{
				State = 1991; partitionOption();
				}
				}
				State = 1996;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartitionOptionContext : ParserRuleContext {
		public PartitionOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partitionOption; } }
	 
		public PartitionOptionContext() { }
		public virtual void CopyFrom(PartitionOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PartitionOptionCommentContext : PartitionOptionContext {
		public IToken comment;
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PartitionOptionCommentContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionComment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionComment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionOptionComment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PartitionOptionNodeGroupContext : PartitionOptionContext {
		public UidContext nodegroup;
		public ITerminalNode NODEGROUP() { return GetToken(MySqlParser.NODEGROUP, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public PartitionOptionNodeGroupContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionNodeGroup(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionNodeGroup(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionOptionNodeGroup(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PartitionOptionIndexDirectoryContext : PartitionOptionContext {
		public IToken indexDirectory;
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(MySqlParser.DIRECTORY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PartitionOptionIndexDirectoryContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionIndexDirectory(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionIndexDirectory(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionOptionIndexDirectory(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PartitionOptionMaxRowsContext : PartitionOptionContext {
		public DecimalLiteralContext maxRows;
		public ITerminalNode MAX_ROWS() { return GetToken(MySqlParser.MAX_ROWS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public PartitionOptionMaxRowsContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionMaxRows(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionMaxRows(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionOptionMaxRows(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PartitionOptionTablespaceContext : PartitionOptionContext {
		public UidContext tablespace;
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public PartitionOptionTablespaceContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionTablespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionTablespace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionOptionTablespace(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PartitionOptionEngineContext : PartitionOptionContext {
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public ITerminalNode STORAGE() { return GetToken(MySqlParser.STORAGE, 0); }
		public PartitionOptionEngineContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionEngine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionEngine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionOptionEngine(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PartitionOptionMinRowsContext : PartitionOptionContext {
		public DecimalLiteralContext minRows;
		public ITerminalNode MIN_ROWS() { return GetToken(MySqlParser.MIN_ROWS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public PartitionOptionMinRowsContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionMinRows(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionMinRows(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionOptionMinRows(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PartitionOptionDataDirectoryContext : PartitionOptionContext {
		public IToken dataDirectory;
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(MySqlParser.DIRECTORY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PartitionOptionDataDirectoryContext(PartitionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPartitionOptionDataDirectory(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPartitionOptionDataDirectory(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartitionOptionDataDirectory(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PartitionOptionContext partitionOption() {
		PartitionOptionContext _localctx = new PartitionOptionContext(Context, State);
		EnterRule(_localctx, 110, RULE_partitionOption);
		int _la;
		try {
			State = 2042;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ENGINE:
			case STORAGE:
				_localctx = new PartitionOptionEngineContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1998;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==STORAGE) {
					{
					State = 1997; Match(STORAGE);
					}
				}

				State = 2000; Match(ENGINE);
				State = 2002;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2001; Match(EQUAL_SYMBOL);
					}
				}

				State = 2004; engineName();
				}
				break;
			case COMMENT:
				_localctx = new PartitionOptionCommentContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 2005; Match(COMMENT);
				State = 2007;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2006; Match(EQUAL_SYMBOL);
					}
				}

				State = 2009; ((PartitionOptionCommentContext)_localctx).comment = Match(STRING_LITERAL);
				}
				break;
			case DATA:
				_localctx = new PartitionOptionDataDirectoryContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 2010; Match(DATA);
				State = 2011; Match(DIRECTORY);
				State = 2013;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2012; Match(EQUAL_SYMBOL);
					}
				}

				State = 2015; ((PartitionOptionDataDirectoryContext)_localctx).dataDirectory = Match(STRING_LITERAL);
				}
				break;
			case INDEX:
				_localctx = new PartitionOptionIndexDirectoryContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 2016; Match(INDEX);
				State = 2017; Match(DIRECTORY);
				State = 2019;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2018; Match(EQUAL_SYMBOL);
					}
				}

				State = 2021; ((PartitionOptionIndexDirectoryContext)_localctx).indexDirectory = Match(STRING_LITERAL);
				}
				break;
			case MAX_ROWS:
				_localctx = new PartitionOptionMaxRowsContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 2022; Match(MAX_ROWS);
				State = 2024;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2023; Match(EQUAL_SYMBOL);
					}
				}

				State = 2026; ((PartitionOptionMaxRowsContext)_localctx).maxRows = decimalLiteral();
				}
				break;
			case MIN_ROWS:
				_localctx = new PartitionOptionMinRowsContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 2027; Match(MIN_ROWS);
				State = 2029;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2028; Match(EQUAL_SYMBOL);
					}
				}

				State = 2031; ((PartitionOptionMinRowsContext)_localctx).minRows = decimalLiteral();
				}
				break;
			case TABLESPACE:
				_localctx = new PartitionOptionTablespaceContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 2032; Match(TABLESPACE);
				State = 2034;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2033; Match(EQUAL_SYMBOL);
					}
				}

				State = 2036; ((PartitionOptionTablespaceContext)_localctx).tablespace = uid();
				}
				break;
			case NODEGROUP:
				_localctx = new PartitionOptionNodeGroupContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 2037; Match(NODEGROUP);
				State = 2039;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2038; Match(EQUAL_SYMBOL);
					}
				}

				State = 2041; ((PartitionOptionNodeGroupContext)_localctx).nodegroup = uid();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterDatabaseContext : ParserRuleContext {
		public AlterDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterDatabase; } }
	 
		public AlterDatabaseContext() { }
		public virtual void CopyFrom(AlterDatabaseContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AlterUpgradeNameContext : AlterDatabaseContext {
		public IToken dbFormat;
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode UPGRADE() { return GetToken(MySqlParser.UPGRADE, 0); }
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(MySqlParser.DIRECTORY, 0); }
		public ITerminalNode NAME() { return GetToken(MySqlParser.NAME, 0); }
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(MySqlParser.SCHEMA, 0); }
		public AlterUpgradeNameContext(AlterDatabaseContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterUpgradeName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterUpgradeName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterUpgradeName(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterSimpleDatabaseContext : AlterDatabaseContext {
		public IToken dbFormat;
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(MySqlParser.SCHEMA, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public CreateDatabaseOptionContext[] createDatabaseOption() {
			return GetRuleContexts<CreateDatabaseOptionContext>();
		}
		public CreateDatabaseOptionContext createDatabaseOption(int i) {
			return GetRuleContext<CreateDatabaseOptionContext>(i);
		}
		public AlterSimpleDatabaseContext(AlterDatabaseContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterSimpleDatabase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterSimpleDatabase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterSimpleDatabase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterDatabaseContext alterDatabase() {
		AlterDatabaseContext _localctx = new AlterDatabaseContext(Context, State);
		EnterRule(_localctx, 112, RULE_alterDatabase);
		int _la;
		try {
			State = 2062;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,247,Context) ) {
			case 1:
				_localctx = new AlterSimpleDatabaseContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 2044; Match(ALTER);
				State = 2045;
				((AlterSimpleDatabaseContext)_localctx).dbFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DATABASE || _la==SCHEMA) ) {
					((AlterSimpleDatabaseContext)_localctx).dbFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2047;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,245,Context) ) {
				case 1:
					{
					State = 2046; uid();
					}
					break;
				}
				State = 2050;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 2049; createDatabaseOption();
					}
					}
					State = 2052;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << CHARACTER) | (1L << COLLATE) | (1L << DEFAULT))) != 0) || _la==CHARSET );
				}
				break;
			case 2:
				_localctx = new AlterUpgradeNameContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 2054; Match(ALTER);
				State = 2055;
				((AlterUpgradeNameContext)_localctx).dbFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DATABASE || _la==SCHEMA) ) {
					((AlterUpgradeNameContext)_localctx).dbFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2056; uid();
				State = 2057; Match(UPGRADE);
				State = 2058; Match(DATA);
				State = 2059; Match(DIRECTORY);
				State = 2060; Match(NAME);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterEventContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode EVENT() { return GetToken(MySqlParser.EVENT, 0); }
		public FullIdContext[] fullId() {
			return GetRuleContexts<FullIdContext>();
		}
		public FullIdContext fullId(int i) {
			return GetRuleContext<FullIdContext>(i);
		}
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public ITerminalNode[] ON() { return GetTokens(MySqlParser.ON); }
		public ITerminalNode ON(int i) {
			return GetToken(MySqlParser.ON, i);
		}
		public ITerminalNode SCHEDULE() { return GetToken(MySqlParser.SCHEDULE, 0); }
		public ScheduleExpressionContext scheduleExpression() {
			return GetRuleContext<ScheduleExpressionContext>(0);
		}
		public ITerminalNode COMPLETION() { return GetToken(MySqlParser.COMPLETION, 0); }
		public ITerminalNode PRESERVE() { return GetToken(MySqlParser.PRESERVE, 0); }
		public ITerminalNode RENAME() { return GetToken(MySqlParser.RENAME, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public EnableTypeContext enableType() {
			return GetRuleContext<EnableTypeContext>(0);
		}
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode DO() { return GetToken(MySqlParser.DO, 0); }
		public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public AlterEventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterEvent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterEvent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterEvent(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterEvent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterEventContext alterEvent() {
		AlterEventContext _localctx = new AlterEventContext(Context, State);
		EnterRule(_localctx, 114, RULE_alterEvent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2064; Match(ALTER);
			State = 2066;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 2065; ownerStatement();
				}
			}

			State = 2068; Match(EVENT);
			State = 2069; fullId();
			State = 2073;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,249,Context) ) {
			case 1:
				{
				State = 2070; Match(ON);
				State = 2071; Match(SCHEDULE);
				State = 2072; scheduleExpression();
				}
				break;
			}
			State = 2081;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 2075; Match(ON);
				State = 2076; Match(COMPLETION);
				State = 2078;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 2077; Match(NOT);
					}
				}

				State = 2080; Match(PRESERVE);
				}
			}

			State = 2086;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,252,Context) ) {
			case 1:
				{
				State = 2083; Match(RENAME);
				State = 2084; Match(TO);
				State = 2085; fullId();
				}
				break;
			}
			State = 2089;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DISABLE || _la==ENABLE) {
				{
				State = 2088; enableType();
				}
			}

			State = 2093;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMENT) {
				{
				State = 2091; Match(COMMENT);
				State = 2092; Match(STRING_LITERAL);
				}
			}

			State = 2097;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,255,Context) ) {
			case 1:
				{
				State = 2095; Match(DO);
				State = 2096; routineBody();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterFunctionContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public RoutineOptionContext[] routineOption() {
			return GetRuleContexts<RoutineOptionContext>();
		}
		public RoutineOptionContext routineOption(int i) {
			return GetRuleContext<RoutineOptionContext>(i);
		}
		public AlterFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterFunctionContext alterFunction() {
		AlterFunctionContext _localctx = new AlterFunctionContext(Context, State);
		EnterRule(_localctx, 116, RULE_alterFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2099; Match(ALTER);
			State = 2100; Match(FUNCTION);
			State = 2101; fullId();
			State = 2105;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DETERMINISTIC || ((((_la - 97)) & ~0x3f) == 0 && ((1L << (_la - 97)) & ((1L << (MODIFIES - 97)) | (1L << (NOT - 97)) | (1L << (READS - 97)) | (1L << (SQL - 97)))) != 0) || _la==COMMENT || _la==CONTAINS || _la==LANGUAGE || _la==NO) {
				{
				{
				State = 2102; routineOption();
				}
				}
				State = 2107;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterInstanceContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode INSTANCE() { return GetToken(MySqlParser.INSTANCE, 0); }
		public ITerminalNode ROTATE() { return GetToken(MySqlParser.ROTATE, 0); }
		public ITerminalNode INNODB() { return GetToken(MySqlParser.INNODB, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public AlterInstanceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterInstance; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterInstance(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterInstance(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterInstance(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterInstanceContext alterInstance() {
		AlterInstanceContext _localctx = new AlterInstanceContext(Context, State);
		EnterRule(_localctx, 118, RULE_alterInstance);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2108; Match(ALTER);
			State = 2109; Match(INSTANCE);
			State = 2110; Match(ROTATE);
			State = 2111; Match(INNODB);
			State = 2112; Match(MASTER);
			State = 2113; Match(KEY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterLogfileGroupContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode LOGFILE() { return GetToken(MySqlParser.LOGFILE, 0); }
		public ITerminalNode GROUP() { return GetToken(MySqlParser.GROUP, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode UNDOFILE() { return GetToken(MySqlParser.UNDOFILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public ITerminalNode INITIAL_SIZE() { return GetToken(MySqlParser.INITIAL_SIZE, 0); }
		public FileSizeLiteralContext fileSizeLiteral() {
			return GetRuleContext<FileSizeLiteralContext>(0);
		}
		public ITerminalNode WAIT() { return GetToken(MySqlParser.WAIT, 0); }
		public AlterLogfileGroupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterLogfileGroup; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterLogfileGroup(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterLogfileGroup(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterLogfileGroup(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterLogfileGroupContext alterLogfileGroup() {
		AlterLogfileGroupContext _localctx = new AlterLogfileGroupContext(Context, State);
		EnterRule(_localctx, 120, RULE_alterLogfileGroup);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2115; Match(ALTER);
			State = 2116; Match(LOGFILE);
			State = 2117; Match(GROUP);
			State = 2118; uid();
			State = 2119; Match(ADD);
			State = 2120; Match(UNDOFILE);
			State = 2121; Match(STRING_LITERAL);
			State = 2127;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INITIAL_SIZE) {
				{
				State = 2122; Match(INITIAL_SIZE);
				State = 2124;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2123; Match(EQUAL_SYMBOL);
					}
				}

				State = 2126; fileSizeLiteral();
				}
			}

			State = 2130;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WAIT) {
				{
				State = 2129; Match(WAIT);
				}
			}

			State = 2132; Match(ENGINE);
			State = 2134;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQUAL_SYMBOL) {
				{
				State = 2133; Match(EQUAL_SYMBOL);
				}
			}

			State = 2136; engineName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterProcedureContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public RoutineOptionContext[] routineOption() {
			return GetRuleContexts<RoutineOptionContext>();
		}
		public RoutineOptionContext routineOption(int i) {
			return GetRuleContext<RoutineOptionContext>(i);
		}
		public AlterProcedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterProcedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterProcedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterProcedure(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterProcedure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterProcedureContext alterProcedure() {
		AlterProcedureContext _localctx = new AlterProcedureContext(Context, State);
		EnterRule(_localctx, 122, RULE_alterProcedure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2138; Match(ALTER);
			State = 2139; Match(PROCEDURE);
			State = 2140; fullId();
			State = 2144;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DETERMINISTIC || ((((_la - 97)) & ~0x3f) == 0 && ((1L << (_la - 97)) & ((1L << (MODIFIES - 97)) | (1L << (NOT - 97)) | (1L << (READS - 97)) | (1L << (SQL - 97)))) != 0) || _la==COMMENT || _la==CONTAINS || _la==LANGUAGE || _la==NO) {
				{
				{
				State = 2141; routineOption();
				}
				}
				State = 2146;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterServerContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode SERVER() { return GetToken(MySqlParser.SERVER, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode OPTIONS() { return GetToken(MySqlParser.OPTIONS, 0); }
		public ServerOptionContext[] serverOption() {
			return GetRuleContexts<ServerOptionContext>();
		}
		public ServerOptionContext serverOption(int i) {
			return GetRuleContext<ServerOptionContext>(i);
		}
		public AlterServerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterServer; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterServer(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterServer(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterServer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterServerContext alterServer() {
		AlterServerContext _localctx = new AlterServerContext(Context, State);
		EnterRule(_localctx, 124, RULE_alterServer);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2147; Match(ALTER);
			State = 2148; Match(SERVER);
			State = 2149; uid();
			State = 2150; Match(OPTIONS);
			State = 2151; Match(LR_BRACKET);
			State = 2152; serverOption();
			State = 2157;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2153; Match(COMMA);
				State = 2154; serverOption();
				}
				}
				State = 2159;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2160; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTableContext : ParserRuleContext {
		public IToken intimeAction;
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public AlterSpecificationContext[] alterSpecification() {
			return GetRuleContexts<AlterSpecificationContext>();
		}
		public AlterSpecificationContext alterSpecification(int i) {
			return GetRuleContext<AlterSpecificationContext>(i);
		}
		public PartitionDefinitionsContext partitionDefinitions() {
			return GetRuleContext<PartitionDefinitionsContext>(0);
		}
		public ITerminalNode ONLINE() { return GetToken(MySqlParser.ONLINE, 0); }
		public ITerminalNode OFFLINE() { return GetToken(MySqlParser.OFFLINE, 0); }
		public AlterTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterTable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterTable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterTableContext alterTable() {
		AlterTableContext _localctx = new AlterTableContext(Context, State);
		EnterRule(_localctx, 126, RULE_alterTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2162; Match(ALTER);
			State = 2164;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OFFLINE || _la==ONLINE) {
				{
				State = 2163;
				_localctx.intimeAction = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==OFFLINE || _la==ONLINE) ) {
					_localctx.intimeAction = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2167;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 2166; Match(IGNORE);
				}
			}

			State = 2169; Match(TABLE);
			State = 2170; tableName();
			State = 2179;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,266,Context) ) {
			case 1:
				{
				State = 2171; alterSpecification();
				State = 2176;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2172; Match(COMMA);
					State = 2173; alterSpecification();
					}
					}
					State = 2178;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			State = 2182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 2181; partitionDefinitions();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterTablespaceContext : ParserRuleContext {
		public IToken objectAction;
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode DATAFILE() { return GetToken(MySqlParser.DATAFILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode INITIAL_SIZE() { return GetToken(MySqlParser.INITIAL_SIZE, 0); }
		public FileSizeLiteralContext fileSizeLiteral() {
			return GetRuleContext<FileSizeLiteralContext>(0);
		}
		public ITerminalNode WAIT() { return GetToken(MySqlParser.WAIT, 0); }
		public AlterTablespaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterTablespace; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterTablespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterTablespace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterTablespace(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterTablespaceContext alterTablespace() {
		AlterTablespaceContext _localctx = new AlterTablespaceContext(Context, State);
		EnterRule(_localctx, 128, RULE_alterTablespace);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2184; Match(ALTER);
			State = 2185; Match(TABLESPACE);
			State = 2186; uid();
			State = 2187;
			_localctx.objectAction = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==ADD || _la==DROP) ) {
				_localctx.objectAction = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2188; Match(DATAFILE);
			State = 2189; Match(STRING_LITERAL);
			State = 2193;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INITIAL_SIZE) {
				{
				State = 2190; Match(INITIAL_SIZE);
				State = 2191; Match(EQUAL_SYMBOL);
				State = 2192; fileSizeLiteral();
				}
			}

			State = 2196;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WAIT) {
				{
				State = 2195; Match(WAIT);
				}
			}

			State = 2198; Match(ENGINE);
			State = 2200;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQUAL_SYMBOL) {
				{
				State = 2199; Match(EQUAL_SYMBOL);
				}
			}

			State = 2202; engineName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterViewContext : ParserRuleContext {
		public IToken algType;
		public IToken secContext;
		public IToken checkOpt;
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode VIEW() { return GetToken(MySqlParser.VIEW, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ITerminalNode ALGORITHM() { return GetToken(MySqlParser.ALGORITHM, 0); }
		public OwnerStatementContext ownerStatement() {
			return GetRuleContext<OwnerStatementContext>(0);
		}
		public ITerminalNode SQL() { return GetToken(MySqlParser.SQL, 0); }
		public ITerminalNode SECURITY() { return GetToken(MySqlParser.SECURITY, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode CHECK() { return GetToken(MySqlParser.CHECK, 0); }
		public ITerminalNode OPTION() { return GetToken(MySqlParser.OPTION, 0); }
		public ITerminalNode UNDEFINED() { return GetToken(MySqlParser.UNDEFINED, 0); }
		public ITerminalNode MERGE() { return GetToken(MySqlParser.MERGE, 0); }
		public ITerminalNode TEMPTABLE() { return GetToken(MySqlParser.TEMPTABLE, 0); }
		public ITerminalNode DEFINER() { return GetToken(MySqlParser.DEFINER, 0); }
		public ITerminalNode INVOKER() { return GetToken(MySqlParser.INVOKER, 0); }
		public ITerminalNode CASCADED() { return GetToken(MySqlParser.CASCADED, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public AlterViewContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterView; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterView(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterView(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterView(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterViewContext alterView() {
		AlterViewContext _localctx = new AlterViewContext(Context, State);
		EnterRule(_localctx, 130, RULE_alterView);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2204; Match(ALTER);
			State = 2208;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALGORITHM) {
				{
				State = 2205; Match(ALGORITHM);
				State = 2206; Match(EQUAL_SYMBOL);
				State = 2207;
				_localctx.algType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==MERGE || _la==TEMPTABLE || _la==UNDEFINED) ) {
					_localctx.algType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2211;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINER) {
				{
				State = 2210; ownerStatement();
				}
			}

			State = 2216;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SQL) {
				{
				State = 2213; Match(SQL);
				State = 2214; Match(SECURITY);
				State = 2215;
				_localctx.secContext = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFINER || _la==INVOKER) ) {
					_localctx.secContext = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2218; Match(VIEW);
			State = 2219; fullId();
			State = 2224;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LR_BRACKET) {
				{
				State = 2220; Match(LR_BRACKET);
				State = 2221; uidList();
				State = 2222; Match(RR_BRACKET);
				}
			}

			State = 2226; Match(AS);
			State = 2227; selectStatement();
			State = 2234;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 2228; Match(WITH);
				State = 2230;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CASCADED || _la==LOCAL) {
					{
					State = 2229;
					_localctx.checkOpt = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==CASCADED || _la==LOCAL) ) {
						_localctx.checkOpt = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2232; Match(CHECK);
				State = 2233; Match(OPTION);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterSpecificationContext : ParserRuleContext {
		public AlterSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterSpecification; } }
	 
		public AlterSpecificationContext() { }
		public virtual void CopyFrom(AlterSpecificationContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AlterByDisableKeysContext : AlterSpecificationContext {
		public ITerminalNode DISABLE() { return GetToken(MySqlParser.DISABLE, 0); }
		public ITerminalNode KEYS() { return GetToken(MySqlParser.KEYS, 0); }
		public AlterByDisableKeysContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDisableKeys(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDisableKeys(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByDisableKeys(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByDefaultCharsetContext : AlterSpecificationContext {
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public AlterByDefaultCharsetContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDefaultCharset(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDefaultCharset(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByDefaultCharset(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByRenameColumnContext : AlterSpecificationContext {
		public UidContext oldColumn;
		public UidContext newColumn;
		public ITerminalNode RENAME() { return GetToken(MySqlParser.RENAME, 0); }
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public AlterByRenameColumnContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByRenameColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByRenameColumn(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByRenameColumn(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByConvertCharsetContext : AlterSpecificationContext {
		public ITerminalNode CONVERT() { return GetToken(MySqlParser.CONVERT, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public AlterByConvertCharsetContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByConvertCharset(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByConvertCharset(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByConvertCharset(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByAddPartitionContext : AlterSpecificationContext {
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public PartitionDefinitionContext[] partitionDefinition() {
			return GetRuleContexts<PartitionDefinitionContext>();
		}
		public PartitionDefinitionContext partitionDefinition(int i) {
			return GetRuleContext<PartitionDefinitionContext>(i);
		}
		public AlterByAddPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddPartition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByAddPartition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByAddForeignKeyContext : AlterSpecificationContext {
		public UidContext name;
		public UidContext indexName;
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode FOREIGN() { return GetToken(MySqlParser.FOREIGN, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ReferenceDefinitionContext referenceDefinition() {
			return GetRuleContext<ReferenceDefinitionContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public AlterByAddForeignKeyContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddForeignKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddForeignKey(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByAddForeignKey(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByRenameIndexContext : AlterSpecificationContext {
		public IToken indexFormat;
		public ITerminalNode RENAME() { return GetToken(MySqlParser.RENAME, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public AlterByRenameIndexContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByRenameIndex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByRenameIndex(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByRenameIndex(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByRemovePartitioningContext : AlterSpecificationContext {
		public ITerminalNode REMOVE() { return GetToken(MySqlParser.REMOVE, 0); }
		public ITerminalNode PARTITIONING() { return GetToken(MySqlParser.PARTITIONING, 0); }
		public AlterByRemovePartitioningContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByRemovePartitioning(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByRemovePartitioning(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByRemovePartitioning(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByRenameContext : AlterSpecificationContext {
		public IToken renameFormat;
		public ITerminalNode RENAME() { return GetToken(MySqlParser.RENAME, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public AlterByRenameContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByRename(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByRename(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByRename(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByOptimizePartitionContext : AlterSpecificationContext {
		public ITerminalNode OPTIMIZE() { return GetToken(MySqlParser.OPTIMIZE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByOptimizePartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByOptimizePartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByOptimizePartition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByOptimizePartition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByImportTablespaceContext : AlterSpecificationContext {
		public ITerminalNode IMPORT() { return GetToken(MySqlParser.IMPORT, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public AlterByImportTablespaceContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByImportTablespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByImportTablespace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByImportTablespace(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByCoalescePartitionContext : AlterSpecificationContext {
		public ITerminalNode COALESCE() { return GetToken(MySqlParser.COALESCE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public AlterByCoalescePartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByCoalescePartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByCoalescePartition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByCoalescePartition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByAddColumnsContext : AlterSpecificationContext {
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ColumnDefinitionContext[] columnDefinition() {
			return GetRuleContexts<ColumnDefinitionContext>();
		}
		public ColumnDefinitionContext columnDefinition(int i) {
			return GetRuleContext<ColumnDefinitionContext>(i);
		}
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public AlterByAddColumnsContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddColumns(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddColumns(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByAddColumns(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByDropForeignKeyContext : AlterSpecificationContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode FOREIGN() { return GetToken(MySqlParser.FOREIGN, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public AlterByDropForeignKeyContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDropForeignKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDropForeignKey(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByDropForeignKey(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByAddCheckTableConstraintContext : AlterSpecificationContext {
		public UidContext name;
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode CHECK() { return GetToken(MySqlParser.CHECK, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public AlterByAddCheckTableConstraintContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddCheckTableConstraint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddCheckTableConstraint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByAddCheckTableConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByRebuildPartitionContext : AlterSpecificationContext {
		public ITerminalNode REBUILD() { return GetToken(MySqlParser.REBUILD, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByRebuildPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByRebuildPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByRebuildPartition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByRebuildPartition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByUpgradePartitioningContext : AlterSpecificationContext {
		public ITerminalNode UPGRADE() { return GetToken(MySqlParser.UPGRADE, 0); }
		public ITerminalNode PARTITIONING() { return GetToken(MySqlParser.PARTITIONING, 0); }
		public AlterByUpgradePartitioningContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByUpgradePartitioning(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByUpgradePartitioning(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByUpgradePartitioning(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByRepairPartitionContext : AlterSpecificationContext {
		public ITerminalNode REPAIR() { return GetToken(MySqlParser.REPAIR, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByRepairPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByRepairPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByRepairPartition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByRepairPartition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByExchangePartitionContext : AlterSpecificationContext {
		public IToken validationFormat;
		public ITerminalNode EXCHANGE() { return GetToken(MySqlParser.EXCHANGE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode[] WITH() { return GetTokens(MySqlParser.WITH); }
		public ITerminalNode WITH(int i) {
			return GetToken(MySqlParser.WITH, i);
		}
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode VALIDATION() { return GetToken(MySqlParser.VALIDATION, 0); }
		public ITerminalNode WITHOUT() { return GetToken(MySqlParser.WITHOUT, 0); }
		public AlterByExchangePartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByExchangePartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByExchangePartition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByExchangePartition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByAddIndexContext : AlterSpecificationContext {
		public IToken indexFormat;
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public AlterByAddIndexContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddIndex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddIndex(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByAddIndex(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByDropColumnContext : AlterSpecificationContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public ITerminalNode RESTRICT() { return GetToken(MySqlParser.RESTRICT, 0); }
		public AlterByDropColumnContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDropColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDropColumn(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByDropColumn(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByImportPartitionContext : AlterSpecificationContext {
		public ITerminalNode IMPORT() { return GetToken(MySqlParser.IMPORT, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByImportPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByImportPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByImportPartition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByImportPartition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByChangeDefaultContext : AlterSpecificationContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public DefaultValueContext defaultValue() {
			return GetRuleContext<DefaultValueContext>(0);
		}
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public AlterByChangeDefaultContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByChangeDefault(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByChangeDefault(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByChangeDefault(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByForceContext : AlterSpecificationContext {
		public ITerminalNode FORCE() { return GetToken(MySqlParser.FORCE, 0); }
		public AlterByForceContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByForce(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByForce(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByForce(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByDropPartitionContext : AlterSpecificationContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public AlterByDropPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDropPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDropPartition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByDropPartition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByAddSpecialIndexContext : AlterSpecificationContext {
		public IToken keyType;
		public IToken indexFormat;
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode FULLTEXT() { return GetToken(MySqlParser.FULLTEXT, 0); }
		public ITerminalNode SPATIAL() { return GetToken(MySqlParser.SPATIAL, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public AlterByAddSpecialIndexContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddSpecialIndex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddSpecialIndex(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByAddSpecialIndex(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByModifyColumnContext : AlterSpecificationContext {
		public ITerminalNode MODIFY() { return GetToken(MySqlParser.MODIFY, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ColumnDefinitionContext columnDefinition() {
			return GetRuleContext<ColumnDefinitionContext>(0);
		}
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode AFTER() { return GetToken(MySqlParser.AFTER, 0); }
		public AlterByModifyColumnContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByModifyColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByModifyColumn(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByModifyColumn(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByTableOptionContext : AlterSpecificationContext {
		public TableOptionContext[] tableOption() {
			return GetRuleContexts<TableOptionContext>();
		}
		public TableOptionContext tableOption(int i) {
			return GetRuleContext<TableOptionContext>(i);
		}
		public AlterByTableOptionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByTableOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByTableOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByTableOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByDropPrimaryKeyContext : AlterSpecificationContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode PRIMARY() { return GetToken(MySqlParser.PRIMARY, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public AlterByDropPrimaryKeyContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDropPrimaryKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDropPrimaryKey(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByDropPrimaryKey(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByLockContext : AlterSpecificationContext {
		public IToken lockType;
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode NONE() { return GetToken(MySqlParser.NONE, 0); }
		public ITerminalNode SHARED() { return GetToken(MySqlParser.SHARED, 0); }
		public ITerminalNode EXCLUSIVE() { return GetToken(MySqlParser.EXCLUSIVE, 0); }
		public AlterByLockContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByLock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByLock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByLock(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByDiscardPartitionContext : AlterSpecificationContext {
		public ITerminalNode DISCARD() { return GetToken(MySqlParser.DISCARD, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByDiscardPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDiscardPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDiscardPartition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByDiscardPartition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByDiscardTablespaceContext : AlterSpecificationContext {
		public ITerminalNode DISCARD() { return GetToken(MySqlParser.DISCARD, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public AlterByDiscardTablespaceContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDiscardTablespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDiscardTablespace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByDiscardTablespace(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByValidateContext : AlterSpecificationContext {
		public IToken validationFormat;
		public ITerminalNode VALIDATION() { return GetToken(MySqlParser.VALIDATION, 0); }
		public ITerminalNode WITHOUT() { return GetToken(MySqlParser.WITHOUT, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public AlterByValidateContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByValidate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByValidate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByValidate(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByAddPrimaryKeyContext : AlterSpecificationContext {
		public UidContext name;
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode PRIMARY() { return GetToken(MySqlParser.PRIMARY, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public AlterByAddPrimaryKeyContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddPrimaryKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddPrimaryKey(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByAddPrimaryKey(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByCheckPartitionContext : AlterSpecificationContext {
		public ITerminalNode CHECK() { return GetToken(MySqlParser.CHECK, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByCheckPartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByCheckPartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByCheckPartition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByCheckPartition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByEnableKeysContext : AlterSpecificationContext {
		public ITerminalNode ENABLE() { return GetToken(MySqlParser.ENABLE, 0); }
		public ITerminalNode KEYS() { return GetToken(MySqlParser.KEYS, 0); }
		public AlterByEnableKeysContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByEnableKeys(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByEnableKeys(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByEnableKeys(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByReorganizePartitionContext : AlterSpecificationContext {
		public ITerminalNode REORGANIZE() { return GetToken(MySqlParser.REORGANIZE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public PartitionDefinitionContext[] partitionDefinition() {
			return GetRuleContexts<PartitionDefinitionContext>();
		}
		public PartitionDefinitionContext partitionDefinition(int i) {
			return GetRuleContext<PartitionDefinitionContext>(i);
		}
		public AlterByReorganizePartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByReorganizePartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByReorganizePartition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByReorganizePartition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterBySetAlgorithmContext : AlterSpecificationContext {
		public IToken algType;
		public ITerminalNode ALGORITHM() { return GetToken(MySqlParser.ALGORITHM, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode INPLACE() { return GetToken(MySqlParser.INPLACE, 0); }
		public ITerminalNode COPY() { return GetToken(MySqlParser.COPY, 0); }
		public AlterBySetAlgorithmContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterBySetAlgorithm(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterBySetAlgorithm(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterBySetAlgorithm(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByAnalyzePartitionContext : AlterSpecificationContext {
		public ITerminalNode ANALYZE() { return GetToken(MySqlParser.ANALYZE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByAnalyzePartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAnalyzePartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAnalyzePartition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByAnalyzePartition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByChangeColumnContext : AlterSpecificationContext {
		public UidContext oldColumn;
		public UidContext newColumn;
		public UidContext afterColumn;
		public ITerminalNode CHANGE() { return GetToken(MySqlParser.CHANGE, 0); }
		public ColumnDefinitionContext columnDefinition() {
			return GetRuleContext<ColumnDefinitionContext>(0);
		}
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode AFTER() { return GetToken(MySqlParser.AFTER, 0); }
		public AlterByChangeColumnContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByChangeColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByChangeColumn(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByChangeColumn(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByAddUniqueKeyContext : AlterSpecificationContext {
		public UidContext name;
		public IToken indexFormat;
		public UidContext indexName;
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public ITerminalNode UNIQUE() { return GetToken(MySqlParser.UNIQUE, 0); }
		public IndexColumnNamesContext indexColumnNames() {
			return GetRuleContext<IndexColumnNamesContext>(0);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(MySqlParser.CONSTRAINT, 0); }
		public IndexTypeContext indexType() {
			return GetRuleContext<IndexTypeContext>(0);
		}
		public IndexOptionContext[] indexOption() {
			return GetRuleContexts<IndexOptionContext>();
		}
		public IndexOptionContext indexOption(int i) {
			return GetRuleContext<IndexOptionContext>(i);
		}
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public AlterByAddUniqueKeyContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddUniqueKey(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddUniqueKey(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByAddUniqueKey(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByTruncatePartitionContext : AlterSpecificationContext {
		public ITerminalNode TRUNCATE() { return GetToken(MySqlParser.TRUNCATE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public AlterByTruncatePartitionContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByTruncatePartition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByTruncatePartition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByTruncatePartition(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByDropIndexContext : AlterSpecificationContext {
		public IToken indexFormat;
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public AlterByDropIndexContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByDropIndex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByDropIndex(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByDropIndex(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByAddColumnContext : AlterSpecificationContext {
		public ITerminalNode ADD() { return GetToken(MySqlParser.ADD, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ColumnDefinitionContext columnDefinition() {
			return GetRuleContext<ColumnDefinitionContext>(0);
		}
		public ITerminalNode COLUMN() { return GetToken(MySqlParser.COLUMN, 0); }
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode AFTER() { return GetToken(MySqlParser.AFTER, 0); }
		public AlterByAddColumnContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByAddColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByAddColumn(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByAddColumn(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterByOrderContext : AlterSpecificationContext {
		public ITerminalNode ORDER() { return GetToken(MySqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public AlterByOrderContext(AlterSpecificationContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterByOrder(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterByOrder(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterByOrder(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterSpecificationContext alterSpecification() {
		AlterSpecificationContext _localctx = new AlterSpecificationContext(Context, State);
		EnterRule(_localctx, 132, RULE_alterSpecification);
		int _la;
		try {
			int _alt;
			State = 2591;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,330,Context) ) {
			case 1:
				_localctx = new AlterByTableOptionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 2236; tableOption();
				State = 2243;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,278,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 2238;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==COMMA) {
							{
							State = 2237; Match(COMMA);
							}
						}

						State = 2240; tableOption();
						}
						} 
					}
					State = 2245;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,278,Context);
				}
				}
				break;
			case 2:
				_localctx = new AlterByAddColumnContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 2246; Match(ADD);
				State = 2248;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLUMN) {
					{
					State = 2247; Match(COLUMN);
					}
				}

				State = 2250; uid();
				State = 2251; columnDefinition();
				State = 2255;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case FIRST:
					{
					State = 2252; Match(FIRST);
					}
					break;
				case AFTER:
					{
					State = 2253; Match(AFTER);
					State = 2254; uid();
					}
					break;
				case Eof:
				case ALTER:
				case ANALYZE:
				case CALL:
				case CHANGE:
				case CHECK:
				case CREATE:
				case DELETE:
				case DESC:
				case DESCRIBE:
				case DROP:
				case EXPLAIN:
				case GRANT:
				case INSERT:
				case KILL:
				case LOAD:
				case LOCK:
				case OPTIMIZE:
				case PARTITION:
				case PURGE:
				case RELEASE:
				case RENAME:
				case REPLACE:
				case REVOKE:
				case SELECT:
				case SET:
				case SHOW:
				case SIGNAL:
				case UNLOCK:
				case UPDATE:
				case USE:
				case BEGIN:
				case BINLOG:
				case CACHE:
				case CHECKSUM:
				case COMMIT:
				case DEALLOCATE:
				case DO:
				case FLUSH:
				case HANDLER:
				case HELP:
				case INSTALL:
				case PREPARE:
				case REPAIR:
				case RESET:
				case ROLLBACK:
				case SAVEPOINT:
				case START:
				case STOP:
				case TRUNCATE:
				case UNINSTALL:
				case XA:
				case EXECUTE:
				case SHUTDOWN:
				case MINUSMINUS:
				case LR_BRACKET:
				case COMMA:
				case SEMI:
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 3:
				_localctx = new AlterByAddColumnsContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 2257; Match(ADD);
				State = 2259;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLUMN) {
					{
					State = 2258; Match(COLUMN);
					}
				}

				State = 2261; Match(LR_BRACKET);
				State = 2262; uid();
				State = 2263; columnDefinition();
				State = 2270;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2264; Match(COMMA);
					State = 2265; uid();
					State = 2266; columnDefinition();
					}
					}
					State = 2272;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2273; Match(RR_BRACKET);
				}
				break;
			case 4:
				_localctx = new AlterByAddIndexContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 2275; Match(ADD);
				State = 2276;
				((AlterByAddIndexContext)_localctx).indexFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==INDEX || _la==KEY) ) {
					((AlterByAddIndexContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2278;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
					{
					State = 2277; uid();
					}
				}

				State = 2281;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 2280; indexType();
					}
				}

				State = 2283; indexColumnNames();
				State = 2287;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==INVISIBLE || _la==KEY_BLOCK_SIZE || _la==VISIBLE) {
					{
					{
					State = 2284; indexOption();
					}
					}
					State = 2289;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 5:
				_localctx = new AlterByAddPrimaryKeyContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 2290; Match(ADD);
				State = 2295;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 2291; Match(CONSTRAINT);
					State = 2293;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
						{
						State = 2292; ((AlterByAddPrimaryKeyContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 2297; Match(PRIMARY);
				State = 2298; Match(KEY);
				State = 2300;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 2299; indexType();
					}
				}

				State = 2302; indexColumnNames();
				State = 2306;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==INVISIBLE || _la==KEY_BLOCK_SIZE || _la==VISIBLE) {
					{
					{
					State = 2303; indexOption();
					}
					}
					State = 2308;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 6:
				_localctx = new AlterByAddUniqueKeyContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 2309; Match(ADD);
				State = 2314;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 2310; Match(CONSTRAINT);
					State = 2312;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
						{
						State = 2311; ((AlterByAddUniqueKeyContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 2316; Match(UNIQUE);
				State = 2318;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDEX || _la==KEY) {
					{
					State = 2317;
					((AlterByAddUniqueKeyContext)_localctx).indexFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==INDEX || _la==KEY) ) {
						((AlterByAddUniqueKeyContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2321;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
					{
					State = 2320; ((AlterByAddUniqueKeyContext)_localctx).indexName = uid();
					}
				}

				State = 2324;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 2323; indexType();
					}
				}

				State = 2326; indexColumnNames();
				State = 2330;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==INVISIBLE || _la==KEY_BLOCK_SIZE || _la==VISIBLE) {
					{
					{
					State = 2327; indexOption();
					}
					}
					State = 2332;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 7:
				_localctx = new AlterByAddSpecialIndexContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 2333; Match(ADD);
				State = 2334;
				((AlterByAddSpecialIndexContext)_localctx).keyType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FULLTEXT || _la==SPATIAL) ) {
					((AlterByAddSpecialIndexContext)_localctx).keyType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2336;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDEX || _la==KEY) {
					{
					State = 2335;
					((AlterByAddSpecialIndexContext)_localctx).indexFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==INDEX || _la==KEY) ) {
						((AlterByAddSpecialIndexContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2339;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
					{
					State = 2338; uid();
					}
				}

				State = 2341; indexColumnNames();
				State = 2345;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==USING || _la==WITH || _la==COMMENT || _la==INVISIBLE || _la==KEY_BLOCK_SIZE || _la==VISIBLE) {
					{
					{
					State = 2342; indexOption();
					}
					}
					State = 2347;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 8:
				_localctx = new AlterByAddForeignKeyContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 2348; Match(ADD);
				State = 2353;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 2349; Match(CONSTRAINT);
					State = 2351;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
						{
						State = 2350; ((AlterByAddForeignKeyContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 2355; Match(FOREIGN);
				State = 2356; Match(KEY);
				State = 2358;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
					{
					State = 2357; ((AlterByAddForeignKeyContext)_localctx).indexName = uid();
					}
				}

				State = 2360; indexColumnNames();
				State = 2361; referenceDefinition();
				}
				break;
			case 9:
				_localctx = new AlterByAddCheckTableConstraintContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 2363; Match(ADD);
				State = 2368;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONSTRAINT) {
					{
					State = 2364; Match(CONSTRAINT);
					State = 2366;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
						{
						State = 2365; ((AlterByAddCheckTableConstraintContext)_localctx).name = uid();
						}
					}

					}
				}

				State = 2370; Match(CHECK);
				State = 2371; Match(LR_BRACKET);
				State = 2372; expression(0);
				State = 2373; Match(RR_BRACKET);
				}
				break;
			case 10:
				_localctx = new AlterBySetAlgorithmContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 2375; Match(ALGORITHM);
				State = 2377;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2376; Match(EQUAL_SYMBOL);
					}
				}

				State = 2379;
				((AlterBySetAlgorithmContext)_localctx).algType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==COPY || _la==INPLACE) ) {
					((AlterBySetAlgorithmContext)_localctx).algType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 11:
				_localctx = new AlterByChangeDefaultContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 2380; Match(ALTER);
				State = 2382;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLUMN) {
					{
					State = 2381; Match(COLUMN);
					}
				}

				State = 2384; uid();
				State = 2390;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case SET:
					{
					State = 2385; Match(SET);
					State = 2386; Match(DEFAULT);
					State = 2387; defaultValue();
					}
					break;
				case DROP:
					{
					State = 2388; Match(DROP);
					State = 2389; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 12:
				_localctx = new AlterByChangeColumnContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 2392; Match(CHANGE);
				State = 2394;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLUMN) {
					{
					State = 2393; Match(COLUMN);
					}
				}

				State = 2396; ((AlterByChangeColumnContext)_localctx).oldColumn = uid();
				State = 2397; ((AlterByChangeColumnContext)_localctx).newColumn = uid();
				State = 2398; columnDefinition();
				State = 2402;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case FIRST:
					{
					State = 2399; Match(FIRST);
					}
					break;
				case AFTER:
					{
					State = 2400; Match(AFTER);
					State = 2401; ((AlterByChangeColumnContext)_localctx).afterColumn = uid();
					}
					break;
				case Eof:
				case ALTER:
				case ANALYZE:
				case CALL:
				case CHANGE:
				case CHECK:
				case CREATE:
				case DELETE:
				case DESC:
				case DESCRIBE:
				case DROP:
				case EXPLAIN:
				case GRANT:
				case INSERT:
				case KILL:
				case LOAD:
				case LOCK:
				case OPTIMIZE:
				case PARTITION:
				case PURGE:
				case RELEASE:
				case RENAME:
				case REPLACE:
				case REVOKE:
				case SELECT:
				case SET:
				case SHOW:
				case SIGNAL:
				case UNLOCK:
				case UPDATE:
				case USE:
				case BEGIN:
				case BINLOG:
				case CACHE:
				case CHECKSUM:
				case COMMIT:
				case DEALLOCATE:
				case DO:
				case FLUSH:
				case HANDLER:
				case HELP:
				case INSTALL:
				case PREPARE:
				case REPAIR:
				case RESET:
				case ROLLBACK:
				case SAVEPOINT:
				case START:
				case STOP:
				case TRUNCATE:
				case UNINSTALL:
				case XA:
				case EXECUTE:
				case SHUTDOWN:
				case MINUSMINUS:
				case LR_BRACKET:
				case COMMA:
				case SEMI:
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 13:
				_localctx = new AlterByRenameColumnContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 2404; Match(RENAME);
				State = 2405; Match(COLUMN);
				State = 2406; ((AlterByRenameColumnContext)_localctx).oldColumn = uid();
				State = 2407; Match(TO);
				State = 2408; ((AlterByRenameColumnContext)_localctx).newColumn = uid();
				}
				break;
			case 14:
				_localctx = new AlterByLockContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 2410; Match(LOCK);
				State = 2412;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2411; Match(EQUAL_SYMBOL);
					}
				}

				State = 2414;
				((AlterByLockContext)_localctx).lockType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==EXCLUSIVE || _la==NONE || _la==SHARED) ) {
					((AlterByLockContext)_localctx).lockType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 15:
				_localctx = new AlterByModifyColumnContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 2415; Match(MODIFY);
				State = 2417;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLUMN) {
					{
					State = 2416; Match(COLUMN);
					}
				}

				State = 2419; uid();
				State = 2420; columnDefinition();
				State = 2424;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case FIRST:
					{
					State = 2421; Match(FIRST);
					}
					break;
				case AFTER:
					{
					State = 2422; Match(AFTER);
					State = 2423; uid();
					}
					break;
				case Eof:
				case ALTER:
				case ANALYZE:
				case CALL:
				case CHANGE:
				case CHECK:
				case CREATE:
				case DELETE:
				case DESC:
				case DESCRIBE:
				case DROP:
				case EXPLAIN:
				case GRANT:
				case INSERT:
				case KILL:
				case LOAD:
				case LOCK:
				case OPTIMIZE:
				case PARTITION:
				case PURGE:
				case RELEASE:
				case RENAME:
				case REPLACE:
				case REVOKE:
				case SELECT:
				case SET:
				case SHOW:
				case SIGNAL:
				case UNLOCK:
				case UPDATE:
				case USE:
				case BEGIN:
				case BINLOG:
				case CACHE:
				case CHECKSUM:
				case COMMIT:
				case DEALLOCATE:
				case DO:
				case FLUSH:
				case HANDLER:
				case HELP:
				case INSTALL:
				case PREPARE:
				case REPAIR:
				case RESET:
				case ROLLBACK:
				case SAVEPOINT:
				case START:
				case STOP:
				case TRUNCATE:
				case UNINSTALL:
				case XA:
				case EXECUTE:
				case SHUTDOWN:
				case MINUSMINUS:
				case LR_BRACKET:
				case COMMA:
				case SEMI:
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 16:
				_localctx = new AlterByDropColumnContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 2426; Match(DROP);
				State = 2428;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLUMN) {
					{
					State = 2427; Match(COLUMN);
					}
				}

				State = 2430; uid();
				State = 2432;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==RESTRICT) {
					{
					State = 2431; Match(RESTRICT);
					}
				}

				}
				break;
			case 17:
				_localctx = new AlterByDropPrimaryKeyContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 2434; Match(DROP);
				State = 2435; Match(PRIMARY);
				State = 2436; Match(KEY);
				}
				break;
			case 18:
				_localctx = new AlterByRenameIndexContext(_localctx);
				EnterOuterAlt(_localctx, 18);
				{
				State = 2437; Match(RENAME);
				State = 2438;
				((AlterByRenameIndexContext)_localctx).indexFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==INDEX || _la==KEY) ) {
					((AlterByRenameIndexContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2439; uid();
				State = 2440; Match(TO);
				State = 2441; uid();
				}
				break;
			case 19:
				_localctx = new AlterByDropIndexContext(_localctx);
				EnterOuterAlt(_localctx, 19);
				{
				State = 2443; Match(DROP);
				State = 2444;
				((AlterByDropIndexContext)_localctx).indexFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==INDEX || _la==KEY) ) {
					((AlterByDropIndexContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2445; uid();
				}
				break;
			case 20:
				_localctx = new AlterByDropForeignKeyContext(_localctx);
				EnterOuterAlt(_localctx, 20);
				{
				State = 2446; Match(DROP);
				State = 2447; Match(FOREIGN);
				State = 2448; Match(KEY);
				State = 2449; uid();
				}
				break;
			case 21:
				_localctx = new AlterByDisableKeysContext(_localctx);
				EnterOuterAlt(_localctx, 21);
				{
				State = 2450; Match(DISABLE);
				State = 2451; Match(KEYS);
				}
				break;
			case 22:
				_localctx = new AlterByEnableKeysContext(_localctx);
				EnterOuterAlt(_localctx, 22);
				{
				State = 2452; Match(ENABLE);
				State = 2453; Match(KEYS);
				}
				break;
			case 23:
				_localctx = new AlterByRenameContext(_localctx);
				EnterOuterAlt(_localctx, 23);
				{
				State = 2454; Match(RENAME);
				State = 2456;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS || _la==TO) {
					{
					State = 2455;
					((AlterByRenameContext)_localctx).renameFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==AS || _la==TO) ) {
						((AlterByRenameContext)_localctx).renameFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2460;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,315,Context) ) {
				case 1:
					{
					State = 2458; uid();
					}
					break;
				case 2:
					{
					State = 2459; fullId();
					}
					break;
				}
				}
				break;
			case 24:
				_localctx = new AlterByOrderContext(_localctx);
				EnterOuterAlt(_localctx, 24);
				{
				State = 2462; Match(ORDER);
				State = 2463; Match(BY);
				State = 2464; uidList();
				}
				break;
			case 25:
				_localctx = new AlterByConvertCharsetContext(_localctx);
				EnterOuterAlt(_localctx, 25);
				{
				State = 2465; Match(CONVERT);
				State = 2466; Match(TO);
				State = 2467; Match(CHARACTER);
				State = 2468; Match(SET);
				State = 2469; charsetName();
				State = 2472;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLLATE) {
					{
					State = 2470; Match(COLLATE);
					State = 2471; collationName();
					}
				}

				}
				break;
			case 26:
				_localctx = new AlterByDefaultCharsetContext(_localctx);
				EnterOuterAlt(_localctx, 26);
				{
				State = 2475;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 2474; Match(DEFAULT);
					}
				}

				State = 2477; Match(CHARACTER);
				State = 2478; Match(SET);
				State = 2479; Match(EQUAL_SYMBOL);
				State = 2480; charsetName();
				State = 2484;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLLATE) {
					{
					State = 2481; Match(COLLATE);
					State = 2482; Match(EQUAL_SYMBOL);
					State = 2483; collationName();
					}
				}

				}
				break;
			case 27:
				_localctx = new AlterByDiscardTablespaceContext(_localctx);
				EnterOuterAlt(_localctx, 27);
				{
				State = 2486; Match(DISCARD);
				State = 2487; Match(TABLESPACE);
				}
				break;
			case 28:
				_localctx = new AlterByImportTablespaceContext(_localctx);
				EnterOuterAlt(_localctx, 28);
				{
				State = 2488; Match(IMPORT);
				State = 2489; Match(TABLESPACE);
				}
				break;
			case 29:
				_localctx = new AlterByForceContext(_localctx);
				EnterOuterAlt(_localctx, 29);
				{
				State = 2490; Match(FORCE);
				}
				break;
			case 30:
				_localctx = new AlterByValidateContext(_localctx);
				EnterOuterAlt(_localctx, 30);
				{
				State = 2491;
				((AlterByValidateContext)_localctx).validationFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==WITH || _la==WITHOUT) ) {
					((AlterByValidateContext)_localctx).validationFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2492; Match(VALIDATION);
				}
				break;
			case 31:
				_localctx = new AlterByAddPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 31);
				{
				State = 2493; Match(ADD);
				State = 2494; Match(PARTITION);
				State = 2495; Match(LR_BRACKET);
				State = 2496; partitionDefinition();
				State = 2501;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2497; Match(COMMA);
					State = 2498; partitionDefinition();
					}
					}
					State = 2503;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2504; Match(RR_BRACKET);
				}
				break;
			case 32:
				_localctx = new AlterByDropPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 32);
				{
				State = 2506; Match(DROP);
				State = 2507; Match(PARTITION);
				State = 2508; uidList();
				}
				break;
			case 33:
				_localctx = new AlterByDiscardPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 33);
				{
				State = 2509; Match(DISCARD);
				State = 2510; Match(PARTITION);
				State = 2513;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLASS_ORIGIN:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COLUMN_NAME:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONSTRAINT_CATALOG:
				case CONSTRAINT_SCHEMA:
				case CONSTRAINT_NAME:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVISIBLE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MESSAGE_TEXT:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case MYSQL_ERRNO:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBCLASS_ORIGIN:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLE_NAME:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case VISIBLE:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case SESSION_VARIABLES_ADMIN:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CATALOG_NAME:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SCHEMA_NAME:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2511; uidList();
					}
					break;
				case ALL:
					{
					State = 2512; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2515; Match(TABLESPACE);
				}
				break;
			case 34:
				_localctx = new AlterByImportPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 34);
				{
				State = 2516; Match(IMPORT);
				State = 2517; Match(PARTITION);
				State = 2520;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLASS_ORIGIN:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COLUMN_NAME:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONSTRAINT_CATALOG:
				case CONSTRAINT_SCHEMA:
				case CONSTRAINT_NAME:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVISIBLE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MESSAGE_TEXT:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case MYSQL_ERRNO:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBCLASS_ORIGIN:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLE_NAME:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case VISIBLE:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case SESSION_VARIABLES_ADMIN:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CATALOG_NAME:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SCHEMA_NAME:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2518; uidList();
					}
					break;
				case ALL:
					{
					State = 2519; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2522; Match(TABLESPACE);
				}
				break;
			case 35:
				_localctx = new AlterByTruncatePartitionContext(_localctx);
				EnterOuterAlt(_localctx, 35);
				{
				State = 2523; Match(TRUNCATE);
				State = 2524; Match(PARTITION);
				State = 2527;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLASS_ORIGIN:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COLUMN_NAME:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONSTRAINT_CATALOG:
				case CONSTRAINT_SCHEMA:
				case CONSTRAINT_NAME:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVISIBLE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MESSAGE_TEXT:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case MYSQL_ERRNO:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBCLASS_ORIGIN:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLE_NAME:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case VISIBLE:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case SESSION_VARIABLES_ADMIN:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CATALOG_NAME:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SCHEMA_NAME:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2525; uidList();
					}
					break;
				case ALL:
					{
					State = 2526; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 36:
				_localctx = new AlterByCoalescePartitionContext(_localctx);
				EnterOuterAlt(_localctx, 36);
				{
				State = 2529; Match(COALESCE);
				State = 2530; Match(PARTITION);
				State = 2531; decimalLiteral();
				}
				break;
			case 37:
				_localctx = new AlterByReorganizePartitionContext(_localctx);
				EnterOuterAlt(_localctx, 37);
				{
				State = 2532; Match(REORGANIZE);
				State = 2533; Match(PARTITION);
				State = 2534; uidList();
				State = 2535; Match(INTO);
				State = 2536; Match(LR_BRACKET);
				State = 2537; partitionDefinition();
				State = 2542;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2538; Match(COMMA);
					State = 2539; partitionDefinition();
					}
					}
					State = 2544;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2545; Match(RR_BRACKET);
				}
				break;
			case 38:
				_localctx = new AlterByExchangePartitionContext(_localctx);
				EnterOuterAlt(_localctx, 38);
				{
				State = 2547; Match(EXCHANGE);
				State = 2548; Match(PARTITION);
				State = 2549; uid();
				State = 2550; Match(WITH);
				State = 2551; Match(TABLE);
				State = 2552; tableName();
				State = 2555;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH || _la==WITHOUT) {
					{
					State = 2553;
					((AlterByExchangePartitionContext)_localctx).validationFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==WITH || _la==WITHOUT) ) {
						((AlterByExchangePartitionContext)_localctx).validationFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 2554; Match(VALIDATION);
					}
				}

				}
				break;
			case 39:
				_localctx = new AlterByAnalyzePartitionContext(_localctx);
				EnterOuterAlt(_localctx, 39);
				{
				State = 2557; Match(ANALYZE);
				State = 2558; Match(PARTITION);
				State = 2561;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLASS_ORIGIN:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COLUMN_NAME:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONSTRAINT_CATALOG:
				case CONSTRAINT_SCHEMA:
				case CONSTRAINT_NAME:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVISIBLE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MESSAGE_TEXT:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case MYSQL_ERRNO:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBCLASS_ORIGIN:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLE_NAME:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case VISIBLE:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case SESSION_VARIABLES_ADMIN:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CATALOG_NAME:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SCHEMA_NAME:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2559; uidList();
					}
					break;
				case ALL:
					{
					State = 2560; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 40:
				_localctx = new AlterByCheckPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 40);
				{
				State = 2563; Match(CHECK);
				State = 2564; Match(PARTITION);
				State = 2567;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLASS_ORIGIN:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COLUMN_NAME:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONSTRAINT_CATALOG:
				case CONSTRAINT_SCHEMA:
				case CONSTRAINT_NAME:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVISIBLE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MESSAGE_TEXT:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case MYSQL_ERRNO:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBCLASS_ORIGIN:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLE_NAME:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case VISIBLE:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case SESSION_VARIABLES_ADMIN:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CATALOG_NAME:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SCHEMA_NAME:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2565; uidList();
					}
					break;
				case ALL:
					{
					State = 2566; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 41:
				_localctx = new AlterByOptimizePartitionContext(_localctx);
				EnterOuterAlt(_localctx, 41);
				{
				State = 2569; Match(OPTIMIZE);
				State = 2570; Match(PARTITION);
				State = 2573;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLASS_ORIGIN:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COLUMN_NAME:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONSTRAINT_CATALOG:
				case CONSTRAINT_SCHEMA:
				case CONSTRAINT_NAME:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVISIBLE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MESSAGE_TEXT:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case MYSQL_ERRNO:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBCLASS_ORIGIN:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLE_NAME:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case VISIBLE:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case SESSION_VARIABLES_ADMIN:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CATALOG_NAME:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SCHEMA_NAME:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2571; uidList();
					}
					break;
				case ALL:
					{
					State = 2572; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 42:
				_localctx = new AlterByRebuildPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 42);
				{
				State = 2575; Match(REBUILD);
				State = 2576; Match(PARTITION);
				State = 2579;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLASS_ORIGIN:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COLUMN_NAME:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONSTRAINT_CATALOG:
				case CONSTRAINT_SCHEMA:
				case CONSTRAINT_NAME:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVISIBLE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MESSAGE_TEXT:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case MYSQL_ERRNO:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBCLASS_ORIGIN:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLE_NAME:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case VISIBLE:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case SESSION_VARIABLES_ADMIN:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CATALOG_NAME:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SCHEMA_NAME:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2577; uidList();
					}
					break;
				case ALL:
					{
					State = 2578; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 43:
				_localctx = new AlterByRepairPartitionContext(_localctx);
				EnterOuterAlt(_localctx, 43);
				{
				State = 2581; Match(REPAIR);
				State = 2582; Match(PARTITION);
				State = 2585;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLASS_ORIGIN:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COLUMN_NAME:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONSTRAINT_CATALOG:
				case CONSTRAINT_SCHEMA:
				case CONSTRAINT_NAME:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVISIBLE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MESSAGE_TEXT:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case MYSQL_ERRNO:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBCLASS_ORIGIN:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLE_NAME:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case VISIBLE:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case SESSION_VARIABLES_ADMIN:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CATALOG_NAME:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SCHEMA_NAME:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 2583; uidList();
					}
					break;
				case ALL:
					{
					State = 2584; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 44:
				_localctx = new AlterByRemovePartitioningContext(_localctx);
				EnterOuterAlt(_localctx, 44);
				{
				State = 2587; Match(REMOVE);
				State = 2588; Match(PARTITIONING);
				}
				break;
			case 45:
				_localctx = new AlterByUpgradePartitioningContext(_localctx);
				EnterOuterAlt(_localctx, 45);
				{
				State = 2589; Match(UPGRADE);
				State = 2590; Match(PARTITIONING);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropDatabaseContext : ParserRuleContext {
		public IToken dbFormat;
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(MySqlParser.SCHEMA, 0); }
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropDatabase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropDatabase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropDatabase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropDatabase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropDatabaseContext dropDatabase() {
		DropDatabaseContext _localctx = new DropDatabaseContext(Context, State);
		EnterRule(_localctx, 134, RULE_dropDatabase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2593; Match(DROP);
			State = 2594;
			_localctx.dbFormat = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DATABASE || _la==SCHEMA) ) {
				_localctx.dbFormat = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2596;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2595; ifExists();
				}
			}

			State = 2598; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropEventContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode EVENT() { return GetToken(MySqlParser.EVENT, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropEventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropEvent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropEvent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropEvent(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropEvent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropEventContext dropEvent() {
		DropEventContext _localctx = new DropEventContext(Context, State);
		EnterRule(_localctx, 136, RULE_dropEvent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2600; Match(DROP);
			State = 2601; Match(EVENT);
			State = 2603;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2602; ifExists();
				}
			}

			State = 2605; fullId();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropIndexContext : ParserRuleContext {
		public IToken intimeAction;
		public IToken algType;
		public IToken lockType;
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode[] ALGORITHM() { return GetTokens(MySqlParser.ALGORITHM); }
		public ITerminalNode ALGORITHM(int i) {
			return GetToken(MySqlParser.ALGORITHM, i);
		}
		public ITerminalNode[] LOCK() { return GetTokens(MySqlParser.LOCK); }
		public ITerminalNode LOCK(int i) {
			return GetToken(MySqlParser.LOCK, i);
		}
		public ITerminalNode ONLINE() { return GetToken(MySqlParser.ONLINE, 0); }
		public ITerminalNode OFFLINE() { return GetToken(MySqlParser.OFFLINE, 0); }
		public ITerminalNode[] DEFAULT() { return GetTokens(MySqlParser.DEFAULT); }
		public ITerminalNode DEFAULT(int i) {
			return GetToken(MySqlParser.DEFAULT, i);
		}
		public ITerminalNode[] INPLACE() { return GetTokens(MySqlParser.INPLACE); }
		public ITerminalNode INPLACE(int i) {
			return GetToken(MySqlParser.INPLACE, i);
		}
		public ITerminalNode[] COPY() { return GetTokens(MySqlParser.COPY); }
		public ITerminalNode COPY(int i) {
			return GetToken(MySqlParser.COPY, i);
		}
		public ITerminalNode[] NONE() { return GetTokens(MySqlParser.NONE); }
		public ITerminalNode NONE(int i) {
			return GetToken(MySqlParser.NONE, i);
		}
		public ITerminalNode[] SHARED() { return GetTokens(MySqlParser.SHARED); }
		public ITerminalNode SHARED(int i) {
			return GetToken(MySqlParser.SHARED, i);
		}
		public ITerminalNode[] EXCLUSIVE() { return GetTokens(MySqlParser.EXCLUSIVE); }
		public ITerminalNode EXCLUSIVE(int i) {
			return GetToken(MySqlParser.EXCLUSIVE, i);
		}
		public DropIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropIndex; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropIndex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropIndex(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropIndex(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropIndexContext dropIndex() {
		DropIndexContext _localctx = new DropIndexContext(Context, State);
		EnterRule(_localctx, 138, RULE_dropIndex);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2607; Match(DROP);
			State = 2608; Match(INDEX);
			State = 2610;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,333,Context) ) {
			case 1:
				{
				State = 2609;
				_localctx.intimeAction = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==OFFLINE || _la==ONLINE) ) {
					_localctx.intimeAction = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 2612; uid();
			State = 2613; Match(ON);
			State = 2614; tableName();
			State = 2627;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,337,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					State = 2625;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ALGORITHM:
						{
						State = 2615; Match(ALGORITHM);
						State = 2617;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==EQUAL_SYMBOL) {
							{
							State = 2616; Match(EQUAL_SYMBOL);
							}
						}

						State = 2619;
						_localctx.algType = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==DEFAULT || _la==COPY || _la==INPLACE) ) {
							_localctx.algType = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					case LOCK:
						{
						State = 2620; Match(LOCK);
						State = 2622;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==EQUAL_SYMBOL) {
							{
							State = 2621; Match(EQUAL_SYMBOL);
							}
						}

						State = 2624;
						_localctx.lockType = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==DEFAULT || _la==EXCLUSIVE || _la==NONE || _la==SHARED) ) {
							_localctx.lockType = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 2629;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,337,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropLogfileGroupContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode LOGFILE() { return GetToken(MySqlParser.LOGFILE, 0); }
		public ITerminalNode GROUP() { return GetToken(MySqlParser.GROUP, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public DropLogfileGroupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropLogfileGroup; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropLogfileGroup(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropLogfileGroup(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropLogfileGroup(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropLogfileGroupContext dropLogfileGroup() {
		DropLogfileGroupContext _localctx = new DropLogfileGroupContext(Context, State);
		EnterRule(_localctx, 140, RULE_dropLogfileGroup);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2630; Match(DROP);
			State = 2631; Match(LOGFILE);
			State = 2632; Match(GROUP);
			State = 2633; uid();
			State = 2634; Match(ENGINE);
			State = 2635; Match(EQUAL_SYMBOL);
			State = 2636; engineName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropProcedureContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropProcedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropProcedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropProcedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropProcedure(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropProcedure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropProcedureContext dropProcedure() {
		DropProcedureContext _localctx = new DropProcedureContext(Context, State);
		EnterRule(_localctx, 142, RULE_dropProcedure);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2638; Match(DROP);
			State = 2639; Match(PROCEDURE);
			State = 2641;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2640; ifExists();
				}
			}

			State = 2643; fullId();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropFunctionContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropFunctionContext dropFunction() {
		DropFunctionContext _localctx = new DropFunctionContext(Context, State);
		EnterRule(_localctx, 144, RULE_dropFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2645; Match(DROP);
			State = 2646; Match(FUNCTION);
			State = 2648;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2647; ifExists();
				}
			}

			State = 2650; fullId();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropServerContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode SERVER() { return GetToken(MySqlParser.SERVER, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropServerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropServer; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropServer(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropServer(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropServer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropServerContext dropServer() {
		DropServerContext _localctx = new DropServerContext(Context, State);
		EnterRule(_localctx, 146, RULE_dropServer);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2652; Match(DROP);
			State = 2653; Match(SERVER);
			State = 2655;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2654; ifExists();
				}
			}

			State = 2657; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropTableContext : ParserRuleContext {
		public IToken dropType;
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public ITerminalNode TEMPORARY() { return GetToken(MySqlParser.TEMPORARY, 0); }
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public ITerminalNode RESTRICT() { return GetToken(MySqlParser.RESTRICT, 0); }
		public ITerminalNode CASCADE() { return GetToken(MySqlParser.CASCADE, 0); }
		public DropTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropTable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropTable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropTableContext dropTable() {
		DropTableContext _localctx = new DropTableContext(Context, State);
		EnterRule(_localctx, 148, RULE_dropTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2659; Match(DROP);
			State = 2661;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TEMPORARY) {
				{
				State = 2660; Match(TEMPORARY);
				}
			}

			State = 2663; Match(TABLE);
			State = 2665;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2664; ifExists();
				}
			}

			State = 2667; tables();
			State = 2669;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CASCADE || _la==RESTRICT) {
				{
				State = 2668;
				_localctx.dropType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==CASCADE || _la==RESTRICT) ) {
					_localctx.dropType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropTablespaceContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public DropTablespaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropTablespace; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropTablespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropTablespace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropTablespace(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropTablespaceContext dropTablespace() {
		DropTablespaceContext _localctx = new DropTablespaceContext(Context, State);
		EnterRule(_localctx, 150, RULE_dropTablespace);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2671; Match(DROP);
			State = 2672; Match(TABLESPACE);
			State = 2673; uid();
			State = 2679;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ENGINE) {
				{
				State = 2674; Match(ENGINE);
				State = 2676;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQUAL_SYMBOL) {
					{
					State = 2675; Match(EQUAL_SYMBOL);
					}
				}

				State = 2678; engineName();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropTriggerContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode TRIGGER() { return GetToken(MySqlParser.TRIGGER, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropTriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropTrigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropTrigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropTrigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropTrigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropTriggerContext dropTrigger() {
		DropTriggerContext _localctx = new DropTriggerContext(Context, State);
		EnterRule(_localctx, 152, RULE_dropTrigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2681; Match(DROP);
			State = 2682; Match(TRIGGER);
			State = 2684;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2683; ifExists();
				}
			}

			State = 2686; fullId();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropViewContext : ParserRuleContext {
		public IToken dropType;
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode VIEW() { return GetToken(MySqlParser.VIEW, 0); }
		public FullIdContext[] fullId() {
			return GetRuleContexts<FullIdContext>();
		}
		public FullIdContext fullId(int i) {
			return GetRuleContext<FullIdContext>(i);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public ITerminalNode RESTRICT() { return GetToken(MySqlParser.RESTRICT, 0); }
		public ITerminalNode CASCADE() { return GetToken(MySqlParser.CASCADE, 0); }
		public DropViewContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropView; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropView(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropView(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropView(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropViewContext dropView() {
		DropViewContext _localctx = new DropViewContext(Context, State);
		EnterRule(_localctx, 154, RULE_dropView);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2688; Match(DROP);
			State = 2689; Match(VIEW);
			State = 2691;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2690; ifExists();
				}
			}

			State = 2693; fullId();
			State = 2698;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2694; Match(COMMA);
				State = 2695; fullId();
				}
				}
				State = 2700;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2702;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CASCADE || _la==RESTRICT) {
				{
				State = 2701;
				_localctx.dropType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==CASCADE || _la==RESTRICT) ) {
					_localctx.dropType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameTableContext : ParserRuleContext {
		public ITerminalNode RENAME() { return GetToken(MySqlParser.RENAME, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public RenameTableClauseContext[] renameTableClause() {
			return GetRuleContexts<RenameTableClauseContext>();
		}
		public RenameTableClauseContext renameTableClause(int i) {
			return GetRuleContext<RenameTableClauseContext>(i);
		}
		public RenameTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRenameTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRenameTable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRenameTable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RenameTableContext renameTable() {
		RenameTableContext _localctx = new RenameTableContext(Context, State);
		EnterRule(_localctx, 156, RULE_renameTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2704; Match(RENAME);
			State = 2705; Match(TABLE);
			State = 2706; renameTableClause();
			State = 2711;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2707; Match(COMMA);
				State = 2708; renameTableClause();
				}
				}
				State = 2713;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameTableClauseContext : ParserRuleContext {
		public TableNameContext[] tableName() {
			return GetRuleContexts<TableNameContext>();
		}
		public TableNameContext tableName(int i) {
			return GetRuleContext<TableNameContext>(i);
		}
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public RenameTableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameTableClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRenameTableClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRenameTableClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRenameTableClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RenameTableClauseContext renameTableClause() {
		RenameTableClauseContext _localctx = new RenameTableClauseContext(Context, State);
		EnterRule(_localctx, 158, RULE_renameTableClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2714; tableName();
			State = 2715; Match(TO);
			State = 2716; tableName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TruncateTableContext : ParserRuleContext {
		public ITerminalNode TRUNCATE() { return GetToken(MySqlParser.TRUNCATE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TruncateTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_truncateTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTruncateTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTruncateTable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTruncateTable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TruncateTableContext truncateTable() {
		TruncateTableContext _localctx = new TruncateTableContext(Context, State);
		EnterRule(_localctx, 160, RULE_truncateTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2718; Match(TRUNCATE);
			State = 2720;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLE) {
				{
				State = 2719; Match(TABLE);
				}
			}

			State = 2722; tableName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallStatementContext : ParserRuleContext {
		public ITerminalNode CALL() { return GetToken(MySqlParser.CALL, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ConstantsContext constants() {
			return GetRuleContext<ConstantsContext>(0);
		}
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public CallStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCallStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCallStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCallStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CallStatementContext callStatement() {
		CallStatementContext _localctx = new CallStatementContext(Context, State);
		EnterRule(_localctx, 162, RULE_callStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2724; Match(CALL);
			State = 2725; fullId();
			State = 2732;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,353,Context) ) {
			case 1:
				{
				State = 2726; Match(LR_BRACKET);
				State = 2729;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,352,Context) ) {
				case 1:
					{
					State = 2727; constants();
					}
					break;
				case 2:
					{
					State = 2728; expressions();
					}
					break;
				}
				State = 2731; Match(RR_BRACKET);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeleteStatementContext : ParserRuleContext {
		public SingleDeleteStatementContext singleDeleteStatement() {
			return GetRuleContext<SingleDeleteStatementContext>(0);
		}
		public MultipleDeleteStatementContext multipleDeleteStatement() {
			return GetRuleContext<MultipleDeleteStatementContext>(0);
		}
		public DeleteStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deleteStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDeleteStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDeleteStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeleteStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeleteStatementContext deleteStatement() {
		DeleteStatementContext _localctx = new DeleteStatementContext(Context, State);
		EnterRule(_localctx, 164, RULE_deleteStatement);
		try {
			State = 2736;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,354,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2734; singleDeleteStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2735; multipleDeleteStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DoStatementContext : ParserRuleContext {
		public ITerminalNode DO() { return GetToken(MySqlParser.DO, 0); }
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public DoStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_doStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDoStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDoStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDoStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DoStatementContext doStatement() {
		DoStatementContext _localctx = new DoStatementContext(Context, State);
		EnterRule(_localctx, 166, RULE_doStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2738; Match(DO);
			State = 2739; expressions();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandlerStatementContext : ParserRuleContext {
		public HandlerOpenStatementContext handlerOpenStatement() {
			return GetRuleContext<HandlerOpenStatementContext>(0);
		}
		public HandlerReadIndexStatementContext handlerReadIndexStatement() {
			return GetRuleContext<HandlerReadIndexStatementContext>(0);
		}
		public HandlerReadStatementContext handlerReadStatement() {
			return GetRuleContext<HandlerReadStatementContext>(0);
		}
		public HandlerCloseStatementContext handlerCloseStatement() {
			return GetRuleContext<HandlerCloseStatementContext>(0);
		}
		public HandlerStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handlerStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHandlerStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HandlerStatementContext handlerStatement() {
		HandlerStatementContext _localctx = new HandlerStatementContext(Context, State);
		EnterRule(_localctx, 168, RULE_handlerStatement);
		try {
			State = 2745;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,355,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2741; handlerOpenStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2742; handlerReadIndexStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2743; handlerReadStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2744; handlerCloseStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertStatementContext : ParserRuleContext {
		public IToken priority;
		public UidListContext partitions;
		public UidListContext columns;
		public UpdatedElementContext setFirst;
		public UpdatedElementContext _updatedElement;
		public IList<UpdatedElementContext> _setElements = new List<UpdatedElementContext>();
		public UpdatedElementContext duplicatedFirst;
		public IList<UpdatedElementContext> _duplicatedElements = new List<UpdatedElementContext>();
		public ITerminalNode INSERT() { return GetToken(MySqlParser.INSERT, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public InsertStatementValueContext insertStatementValue() {
			return GetRuleContext<InsertStatementValueContext>(0);
		}
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UpdatedElementContext[] updatedElement() {
			return GetRuleContexts<UpdatedElementContext>();
		}
		public UpdatedElementContext updatedElement(int i) {
			return GetRuleContext<UpdatedElementContext>(i);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ITerminalNode DUPLICATE() { return GetToken(MySqlParser.DUPLICATE, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public UidListContext[] uidList() {
			return GetRuleContexts<UidListContext>();
		}
		public UidListContext uidList(int i) {
			return GetRuleContext<UidListContext>(i);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public ITerminalNode DELAYED() { return GetToken(MySqlParser.DELAYED, 0); }
		public ITerminalNode HIGH_PRIORITY() { return GetToken(MySqlParser.HIGH_PRIORITY, 0); }
		public InsertStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterInsertStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitInsertStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsertStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InsertStatementContext insertStatement() {
		InsertStatementContext _localctx = new InsertStatementContext(Context, State);
		EnterRule(_localctx, 170, RULE_insertStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2747; Match(INSERT);
			State = 2749;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 38)) & ~0x3f) == 0 && ((1L << (_la - 38)) & ((1L << (DELAYED - 38)) | (1L << (HIGH_PRIORITY - 38)) | (1L << (LOW_PRIORITY - 38)))) != 0)) {
				{
				State = 2748;
				_localctx.priority = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 38)) & ~0x3f) == 0 && ((1L << (_la - 38)) & ((1L << (DELAYED - 38)) | (1L << (HIGH_PRIORITY - 38)) | (1L << (LOW_PRIORITY - 38)))) != 0)) ) {
					_localctx.priority = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2752;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 2751; Match(IGNORE);
				}
			}

			State = 2755;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTO) {
				{
				State = 2754; Match(INTO);
				}
			}

			State = 2757; tableName();
			State = 2763;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 2758; Match(PARTITION);
				State = 2759; Match(LR_BRACKET);
				State = 2760; _localctx.partitions = uidList();
				State = 2761; Match(RR_BRACKET);
				}
			}

			State = 2781;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
			case VALUES:
			case VALUE:
			case LR_BRACKET:
				{
				State = 2769;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,360,Context) ) {
				case 1:
					{
					State = 2765; Match(LR_BRACKET);
					State = 2766; _localctx.columns = uidList();
					State = 2767; Match(RR_BRACKET);
					}
					break;
				}
				State = 2771; insertStatementValue();
				}
				break;
			case SET:
				{
				State = 2772; Match(SET);
				State = 2773; _localctx.setFirst = updatedElement();
				State = 2778;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2774; Match(COMMA);
					State = 2775; _localctx._updatedElement = updatedElement();
					_localctx._setElements.Add(_localctx._updatedElement);
					}
					}
					State = 2780;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2795;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 2783; Match(ON);
				State = 2784; Match(DUPLICATE);
				State = 2785; Match(KEY);
				State = 2786; Match(UPDATE);
				State = 2787; _localctx.duplicatedFirst = updatedElement();
				State = 2792;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2788; Match(COMMA);
					State = 2789; _localctx._updatedElement = updatedElement();
					_localctx._duplicatedElements.Add(_localctx._updatedElement);
					}
					}
					State = 2794;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoadDataStatementContext : ParserRuleContext {
		public IToken priority;
		public IToken filename;
		public IToken violation;
		public CharsetNameContext charset;
		public IToken fieldsFormat;
		public IToken linesFormat;
		public ITerminalNode LOAD() { return GetToken(MySqlParser.LOAD, 0); }
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode INFILE() { return GetToken(MySqlParser.INFILE, 0); }
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode[] SET() { return GetTokens(MySqlParser.SET); }
		public ITerminalNode SET(int i) {
			return GetToken(MySqlParser.SET, i);
		}
		public ITerminalNode[] LINES() { return GetTokens(MySqlParser.LINES); }
		public ITerminalNode LINES(int i) {
			return GetToken(MySqlParser.LINES, i);
		}
		public ITerminalNode[] IGNORE() { return GetTokens(MySqlParser.IGNORE); }
		public ITerminalNode IGNORE(int i) {
			return GetToken(MySqlParser.IGNORE, i);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public AssignmentFieldContext[] assignmentField() {
			return GetRuleContexts<AssignmentFieldContext>();
		}
		public AssignmentFieldContext assignmentField(int i) {
			return GetRuleContext<AssignmentFieldContext>(i);
		}
		public UpdatedElementContext[] updatedElement() {
			return GetRuleContexts<UpdatedElementContext>();
		}
		public UpdatedElementContext updatedElement(int i) {
			return GetRuleContext<UpdatedElementContext>(i);
		}
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public ITerminalNode CONCURRENT() { return GetToken(MySqlParser.CONCURRENT, 0); }
		public ITerminalNode REPLACE() { return GetToken(MySqlParser.REPLACE, 0); }
		public ITerminalNode FIELDS() { return GetToken(MySqlParser.FIELDS, 0); }
		public ITerminalNode COLUMNS() { return GetToken(MySqlParser.COLUMNS, 0); }
		public ITerminalNode ROWS() { return GetToken(MySqlParser.ROWS, 0); }
		public SelectFieldsIntoContext[] selectFieldsInto() {
			return GetRuleContexts<SelectFieldsIntoContext>();
		}
		public SelectFieldsIntoContext selectFieldsInto(int i) {
			return GetRuleContext<SelectFieldsIntoContext>(i);
		}
		public SelectLinesIntoContext[] selectLinesInto() {
			return GetRuleContexts<SelectLinesIntoContext>();
		}
		public SelectLinesIntoContext selectLinesInto(int i) {
			return GetRuleContext<SelectLinesIntoContext>(i);
		}
		public LoadDataStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loadDataStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLoadDataStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLoadDataStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoadDataStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoadDataStatementContext loadDataStatement() {
		LoadDataStatementContext _localctx = new LoadDataStatementContext(Context, State);
		EnterRule(_localctx, 172, RULE_loadDataStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2797; Match(LOAD);
			State = 2798; Match(DATA);
			State = 2800;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOW_PRIORITY || _la==CONCURRENT) {
				{
				State = 2799;
				_localctx.priority = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==LOW_PRIORITY || _la==CONCURRENT) ) {
					_localctx.priority = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2803;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOCAL) {
				{
				State = 2802; Match(LOCAL);
				}
			}

			State = 2805; Match(INFILE);
			State = 2806; _localctx.filename = Match(STRING_LITERAL);
			State = 2808;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE || _la==REPLACE) {
				{
				State = 2807;
				_localctx.violation = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==IGNORE || _la==REPLACE) ) {
					_localctx.violation = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2810; Match(INTO);
			State = 2811; Match(TABLE);
			State = 2812; tableName();
			State = 2818;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 2813; Match(PARTITION);
				State = 2814; Match(LR_BRACKET);
				State = 2815; uidList();
				State = 2816; Match(RR_BRACKET);
				}
			}

			State = 2823;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CHARACTER) {
				{
				State = 2820; Match(CHARACTER);
				State = 2821; Match(SET);
				State = 2822; _localctx.charset = charsetName();
				}
			}

			State = 2831;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLUMNS || _la==FIELDS) {
				{
				State = 2825;
				_localctx.fieldsFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==COLUMNS || _la==FIELDS) ) {
					_localctx.fieldsFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2827;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 2826; selectFieldsInto();
					}
					}
					State = 2829;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==ENCLOSED || _la==ESCAPED || _la==OPTIONALLY || _la==TERMINATED );
				}
			}

			State = 2839;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LINES) {
				{
				State = 2833; Match(LINES);
				State = 2835;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 2834; selectLinesInto();
					}
					}
					State = 2837;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==STARTING || _la==TERMINATED );
				}
			}

			State = 2845;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 2841; Match(IGNORE);
				State = 2842; decimalLiteral();
				State = 2843;
				_localctx.linesFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==LINES || _la==ROWS) ) {
					_localctx.linesFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2858;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,376,Context) ) {
			case 1:
				{
				State = 2847; Match(LR_BRACKET);
				State = 2848; assignmentField();
				State = 2853;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2849; Match(COMMA);
					State = 2850; assignmentField();
					}
					}
					State = 2855;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2856; Match(RR_BRACKET);
				}
				break;
			}
			State = 2869;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,378,Context) ) {
			case 1:
				{
				State = 2860; Match(SET);
				State = 2861; updatedElement();
				State = 2866;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2862; Match(COMMA);
					State = 2863; updatedElement();
					}
					}
					State = 2868;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoadXmlStatementContext : ParserRuleContext {
		public IToken priority;
		public IToken filename;
		public IToken violation;
		public CharsetNameContext charset;
		public IToken tag;
		public IToken linesFormat;
		public ITerminalNode LOAD() { return GetToken(MySqlParser.LOAD, 0); }
		public ITerminalNode XML() { return GetToken(MySqlParser.XML, 0); }
		public ITerminalNode INFILE() { return GetToken(MySqlParser.INFILE, 0); }
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(MySqlParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(MySqlParser.STRING_LITERAL, i);
		}
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode[] SET() { return GetTokens(MySqlParser.SET); }
		public ITerminalNode SET(int i) {
			return GetToken(MySqlParser.SET, i);
		}
		public ITerminalNode[] ROWS() { return GetTokens(MySqlParser.ROWS); }
		public ITerminalNode ROWS(int i) {
			return GetToken(MySqlParser.ROWS, i);
		}
		public ITerminalNode IDENTIFIED() { return GetToken(MySqlParser.IDENTIFIED, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public ITerminalNode[] IGNORE() { return GetTokens(MySqlParser.IGNORE); }
		public ITerminalNode IGNORE(int i) {
			return GetToken(MySqlParser.IGNORE, i);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public AssignmentFieldContext[] assignmentField() {
			return GetRuleContexts<AssignmentFieldContext>();
		}
		public AssignmentFieldContext assignmentField(int i) {
			return GetRuleContext<AssignmentFieldContext>(i);
		}
		public UpdatedElementContext[] updatedElement() {
			return GetRuleContexts<UpdatedElementContext>();
		}
		public UpdatedElementContext updatedElement(int i) {
			return GetRuleContext<UpdatedElementContext>(i);
		}
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public ITerminalNode CONCURRENT() { return GetToken(MySqlParser.CONCURRENT, 0); }
		public ITerminalNode REPLACE() { return GetToken(MySqlParser.REPLACE, 0); }
		public ITerminalNode LINES() { return GetToken(MySqlParser.LINES, 0); }
		public LoadXmlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loadXmlStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLoadXmlStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLoadXmlStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoadXmlStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoadXmlStatementContext loadXmlStatement() {
		LoadXmlStatementContext _localctx = new LoadXmlStatementContext(Context, State);
		EnterRule(_localctx, 174, RULE_loadXmlStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2871; Match(LOAD);
			State = 2872; Match(XML);
			State = 2874;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOW_PRIORITY || _la==CONCURRENT) {
				{
				State = 2873;
				_localctx.priority = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==LOW_PRIORITY || _la==CONCURRENT) ) {
					_localctx.priority = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2877;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOCAL) {
				{
				State = 2876; Match(LOCAL);
				}
			}

			State = 2879; Match(INFILE);
			State = 2880; _localctx.filename = Match(STRING_LITERAL);
			State = 2882;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE || _la==REPLACE) {
				{
				State = 2881;
				_localctx.violation = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==IGNORE || _la==REPLACE) ) {
					_localctx.violation = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2884; Match(INTO);
			State = 2885; Match(TABLE);
			State = 2886; tableName();
			State = 2890;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CHARACTER) {
				{
				State = 2887; Match(CHARACTER);
				State = 2888; Match(SET);
				State = 2889; _localctx.charset = charsetName();
				}
			}

			State = 2898;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ROWS) {
				{
				State = 2892; Match(ROWS);
				State = 2893; Match(IDENTIFIED);
				State = 2894; Match(BY);
				State = 2895; Match(LESS_SYMBOL);
				State = 2896; _localctx.tag = Match(STRING_LITERAL);
				State = 2897; Match(GREATER_SYMBOL);
				}
			}

			State = 2904;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 2900; Match(IGNORE);
				State = 2901; decimalLiteral();
				State = 2902;
				_localctx.linesFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==LINES || _la==ROWS) ) {
					_localctx.linesFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2917;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,386,Context) ) {
			case 1:
				{
				State = 2906; Match(LR_BRACKET);
				State = 2907; assignmentField();
				State = 2912;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2908; Match(COMMA);
					State = 2909; assignmentField();
					}
					}
					State = 2914;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2915; Match(RR_BRACKET);
				}
				break;
			}
			State = 2928;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,388,Context) ) {
			case 1:
				{
				State = 2919; Match(SET);
				State = 2920; updatedElement();
				State = 2925;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2921; Match(COMMA);
					State = 2922; updatedElement();
					}
					}
					State = 2927;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReplaceStatementContext : ParserRuleContext {
		public IToken priority;
		public UidListContext partitions;
		public UidListContext columns;
		public UpdatedElementContext setFirst;
		public UpdatedElementContext _updatedElement;
		public IList<UpdatedElementContext> _setElements = new List<UpdatedElementContext>();
		public ITerminalNode REPLACE() { return GetToken(MySqlParser.REPLACE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public InsertStatementValueContext insertStatementValue() {
			return GetRuleContext<InsertStatementValueContext>(0);
		}
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UpdatedElementContext[] updatedElement() {
			return GetRuleContexts<UpdatedElementContext>();
		}
		public UpdatedElementContext updatedElement(int i) {
			return GetRuleContext<UpdatedElementContext>(i);
		}
		public UidListContext[] uidList() {
			return GetRuleContexts<UidListContext>();
		}
		public UidListContext uidList(int i) {
			return GetRuleContext<UidListContext>(i);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public ITerminalNode DELAYED() { return GetToken(MySqlParser.DELAYED, 0); }
		public ReplaceStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_replaceStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReplaceStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReplaceStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReplaceStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReplaceStatementContext replaceStatement() {
		ReplaceStatementContext _localctx = new ReplaceStatementContext(Context, State);
		EnterRule(_localctx, 176, RULE_replaceStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2930; Match(REPLACE);
			State = 2932;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DELAYED || _la==LOW_PRIORITY) {
				{
				State = 2931;
				_localctx.priority = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DELAYED || _la==LOW_PRIORITY) ) {
					_localctx.priority = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2935;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTO) {
				{
				State = 2934; Match(INTO);
				}
			}

			State = 2937; tableName();
			State = 2943;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 2938; Match(PARTITION);
				State = 2939; Match(LR_BRACKET);
				State = 2940; _localctx.partitions = uidList();
				State = 2941; Match(RR_BRACKET);
				}
			}

			State = 2961;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
			case VALUES:
			case VALUE:
			case LR_BRACKET:
				{
				State = 2949;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,392,Context) ) {
				case 1:
					{
					State = 2945; Match(LR_BRACKET);
					State = 2946; _localctx.columns = uidList();
					State = 2947; Match(RR_BRACKET);
					}
					break;
				}
				State = 2951; insertStatementValue();
				}
				break;
			case SET:
				{
				State = 2952; Match(SET);
				State = 2953; _localctx.setFirst = updatedElement();
				State = 2958;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2954; Match(COMMA);
					State = 2955; _localctx._updatedElement = updatedElement();
					_localctx._setElements.Add(_localctx._updatedElement);
					}
					}
					State = 2960;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectStatementContext : ParserRuleContext {
		public SelectStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectStatement; } }
	 
		public SelectStatementContext() { }
		public virtual void CopyFrom(SelectStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class UnionSelectContext : SelectStatementContext {
		public IToken unionType;
		public QuerySpecificationNointoContext querySpecificationNointo() {
			return GetRuleContext<QuerySpecificationNointoContext>(0);
		}
		public UnionStatementContext[] unionStatement() {
			return GetRuleContexts<UnionStatementContext>();
		}
		public UnionStatementContext unionStatement(int i) {
			return GetRuleContext<UnionStatementContext>(i);
		}
		public ITerminalNode UNION() { return GetToken(MySqlParser.UNION, 0); }
		public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public LimitClauseContext limitClause() {
			return GetRuleContext<LimitClauseContext>(0);
		}
		public LockClauseContext lockClause() {
			return GetRuleContext<LockClauseContext>(0);
		}
		public QuerySpecificationContext querySpecification() {
			return GetRuleContext<QuerySpecificationContext>(0);
		}
		public QueryExpressionContext queryExpression() {
			return GetRuleContext<QueryExpressionContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(MySqlParser.DISTINCT, 0); }
		public UnionSelectContext(SelectStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnionSelect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnionSelect(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnionSelect(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnionParenthesisSelectContext : SelectStatementContext {
		public IToken unionType;
		public QueryExpressionNointoContext queryExpressionNointo() {
			return GetRuleContext<QueryExpressionNointoContext>(0);
		}
		public UnionParenthesisContext[] unionParenthesis() {
			return GetRuleContexts<UnionParenthesisContext>();
		}
		public UnionParenthesisContext unionParenthesis(int i) {
			return GetRuleContext<UnionParenthesisContext>(i);
		}
		public ITerminalNode UNION() { return GetToken(MySqlParser.UNION, 0); }
		public QueryExpressionContext queryExpression() {
			return GetRuleContext<QueryExpressionContext>(0);
		}
		public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public LimitClauseContext limitClause() {
			return GetRuleContext<LimitClauseContext>(0);
		}
		public LockClauseContext lockClause() {
			return GetRuleContext<LockClauseContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(MySqlParser.DISTINCT, 0); }
		public UnionParenthesisSelectContext(SelectStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnionParenthesisSelect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnionParenthesisSelect(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnionParenthesisSelect(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SimpleSelectContext : SelectStatementContext {
		public QuerySpecificationContext querySpecification() {
			return GetRuleContext<QuerySpecificationContext>(0);
		}
		public LockClauseContext lockClause() {
			return GetRuleContext<LockClauseContext>(0);
		}
		public SimpleSelectContext(SelectStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleSelect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleSelect(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleSelect(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesisSelectContext : SelectStatementContext {
		public QueryExpressionContext queryExpression() {
			return GetRuleContext<QueryExpressionContext>(0);
		}
		public LockClauseContext lockClause() {
			return GetRuleContext<LockClauseContext>(0);
		}
		public ParenthesisSelectContext(SelectStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterParenthesisSelect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitParenthesisSelect(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesisSelect(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectStatementContext selectStatement() {
		SelectStatementContext _localctx = new SelectStatementContext(Context, State);
		EnterRule(_localctx, 178, RULE_selectStatement);
		int _la;
		try {
			int _alt;
			State = 3018;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,410,Context) ) {
			case 1:
				_localctx = new SimpleSelectContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 2963; querySpecification();
				State = 2965;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,395,Context) ) {
				case 1:
					{
					State = 2964; lockClause();
					}
					break;
				}
				}
				break;
			case 2:
				_localctx = new ParenthesisSelectContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 2967; queryExpression();
				State = 2969;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,396,Context) ) {
				case 1:
					{
					State = 2968; lockClause();
					}
					break;
				}
				}
				break;
			case 3:
				_localctx = new UnionSelectContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 2971; querySpecificationNointo();
				State = 2973;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 2972; unionStatement();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2975;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,397,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 2985;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNION) {
					{
					State = 2977; Match(UNION);
					State = 2979;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==ALL || _la==DISTINCT) {
						{
						State = 2978;
						((UnionSelectContext)_localctx).unionType = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==ALL || _la==DISTINCT) ) {
							((UnionSelectContext)_localctx).unionType = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					State = 2983;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case SELECT:
						{
						State = 2981; querySpecification();
						}
						break;
					case LR_BRACKET:
						{
						State = 2982; queryExpression();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				State = 2988;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ORDER) {
					{
					State = 2987; orderByClause();
					}
				}

				State = 2991;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIMIT) {
					{
					State = 2990; limitClause();
					}
				}

				State = 2994;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,403,Context) ) {
				case 1:
					{
					State = 2993; lockClause();
					}
					break;
				}
				}
				break;
			case 4:
				_localctx = new UnionParenthesisSelectContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 2996; queryExpressionNointo();
				State = 2998;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 2997; unionParenthesis();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 3000;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,404,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 3007;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNION) {
					{
					State = 3002; Match(UNION);
					State = 3004;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==ALL || _la==DISTINCT) {
						{
						State = 3003;
						((UnionParenthesisSelectContext)_localctx).unionType = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==ALL || _la==DISTINCT) ) {
							((UnionParenthesisSelectContext)_localctx).unionType = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					State = 3006; queryExpression();
					}
				}

				State = 3010;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ORDER) {
					{
					State = 3009; orderByClause();
					}
				}

				State = 3013;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIMIT) {
					{
					State = 3012; limitClause();
					}
				}

				State = 3016;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,409,Context) ) {
				case 1:
					{
					State = 3015; lockClause();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UpdateStatementContext : ParserRuleContext {
		public SingleUpdateStatementContext singleUpdateStatement() {
			return GetRuleContext<SingleUpdateStatementContext>(0);
		}
		public MultipleUpdateStatementContext multipleUpdateStatement() {
			return GetRuleContext<MultipleUpdateStatementContext>(0);
		}
		public UpdateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_updateStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUpdateStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUpdateStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdateStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UpdateStatementContext updateStatement() {
		UpdateStatementContext _localctx = new UpdateStatementContext(Context, State);
		EnterRule(_localctx, 180, RULE_updateStatement);
		try {
			State = 3022;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,411,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3020; singleUpdateStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3021; multipleUpdateStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertStatementValueContext : ParserRuleContext {
		public IToken insertFormat;
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ExpressionsWithDefaultsContext[] expressionsWithDefaults() {
			return GetRuleContexts<ExpressionsWithDefaultsContext>();
		}
		public ExpressionsWithDefaultsContext expressionsWithDefaults(int i) {
			return GetRuleContext<ExpressionsWithDefaultsContext>(i);
		}
		public ITerminalNode VALUES() { return GetToken(MySqlParser.VALUES, 0); }
		public ITerminalNode VALUE() { return GetToken(MySqlParser.VALUE, 0); }
		public InsertStatementValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertStatementValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterInsertStatementValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitInsertStatementValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsertStatementValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InsertStatementValueContext insertStatementValue() {
		InsertStatementValueContext _localctx = new InsertStatementValueContext(Context, State);
		EnterRule(_localctx, 182, RULE_insertStatementValue);
		int _la;
		try {
			State = 3039;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
			case LR_BRACKET:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3024; selectStatement();
				}
				break;
			case VALUES:
			case VALUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3025;
				_localctx.insertFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==VALUES || _la==VALUE) ) {
					_localctx.insertFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3026; Match(LR_BRACKET);
				State = 3027; expressionsWithDefaults();
				State = 3028; Match(RR_BRACKET);
				State = 3036;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3029; Match(COMMA);
					State = 3030; Match(LR_BRACKET);
					State = 3031; expressionsWithDefaults();
					State = 3032; Match(RR_BRACKET);
					}
					}
					State = 3038;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UpdatedElementContext : ParserRuleContext {
		public FullColumnNameContext fullColumnName() {
			return GetRuleContext<FullColumnNameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public UpdatedElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_updatedElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUpdatedElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUpdatedElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdatedElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UpdatedElementContext updatedElement() {
		UpdatedElementContext _localctx = new UpdatedElementContext(Context, State);
		EnterRule(_localctx, 184, RULE_updatedElement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3041; fullColumnName();
			State = 3042; Match(EQUAL_SYMBOL);
			State = 3045;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CASE:
			case CAST:
			case CONVERT:
			case CURRENT_USER:
			case DATABASE:
			case EXISTS:
			case FALSE:
			case IF:
			case INSERT:
			case INTERVAL:
			case LEFT:
			case NOT:
			case NULL_LITERAL:
			case REPLACE:
			case RIGHT:
			case TRUE:
			case VALUES:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case CHAR:
			case BINARY:
			case TEXT:
			case ENUM:
			case SERIAL:
			case AVG:
			case BIT_AND:
			case BIT_OR:
			case BIT_XOR:
			case COUNT:
			case GROUP_CONCAT:
			case MAX:
			case MIN:
			case STD:
			case STDDEV:
			case STDDEV_POP:
			case STDDEV_SAMP:
			case SUM:
			case VAR_POP:
			case VAR_SAMP:
			case VARIANCE:
			case CURRENT_DATE:
			case CURRENT_TIME:
			case CURRENT_TIMESTAMP:
			case LOCALTIME:
			case CURDATE:
			case CURTIME:
			case DATE_ADD:
			case DATE_SUB:
			case EXTRACT:
			case LOCALTIMESTAMP:
			case NOW:
			case POSITION:
			case SUBSTR:
			case SUBSTRING:
			case SYSDATE:
			case TRIM:
			case UTC_DATE:
			case UTC_TIME:
			case UTC_TIMESTAMP:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLASS_ORIGIN:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COLUMN_NAME:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONSTRAINT_CATALOG:
			case CONSTRAINT_SCHEMA:
			case CONSTRAINT_NAME:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVISIBLE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MESSAGE_TEXT:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case MYSQL_ERRNO:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBCLASS_ORIGIN:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLE_NAME:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case VISIBLE:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case SESSION_VARIABLES_ADMIN:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CATALOG_NAME:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SCHEMA_NAME:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case PLUS:
			case MINUS:
			case EXCLAMATION_SYMBOL:
			case BIT_NOT_OP:
			case LR_BRACKET:
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case CHARSET_REVERSE_QOUTE_STRING:
			case START_NATIONAL_STRING_LITERAL:
			case STRING_LITERAL:
			case DECIMAL_LITERAL:
			case HEXADECIMAL_LITERAL:
			case REAL_LITERAL:
			case NULL_SPEC_LITERAL:
			case BIT_STRING:
			case STRING_CHARSET_NAME:
			case ID:
			case REVERSE_QUOTE_ID:
			case LOCAL_ID:
			case GLOBAL_ID:
				{
				State = 3043; expression(0);
				}
				break;
			case DEFAULT:
				{
				State = 3044; Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentFieldContext : ParserRuleContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode LOCAL_ID() { return GetToken(MySqlParser.LOCAL_ID, 0); }
		public AssignmentFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignmentField; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAssignmentField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAssignmentField(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignmentField(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentFieldContext assignmentField() {
		AssignmentFieldContext _localctx = new AssignmentFieldContext(Context, State);
		EnterRule(_localctx, 186, RULE_assignmentField);
		try {
			State = 3049;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DATABASE:
			case LEFT:
			case RIGHT:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case TEXT:
			case ENUM:
			case SERIAL:
			case COUNT:
			case POSITION:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLASS_ORIGIN:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COLUMN_NAME:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONSTRAINT_CATALOG:
			case CONSTRAINT_SCHEMA:
			case CONSTRAINT_NAME:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVISIBLE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MESSAGE_TEXT:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case MYSQL_ERRNO:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBCLASS_ORIGIN:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLE_NAME:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case VISIBLE:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case SESSION_VARIABLES_ADMIN:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CATALOG_NAME:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SCHEMA_NAME:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case CHARSET_REVERSE_QOUTE_STRING:
			case STRING_LITERAL:
			case ID:
			case REVERSE_QUOTE_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3047; uid();
				}
				break;
			case LOCAL_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3048; Match(LOCAL_ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockClauseContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public ITerminalNode SHARE() { return GetToken(MySqlParser.SHARE, 0); }
		public ITerminalNode MODE() { return GetToken(MySqlParser.MODE, 0); }
		public LockClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLockClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLockClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLockClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LockClauseContext lockClause() {
		LockClauseContext _localctx = new LockClauseContext(Context, State);
		EnterRule(_localctx, 188, RULE_lockClause);
		try {
			State = 3057;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FOR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3051; Match(FOR);
				State = 3052; Match(UPDATE);
				}
				break;
			case LOCK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3053; Match(LOCK);
				State = 3054; Match(IN);
				State = 3055; Match(SHARE);
				State = 3056; Match(MODE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleDeleteStatementContext : ParserRuleContext {
		public IToken priority;
		public ITerminalNode DELETE() { return GetToken(MySqlParser.DELETE, 0); }
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode QUICK() { return GetToken(MySqlParser.QUICK, 0); }
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public SingleDeleteStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleDeleteStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSingleDeleteStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSingleDeleteStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingleDeleteStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SingleDeleteStatementContext singleDeleteStatement() {
		SingleDeleteStatementContext _localctx = new SingleDeleteStatementContext(Context, State);
		EnterRule(_localctx, 190, RULE_singleDeleteStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3059; Match(DELETE);
			State = 3061;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOW_PRIORITY) {
				{
				State = 3060; _localctx.priority = Match(LOW_PRIORITY);
				}
			}

			State = 3064;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==QUICK) {
				{
				State = 3063; Match(QUICK);
				}
			}

			State = 3067;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 3066; Match(IGNORE);
				}
			}

			State = 3069; Match(FROM);
			State = 3070; tableName();
			State = 3076;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 3071; Match(PARTITION);
				State = 3072; Match(LR_BRACKET);
				State = 3073; uidList();
				State = 3074; Match(RR_BRACKET);
				}
			}

			State = 3080;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3078; Match(WHERE);
				State = 3079; expression(0);
				}
			}

			State = 3083;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 3082; orderByClause();
				}
			}

			State = 3087;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LIMIT) {
				{
				State = 3085; Match(LIMIT);
				State = 3086; decimalLiteral();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultipleDeleteStatementContext : ParserRuleContext {
		public IToken priority;
		public ITerminalNode DELETE() { return GetToken(MySqlParser.DELETE, 0); }
		public TableNameContext[] tableName() {
			return GetRuleContexts<TableNameContext>();
		}
		public TableNameContext tableName(int i) {
			return GetRuleContext<TableNameContext>(i);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public TableSourcesContext tableSources() {
			return GetRuleContext<TableSourcesContext>(0);
		}
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public ITerminalNode QUICK() { return GetToken(MySqlParser.QUICK, 0); }
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public MultipleDeleteStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multipleDeleteStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMultipleDeleteStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMultipleDeleteStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultipleDeleteStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultipleDeleteStatementContext multipleDeleteStatement() {
		MultipleDeleteStatementContext _localctx = new MultipleDeleteStatementContext(Context, State);
		EnterRule(_localctx, 192, RULE_multipleDeleteStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3089; Match(DELETE);
			State = 3091;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOW_PRIORITY) {
				{
				State = 3090; _localctx.priority = Match(LOW_PRIORITY);
				}
			}

			State = 3094;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,425,Context) ) {
			case 1:
				{
				State = 3093; Match(QUICK);
				}
				break;
			}
			State = 3097;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 3096; Match(IGNORE);
				}
			}

			State = 3138;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DATABASE:
			case LEFT:
			case RIGHT:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case TEXT:
			case ENUM:
			case SERIAL:
			case COUNT:
			case POSITION:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLASS_ORIGIN:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COLUMN_NAME:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONSTRAINT_CATALOG:
			case CONSTRAINT_SCHEMA:
			case CONSTRAINT_NAME:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVISIBLE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MESSAGE_TEXT:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case MYSQL_ERRNO:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBCLASS_ORIGIN:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLE_NAME:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case VISIBLE:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case SESSION_VARIABLES_ADMIN:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CATALOG_NAME:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SCHEMA_NAME:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case CHARSET_REVERSE_QOUTE_STRING:
			case STRING_LITERAL:
			case ID:
			case REVERSE_QUOTE_ID:
				{
				State = 3099; tableName();
				State = 3102;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOT) {
					{
					State = 3100; Match(DOT);
					State = 3101; Match(STAR);
					}
				}

				State = 3112;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3104; Match(COMMA);
					State = 3105; tableName();
					State = 3108;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DOT) {
						{
						State = 3106; Match(DOT);
						State = 3107; Match(STAR);
						}
					}

					}
					}
					State = 3114;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3115; Match(FROM);
				State = 3116; tableSources();
				}
				break;
			case FROM:
				{
				State = 3118; Match(FROM);
				State = 3119; tableName();
				State = 3122;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOT) {
					{
					State = 3120; Match(DOT);
					State = 3121; Match(STAR);
					}
				}

				State = 3132;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3124; Match(COMMA);
					State = 3125; tableName();
					State = 3128;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==DOT) {
						{
						State = 3126; Match(DOT);
						State = 3127; Match(STAR);
						}
					}

					}
					}
					State = 3134;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3135; Match(USING);
				State = 3136; tableSources();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3142;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3140; Match(WHERE);
				State = 3141; expression(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandlerOpenStatementContext : ParserRuleContext {
		public ITerminalNode HANDLER() { return GetToken(MySqlParser.HANDLER, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode OPEN() { return GetToken(MySqlParser.OPEN, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public HandlerOpenStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handlerOpenStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerOpenStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerOpenStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHandlerOpenStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HandlerOpenStatementContext handlerOpenStatement() {
		HandlerOpenStatementContext _localctx = new HandlerOpenStatementContext(Context, State);
		EnterRule(_localctx, 194, RULE_handlerOpenStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3144; Match(HANDLER);
			State = 3145; tableName();
			State = 3146; Match(OPEN);
			State = 3151;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,436,Context) ) {
			case 1:
				{
				State = 3148;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 3147; Match(AS);
					}
				}

				State = 3150; uid();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandlerReadIndexStatementContext : ParserRuleContext {
		public UidContext index;
		public IToken moveOrder;
		public ITerminalNode HANDLER() { return GetToken(MySqlParser.HANDLER, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ComparisonOperatorContext comparisonOperator() {
			return GetRuleContext<ComparisonOperatorContext>(0);
		}
		public ConstantsContext constants() {
			return GetRuleContext<ConstantsContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode NEXT() { return GetToken(MySqlParser.NEXT, 0); }
		public ITerminalNode PREV() { return GetToken(MySqlParser.PREV, 0); }
		public ITerminalNode LAST() { return GetToken(MySqlParser.LAST, 0); }
		public HandlerReadIndexStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handlerReadIndexStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerReadIndexStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerReadIndexStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHandlerReadIndexStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HandlerReadIndexStatementContext handlerReadIndexStatement() {
		HandlerReadIndexStatementContext _localctx = new HandlerReadIndexStatementContext(Context, State);
		EnterRule(_localctx, 196, RULE_handlerReadIndexStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3153; Match(HANDLER);
			State = 3154; tableName();
			State = 3155; Match(READ);
			State = 3156; _localctx.index = uid();
			State = 3163;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EQUAL_SYMBOL:
			case GREATER_SYMBOL:
			case LESS_SYMBOL:
			case EXCLAMATION_SYMBOL:
				{
				State = 3157; comparisonOperator();
				State = 3158; Match(LR_BRACKET);
				State = 3159; constants();
				State = 3160; Match(RR_BRACKET);
				}
				break;
			case FIRST:
			case LAST:
			case NEXT:
			case PREV:
				{
				State = 3162;
				_localctx.moveOrder = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FIRST || _la==LAST || _la==NEXT || _la==PREV) ) {
					_localctx.moveOrder = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3167;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3165; Match(WHERE);
				State = 3166; expression(0);
				}
			}

			State = 3171;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LIMIT) {
				{
				State = 3169; Match(LIMIT);
				State = 3170; decimalLiteral();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandlerReadStatementContext : ParserRuleContext {
		public IToken moveOrder;
		public ITerminalNode HANDLER() { return GetToken(MySqlParser.HANDLER, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode NEXT() { return GetToken(MySqlParser.NEXT, 0); }
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public HandlerReadStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handlerReadStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerReadStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerReadStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHandlerReadStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HandlerReadStatementContext handlerReadStatement() {
		HandlerReadStatementContext _localctx = new HandlerReadStatementContext(Context, State);
		EnterRule(_localctx, 198, RULE_handlerReadStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3173; Match(HANDLER);
			State = 3174; tableName();
			State = 3175; Match(READ);
			State = 3176;
			_localctx.moveOrder = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==FIRST || _la==NEXT) ) {
				_localctx.moveOrder = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3177; Match(WHERE);
				State = 3178; expression(0);
				}
			}

			State = 3183;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LIMIT) {
				{
				State = 3181; Match(LIMIT);
				State = 3182; decimalLiteral();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandlerCloseStatementContext : ParserRuleContext {
		public ITerminalNode HANDLER() { return GetToken(MySqlParser.HANDLER, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode CLOSE() { return GetToken(MySqlParser.CLOSE, 0); }
		public HandlerCloseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handlerCloseStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerCloseStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerCloseStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHandlerCloseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HandlerCloseStatementContext handlerCloseStatement() {
		HandlerCloseStatementContext _localctx = new HandlerCloseStatementContext(Context, State);
		EnterRule(_localctx, 200, RULE_handlerCloseStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3185; Match(HANDLER);
			State = 3186; tableName();
			State = 3187; Match(CLOSE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleUpdateStatementContext : ParserRuleContext {
		public IToken priority;
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public UpdatedElementContext[] updatedElement() {
			return GetRuleContexts<UpdatedElementContext>();
		}
		public UpdatedElementContext updatedElement(int i) {
			return GetRuleContext<UpdatedElementContext>(i);
		}
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public LimitClauseContext limitClause() {
			return GetRuleContext<LimitClauseContext>(0);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SingleUpdateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleUpdateStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSingleUpdateStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSingleUpdateStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingleUpdateStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SingleUpdateStatementContext singleUpdateStatement() {
		SingleUpdateStatementContext _localctx = new SingleUpdateStatementContext(Context, State);
		EnterRule(_localctx, 202, RULE_singleUpdateStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3189; Match(UPDATE);
			State = 3191;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOW_PRIORITY) {
				{
				State = 3190; _localctx.priority = Match(LOW_PRIORITY);
				}
			}

			State = 3194;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 3193; Match(IGNORE);
				}
			}

			State = 3196; tableName();
			State = 3201;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
				{
				State = 3198;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 3197; Match(AS);
					}
				}

				State = 3200; uid();
				}
			}

			State = 3203; Match(SET);
			State = 3204; updatedElement();
			State = 3209;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3205; Match(COMMA);
				State = 3206; updatedElement();
				}
				}
				State = 3211;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3214;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3212; Match(WHERE);
				State = 3213; expression(0);
				}
			}

			State = 3217;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 3216; orderByClause();
				}
			}

			State = 3220;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LIMIT) {
				{
				State = 3219; limitClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultipleUpdateStatementContext : ParserRuleContext {
		public IToken priority;
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public TableSourcesContext tableSources() {
			return GetRuleContext<TableSourcesContext>(0);
		}
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public UpdatedElementContext[] updatedElement() {
			return GetRuleContexts<UpdatedElementContext>();
		}
		public UpdatedElementContext updatedElement(int i) {
			return GetRuleContext<UpdatedElementContext>(i);
		}
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public MultipleUpdateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multipleUpdateStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMultipleUpdateStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMultipleUpdateStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultipleUpdateStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultipleUpdateStatementContext multipleUpdateStatement() {
		MultipleUpdateStatementContext _localctx = new MultipleUpdateStatementContext(Context, State);
		EnterRule(_localctx, 204, RULE_multipleUpdateStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3222; Match(UPDATE);
			State = 3224;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOW_PRIORITY) {
				{
				State = 3223; _localctx.priority = Match(LOW_PRIORITY);
				}
			}

			State = 3227;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 3226; Match(IGNORE);
				}
			}

			State = 3229; tableSources();
			State = 3230; Match(SET);
			State = 3231; updatedElement();
			State = 3236;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3232; Match(COMMA);
				State = 3233; updatedElement();
				}
				}
				State = 3238;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3241;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3239; Match(WHERE);
				State = 3240; expression(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByClauseContext : ParserRuleContext {
		public ITerminalNode ORDER() { return GetToken(MySqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public OrderByExpressionContext[] orderByExpression() {
			return GetRuleContexts<OrderByExpressionContext>();
		}
		public OrderByExpressionContext orderByExpression(int i) {
			return GetRuleContext<OrderByExpressionContext>(i);
		}
		public OrderByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterOrderByClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitOrderByClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrderByClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OrderByClauseContext orderByClause() {
		OrderByClauseContext _localctx = new OrderByClauseContext(Context, State);
		EnterRule(_localctx, 206, RULE_orderByClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3243; Match(ORDER);
			State = 3244; Match(BY);
			State = 3245; orderByExpression();
			State = 3250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3246; Match(COMMA);
				State = 3247; orderByExpression();
				}
				}
				State = 3252;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByExpressionContext : ParserRuleContext {
		public IToken order;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASC() { return GetToken(MySqlParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(MySqlParser.DESC, 0); }
		public OrderByExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterOrderByExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitOrderByExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrderByExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OrderByExpressionContext orderByExpression() {
		OrderByExpressionContext _localctx = new OrderByExpressionContext(Context, State);
		EnterRule(_localctx, 208, RULE_orderByExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3253; expression(0);
			State = 3255;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,455,Context) ) {
			case 1:
				{
				State = 3254;
				_localctx.order = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ASC || _la==DESC) ) {
					_localctx.order = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableSourcesContext : ParserRuleContext {
		public TableSourceContext[] tableSource() {
			return GetRuleContexts<TableSourceContext>();
		}
		public TableSourceContext tableSource(int i) {
			return GetRuleContext<TableSourceContext>(i);
		}
		public TableSourcesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableSources; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableSources(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableSources(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableSources(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TableSourcesContext tableSources() {
		TableSourcesContext _localctx = new TableSourcesContext(Context, State);
		EnterRule(_localctx, 210, RULE_tableSources);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3257; tableSource();
			State = 3262;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3258; Match(COMMA);
				State = 3259; tableSource();
				}
				}
				State = 3264;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableSourceContext : ParserRuleContext {
		public TableSourceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableSource; } }
	 
		public TableSourceContext() { }
		public virtual void CopyFrom(TableSourceContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TableSourceNestedContext : TableSourceContext {
		public TableSourceItemContext tableSourceItem() {
			return GetRuleContext<TableSourceItemContext>(0);
		}
		public JoinPartContext[] joinPart() {
			return GetRuleContexts<JoinPartContext>();
		}
		public JoinPartContext joinPart(int i) {
			return GetRuleContext<JoinPartContext>(i);
		}
		public TableSourceNestedContext(TableSourceContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableSourceNested(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableSourceNested(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableSourceNested(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableSourceBaseContext : TableSourceContext {
		public TableSourceItemContext tableSourceItem() {
			return GetRuleContext<TableSourceItemContext>(0);
		}
		public JoinPartContext[] joinPart() {
			return GetRuleContexts<JoinPartContext>();
		}
		public JoinPartContext joinPart(int i) {
			return GetRuleContext<JoinPartContext>(i);
		}
		public TableSourceBaseContext(TableSourceContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableSourceBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableSourceBase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableSourceBase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TableSourceContext tableSource() {
		TableSourceContext _localctx = new TableSourceContext(Context, State);
		EnterRule(_localctx, 212, RULE_tableSource);
		int _la;
		try {
			int _alt;
			State = 3282;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,459,Context) ) {
			case 1:
				_localctx = new TableSourceBaseContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3265; tableSourceItem();
				State = 3269;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,457,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 3266; joinPart();
						}
						} 
					}
					State = 3271;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,457,Context);
				}
				}
				break;
			case 2:
				_localctx = new TableSourceNestedContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3272; Match(LR_BRACKET);
				State = 3273; tableSourceItem();
				State = 3277;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (((((_la - 31)) & ~0x3f) == 0 && ((1L << (_la - 31)) & ((1L << (CROSS - 31)) | (1L << (INNER - 31)) | (1L << (JOIN - 31)) | (1L << (LEFT - 31)))) != 0) || ((((_la - 98)) & ~0x3f) == 0 && ((1L << (_la - 98)) & ((1L << (NATURAL - 98)) | (1L << (RIGHT - 98)) | (1L << (STRAIGHT_JOIN - 98)))) != 0)) {
					{
					{
					State = 3274; joinPart();
					}
					}
					State = 3279;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3280; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableSourceItemContext : ParserRuleContext {
		public TableSourceItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableSourceItem; } }
	 
		public TableSourceItemContext() { }
		public virtual void CopyFrom(TableSourceItemContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SubqueryTableItemContext : TableSourceItemContext {
		public SelectStatementContext parenthesisSubquery;
		public UidContext alias;
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SubqueryTableItemContext(TableSourceItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubqueryTableItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubqueryTableItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubqueryTableItem(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AtomTableItemContext : TableSourceItemContext {
		public UidContext alias;
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public IndexHintContext[] indexHint() {
			return GetRuleContexts<IndexHintContext>();
		}
		public IndexHintContext indexHint(int i) {
			return GetRuleContext<IndexHintContext>(i);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public AtomTableItemContext(TableSourceItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAtomTableItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAtomTableItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAtomTableItem(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TableSourcesItemContext : TableSourceItemContext {
		public TableSourcesContext tableSources() {
			return GetRuleContext<TableSourcesContext>(0);
		}
		public TableSourcesItemContext(TableSourceItemContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableSourcesItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableSourcesItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableSourcesItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TableSourceItemContext tableSourceItem() {
		TableSourceItemContext _localctx = new TableSourceItemContext(Context, State);
		EnterRule(_localctx, 214, RULE_tableSourceItem);
		int _la;
		try {
			int _alt;
			State = 3324;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,467,Context) ) {
			case 1:
				_localctx = new AtomTableItemContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3284; tableName();
				State = 3290;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PARTITION) {
					{
					State = 3285; Match(PARTITION);
					State = 3286; Match(LR_BRACKET);
					State = 3287; uidList();
					State = 3288; Match(RR_BRACKET);
					}
				}

				State = 3296;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,462,Context) ) {
				case 1:
					{
					State = 3293;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AS) {
						{
						State = 3292; Match(AS);
						}
					}

					State = 3295; ((AtomTableItemContext)_localctx).alias = uid();
					}
					break;
				}
				State = 3306;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,464,Context) ) {
				case 1:
					{
					State = 3298; indexHint();
					State = 3303;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,463,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 3299; Match(COMMA);
							State = 3300; indexHint();
							}
							} 
						}
						State = 3305;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,463,Context);
					}
					}
					break;
				}
				}
				break;
			case 2:
				_localctx = new SubqueryTableItemContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3313;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,465,Context) ) {
				case 1:
					{
					State = 3308; selectStatement();
					}
					break;
				case 2:
					{
					State = 3309; Match(LR_BRACKET);
					State = 3310; ((SubqueryTableItemContext)_localctx).parenthesisSubquery = selectStatement();
					State = 3311; Match(RR_BRACKET);
					}
					break;
				}
				State = 3316;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 3315; Match(AS);
					}
				}

				State = 3318; ((SubqueryTableItemContext)_localctx).alias = uid();
				}
				break;
			case 3:
				_localctx = new TableSourcesItemContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3320; Match(LR_BRACKET);
				State = 3321; tableSources();
				State = 3322; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexHintContext : ParserRuleContext {
		public IToken indexHintAction;
		public IToken keyFormat;
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode USE() { return GetToken(MySqlParser.USE, 0); }
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode FORCE() { return GetToken(MySqlParser.FORCE, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public IndexHintTypeContext indexHintType() {
			return GetRuleContext<IndexHintTypeContext>(0);
		}
		public IndexHintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexHint; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexHint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexHint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexHint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexHintContext indexHint() {
		IndexHintContext _localctx = new IndexHintContext(Context, State);
		EnterRule(_localctx, 216, RULE_indexHint);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3326;
			_localctx.indexHintAction = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==FORCE || _la==IGNORE || _la==USE) ) {
				_localctx.indexHintAction = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3327;
			_localctx.keyFormat = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==INDEX || _la==KEY) ) {
				_localctx.keyFormat = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3330;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 3328; Match(FOR);
				State = 3329; indexHintType();
				}
			}

			State = 3332; Match(LR_BRACKET);
			State = 3333; uidList();
			State = 3334; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexHintTypeContext : ParserRuleContext {
		public ITerminalNode JOIN() { return GetToken(MySqlParser.JOIN, 0); }
		public ITerminalNode ORDER() { return GetToken(MySqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public ITerminalNode GROUP() { return GetToken(MySqlParser.GROUP, 0); }
		public IndexHintTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexHintType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexHintType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexHintType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexHintType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexHintTypeContext indexHintType() {
		IndexHintTypeContext _localctx = new IndexHintTypeContext(Context, State);
		EnterRule(_localctx, 218, RULE_indexHintType);
		try {
			State = 3341;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case JOIN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3336; Match(JOIN);
				}
				break;
			case ORDER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3337; Match(ORDER);
				State = 3338; Match(BY);
				}
				break;
			case GROUP:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3339; Match(GROUP);
				State = 3340; Match(BY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JoinPartContext : ParserRuleContext {
		public JoinPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_joinPart; } }
	 
		public JoinPartContext() { }
		public virtual void CopyFrom(JoinPartContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class InnerJoinContext : JoinPartContext {
		public ITerminalNode JOIN() { return GetToken(MySqlParser.JOIN, 0); }
		public TableSourceItemContext tableSourceItem() {
			return GetRuleContext<TableSourceItemContext>(0);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode INNER() { return GetToken(MySqlParser.INNER, 0); }
		public ITerminalNode CROSS() { return GetToken(MySqlParser.CROSS, 0); }
		public InnerJoinContext(JoinPartContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterInnerJoin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitInnerJoin(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInnerJoin(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NaturalJoinContext : JoinPartContext {
		public ITerminalNode NATURAL() { return GetToken(MySqlParser.NATURAL, 0); }
		public ITerminalNode JOIN() { return GetToken(MySqlParser.JOIN, 0); }
		public TableSourceItemContext tableSourceItem() {
			return GetRuleContext<TableSourceItemContext>(0);
		}
		public ITerminalNode LEFT() { return GetToken(MySqlParser.LEFT, 0); }
		public ITerminalNode RIGHT() { return GetToken(MySqlParser.RIGHT, 0); }
		public ITerminalNode OUTER() { return GetToken(MySqlParser.OUTER, 0); }
		public NaturalJoinContext(JoinPartContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNaturalJoin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNaturalJoin(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNaturalJoin(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OuterJoinContext : JoinPartContext {
		public ITerminalNode JOIN() { return GetToken(MySqlParser.JOIN, 0); }
		public TableSourceItemContext tableSourceItem() {
			return GetRuleContext<TableSourceItemContext>(0);
		}
		public ITerminalNode LEFT() { return GetToken(MySqlParser.LEFT, 0); }
		public ITerminalNode RIGHT() { return GetToken(MySqlParser.RIGHT, 0); }
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode OUTER() { return GetToken(MySqlParser.OUTER, 0); }
		public OuterJoinContext(JoinPartContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterOuterJoin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitOuterJoin(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuterJoin(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StraightJoinContext : JoinPartContext {
		public ITerminalNode STRAIGHT_JOIN() { return GetToken(MySqlParser.STRAIGHT_JOIN, 0); }
		public TableSourceItemContext tableSourceItem() {
			return GetRuleContext<TableSourceItemContext>(0);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StraightJoinContext(JoinPartContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStraightJoin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStraightJoin(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStraightJoin(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JoinPartContext joinPart() {
		JoinPartContext _localctx = new JoinPartContext(Context, State);
		EnterRule(_localctx, 220, RULE_joinPart);
		int _la;
		try {
			State = 3387;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CROSS:
			case INNER:
			case JOIN:
				_localctx = new InnerJoinContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3344;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CROSS || _la==INNER) {
					{
					State = 3343;
					_la = TokenStream.LA(1);
					if ( !(_la==CROSS || _la==INNER) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 3346; Match(JOIN);
				State = 3347; tableSourceItem();
				State = 3355;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,471,Context) ) {
				case 1:
					{
					State = 3348; Match(ON);
					State = 3349; expression(0);
					}
					break;
				case 2:
					{
					State = 3350; Match(USING);
					State = 3351; Match(LR_BRACKET);
					State = 3352; uidList();
					State = 3353; Match(RR_BRACKET);
					}
					break;
				}
				}
				break;
			case STRAIGHT_JOIN:
				_localctx = new StraightJoinContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3357; Match(STRAIGHT_JOIN);
				State = 3358; tableSourceItem();
				State = 3361;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,472,Context) ) {
				case 1:
					{
					State = 3359; Match(ON);
					State = 3360; expression(0);
					}
					break;
				}
				}
				break;
			case LEFT:
			case RIGHT:
				_localctx = new OuterJoinContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3363;
				_la = TokenStream.LA(1);
				if ( !(_la==LEFT || _la==RIGHT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3365;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==OUTER) {
					{
					State = 3364; Match(OUTER);
					}
				}

				State = 3367; Match(JOIN);
				State = 3368; tableSourceItem();
				State = 3376;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ON:
					{
					State = 3369; Match(ON);
					State = 3370; expression(0);
					}
					break;
				case USING:
					{
					State = 3371; Match(USING);
					State = 3372; Match(LR_BRACKET);
					State = 3373; uidList();
					State = 3374; Match(RR_BRACKET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case NATURAL:
				_localctx = new NaturalJoinContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 3378; Match(NATURAL);
				State = 3383;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LEFT || _la==RIGHT) {
					{
					State = 3379;
					_la = TokenStream.LA(1);
					if ( !(_la==LEFT || _la==RIGHT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 3381;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==OUTER) {
						{
						State = 3380; Match(OUTER);
						}
					}

					}
				}

				State = 3385; Match(JOIN);
				State = 3386; tableSourceItem();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryExpressionContext : ParserRuleContext {
		public QuerySpecificationContext querySpecification() {
			return GetRuleContext<QuerySpecificationContext>(0);
		}
		public QueryExpressionContext queryExpression() {
			return GetRuleContext<QueryExpressionContext>(0);
		}
		public QueryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterQueryExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitQueryExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryExpressionContext queryExpression() {
		QueryExpressionContext _localctx = new QueryExpressionContext(Context, State);
		EnterRule(_localctx, 222, RULE_queryExpression);
		try {
			State = 3397;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,478,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3389; Match(LR_BRACKET);
				State = 3390; querySpecification();
				State = 3391; Match(RR_BRACKET);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3393; Match(LR_BRACKET);
				State = 3394; queryExpression();
				State = 3395; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryExpressionNointoContext : ParserRuleContext {
		public QuerySpecificationNointoContext querySpecificationNointo() {
			return GetRuleContext<QuerySpecificationNointoContext>(0);
		}
		public QueryExpressionNointoContext queryExpressionNointo() {
			return GetRuleContext<QueryExpressionNointoContext>(0);
		}
		public QueryExpressionNointoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryExpressionNointo; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterQueryExpressionNointo(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitQueryExpressionNointo(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryExpressionNointo(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryExpressionNointoContext queryExpressionNointo() {
		QueryExpressionNointoContext _localctx = new QueryExpressionNointoContext(Context, State);
		EnterRule(_localctx, 224, RULE_queryExpressionNointo);
		try {
			State = 3407;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,479,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3399; Match(LR_BRACKET);
				State = 3400; querySpecificationNointo();
				State = 3401; Match(RR_BRACKET);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3403; Match(LR_BRACKET);
				State = 3404; queryExpressionNointo();
				State = 3405; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QuerySpecificationContext : ParserRuleContext {
		public ITerminalNode SELECT() { return GetToken(MySqlParser.SELECT, 0); }
		public SelectElementsContext selectElements() {
			return GetRuleContext<SelectElementsContext>(0);
		}
		public SelectSpecContext[] selectSpec() {
			return GetRuleContexts<SelectSpecContext>();
		}
		public SelectSpecContext selectSpec(int i) {
			return GetRuleContext<SelectSpecContext>(i);
		}
		public SelectIntoExpressionContext selectIntoExpression() {
			return GetRuleContext<SelectIntoExpressionContext>(0);
		}
		public FromClauseContext fromClause() {
			return GetRuleContext<FromClauseContext>(0);
		}
		public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public LimitClauseContext limitClause() {
			return GetRuleContext<LimitClauseContext>(0);
		}
		public QuerySpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_querySpecification; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterQuerySpecification(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitQuerySpecification(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuerySpecification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QuerySpecificationContext querySpecification() {
		QuerySpecificationContext _localctx = new QuerySpecificationContext(Context, State);
		EnterRule(_localctx, 226, RULE_querySpecification);
		int _la;
		try {
			int _alt;
			State = 3449;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,490,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3409; Match(SELECT);
				State = 3413;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,480,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 3410; selectSpec();
						}
						} 
					}
					State = 3415;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,480,Context);
				}
				State = 3416; selectElements();
				State = 3418;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INTO) {
					{
					State = 3417; selectIntoExpression();
					}
				}

				State = 3421;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM) {
					{
					State = 3420; fromClause();
					}
				}

				State = 3424;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,483,Context) ) {
				case 1:
					{
					State = 3423; orderByClause();
					}
					break;
				}
				State = 3427;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,484,Context) ) {
				case 1:
					{
					State = 3426; limitClause();
					}
					break;
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3429; Match(SELECT);
				State = 3433;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,485,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 3430; selectSpec();
						}
						} 
					}
					State = 3435;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,485,Context);
				}
				State = 3436; selectElements();
				State = 3438;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM) {
					{
					State = 3437; fromClause();
					}
				}

				State = 3441;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,487,Context) ) {
				case 1:
					{
					State = 3440; orderByClause();
					}
					break;
				}
				State = 3444;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,488,Context) ) {
				case 1:
					{
					State = 3443; limitClause();
					}
					break;
				}
				State = 3447;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INTO) {
					{
					State = 3446; selectIntoExpression();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QuerySpecificationNointoContext : ParserRuleContext {
		public ITerminalNode SELECT() { return GetToken(MySqlParser.SELECT, 0); }
		public SelectElementsContext selectElements() {
			return GetRuleContext<SelectElementsContext>(0);
		}
		public SelectSpecContext[] selectSpec() {
			return GetRuleContexts<SelectSpecContext>();
		}
		public SelectSpecContext selectSpec(int i) {
			return GetRuleContext<SelectSpecContext>(i);
		}
		public FromClauseContext fromClause() {
			return GetRuleContext<FromClauseContext>(0);
		}
		public OrderByClauseContext orderByClause() {
			return GetRuleContext<OrderByClauseContext>(0);
		}
		public LimitClauseContext limitClause() {
			return GetRuleContext<LimitClauseContext>(0);
		}
		public QuerySpecificationNointoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_querySpecificationNointo; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterQuerySpecificationNointo(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitQuerySpecificationNointo(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuerySpecificationNointo(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QuerySpecificationNointoContext querySpecificationNointo() {
		QuerySpecificationNointoContext _localctx = new QuerySpecificationNointoContext(Context, State);
		EnterRule(_localctx, 228, RULE_querySpecificationNointo);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3451; Match(SELECT);
			State = 3455;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,491,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 3452; selectSpec();
					}
					} 
				}
				State = 3457;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,491,Context);
			}
			State = 3458; selectElements();
			State = 3460;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FROM) {
				{
				State = 3459; fromClause();
				}
			}

			State = 3463;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,493,Context) ) {
			case 1:
				{
				State = 3462; orderByClause();
				}
				break;
			}
			State = 3466;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,494,Context) ) {
			case 1:
				{
				State = 3465; limitClause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnionParenthesisContext : ParserRuleContext {
		public IToken unionType;
		public ITerminalNode UNION() { return GetToken(MySqlParser.UNION, 0); }
		public QueryExpressionNointoContext queryExpressionNointo() {
			return GetRuleContext<QueryExpressionNointoContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(MySqlParser.DISTINCT, 0); }
		public UnionParenthesisContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unionParenthesis; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnionParenthesis(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnionParenthesis(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnionParenthesis(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnionParenthesisContext unionParenthesis() {
		UnionParenthesisContext _localctx = new UnionParenthesisContext(Context, State);
		EnterRule(_localctx, 230, RULE_unionParenthesis);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3468; Match(UNION);
			State = 3470;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==DISTINCT) {
				{
				State = 3469;
				_localctx.unionType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==DISTINCT) ) {
					_localctx.unionType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3472; queryExpressionNointo();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnionStatementContext : ParserRuleContext {
		public IToken unionType;
		public ITerminalNode UNION() { return GetToken(MySqlParser.UNION, 0); }
		public QuerySpecificationNointoContext querySpecificationNointo() {
			return GetRuleContext<QuerySpecificationNointoContext>(0);
		}
		public QueryExpressionNointoContext queryExpressionNointo() {
			return GetRuleContext<QueryExpressionNointoContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(MySqlParser.DISTINCT, 0); }
		public UnionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unionStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnionStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnionStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnionStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnionStatementContext unionStatement() {
		UnionStatementContext _localctx = new UnionStatementContext(Context, State);
		EnterRule(_localctx, 232, RULE_unionStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3474; Match(UNION);
			State = 3476;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==DISTINCT) {
				{
				State = 3475;
				_localctx.unionType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==DISTINCT) ) {
					_localctx.unionType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3480;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
				{
				State = 3478; querySpecificationNointo();
				}
				break;
			case LR_BRACKET:
				{
				State = 3479; queryExpressionNointo();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectSpecContext : ParserRuleContext {
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(MySqlParser.DISTINCT, 0); }
		public ITerminalNode DISTINCTROW() { return GetToken(MySqlParser.DISTINCTROW, 0); }
		public ITerminalNode HIGH_PRIORITY() { return GetToken(MySqlParser.HIGH_PRIORITY, 0); }
		public ITerminalNode STRAIGHT_JOIN() { return GetToken(MySqlParser.STRAIGHT_JOIN, 0); }
		public ITerminalNode SQL_SMALL_RESULT() { return GetToken(MySqlParser.SQL_SMALL_RESULT, 0); }
		public ITerminalNode SQL_BIG_RESULT() { return GetToken(MySqlParser.SQL_BIG_RESULT, 0); }
		public ITerminalNode SQL_BUFFER_RESULT() { return GetToken(MySqlParser.SQL_BUFFER_RESULT, 0); }
		public ITerminalNode SQL_CACHE() { return GetToken(MySqlParser.SQL_CACHE, 0); }
		public ITerminalNode SQL_NO_CACHE() { return GetToken(MySqlParser.SQL_NO_CACHE, 0); }
		public ITerminalNode SQL_CALC_FOUND_ROWS() { return GetToken(MySqlParser.SQL_CALC_FOUND_ROWS, 0); }
		public SelectSpecContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectSpec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectSpec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectSpec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectSpec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectSpecContext selectSpec() {
		SelectSpecContext _localctx = new SelectSpecContext(Context, State);
		EnterRule(_localctx, 234, RULE_selectSpec);
		int _la;
		try {
			State = 3490;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALL:
			case DISTINCT:
			case DISTINCTROW:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3482;
				_la = TokenStream.LA(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ALL) | (1L << DISTINCT) | (1L << DISTINCTROW))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case HIGH_PRIORITY:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3483; Match(HIGH_PRIORITY);
				}
				break;
			case STRAIGHT_JOIN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3484; Match(STRAIGHT_JOIN);
				}
				break;
			case SQL_SMALL_RESULT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3485; Match(SQL_SMALL_RESULT);
				}
				break;
			case SQL_BIG_RESULT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3486; Match(SQL_BIG_RESULT);
				}
				break;
			case SQL_BUFFER_RESULT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 3487; Match(SQL_BUFFER_RESULT);
				}
				break;
			case SQL_CACHE:
			case SQL_NO_CACHE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 3488;
				_la = TokenStream.LA(1);
				if ( !(_la==SQL_CACHE || _la==SQL_NO_CACHE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case SQL_CALC_FOUND_ROWS:
				EnterOuterAlt(_localctx, 8);
				{
				State = 3489; Match(SQL_CALC_FOUND_ROWS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectElementsContext : ParserRuleContext {
		public IToken star;
		public SelectElementContext[] selectElement() {
			return GetRuleContexts<SelectElementContext>();
		}
		public SelectElementContext selectElement(int i) {
			return GetRuleContext<SelectElementContext>(i);
		}
		public SelectElementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectElements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectElements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectElements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectElements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectElementsContext selectElements() {
		SelectElementsContext _localctx = new SelectElementsContext(Context, State);
		EnterRule(_localctx, 236, RULE_selectElements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3494;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STAR:
				{
				State = 3492; _localctx.star = Match(STAR);
				}
				break;
			case CASE:
			case CAST:
			case CONVERT:
			case CURRENT_USER:
			case DATABASE:
			case EXISTS:
			case FALSE:
			case IF:
			case INSERT:
			case INTERVAL:
			case LEFT:
			case NOT:
			case NULL_LITERAL:
			case REPLACE:
			case RIGHT:
			case TRUE:
			case VALUES:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case CHAR:
			case BINARY:
			case TEXT:
			case ENUM:
			case SERIAL:
			case AVG:
			case BIT_AND:
			case BIT_OR:
			case BIT_XOR:
			case COUNT:
			case GROUP_CONCAT:
			case MAX:
			case MIN:
			case STD:
			case STDDEV:
			case STDDEV_POP:
			case STDDEV_SAMP:
			case SUM:
			case VAR_POP:
			case VAR_SAMP:
			case VARIANCE:
			case CURRENT_DATE:
			case CURRENT_TIME:
			case CURRENT_TIMESTAMP:
			case LOCALTIME:
			case CURDATE:
			case CURTIME:
			case DATE_ADD:
			case DATE_SUB:
			case EXTRACT:
			case LOCALTIMESTAMP:
			case NOW:
			case POSITION:
			case SUBSTR:
			case SUBSTRING:
			case SYSDATE:
			case TRIM:
			case UTC_DATE:
			case UTC_TIME:
			case UTC_TIMESTAMP:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLASS_ORIGIN:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COLUMN_NAME:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONSTRAINT_CATALOG:
			case CONSTRAINT_SCHEMA:
			case CONSTRAINT_NAME:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVISIBLE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MESSAGE_TEXT:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case MYSQL_ERRNO:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBCLASS_ORIGIN:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLE_NAME:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case VISIBLE:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case SESSION_VARIABLES_ADMIN:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CATALOG_NAME:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SCHEMA_NAME:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case PLUS:
			case MINUS:
			case EXCLAMATION_SYMBOL:
			case BIT_NOT_OP:
			case LR_BRACKET:
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case CHARSET_REVERSE_QOUTE_STRING:
			case START_NATIONAL_STRING_LITERAL:
			case STRING_LITERAL:
			case DECIMAL_LITERAL:
			case HEXADECIMAL_LITERAL:
			case REAL_LITERAL:
			case NULL_SPEC_LITERAL:
			case BIT_STRING:
			case STRING_CHARSET_NAME:
			case ID:
			case REVERSE_QUOTE_ID:
			case LOCAL_ID:
			case GLOBAL_ID:
				{
				State = 3493; selectElement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3500;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3496; Match(COMMA);
				State = 3497; selectElement();
				}
				}
				State = 3502;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectElementContext : ParserRuleContext {
		public SelectElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectElement; } }
	 
		public SelectElementContext() { }
		public virtual void CopyFrom(SelectElementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SelectExpressionElementContext : SelectElementContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LOCAL_ID() { return GetToken(MySqlParser.LOCAL_ID, 0); }
		public ITerminalNode VAR_ASSIGN() { return GetToken(MySqlParser.VAR_ASSIGN, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SelectExpressionElementContext(SelectElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectExpressionElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectExpressionElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectExpressionElement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SelectFunctionElementContext : SelectElementContext {
		public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SelectFunctionElementContext(SelectElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectFunctionElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectFunctionElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectFunctionElement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SelectStarElementContext : SelectElementContext {
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public SelectStarElementContext(SelectElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectStarElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectStarElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectStarElement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SelectColumnElementContext : SelectElementContext {
		public FullColumnNameContext fullColumnName() {
			return GetRuleContext<FullColumnNameContext>(0);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public SelectColumnElementContext(SelectElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectColumnElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectColumnElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectColumnElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectElementContext selectElement() {
		SelectElementContext _localctx = new SelectElementContext(Context, State);
		EnterRule(_localctx, 238, RULE_selectElement);
		int _la;
		try {
			State = 3532;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,508,Context) ) {
			case 1:
				_localctx = new SelectStarElementContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3503; fullId();
				State = 3504; Match(DOT);
				State = 3505; Match(STAR);
				}
				break;
			case 2:
				_localctx = new SelectColumnElementContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3507; fullColumnName();
				State = 3512;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,502,Context) ) {
				case 1:
					{
					State = 3509;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AS) {
						{
						State = 3508; Match(AS);
						}
					}

					State = 3511; uid();
					}
					break;
				}
				}
				break;
			case 3:
				_localctx = new SelectFunctionElementContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3514; functionCall();
				State = 3519;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,504,Context) ) {
				case 1:
					{
					State = 3516;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AS) {
						{
						State = 3515; Match(AS);
						}
					}

					State = 3518; uid();
					}
					break;
				}
				}
				break;
			case 4:
				_localctx = new SelectExpressionElementContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 3523;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,505,Context) ) {
				case 1:
					{
					State = 3521; Match(LOCAL_ID);
					State = 3522; Match(VAR_ASSIGN);
					}
					break;
				}
				State = 3525; expression(0);
				State = 3530;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,507,Context) ) {
				case 1:
					{
					State = 3527;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AS) {
						{
						State = 3526; Match(AS);
						}
					}

					State = 3529; uid();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectIntoExpressionContext : ParserRuleContext {
		public SelectIntoExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectIntoExpression; } }
	 
		public SelectIntoExpressionContext() { }
		public virtual void CopyFrom(SelectIntoExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SelectIntoVariablesContext : SelectIntoExpressionContext {
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public AssignmentFieldContext[] assignmentField() {
			return GetRuleContexts<AssignmentFieldContext>();
		}
		public AssignmentFieldContext assignmentField(int i) {
			return GetRuleContext<AssignmentFieldContext>(i);
		}
		public SelectIntoVariablesContext(SelectIntoExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectIntoVariables(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectIntoVariables(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectIntoVariables(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SelectIntoTextFileContext : SelectIntoExpressionContext {
		public IToken filename;
		public CharsetNameContext charset;
		public IToken fieldsFormat;
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode OUTFILE() { return GetToken(MySqlParser.OUTFILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode LINES() { return GetToken(MySqlParser.LINES, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode FIELDS() { return GetToken(MySqlParser.FIELDS, 0); }
		public ITerminalNode COLUMNS() { return GetToken(MySqlParser.COLUMNS, 0); }
		public SelectFieldsIntoContext[] selectFieldsInto() {
			return GetRuleContexts<SelectFieldsIntoContext>();
		}
		public SelectFieldsIntoContext selectFieldsInto(int i) {
			return GetRuleContext<SelectFieldsIntoContext>(i);
		}
		public SelectLinesIntoContext[] selectLinesInto() {
			return GetRuleContexts<SelectLinesIntoContext>();
		}
		public SelectLinesIntoContext selectLinesInto(int i) {
			return GetRuleContext<SelectLinesIntoContext>(i);
		}
		public SelectIntoTextFileContext(SelectIntoExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectIntoTextFile(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectIntoTextFile(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectIntoTextFile(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SelectIntoDumpFileContext : SelectIntoExpressionContext {
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode DUMPFILE() { return GetToken(MySqlParser.DUMPFILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public SelectIntoDumpFileContext(SelectIntoExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectIntoDumpFile(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectIntoDumpFile(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectIntoDumpFile(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectIntoExpressionContext selectIntoExpression() {
		SelectIntoExpressionContext _localctx = new SelectIntoExpressionContext(Context, State);
		EnterRule(_localctx, 240, RULE_selectIntoExpression);
		int _la;
		try {
			State = 3570;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,515,Context) ) {
			case 1:
				_localctx = new SelectIntoVariablesContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3534; Match(INTO);
				State = 3535; assignmentField();
				State = 3540;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3536; Match(COMMA);
					State = 3537; assignmentField();
					}
					}
					State = 3542;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new SelectIntoDumpFileContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3543; Match(INTO);
				State = 3544; Match(DUMPFILE);
				State = 3545; Match(STRING_LITERAL);
				}
				break;
			case 3:
				_localctx = new SelectIntoTextFileContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				{
				State = 3546; Match(INTO);
				State = 3547; Match(OUTFILE);
				State = 3548; ((SelectIntoTextFileContext)_localctx).filename = Match(STRING_LITERAL);
				State = 3552;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CHARACTER) {
					{
					State = 3549; Match(CHARACTER);
					State = 3550; Match(SET);
					State = 3551; ((SelectIntoTextFileContext)_localctx).charset = charsetName();
					}
				}

				State = 3560;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,512,Context) ) {
				case 1:
					{
					State = 3554;
					((SelectIntoTextFileContext)_localctx).fieldsFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==COLUMNS || _la==FIELDS) ) {
						((SelectIntoTextFileContext)_localctx).fieldsFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 3556;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 3555; selectFieldsInto();
						}
						}
						State = 3558;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( _la==ENCLOSED || _la==ESCAPED || _la==OPTIONALLY || _la==TERMINATED );
					}
					break;
				}
				State = 3568;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LINES) {
					{
					State = 3562; Match(LINES);
					State = 3564;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 3563; selectLinesInto();
						}
						}
						State = 3566;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( _la==STARTING || _la==TERMINATED );
					}
				}

				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectFieldsIntoContext : ParserRuleContext {
		public IToken terminationField;
		public IToken enclosion;
		public IToken escaping;
		public ITerminalNode TERMINATED() { return GetToken(MySqlParser.TERMINATED, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode ENCLOSED() { return GetToken(MySqlParser.ENCLOSED, 0); }
		public ITerminalNode OPTIONALLY() { return GetToken(MySqlParser.OPTIONALLY, 0); }
		public ITerminalNode ESCAPED() { return GetToken(MySqlParser.ESCAPED, 0); }
		public SelectFieldsIntoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectFieldsInto; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectFieldsInto(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectFieldsInto(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectFieldsInto(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectFieldsIntoContext selectFieldsInto() {
		SelectFieldsIntoContext _localctx = new SelectFieldsIntoContext(Context, State);
		EnterRule(_localctx, 242, RULE_selectFieldsInto);
		int _la;
		try {
			State = 3584;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TERMINATED:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3572; Match(TERMINATED);
				State = 3573; Match(BY);
				State = 3574; _localctx.terminationField = Match(STRING_LITERAL);
				}
				break;
			case ENCLOSED:
			case OPTIONALLY:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3576;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==OPTIONALLY) {
					{
					State = 3575; Match(OPTIONALLY);
					}
				}

				State = 3578; Match(ENCLOSED);
				State = 3579; Match(BY);
				State = 3580; _localctx.enclosion = Match(STRING_LITERAL);
				}
				break;
			case ESCAPED:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3581; Match(ESCAPED);
				State = 3582; Match(BY);
				State = 3583; _localctx.escaping = Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectLinesIntoContext : ParserRuleContext {
		public IToken starting;
		public IToken terminationLine;
		public ITerminalNode STARTING() { return GetToken(MySqlParser.STARTING, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode TERMINATED() { return GetToken(MySqlParser.TERMINATED, 0); }
		public SelectLinesIntoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectLinesInto; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSelectLinesInto(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSelectLinesInto(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectLinesInto(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectLinesIntoContext selectLinesInto() {
		SelectLinesIntoContext _localctx = new SelectLinesIntoContext(Context, State);
		EnterRule(_localctx, 244, RULE_selectLinesInto);
		try {
			State = 3592;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STARTING:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3586; Match(STARTING);
				State = 3587; Match(BY);
				State = 3588; _localctx.starting = Match(STRING_LITERAL);
				}
				break;
			case TERMINATED:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3589; Match(TERMINATED);
				State = 3590; Match(BY);
				State = 3591; _localctx.terminationLine = Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FromClauseContext : ParserRuleContext {
		public ExpressionContext whereExpr;
		public ExpressionContext havingExpr;
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public TableSourcesContext tableSources() {
			return GetRuleContext<TableSourcesContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ITerminalNode GROUP() { return GetToken(MySqlParser.GROUP, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public GroupByItemContext[] groupByItem() {
			return GetRuleContexts<GroupByItemContext>();
		}
		public GroupByItemContext groupByItem(int i) {
			return GetRuleContext<GroupByItemContext>(i);
		}
		public ITerminalNode HAVING() { return GetToken(MySqlParser.HAVING, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode ROLLUP() { return GetToken(MySqlParser.ROLLUP, 0); }
		public FromClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fromClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFromClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFromClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFromClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FromClauseContext fromClause() {
		FromClauseContext _localctx = new FromClauseContext(Context, State);
		EnterRule(_localctx, 246, RULE_fromClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3594; Match(FROM);
			State = 3595; tableSources();
			State = 3598;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 3596; Match(WHERE);
				State = 3597; _localctx.whereExpr = expression(0);
				}
			}

			State = 3614;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GROUP) {
				{
				State = 3600; Match(GROUP);
				State = 3601; Match(BY);
				State = 3602; groupByItem();
				State = 3607;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3603; Match(COMMA);
					State = 3604; groupByItem();
					}
					}
					State = 3609;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3612;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,521,Context) ) {
				case 1:
					{
					State = 3610; Match(WITH);
					State = 3611; Match(ROLLUP);
					}
					break;
				}
				}
			}

			State = 3618;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==HAVING) {
				{
				State = 3616; Match(HAVING);
				State = 3617; _localctx.havingExpr = expression(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByItemContext : ParserRuleContext {
		public IToken order;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASC() { return GetToken(MySqlParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(MySqlParser.DESC, 0); }
		public GroupByItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGroupByItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGroupByItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupByItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupByItemContext groupByItem() {
		GroupByItemContext _localctx = new GroupByItemContext(Context, State);
		EnterRule(_localctx, 248, RULE_groupByItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3620; expression(0);
			State = 3622;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,524,Context) ) {
			case 1:
				{
				State = 3621;
				_localctx.order = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ASC || _la==DESC) ) {
					_localctx.order = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LimitClauseContext : ParserRuleContext {
		public LimitClauseAtomContext offset;
		public LimitClauseAtomContext limit;
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public ITerminalNode OFFSET() { return GetToken(MySqlParser.OFFSET, 0); }
		public LimitClauseAtomContext[] limitClauseAtom() {
			return GetRuleContexts<LimitClauseAtomContext>();
		}
		public LimitClauseAtomContext limitClauseAtom(int i) {
			return GetRuleContext<LimitClauseAtomContext>(i);
		}
		public LimitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_limitClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLimitClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLimitClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLimitClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LimitClauseContext limitClause() {
		LimitClauseContext _localctx = new LimitClauseContext(Context, State);
		EnterRule(_localctx, 250, RULE_limitClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3624; Match(LIMIT);
			State = 3635;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,526,Context) ) {
			case 1:
				{
				State = 3628;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,525,Context) ) {
				case 1:
					{
					State = 3625; _localctx.offset = limitClauseAtom();
					State = 3626; Match(COMMA);
					}
					break;
				}
				State = 3630; _localctx.limit = limitClauseAtom();
				}
				break;
			case 2:
				{
				State = 3631; _localctx.limit = limitClauseAtom();
				State = 3632; Match(OFFSET);
				State = 3633; _localctx.offset = limitClauseAtom();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LimitClauseAtomContext : ParserRuleContext {
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public MysqlVariableContext mysqlVariable() {
			return GetRuleContext<MysqlVariableContext>(0);
		}
		public LimitClauseAtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_limitClauseAtom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLimitClauseAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLimitClauseAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLimitClauseAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LimitClauseAtomContext limitClauseAtom() {
		LimitClauseAtomContext _localctx = new LimitClauseAtomContext(Context, State);
		EnterRule(_localctx, 252, RULE_limitClauseAtom);
		try {
			State = 3639;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case DECIMAL_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3637; decimalLiteral();
				}
				break;
			case LOCAL_ID:
			case GLOBAL_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3638; mysqlVariable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartTransactionContext : ParserRuleContext {
		public ITerminalNode START() { return GetToken(MySqlParser.START, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(MySqlParser.TRANSACTION, 0); }
		public TransactionModeContext[] transactionMode() {
			return GetRuleContexts<TransactionModeContext>();
		}
		public TransactionModeContext transactionMode(int i) {
			return GetRuleContext<TransactionModeContext>(i);
		}
		public StartTransactionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startTransaction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStartTransaction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStartTransaction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartTransaction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartTransactionContext startTransaction() {
		StartTransactionContext _localctx = new StartTransactionContext(Context, State);
		EnterRule(_localctx, 254, RULE_startTransaction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3641; Match(START);
			State = 3642; Match(TRANSACTION);
			State = 3651;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==READ || _la==WITH) {
				{
				State = 3643; transactionMode();
				State = 3648;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3644; Match(COMMA);
					State = 3645; transactionMode();
					}
					}
					State = 3650;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BeginWorkContext : ParserRuleContext {
		public ITerminalNode BEGIN() { return GetToken(MySqlParser.BEGIN, 0); }
		public ITerminalNode WORK() { return GetToken(MySqlParser.WORK, 0); }
		public BeginWorkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_beginWork; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBeginWork(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBeginWork(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBeginWork(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BeginWorkContext beginWork() {
		BeginWorkContext _localctx = new BeginWorkContext(Context, State);
		EnterRule(_localctx, 256, RULE_beginWork);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3653; Match(BEGIN);
			State = 3655;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WORK) {
				{
				State = 3654; Match(WORK);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommitWorkContext : ParserRuleContext {
		public IToken nochain;
		public IToken norelease;
		public ITerminalNode COMMIT() { return GetToken(MySqlParser.COMMIT, 0); }
		public ITerminalNode WORK() { return GetToken(MySqlParser.WORK, 0); }
		public ITerminalNode AND() { return GetToken(MySqlParser.AND, 0); }
		public ITerminalNode CHAIN() { return GetToken(MySqlParser.CHAIN, 0); }
		public ITerminalNode RELEASE() { return GetToken(MySqlParser.RELEASE, 0); }
		public ITerminalNode[] NO() { return GetTokens(MySqlParser.NO); }
		public ITerminalNode NO(int i) {
			return GetToken(MySqlParser.NO, i);
		}
		public CommitWorkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commitWork; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCommitWork(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCommitWork(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommitWork(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommitWorkContext commitWork() {
		CommitWorkContext _localctx = new CommitWorkContext(Context, State);
		EnterRule(_localctx, 258, RULE_commitWork);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3657; Match(COMMIT);
			State = 3659;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WORK) {
				{
				State = 3658; Match(WORK);
				}
			}

			State = 3666;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AND) {
				{
				State = 3661; Match(AND);
				State = 3663;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO) {
					{
					State = 3662; _localctx.nochain = Match(NO);
					}
				}

				State = 3665; Match(CHAIN);
				}
			}

			State = 3672;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,535,Context) ) {
			case 1:
				{
				State = 3669;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO) {
					{
					State = 3668; _localctx.norelease = Match(NO);
					}
				}

				State = 3671; Match(RELEASE);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RollbackWorkContext : ParserRuleContext {
		public IToken nochain;
		public IToken norelease;
		public ITerminalNode ROLLBACK() { return GetToken(MySqlParser.ROLLBACK, 0); }
		public ITerminalNode WORK() { return GetToken(MySqlParser.WORK, 0); }
		public ITerminalNode AND() { return GetToken(MySqlParser.AND, 0); }
		public ITerminalNode CHAIN() { return GetToken(MySqlParser.CHAIN, 0); }
		public ITerminalNode RELEASE() { return GetToken(MySqlParser.RELEASE, 0); }
		public ITerminalNode[] NO() { return GetTokens(MySqlParser.NO); }
		public ITerminalNode NO(int i) {
			return GetToken(MySqlParser.NO, i);
		}
		public RollbackWorkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollbackWork; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRollbackWork(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRollbackWork(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRollbackWork(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RollbackWorkContext rollbackWork() {
		RollbackWorkContext _localctx = new RollbackWorkContext(Context, State);
		EnterRule(_localctx, 260, RULE_rollbackWork);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3674; Match(ROLLBACK);
			State = 3676;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WORK) {
				{
				State = 3675; Match(WORK);
				}
			}

			State = 3683;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AND) {
				{
				State = 3678; Match(AND);
				State = 3680;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO) {
					{
					State = 3679; _localctx.nochain = Match(NO);
					}
				}

				State = 3682; Match(CHAIN);
				}
			}

			State = 3689;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,540,Context) ) {
			case 1:
				{
				State = 3686;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO) {
					{
					State = 3685; _localctx.norelease = Match(NO);
					}
				}

				State = 3688; Match(RELEASE);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SavepointStatementContext : ParserRuleContext {
		public ITerminalNode SAVEPOINT() { return GetToken(MySqlParser.SAVEPOINT, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public SavepointStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_savepointStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSavepointStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSavepointStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSavepointStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SavepointStatementContext savepointStatement() {
		SavepointStatementContext _localctx = new SavepointStatementContext(Context, State);
		EnterRule(_localctx, 262, RULE_savepointStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3691; Match(SAVEPOINT);
			State = 3692; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RollbackStatementContext : ParserRuleContext {
		public ITerminalNode ROLLBACK() { return GetToken(MySqlParser.ROLLBACK, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode WORK() { return GetToken(MySqlParser.WORK, 0); }
		public ITerminalNode SAVEPOINT() { return GetToken(MySqlParser.SAVEPOINT, 0); }
		public RollbackStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollbackStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRollbackStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRollbackStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRollbackStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RollbackStatementContext rollbackStatement() {
		RollbackStatementContext _localctx = new RollbackStatementContext(Context, State);
		EnterRule(_localctx, 264, RULE_rollbackStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3694; Match(ROLLBACK);
			State = 3696;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WORK) {
				{
				State = 3695; Match(WORK);
				}
			}

			State = 3698; Match(TO);
			State = 3700;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,542,Context) ) {
			case 1:
				{
				State = 3699; Match(SAVEPOINT);
				}
				break;
			}
			State = 3702; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReleaseStatementContext : ParserRuleContext {
		public ITerminalNode RELEASE() { return GetToken(MySqlParser.RELEASE, 0); }
		public ITerminalNode SAVEPOINT() { return GetToken(MySqlParser.SAVEPOINT, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ReleaseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_releaseStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReleaseStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReleaseStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReleaseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReleaseStatementContext releaseStatement() {
		ReleaseStatementContext _localctx = new ReleaseStatementContext(Context, State);
		EnterRule(_localctx, 266, RULE_releaseStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3704; Match(RELEASE);
			State = 3705; Match(SAVEPOINT);
			State = 3706; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockTablesContext : ParserRuleContext {
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public LockTableElementContext[] lockTableElement() {
			return GetRuleContexts<LockTableElementContext>();
		}
		public LockTableElementContext lockTableElement(int i) {
			return GetRuleContext<LockTableElementContext>(i);
		}
		public LockTablesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockTables; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLockTables(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLockTables(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLockTables(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LockTablesContext lockTables() {
		LockTablesContext _localctx = new LockTablesContext(Context, State);
		EnterRule(_localctx, 268, RULE_lockTables);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3708; Match(LOCK);
			State = 3709; Match(TABLES);
			State = 3710; lockTableElement();
			State = 3715;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3711; Match(COMMA);
				State = 3712; lockTableElement();
				}
				}
				State = 3717;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnlockTablesContext : ParserRuleContext {
		public ITerminalNode UNLOCK() { return GetToken(MySqlParser.UNLOCK, 0); }
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public UnlockTablesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unlockTables; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnlockTables(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnlockTables(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnlockTables(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnlockTablesContext unlockTables() {
		UnlockTablesContext _localctx = new UnlockTablesContext(Context, State);
		EnterRule(_localctx, 270, RULE_unlockTables);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3718; Match(UNLOCK);
			State = 3719; Match(TABLES);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetAutocommitStatementContext : ParserRuleContext {
		public IToken autocommitValue;
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode AUTOCOMMIT() { return GetToken(MySqlParser.AUTOCOMMIT, 0); }
		public SetAutocommitStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setAutocommitStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetAutocommitStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetAutocommitStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetAutocommitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SetAutocommitStatementContext setAutocommitStatement() {
		SetAutocommitStatementContext _localctx = new SetAutocommitStatementContext(Context, State);
		EnterRule(_localctx, 272, RULE_setAutocommitStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3721; Match(SET);
			State = 3722; Match(AUTOCOMMIT);
			State = 3723; Match(EQUAL_SYMBOL);
			State = 3724;
			_localctx.autocommitValue = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
				_localctx.autocommitValue = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetTransactionStatementContext : ParserRuleContext {
		public IToken transactionContext;
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(MySqlParser.TRANSACTION, 0); }
		public TransactionOptionContext[] transactionOption() {
			return GetRuleContexts<TransactionOptionContext>();
		}
		public TransactionOptionContext transactionOption(int i) {
			return GetRuleContext<TransactionOptionContext>(i);
		}
		public ITerminalNode GLOBAL() { return GetToken(MySqlParser.GLOBAL, 0); }
		public ITerminalNode SESSION() { return GetToken(MySqlParser.SESSION, 0); }
		public SetTransactionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setTransactionStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetTransactionStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetTransactionStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetTransactionStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SetTransactionStatementContext setTransactionStatement() {
		SetTransactionStatementContext _localctx = new SetTransactionStatementContext(Context, State);
		EnterRule(_localctx, 274, RULE_setTransactionStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3726; Match(SET);
			State = 3728;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GLOBAL || _la==SESSION) {
				{
				State = 3727;
				_localctx.transactionContext = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==GLOBAL || _la==SESSION) ) {
					_localctx.transactionContext = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3730; Match(TRANSACTION);
			State = 3731; transactionOption();
			State = 3736;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3732; Match(COMMA);
				State = 3733; transactionOption();
				}
				}
				State = 3738;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TransactionModeContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode CONSISTENT() { return GetToken(MySqlParser.CONSISTENT, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(MySqlParser.SNAPSHOT, 0); }
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode WRITE() { return GetToken(MySqlParser.WRITE, 0); }
		public ITerminalNode ONLY() { return GetToken(MySqlParser.ONLY, 0); }
		public TransactionModeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transactionMode; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTransactionMode(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTransactionMode(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTransactionMode(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TransactionModeContext transactionMode() {
		TransactionModeContext _localctx = new TransactionModeContext(Context, State);
		EnterRule(_localctx, 276, RULE_transactionMode);
		try {
			State = 3746;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,546,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3739; Match(WITH);
				State = 3740; Match(CONSISTENT);
				State = 3741; Match(SNAPSHOT);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3742; Match(READ);
				State = 3743; Match(WRITE);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3744; Match(READ);
				State = 3745; Match(ONLY);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockTableElementContext : ParserRuleContext {
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public LockActionContext lockAction() {
			return GetRuleContext<LockActionContext>(0);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public LockTableElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockTableElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLockTableElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLockTableElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLockTableElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LockTableElementContext lockTableElement() {
		LockTableElementContext _localctx = new LockTableElementContext(Context, State);
		EnterRule(_localctx, 278, RULE_lockTableElement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3748; tableName();
			State = 3753;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
				{
				State = 3750;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 3749; Match(AS);
					}
				}

				State = 3752; uid();
				}
			}

			State = 3755; lockAction();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LockActionContext : ParserRuleContext {
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public ITerminalNode WRITE() { return GetToken(MySqlParser.WRITE, 0); }
		public ITerminalNode LOW_PRIORITY() { return GetToken(MySqlParser.LOW_PRIORITY, 0); }
		public LockActionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lockAction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLockAction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLockAction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLockAction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LockActionContext lockAction() {
		LockActionContext _localctx = new LockActionContext(Context, State);
		EnterRule(_localctx, 280, RULE_lockAction);
		int _la;
		try {
			State = 3765;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case READ:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3757; Match(READ);
				State = 3759;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOCAL) {
					{
					State = 3758; Match(LOCAL);
					}
				}

				}
				break;
			case LOW_PRIORITY:
			case WRITE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3762;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LOW_PRIORITY) {
					{
					State = 3761; Match(LOW_PRIORITY);
					}
				}

				State = 3764; Match(WRITE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TransactionOptionContext : ParserRuleContext {
		public ITerminalNode ISOLATION() { return GetToken(MySqlParser.ISOLATION, 0); }
		public ITerminalNode LEVEL() { return GetToken(MySqlParser.LEVEL, 0); }
		public TransactionLevelContext transactionLevel() {
			return GetRuleContext<TransactionLevelContext>(0);
		}
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode WRITE() { return GetToken(MySqlParser.WRITE, 0); }
		public ITerminalNode ONLY() { return GetToken(MySqlParser.ONLY, 0); }
		public TransactionOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transactionOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTransactionOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTransactionOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTransactionOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TransactionOptionContext transactionOption() {
		TransactionOptionContext _localctx = new TransactionOptionContext(Context, State);
		EnterRule(_localctx, 282, RULE_transactionOption);
		try {
			State = 3774;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,552,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3767; Match(ISOLATION);
				State = 3768; Match(LEVEL);
				State = 3769; transactionLevel();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3770; Match(READ);
				State = 3771; Match(WRITE);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3772; Match(READ);
				State = 3773; Match(ONLY);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TransactionLevelContext : ParserRuleContext {
		public ITerminalNode REPEATABLE() { return GetToken(MySqlParser.REPEATABLE, 0); }
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode COMMITTED() { return GetToken(MySqlParser.COMMITTED, 0); }
		public ITerminalNode UNCOMMITTED() { return GetToken(MySqlParser.UNCOMMITTED, 0); }
		public ITerminalNode SERIALIZABLE() { return GetToken(MySqlParser.SERIALIZABLE, 0); }
		public TransactionLevelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transactionLevel; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTransactionLevel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTransactionLevel(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTransactionLevel(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TransactionLevelContext transactionLevel() {
		TransactionLevelContext _localctx = new TransactionLevelContext(Context, State);
		EnterRule(_localctx, 284, RULE_transactionLevel);
		try {
			State = 3783;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,553,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3776; Match(REPEATABLE);
				State = 3777; Match(READ);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3778; Match(READ);
				State = 3779; Match(COMMITTED);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3780; Match(READ);
				State = 3781; Match(UNCOMMITTED);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3782; Match(SERIALIZABLE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ChangeMasterContext : ParserRuleContext {
		public ITerminalNode CHANGE() { return GetToken(MySqlParser.CHANGE, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public MasterOptionContext[] masterOption() {
			return GetRuleContexts<MasterOptionContext>();
		}
		public MasterOptionContext masterOption(int i) {
			return GetRuleContext<MasterOptionContext>(i);
		}
		public ChannelOptionContext channelOption() {
			return GetRuleContext<ChannelOptionContext>(0);
		}
		public ChangeMasterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_changeMaster; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterChangeMaster(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitChangeMaster(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChangeMaster(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ChangeMasterContext changeMaster() {
		ChangeMasterContext _localctx = new ChangeMasterContext(Context, State);
		EnterRule(_localctx, 286, RULE_changeMaster);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3785; Match(CHANGE);
			State = 3786; Match(MASTER);
			State = 3787; Match(TO);
			State = 3788; masterOption();
			State = 3793;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3789; Match(COMMA);
				State = 3790; masterOption();
				}
				}
				State = 3795;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3797;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 3796; channelOption();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ChangeReplicationFilterContext : ParserRuleContext {
		public ITerminalNode CHANGE() { return GetToken(MySqlParser.CHANGE, 0); }
		public ITerminalNode REPLICATION() { return GetToken(MySqlParser.REPLICATION, 0); }
		public ITerminalNode FILTER() { return GetToken(MySqlParser.FILTER, 0); }
		public ReplicationFilterContext[] replicationFilter() {
			return GetRuleContexts<ReplicationFilterContext>();
		}
		public ReplicationFilterContext replicationFilter(int i) {
			return GetRuleContext<ReplicationFilterContext>(i);
		}
		public ChangeReplicationFilterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_changeReplicationFilter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterChangeReplicationFilter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitChangeReplicationFilter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChangeReplicationFilter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ChangeReplicationFilterContext changeReplicationFilter() {
		ChangeReplicationFilterContext _localctx = new ChangeReplicationFilterContext(Context, State);
		EnterRule(_localctx, 288, RULE_changeReplicationFilter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3799; Match(CHANGE);
			State = 3800; Match(REPLICATION);
			State = 3801; Match(FILTER);
			State = 3802; replicationFilter();
			State = 3807;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3803; Match(COMMA);
				State = 3804; replicationFilter();
				}
				}
				State = 3809;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PurgeBinaryLogsContext : ParserRuleContext {
		public IToken purgeFormat;
		public IToken fileName;
		public IToken timeValue;
		public ITerminalNode PURGE() { return GetToken(MySqlParser.PURGE, 0); }
		public ITerminalNode LOGS() { return GetToken(MySqlParser.LOGS, 0); }
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public ITerminalNode BEFORE() { return GetToken(MySqlParser.BEFORE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PurgeBinaryLogsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_purgeBinaryLogs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPurgeBinaryLogs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPurgeBinaryLogs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPurgeBinaryLogs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PurgeBinaryLogsContext purgeBinaryLogs() {
		PurgeBinaryLogsContext _localctx = new PurgeBinaryLogsContext(Context, State);
		EnterRule(_localctx, 290, RULE_purgeBinaryLogs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3810; Match(PURGE);
			State = 3811;
			_localctx.purgeFormat = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==BINARY || _la==MASTER) ) {
				_localctx.purgeFormat = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3812; Match(LOGS);
			State = 3817;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TO:
				{
				State = 3813; Match(TO);
				State = 3814; _localctx.fileName = Match(STRING_LITERAL);
				}
				break;
			case BEFORE:
				{
				State = 3815; Match(BEFORE);
				State = 3816; _localctx.timeValue = Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResetMasterContext : ParserRuleContext {
		public ITerminalNode RESET() { return GetToken(MySqlParser.RESET, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ResetMasterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_resetMaster; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterResetMaster(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitResetMaster(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitResetMaster(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ResetMasterContext resetMaster() {
		ResetMasterContext _localctx = new ResetMasterContext(Context, State);
		EnterRule(_localctx, 292, RULE_resetMaster);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3819; Match(RESET);
			State = 3820; Match(MASTER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResetSlaveContext : ParserRuleContext {
		public ITerminalNode RESET() { return GetToken(MySqlParser.RESET, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ChannelOptionContext channelOption() {
			return GetRuleContext<ChannelOptionContext>(0);
		}
		public ResetSlaveContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_resetSlave; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterResetSlave(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitResetSlave(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitResetSlave(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ResetSlaveContext resetSlave() {
		ResetSlaveContext _localctx = new ResetSlaveContext(Context, State);
		EnterRule(_localctx, 294, RULE_resetSlave);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3822; Match(RESET);
			State = 3823; Match(SLAVE);
			State = 3825;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL) {
				{
				State = 3824; Match(ALL);
				}
			}

			State = 3828;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 3827; channelOption();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartSlaveContext : ParserRuleContext {
		public ITerminalNode START() { return GetToken(MySqlParser.START, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ThreadTypeContext[] threadType() {
			return GetRuleContexts<ThreadTypeContext>();
		}
		public ThreadTypeContext threadType(int i) {
			return GetRuleContext<ThreadTypeContext>(i);
		}
		public ITerminalNode UNTIL() { return GetToken(MySqlParser.UNTIL, 0); }
		public UntilOptionContext untilOption() {
			return GetRuleContext<UntilOptionContext>(0);
		}
		public ConnectionOptionContext[] connectionOption() {
			return GetRuleContexts<ConnectionOptionContext>();
		}
		public ConnectionOptionContext connectionOption(int i) {
			return GetRuleContext<ConnectionOptionContext>(i);
		}
		public ChannelOptionContext channelOption() {
			return GetRuleContext<ChannelOptionContext>(0);
		}
		public StartSlaveContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startSlave; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStartSlave(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStartSlave(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartSlave(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartSlaveContext startSlave() {
		StartSlaveContext _localctx = new StartSlaveContext(Context, State);
		EnterRule(_localctx, 296, RULE_startSlave);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3830; Match(START);
			State = 3831; Match(SLAVE);
			State = 3840;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IO_THREAD || _la==SQL_THREAD) {
				{
				State = 3832; threadType();
				State = 3837;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3833; Match(COMMA);
					State = 3834; threadType();
					}
					}
					State = 3839;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 3844;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNTIL) {
				{
				State = 3842; Match(UNTIL);
				State = 3843; untilOption();
				}
			}

			State = 3849;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DEFAULT_AUTH || _la==PASSWORD || _la==PLUGIN_DIR || _la==USER) {
				{
				{
				State = 3846; connectionOption();
				}
				}
				State = 3851;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3853;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 3852; channelOption();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StopSlaveContext : ParserRuleContext {
		public ITerminalNode STOP() { return GetToken(MySqlParser.STOP, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ThreadTypeContext[] threadType() {
			return GetRuleContexts<ThreadTypeContext>();
		}
		public ThreadTypeContext threadType(int i) {
			return GetRuleContext<ThreadTypeContext>(i);
		}
		public StopSlaveContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stopSlave; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStopSlave(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStopSlave(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStopSlave(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StopSlaveContext stopSlave() {
		StopSlaveContext _localctx = new StopSlaveContext(Context, State);
		EnterRule(_localctx, 298, RULE_stopSlave);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3855; Match(STOP);
			State = 3856; Match(SLAVE);
			State = 3865;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IO_THREAD || _la==SQL_THREAD) {
				{
				State = 3857; threadType();
				State = 3862;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3858; Match(COMMA);
					State = 3859; threadType();
					}
					}
					State = 3864;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartGroupReplicationContext : ParserRuleContext {
		public ITerminalNode START() { return GetToken(MySqlParser.START, 0); }
		public ITerminalNode GROUP_REPLICATION() { return GetToken(MySqlParser.GROUP_REPLICATION, 0); }
		public StartGroupReplicationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startGroupReplication; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStartGroupReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStartGroupReplication(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartGroupReplication(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartGroupReplicationContext startGroupReplication() {
		StartGroupReplicationContext _localctx = new StartGroupReplicationContext(Context, State);
		EnterRule(_localctx, 300, RULE_startGroupReplication);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3867; Match(START);
			State = 3868; Match(GROUP_REPLICATION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StopGroupReplicationContext : ParserRuleContext {
		public ITerminalNode STOP() { return GetToken(MySqlParser.STOP, 0); }
		public ITerminalNode GROUP_REPLICATION() { return GetToken(MySqlParser.GROUP_REPLICATION, 0); }
		public StopGroupReplicationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stopGroupReplication; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStopGroupReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStopGroupReplication(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStopGroupReplication(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StopGroupReplicationContext stopGroupReplication() {
		StopGroupReplicationContext _localctx = new StopGroupReplicationContext(Context, State);
		EnterRule(_localctx, 302, RULE_stopGroupReplication);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3870; Match(STOP);
			State = 3871; Match(GROUP_REPLICATION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MasterOptionContext : ParserRuleContext {
		public MasterOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_masterOption; } }
	 
		public MasterOptionContext() { }
		public virtual void CopyFrom(MasterOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class MasterStringOptionContext : MasterOptionContext {
		public StringMasterOptionContext stringMasterOption() {
			return GetRuleContext<StringMasterOptionContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public MasterStringOptionContext(MasterOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMasterStringOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMasterStringOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMasterStringOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MasterRealOptionContext : MasterOptionContext {
		public ITerminalNode MASTER_HEARTBEAT_PERIOD() { return GetToken(MySqlParser.MASTER_HEARTBEAT_PERIOD, 0); }
		public ITerminalNode REAL_LITERAL() { return GetToken(MySqlParser.REAL_LITERAL, 0); }
		public MasterRealOptionContext(MasterOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMasterRealOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMasterRealOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMasterRealOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MasterBoolOptionContext : MasterOptionContext {
		public IToken boolVal;
		public BoolMasterOptionContext boolMasterOption() {
			return GetRuleContext<BoolMasterOptionContext>(0);
		}
		public MasterBoolOptionContext(MasterOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMasterBoolOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMasterBoolOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMasterBoolOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MasterUidListOptionContext : MasterOptionContext {
		public ITerminalNode IGNORE_SERVER_IDS() { return GetToken(MySqlParser.IGNORE_SERVER_IDS, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public MasterUidListOptionContext(MasterOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMasterUidListOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMasterUidListOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMasterUidListOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MasterDecimalOptionContext : MasterOptionContext {
		public DecimalMasterOptionContext decimalMasterOption() {
			return GetRuleContext<DecimalMasterOptionContext>(0);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public MasterDecimalOptionContext(MasterOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMasterDecimalOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMasterDecimalOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMasterDecimalOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MasterOptionContext masterOption() {
		MasterOptionContext _localctx = new MasterOptionContext(Context, State);
		EnterRule(_localctx, 304, RULE_masterOption);
		int _la;
		try {
			State = 3902;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MASTER_BIND:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_PASSWORD:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case RELAY_LOG_FILE:
				_localctx = new MasterStringOptionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3873; stringMasterOption();
				State = 3874; Match(EQUAL_SYMBOL);
				State = 3875; Match(STRING_LITERAL);
				}
				break;
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_LOG_POS:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case RELAY_LOG_POS:
				_localctx = new MasterDecimalOptionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3877; decimalMasterOption();
				State = 3878; Match(EQUAL_SYMBOL);
				State = 3879; decimalLiteral();
				}
				break;
			case MASTER_SSL_VERIFY_SERVER_CERT:
			case MASTER_AUTO_POSITION:
			case MASTER_SSL:
				_localctx = new MasterBoolOptionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3881; boolMasterOption();
				State = 3882; Match(EQUAL_SYMBOL);
				State = 3883;
				((MasterBoolOptionContext)_localctx).boolVal = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ZERO_DECIMAL || _la==ONE_DECIMAL) ) {
					((MasterBoolOptionContext)_localctx).boolVal = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case MASTER_HEARTBEAT_PERIOD:
				_localctx = new MasterRealOptionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 3885; Match(MASTER_HEARTBEAT_PERIOD);
				State = 3886; Match(EQUAL_SYMBOL);
				State = 3887; Match(REAL_LITERAL);
				}
				break;
			case IGNORE_SERVER_IDS:
				_localctx = new MasterUidListOptionContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 3888; Match(IGNORE_SERVER_IDS);
				State = 3889; Match(EQUAL_SYMBOL);
				State = 3890; Match(LR_BRACKET);
				State = 3899;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
					{
					State = 3891; uid();
					State = 3896;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 3892; Match(COMMA);
						State = 3893; uid();
						}
						}
						State = 3898;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 3901; Match(RR_BRACKET);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringMasterOptionContext : ParserRuleContext {
		public ITerminalNode MASTER_BIND() { return GetToken(MySqlParser.MASTER_BIND, 0); }
		public ITerminalNode MASTER_HOST() { return GetToken(MySqlParser.MASTER_HOST, 0); }
		public ITerminalNode MASTER_USER() { return GetToken(MySqlParser.MASTER_USER, 0); }
		public ITerminalNode MASTER_PASSWORD() { return GetToken(MySqlParser.MASTER_PASSWORD, 0); }
		public ITerminalNode MASTER_LOG_FILE() { return GetToken(MySqlParser.MASTER_LOG_FILE, 0); }
		public ITerminalNode RELAY_LOG_FILE() { return GetToken(MySqlParser.RELAY_LOG_FILE, 0); }
		public ITerminalNode MASTER_SSL_CA() { return GetToken(MySqlParser.MASTER_SSL_CA, 0); }
		public ITerminalNode MASTER_SSL_CAPATH() { return GetToken(MySqlParser.MASTER_SSL_CAPATH, 0); }
		public ITerminalNode MASTER_SSL_CERT() { return GetToken(MySqlParser.MASTER_SSL_CERT, 0); }
		public ITerminalNode MASTER_SSL_CRL() { return GetToken(MySqlParser.MASTER_SSL_CRL, 0); }
		public ITerminalNode MASTER_SSL_CRLPATH() { return GetToken(MySqlParser.MASTER_SSL_CRLPATH, 0); }
		public ITerminalNode MASTER_SSL_KEY() { return GetToken(MySqlParser.MASTER_SSL_KEY, 0); }
		public ITerminalNode MASTER_SSL_CIPHER() { return GetToken(MySqlParser.MASTER_SSL_CIPHER, 0); }
		public ITerminalNode MASTER_TLS_VERSION() { return GetToken(MySqlParser.MASTER_TLS_VERSION, 0); }
		public StringMasterOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringMasterOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStringMasterOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStringMasterOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringMasterOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringMasterOptionContext stringMasterOption() {
		StringMasterOptionContext _localctx = new StringMasterOptionContext(Context, State);
		EnterRule(_localctx, 306, RULE_stringMasterOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3904;
			_la = TokenStream.LA(1);
			if ( !(_la==MASTER_BIND || ((((_la - 392)) & ~0x3f) == 0 && ((1L << (_la - 392)) & ((1L << (MASTER_HOST - 392)) | (1L << (MASTER_LOG_FILE - 392)) | (1L << (MASTER_PASSWORD - 392)) | (1L << (MASTER_SSL_CA - 392)) | (1L << (MASTER_SSL_CAPATH - 392)) | (1L << (MASTER_SSL_CERT - 392)) | (1L << (MASTER_SSL_CIPHER - 392)) | (1L << (MASTER_SSL_CRL - 392)) | (1L << (MASTER_SSL_CRLPATH - 392)) | (1L << (MASTER_SSL_KEY - 392)) | (1L << (MASTER_TLS_VERSION - 392)) | (1L << (MASTER_USER - 392)))) != 0) || _la==RELAY_LOG_FILE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DecimalMasterOptionContext : ParserRuleContext {
		public ITerminalNode MASTER_PORT() { return GetToken(MySqlParser.MASTER_PORT, 0); }
		public ITerminalNode MASTER_CONNECT_RETRY() { return GetToken(MySqlParser.MASTER_CONNECT_RETRY, 0); }
		public ITerminalNode MASTER_RETRY_COUNT() { return GetToken(MySqlParser.MASTER_RETRY_COUNT, 0); }
		public ITerminalNode MASTER_DELAY() { return GetToken(MySqlParser.MASTER_DELAY, 0); }
		public ITerminalNode MASTER_LOG_POS() { return GetToken(MySqlParser.MASTER_LOG_POS, 0); }
		public ITerminalNode RELAY_LOG_POS() { return GetToken(MySqlParser.RELAY_LOG_POS, 0); }
		public DecimalMasterOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_decimalMasterOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDecimalMasterOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDecimalMasterOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDecimalMasterOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DecimalMasterOptionContext decimalMasterOption() {
		DecimalMasterOptionContext _localctx = new DecimalMasterOptionContext(Context, State);
		EnterRule(_localctx, 308, RULE_decimalMasterOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3906;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 389)) & ~0x3f) == 0 && ((1L << (_la - 389)) & ((1L << (MASTER_CONNECT_RETRY - 389)) | (1L << (MASTER_DELAY - 389)) | (1L << (MASTER_LOG_POS - 389)) | (1L << (MASTER_PORT - 389)) | (1L << (MASTER_RETRY_COUNT - 389)))) != 0) || _la==RELAY_LOG_POS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BoolMasterOptionContext : ParserRuleContext {
		public ITerminalNode MASTER_AUTO_POSITION() { return GetToken(MySqlParser.MASTER_AUTO_POSITION, 0); }
		public ITerminalNode MASTER_SSL() { return GetToken(MySqlParser.MASTER_SSL, 0); }
		public ITerminalNode MASTER_SSL_VERIFY_SERVER_CERT() { return GetToken(MySqlParser.MASTER_SSL_VERIFY_SERVER_CERT, 0); }
		public BoolMasterOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_boolMasterOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBoolMasterOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBoolMasterOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBoolMasterOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BoolMasterOptionContext boolMasterOption() {
		BoolMasterOptionContext _localctx = new BoolMasterOptionContext(Context, State);
		EnterRule(_localctx, 310, RULE_boolMasterOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3908;
			_la = TokenStream.LA(1);
			if ( !(_la==MASTER_SSL_VERIFY_SERVER_CERT || _la==MASTER_AUTO_POSITION || _la==MASTER_SSL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ChannelOptionContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode CHANNEL() { return GetToken(MySqlParser.CHANNEL, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ChannelOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_channelOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterChannelOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitChannelOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChannelOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ChannelOptionContext channelOption() {
		ChannelOptionContext _localctx = new ChannelOptionContext(Context, State);
		EnterRule(_localctx, 312, RULE_channelOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3910; Match(FOR);
			State = 3911; Match(CHANNEL);
			State = 3912; Match(STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReplicationFilterContext : ParserRuleContext {
		public ReplicationFilterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_replicationFilter; } }
	 
		public ReplicationFilterContext() { }
		public virtual void CopyFrom(ReplicationFilterContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class WildIgnoreTableReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_WILD_IGNORE_TABLE() { return GetToken(MySqlParser.REPLICATE_WILD_IGNORE_TABLE, 0); }
		public SimpleStringsContext simpleStrings() {
			return GetRuleContext<SimpleStringsContext>(0);
		}
		public WildIgnoreTableReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterWildIgnoreTableReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitWildIgnoreTableReplication(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWildIgnoreTableReplication(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DoTableReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_DO_TABLE() { return GetToken(MySqlParser.REPLICATE_DO_TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public DoTableReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDoTableReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDoTableReplication(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDoTableReplication(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IgnoreTableReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_IGNORE_TABLE() { return GetToken(MySqlParser.REPLICATE_IGNORE_TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public IgnoreTableReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIgnoreTableReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIgnoreTableReplication(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIgnoreTableReplication(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RewriteDbReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_REWRITE_DB() { return GetToken(MySqlParser.REPLICATE_REWRITE_DB, 0); }
		public TablePairContext[] tablePair() {
			return GetRuleContexts<TablePairContext>();
		}
		public TablePairContext tablePair(int i) {
			return GetRuleContext<TablePairContext>(i);
		}
		public RewriteDbReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRewriteDbReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRewriteDbReplication(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRewriteDbReplication(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DoDbReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_DO_DB() { return GetToken(MySqlParser.REPLICATE_DO_DB, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public DoDbReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDoDbReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDoDbReplication(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDoDbReplication(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IgnoreDbReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_IGNORE_DB() { return GetToken(MySqlParser.REPLICATE_IGNORE_DB, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public IgnoreDbReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIgnoreDbReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIgnoreDbReplication(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIgnoreDbReplication(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WildDoTableReplicationContext : ReplicationFilterContext {
		public ITerminalNode REPLICATE_WILD_DO_TABLE() { return GetToken(MySqlParser.REPLICATE_WILD_DO_TABLE, 0); }
		public SimpleStringsContext simpleStrings() {
			return GetRuleContext<SimpleStringsContext>(0);
		}
		public WildDoTableReplicationContext(ReplicationFilterContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterWildDoTableReplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitWildDoTableReplication(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWildDoTableReplication(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReplicationFilterContext replicationFilter() {
		ReplicationFilterContext _localctx = new ReplicationFilterContext(Context, State);
		EnterRule(_localctx, 314, RULE_replicationFilter);
		int _la;
		try {
			State = 3963;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case REPLICATE_DO_DB:
				_localctx = new DoDbReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3914; Match(REPLICATE_DO_DB);
				State = 3915; Match(EQUAL_SYMBOL);
				State = 3916; Match(LR_BRACKET);
				State = 3917; uidList();
				State = 3918; Match(RR_BRACKET);
				}
				break;
			case REPLICATE_IGNORE_DB:
				_localctx = new IgnoreDbReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3920; Match(REPLICATE_IGNORE_DB);
				State = 3921; Match(EQUAL_SYMBOL);
				State = 3922; Match(LR_BRACKET);
				State = 3923; uidList();
				State = 3924; Match(RR_BRACKET);
				}
				break;
			case REPLICATE_DO_TABLE:
				_localctx = new DoTableReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3926; Match(REPLICATE_DO_TABLE);
				State = 3927; Match(EQUAL_SYMBOL);
				State = 3928; Match(LR_BRACKET);
				State = 3929; tables();
				State = 3930; Match(RR_BRACKET);
				}
				break;
			case REPLICATE_IGNORE_TABLE:
				_localctx = new IgnoreTableReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 3932; Match(REPLICATE_IGNORE_TABLE);
				State = 3933; Match(EQUAL_SYMBOL);
				State = 3934; Match(LR_BRACKET);
				State = 3935; tables();
				State = 3936; Match(RR_BRACKET);
				}
				break;
			case REPLICATE_WILD_DO_TABLE:
				_localctx = new WildDoTableReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 3938; Match(REPLICATE_WILD_DO_TABLE);
				State = 3939; Match(EQUAL_SYMBOL);
				State = 3940; Match(LR_BRACKET);
				State = 3941; simpleStrings();
				State = 3942; Match(RR_BRACKET);
				}
				break;
			case REPLICATE_WILD_IGNORE_TABLE:
				_localctx = new WildIgnoreTableReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 3944; Match(REPLICATE_WILD_IGNORE_TABLE);
				State = 3945; Match(EQUAL_SYMBOL);
				State = 3946; Match(LR_BRACKET);
				State = 3947; simpleStrings();
				State = 3948; Match(RR_BRACKET);
				}
				break;
			case REPLICATE_REWRITE_DB:
				_localctx = new RewriteDbReplicationContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 3950; Match(REPLICATE_REWRITE_DB);
				State = 3951; Match(EQUAL_SYMBOL);
				State = 3952; Match(LR_BRACKET);
				State = 3953; tablePair();
				State = 3958;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3954; Match(COMMA);
					State = 3955; tablePair();
					}
					}
					State = 3960;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 3961; Match(RR_BRACKET);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablePairContext : ParserRuleContext {
		public TableNameContext firstTable;
		public TableNameContext secondTable;
		public TableNameContext[] tableName() {
			return GetRuleContexts<TableNameContext>();
		}
		public TableNameContext tableName(int i) {
			return GetRuleContext<TableNameContext>(i);
		}
		public TablePairContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tablePair; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTablePair(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTablePair(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTablePair(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TablePairContext tablePair() {
		TablePairContext _localctx = new TablePairContext(Context, State);
		EnterRule(_localctx, 316, RULE_tablePair);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3965; Match(LR_BRACKET);
			State = 3966; _localctx.firstTable = tableName();
			State = 3967; Match(COMMA);
			State = 3968; _localctx.secondTable = tableName();
			State = 3969; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ThreadTypeContext : ParserRuleContext {
		public ITerminalNode IO_THREAD() { return GetToken(MySqlParser.IO_THREAD, 0); }
		public ITerminalNode SQL_THREAD() { return GetToken(MySqlParser.SQL_THREAD, 0); }
		public ThreadTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_threadType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterThreadType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitThreadType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitThreadType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ThreadTypeContext threadType() {
		ThreadTypeContext _localctx = new ThreadTypeContext(Context, State);
		EnterRule(_localctx, 318, RULE_threadType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3971;
			_la = TokenStream.LA(1);
			if ( !(_la==IO_THREAD || _la==SQL_THREAD) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UntilOptionContext : ParserRuleContext {
		public UntilOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_untilOption; } }
	 
		public UntilOptionContext() { }
		public virtual void CopyFrom(UntilOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class GtidsUntilOptionContext : UntilOptionContext {
		public IToken gtids;
		public GtuidSetContext gtuidSet() {
			return GetRuleContext<GtuidSetContext>(0);
		}
		public ITerminalNode SQL_BEFORE_GTIDS() { return GetToken(MySqlParser.SQL_BEFORE_GTIDS, 0); }
		public ITerminalNode SQL_AFTER_GTIDS() { return GetToken(MySqlParser.SQL_AFTER_GTIDS, 0); }
		public GtidsUntilOptionContext(UntilOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGtidsUntilOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGtidsUntilOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGtidsUntilOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SqlGapsUntilOptionContext : UntilOptionContext {
		public ITerminalNode SQL_AFTER_MTS_GAPS() { return GetToken(MySqlParser.SQL_AFTER_MTS_GAPS, 0); }
		public SqlGapsUntilOptionContext(UntilOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSqlGapsUntilOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSqlGapsUntilOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqlGapsUntilOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MasterLogUntilOptionContext : UntilOptionContext {
		public ITerminalNode MASTER_LOG_FILE() { return GetToken(MySqlParser.MASTER_LOG_FILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode MASTER_LOG_POS() { return GetToken(MySqlParser.MASTER_LOG_POS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public MasterLogUntilOptionContext(UntilOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMasterLogUntilOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMasterLogUntilOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMasterLogUntilOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RelayLogUntilOptionContext : UntilOptionContext {
		public ITerminalNode RELAY_LOG_FILE() { return GetToken(MySqlParser.RELAY_LOG_FILE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode RELAY_LOG_POS() { return GetToken(MySqlParser.RELAY_LOG_POS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public RelayLogUntilOptionContext(UntilOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRelayLogUntilOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRelayLogUntilOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelayLogUntilOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UntilOptionContext untilOption() {
		UntilOptionContext _localctx = new UntilOptionContext(Context, State);
		EnterRule(_localctx, 320, RULE_untilOption);
		int _la;
		try {
			State = 3991;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SQL_AFTER_GTIDS:
			case SQL_BEFORE_GTIDS:
				_localctx = new GtidsUntilOptionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3973;
				((GtidsUntilOptionContext)_localctx).gtids = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==SQL_AFTER_GTIDS || _la==SQL_BEFORE_GTIDS) ) {
					((GtidsUntilOptionContext)_localctx).gtids = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3974; Match(EQUAL_SYMBOL);
				State = 3975; gtuidSet();
				}
				break;
			case MASTER_LOG_FILE:
				_localctx = new MasterLogUntilOptionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3976; Match(MASTER_LOG_FILE);
				State = 3977; Match(EQUAL_SYMBOL);
				State = 3978; Match(STRING_LITERAL);
				State = 3979; Match(COMMA);
				State = 3980; Match(MASTER_LOG_POS);
				State = 3981; Match(EQUAL_SYMBOL);
				State = 3982; decimalLiteral();
				}
				break;
			case RELAY_LOG_FILE:
				_localctx = new RelayLogUntilOptionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3983; Match(RELAY_LOG_FILE);
				State = 3984; Match(EQUAL_SYMBOL);
				State = 3985; Match(STRING_LITERAL);
				State = 3986; Match(COMMA);
				State = 3987; Match(RELAY_LOG_POS);
				State = 3988; Match(EQUAL_SYMBOL);
				State = 3989; decimalLiteral();
				}
				break;
			case SQL_AFTER_MTS_GAPS:
				_localctx = new SqlGapsUntilOptionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 3990; Match(SQL_AFTER_MTS_GAPS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConnectionOptionContext : ParserRuleContext {
		public ConnectionOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_connectionOption; } }
	 
		public ConnectionOptionContext() { }
		public virtual void CopyFrom(ConnectionOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PluginDirConnectionOptionContext : ConnectionOptionContext {
		public IToken conOptPluginDir;
		public ITerminalNode PLUGIN_DIR() { return GetToken(MySqlParser.PLUGIN_DIR, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PluginDirConnectionOptionContext(ConnectionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPluginDirConnectionOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPluginDirConnectionOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPluginDirConnectionOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UserConnectionOptionContext : ConnectionOptionContext {
		public IToken conOptUser;
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public UserConnectionOptionContext(ConnectionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserConnectionOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserConnectionOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUserConnectionOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DefaultAuthConnectionOptionContext : ConnectionOptionContext {
		public IToken conOptDefAuth;
		public ITerminalNode DEFAULT_AUTH() { return GetToken(MySqlParser.DEFAULT_AUTH, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public DefaultAuthConnectionOptionContext(ConnectionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDefaultAuthConnectionOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDefaultAuthConnectionOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefaultAuthConnectionOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PasswordConnectionOptionContext : ConnectionOptionContext {
		public IToken conOptPassword;
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PasswordConnectionOptionContext(ConnectionOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPasswordConnectionOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPasswordConnectionOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPasswordConnectionOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConnectionOptionContext connectionOption() {
		ConnectionOptionContext _localctx = new ConnectionOptionContext(Context, State);
		EnterRule(_localctx, 322, RULE_connectionOption);
		try {
			State = 4005;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case USER:
				_localctx = new UserConnectionOptionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3993; Match(USER);
				State = 3994; Match(EQUAL_SYMBOL);
				State = 3995; ((UserConnectionOptionContext)_localctx).conOptUser = Match(STRING_LITERAL);
				}
				break;
			case PASSWORD:
				_localctx = new PasswordConnectionOptionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3996; Match(PASSWORD);
				State = 3997; Match(EQUAL_SYMBOL);
				State = 3998; ((PasswordConnectionOptionContext)_localctx).conOptPassword = Match(STRING_LITERAL);
				}
				break;
			case DEFAULT_AUTH:
				_localctx = new DefaultAuthConnectionOptionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3999; Match(DEFAULT_AUTH);
				State = 4000; Match(EQUAL_SYMBOL);
				State = 4001; ((DefaultAuthConnectionOptionContext)_localctx).conOptDefAuth = Match(STRING_LITERAL);
				}
				break;
			case PLUGIN_DIR:
				_localctx = new PluginDirConnectionOptionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 4002; Match(PLUGIN_DIR);
				State = 4003; Match(EQUAL_SYMBOL);
				State = 4004; ((PluginDirConnectionOptionContext)_localctx).conOptPluginDir = Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GtuidSetContext : ParserRuleContext {
		public UuidSetContext[] uuidSet() {
			return GetRuleContexts<UuidSetContext>();
		}
		public UuidSetContext uuidSet(int i) {
			return GetRuleContext<UuidSetContext>(i);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public GtuidSetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gtuidSet; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGtuidSet(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGtuidSet(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGtuidSet(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GtuidSetContext gtuidSet() {
		GtuidSetContext _localctx = new GtuidSetContext(Context, State);
		EnterRule(_localctx, 324, RULE_gtuidSet);
		int _la;
		try {
			State = 4016;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case DECIMAL_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4007; uuidSet();
				State = 4012;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4008; Match(COMMA);
					State = 4009; uuidSet();
					}
					}
					State = 4014;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4015; Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XaStartTransactionContext : ParserRuleContext {
		public IToken xaStart;
		public IToken xaAction;
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public XidContext xid() {
			return GetRuleContext<XidContext>(0);
		}
		public ITerminalNode START() { return GetToken(MySqlParser.START, 0); }
		public ITerminalNode BEGIN() { return GetToken(MySqlParser.BEGIN, 0); }
		public ITerminalNode JOIN() { return GetToken(MySqlParser.JOIN, 0); }
		public ITerminalNode RESUME() { return GetToken(MySqlParser.RESUME, 0); }
		public XaStartTransactionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xaStartTransaction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXaStartTransaction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXaStartTransaction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXaStartTransaction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public XaStartTransactionContext xaStartTransaction() {
		XaStartTransactionContext _localctx = new XaStartTransactionContext(Context, State);
		EnterRule(_localctx, 326, RULE_xaStartTransaction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4018; Match(XA);
			State = 4019;
			_localctx.xaStart = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==BEGIN || _la==START) ) {
				_localctx.xaStart = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4020; xid();
			State = 4022;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==JOIN || _la==RESUME) {
				{
				State = 4021;
				_localctx.xaAction = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==JOIN || _la==RESUME) ) {
					_localctx.xaAction = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XaEndTransactionContext : ParserRuleContext {
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public XidContext xid() {
			return GetRuleContext<XidContext>(0);
		}
		public ITerminalNode SUSPEND() { return GetToken(MySqlParser.SUSPEND, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode MIGRATE() { return GetToken(MySqlParser.MIGRATE, 0); }
		public XaEndTransactionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xaEndTransaction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXaEndTransaction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXaEndTransaction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXaEndTransaction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public XaEndTransactionContext xaEndTransaction() {
		XaEndTransactionContext _localctx = new XaEndTransactionContext(Context, State);
		EnterRule(_localctx, 328, RULE_xaEndTransaction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4024; Match(XA);
			State = 4025; Match(END);
			State = 4026; xid();
			State = 4032;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SUSPEND) {
				{
				State = 4027; Match(SUSPEND);
				State = 4030;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 4028; Match(FOR);
					State = 4029; Match(MIGRATE);
					}
				}

				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XaPrepareStatementContext : ParserRuleContext {
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public ITerminalNode PREPARE() { return GetToken(MySqlParser.PREPARE, 0); }
		public XidContext xid() {
			return GetRuleContext<XidContext>(0);
		}
		public XaPrepareStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xaPrepareStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXaPrepareStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXaPrepareStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXaPrepareStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public XaPrepareStatementContext xaPrepareStatement() {
		XaPrepareStatementContext _localctx = new XaPrepareStatementContext(Context, State);
		EnterRule(_localctx, 330, RULE_xaPrepareStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4034; Match(XA);
			State = 4035; Match(PREPARE);
			State = 4036; xid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XaCommitWorkContext : ParserRuleContext {
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public ITerminalNode COMMIT() { return GetToken(MySqlParser.COMMIT, 0); }
		public XidContext xid() {
			return GetRuleContext<XidContext>(0);
		}
		public ITerminalNode ONE() { return GetToken(MySqlParser.ONE, 0); }
		public ITerminalNode PHASE() { return GetToken(MySqlParser.PHASE, 0); }
		public XaCommitWorkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xaCommitWork; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXaCommitWork(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXaCommitWork(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXaCommitWork(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public XaCommitWorkContext xaCommitWork() {
		XaCommitWorkContext _localctx = new XaCommitWorkContext(Context, State);
		EnterRule(_localctx, 332, RULE_xaCommitWork);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4038; Match(XA);
			State = 4039; Match(COMMIT);
			State = 4040; xid();
			State = 4043;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ONE) {
				{
				State = 4041; Match(ONE);
				State = 4042; Match(PHASE);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XaRollbackWorkContext : ParserRuleContext {
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(MySqlParser.ROLLBACK, 0); }
		public XidContext xid() {
			return GetRuleContext<XidContext>(0);
		}
		public XaRollbackWorkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xaRollbackWork; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXaRollbackWork(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXaRollbackWork(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXaRollbackWork(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public XaRollbackWorkContext xaRollbackWork() {
		XaRollbackWorkContext _localctx = new XaRollbackWorkContext(Context, State);
		EnterRule(_localctx, 334, RULE_xaRollbackWork);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4045; Match(XA);
			State = 4046; Match(ROLLBACK);
			State = 4047; xid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XaRecoverWorkContext : ParserRuleContext {
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public ITerminalNode RECOVER() { return GetToken(MySqlParser.RECOVER, 0); }
		public ITerminalNode CONVERT() { return GetToken(MySqlParser.CONVERT, 0); }
		public XidContext xid() {
			return GetRuleContext<XidContext>(0);
		}
		public XaRecoverWorkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xaRecoverWork; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXaRecoverWork(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXaRecoverWork(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXaRecoverWork(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public XaRecoverWorkContext xaRecoverWork() {
		XaRecoverWorkContext _localctx = new XaRecoverWorkContext(Context, State);
		EnterRule(_localctx, 336, RULE_xaRecoverWork);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4049; Match(XA);
			State = 4050; Match(RECOVER);
			State = 4053;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONVERT) {
				{
				State = 4051; Match(CONVERT);
				State = 4052; xid();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrepareStatementContext : ParserRuleContext {
		public IToken query;
		public IToken variable;
		public ITerminalNode PREPARE() { return GetToken(MySqlParser.PREPARE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode LOCAL_ID() { return GetToken(MySqlParser.LOCAL_ID, 0); }
		public PrepareStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prepareStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPrepareStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPrepareStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrepareStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrepareStatementContext prepareStatement() {
		PrepareStatementContext _localctx = new PrepareStatementContext(Context, State);
		EnterRule(_localctx, 338, RULE_prepareStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4055; Match(PREPARE);
			State = 4056; uid();
			State = 4057; Match(FROM);
			State = 4060;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STRING_LITERAL:
				{
				State = 4058; _localctx.query = Match(STRING_LITERAL);
				}
				break;
			case LOCAL_ID:
				{
				State = 4059; _localctx.variable = Match(LOCAL_ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExecuteStatementContext : ParserRuleContext {
		public ITerminalNode EXECUTE() { return GetToken(MySqlParser.EXECUTE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public UserVariablesContext userVariables() {
			return GetRuleContext<UserVariablesContext>(0);
		}
		public ExecuteStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_executeStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExecuteStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExecuteStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExecuteStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExecuteStatementContext executeStatement() {
		ExecuteStatementContext _localctx = new ExecuteStatementContext(Context, State);
		EnterRule(_localctx, 340, RULE_executeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4062; Match(EXECUTE);
			State = 4063; uid();
			State = 4066;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 4064; Match(USING);
				State = 4065; userVariables();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeallocatePrepareContext : ParserRuleContext {
		public IToken dropFormat;
		public ITerminalNode PREPARE() { return GetToken(MySqlParser.PREPARE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode DEALLOCATE() { return GetToken(MySqlParser.DEALLOCATE, 0); }
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public DeallocatePrepareContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deallocatePrepare; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDeallocatePrepare(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDeallocatePrepare(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeallocatePrepare(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeallocatePrepareContext deallocatePrepare() {
		DeallocatePrepareContext _localctx = new DeallocatePrepareContext(Context, State);
		EnterRule(_localctx, 342, RULE_deallocatePrepare);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4068;
			_localctx.dropFormat = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==DROP || _la==DEALLOCATE) ) {
				_localctx.dropFormat = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4069; Match(PREPARE);
			State = 4070; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RoutineBodyContext : ParserRuleContext {
		public BlockStatementContext blockStatement() {
			return GetRuleContext<BlockStatementContext>(0);
		}
		public SqlStatementContext sqlStatement() {
			return GetRuleContext<SqlStatementContext>(0);
		}
		public RoutineBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routineBody; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRoutineBody(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRoutineBody(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoutineBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RoutineBodyContext routineBody() {
		RoutineBodyContext _localctx = new RoutineBodyContext(Context, State);
		EnterRule(_localctx, 344, RULE_routineBody);
		try {
			State = 4074;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,583,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4072; blockStatement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4073; sqlStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockStatementContext : ParserRuleContext {
		public ITerminalNode BEGIN() { return GetToken(MySqlParser.BEGIN, 0); }
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public DeclareVariableContext[] declareVariable() {
			return GetRuleContexts<DeclareVariableContext>();
		}
		public DeclareVariableContext declareVariable(int i) {
			return GetRuleContext<DeclareVariableContext>(i);
		}
		public ITerminalNode[] SEMI() { return GetTokens(MySqlParser.SEMI); }
		public ITerminalNode SEMI(int i) {
			return GetToken(MySqlParser.SEMI, i);
		}
		public DeclareConditionContext[] declareCondition() {
			return GetRuleContexts<DeclareConditionContext>();
		}
		public DeclareConditionContext declareCondition(int i) {
			return GetRuleContext<DeclareConditionContext>(i);
		}
		public DeclareCursorContext[] declareCursor() {
			return GetRuleContexts<DeclareCursorContext>();
		}
		public DeclareCursorContext declareCursor(int i) {
			return GetRuleContext<DeclareCursorContext>(i);
		}
		public DeclareHandlerContext[] declareHandler() {
			return GetRuleContexts<DeclareHandlerContext>();
		}
		public DeclareHandlerContext declareHandler(int i) {
			return GetRuleContext<DeclareHandlerContext>(i);
		}
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public BlockStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_blockStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBlockStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBlockStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockStatementContext blockStatement() {
		BlockStatementContext _localctx = new BlockStatementContext(Context, State);
		EnterRule(_localctx, 346, RULE_blockStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4079;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,584,Context) ) {
			case 1:
				{
				State = 4076; uid();
				State = 4077; Match(COLON_SYMB);
				}
				break;
			}
			State = 4081; Match(BEGIN);
			State = 4120;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,590,Context) ) {
			case 1:
				{
				State = 4087;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,585,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 4082; declareVariable();
						State = 4083; Match(SEMI);
						}
						} 
					}
					State = 4089;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,585,Context);
				}
				State = 4095;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,586,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 4090; declareCondition();
						State = 4091; Match(SEMI);
						}
						} 
					}
					State = 4097;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,586,Context);
				}
				State = 4103;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,587,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 4098; declareCursor();
						State = 4099; Match(SEMI);
						}
						} 
					}
					State = 4105;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,587,Context);
				}
				State = 4111;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==DECLARE) {
					{
					{
					State = 4106; declareHandler();
					State = 4107; Match(SEMI);
					}
					}
					State = 4113;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4117;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,589,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 4114; procedureSqlStatement();
						}
						} 
					}
					State = 4119;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,589,Context);
				}
				}
				break;
			}
			State = 4122; Match(END);
			State = 4124;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,591,Context) ) {
			case 1:
				{
				State = 4123; uid();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseStatementContext : ParserRuleContext {
		public ITerminalNode[] CASE() { return GetTokens(MySqlParser.CASE); }
		public ITerminalNode CASE(int i) {
			return GetToken(MySqlParser.CASE, i);
		}
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CaseAlternativeContext[] caseAlternative() {
			return GetRuleContexts<CaseAlternativeContext>();
		}
		public CaseAlternativeContext caseAlternative(int i) {
			return GetRuleContext<CaseAlternativeContext>(i);
		}
		public ITerminalNode ELSE() { return GetToken(MySqlParser.ELSE, 0); }
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public CaseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCaseStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCaseStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaseStatementContext caseStatement() {
		CaseStatementContext _localctx = new CaseStatementContext(Context, State);
		EnterRule(_localctx, 348, RULE_caseStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4126; Match(CASE);
			State = 4129;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,592,Context) ) {
			case 1:
				{
				State = 4127; uid();
				}
				break;
			case 2:
				{
				State = 4128; expression(0);
				}
				break;
			}
			State = 4132;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 4131; caseAlternative();
				}
				}
				State = 4134;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 4142;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 4136; Match(ELSE);
				State = 4138;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 4137; procedureSqlStatement();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4140;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,594,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
			}

			State = 4144; Match(END);
			State = 4145; Match(CASE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		public ProcedureSqlStatementContext _procedureSqlStatement;
		public IList<ProcedureSqlStatementContext> _thenStatements = new List<ProcedureSqlStatementContext>();
		public IList<ProcedureSqlStatementContext> _elseStatements = new List<ProcedureSqlStatementContext>();
		public ITerminalNode[] IF() { return GetTokens(MySqlParser.IF); }
		public ITerminalNode IF(int i) {
			return GetToken(MySqlParser.IF, i);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(MySqlParser.THEN, 0); }
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public ElifAlternativeContext[] elifAlternative() {
			return GetRuleContexts<ElifAlternativeContext>();
		}
		public ElifAlternativeContext elifAlternative(int i) {
			return GetRuleContext<ElifAlternativeContext>(i);
		}
		public ITerminalNode ELSE() { return GetToken(MySqlParser.ELSE, 0); }
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIfStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIfStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		IfStatementContext _localctx = new IfStatementContext(Context, State);
		EnterRule(_localctx, 350, RULE_ifStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4147; Match(IF);
			State = 4148; expression(0);
			State = 4149; Match(THEN);
			State = 4151;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4150; _localctx._procedureSqlStatement = procedureSqlStatement();
					_localctx._thenStatements.Add(_localctx._procedureSqlStatement);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4153;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,596,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			State = 4158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ELSEIF) {
				{
				{
				State = 4155; elifAlternative();
				}
				}
				State = 4160;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4167;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 4161; Match(ELSE);
				State = 4163;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 4162; _localctx._procedureSqlStatement = procedureSqlStatement();
						_localctx._elseStatements.Add(_localctx._procedureSqlStatement);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4165;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,598,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
			}

			State = 4169; Match(END);
			State = 4170; Match(IF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IterateStatementContext : ParserRuleContext {
		public ITerminalNode ITERATE() { return GetToken(MySqlParser.ITERATE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public IterateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_iterateStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIterateStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIterateStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIterateStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IterateStatementContext iterateStatement() {
		IterateStatementContext _localctx = new IterateStatementContext(Context, State);
		EnterRule(_localctx, 352, RULE_iterateStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4172; Match(ITERATE);
			State = 4173; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LeaveStatementContext : ParserRuleContext {
		public ITerminalNode LEAVE() { return GetToken(MySqlParser.LEAVE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public LeaveStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_leaveStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLeaveStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLeaveStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLeaveStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LeaveStatementContext leaveStatement() {
		LeaveStatementContext _localctx = new LeaveStatementContext(Context, State);
		EnterRule(_localctx, 354, RULE_leaveStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4175; Match(LEAVE);
			State = 4176; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopStatementContext : ParserRuleContext {
		public ITerminalNode[] LOOP() { return GetTokens(MySqlParser.LOOP); }
		public ITerminalNode LOOP(int i) {
			return GetToken(MySqlParser.LOOP, i);
		}
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public LoopStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLoopStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLoopStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoopStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopStatementContext loopStatement() {
		LoopStatementContext _localctx = new LoopStatementContext(Context, State);
		EnterRule(_localctx, 356, RULE_loopStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4181;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
				{
				State = 4178; uid();
				State = 4179; Match(COLON_SYMB);
				}
			}

			State = 4183; Match(LOOP);
			State = 4185;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4184; procedureSqlStatement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4187;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,601,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			State = 4189; Match(END);
			State = 4190; Match(LOOP);
			State = 4192;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
				{
				State = 4191; uid();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RepeatStatementContext : ParserRuleContext {
		public ITerminalNode[] REPEAT() { return GetTokens(MySqlParser.REPEAT); }
		public ITerminalNode REPEAT(int i) {
			return GetToken(MySqlParser.REPEAT, i);
		}
		public ITerminalNode UNTIL() { return GetToken(MySqlParser.UNTIL, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public RepeatStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_repeatStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRepeatStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRepeatStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRepeatStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RepeatStatementContext repeatStatement() {
		RepeatStatementContext _localctx = new RepeatStatementContext(Context, State);
		EnterRule(_localctx, 358, RULE_repeatStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4197;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
				{
				State = 4194; uid();
				State = 4195; Match(COLON_SYMB);
				}
			}

			State = 4199; Match(REPEAT);
			State = 4201;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4200; procedureSqlStatement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4203;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,604,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			State = 4205; Match(UNTIL);
			State = 4206; expression(0);
			State = 4207; Match(END);
			State = 4208; Match(REPEAT);
			State = 4210;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
				{
				State = 4209; uid();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnStatementContext : ParserRuleContext {
		public ITerminalNode RETURN() { return GetToken(MySqlParser.RETURN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ReturnStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterReturnStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitReturnStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReturnStatementContext returnStatement() {
		ReturnStatementContext _localctx = new ReturnStatementContext(Context, State);
		EnterRule(_localctx, 360, RULE_returnStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4212; Match(RETURN);
			State = 4213; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileStatementContext : ParserRuleContext {
		public ITerminalNode[] WHILE() { return GetTokens(MySqlParser.WHILE); }
		public ITerminalNode WHILE(int i) {
			return GetToken(MySqlParser.WHILE, i);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode DO() { return GetToken(MySqlParser.DO, 0); }
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public WhileStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterWhileStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitWhileStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhileStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileStatementContext whileStatement() {
		WhileStatementContext _localctx = new WhileStatementContext(Context, State);
		EnterRule(_localctx, 362, RULE_whileStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4218;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
				{
				State = 4215; uid();
				State = 4216; Match(COLON_SYMB);
				}
			}

			State = 4220; Match(WHILE);
			State = 4221; expression(0);
			State = 4222; Match(DO);
			State = 4224;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4223; procedureSqlStatement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4226;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,607,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			State = 4228; Match(END);
			State = 4229; Match(WHILE);
			State = 4231;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)) | (1L << (SERIAL - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || ((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (ACCOUNT - 253)) | (1L << (ACTION - 253)) | (1L << (AFTER - 253)) | (1L << (AGGREGATE - 253)) | (1L << (ALGORITHM - 253)) | (1L << (ANY - 253)) | (1L << (AT - 253)) | (1L << (AUTHORS - 253)) | (1L << (AUTOCOMMIT - 253)) | (1L << (AUTOEXTEND_SIZE - 253)) | (1L << (AUTO_INCREMENT - 253)) | (1L << (AVG_ROW_LENGTH - 253)) | (1L << (BEGIN - 253)) | (1L << (BINLOG - 253)) | (1L << (BIT - 253)) | (1L << (BLOCK - 253)) | (1L << (BOOL - 253)) | (1L << (BOOLEAN - 253)) | (1L << (BTREE - 253)) | (1L << (CACHE - 253)) | (1L << (CASCADED - 253)) | (1L << (CHAIN - 253)) | (1L << (CHANGED - 253)) | (1L << (CHANNEL - 253)) | (1L << (CHECKSUM - 253)) | (1L << (PAGE_CHECKSUM - 253)) | (1L << (CIPHER - 253)) | (1L << (CLASS_ORIGIN - 253)) | (1L << (CLIENT - 253)) | (1L << (CLOSE - 253)) | (1L << (COALESCE - 253)) | (1L << (CODE - 253)) | (1L << (COLUMNS - 253)) | (1L << (COLUMN_FORMAT - 253)) | (1L << (COLUMN_NAME - 253)) | (1L << (COMMENT - 253)) | (1L << (COMMIT - 253)) | (1L << (COMPACT - 253)) | (1L << (COMPLETION - 253)) | (1L << (COMPRESSED - 253)) | (1L << (COMPRESSION - 253)) | (1L << (CONCURRENT - 253)) | (1L << (CONNECTION - 253)) | (1L << (CONSISTENT - 253)) | (1L << (CONSTRAINT_CATALOG - 253)) | (1L << (CONSTRAINT_SCHEMA - 253)) | (1L << (CONSTRAINT_NAME - 253)) | (1L << (CONTAINS - 253)) | (1L << (CONTEXT - 253)) | (1L << (CONTRIBUTORS - 253)) | (1L << (COPY - 253)) | (1L << (CPU - 253)) | (1L << (DATA - 253)) | (1L << (DATAFILE - 253)) | (1L << (DEALLOCATE - 253)) | (1L << (DEFAULT_AUTH - 253)) | (1L << (DEFINER - 253)) | (1L << (DELAY_KEY_WRITE - 253)) | (1L << (DES_KEY_FILE - 253)) | (1L << (DIRECTORY - 253)) | (1L << (DISABLE - 253)) | (1L << (DISCARD - 253)) | (1L << (DISK - 253)) | (1L << (DO - 253)))) != 0) || ((((_la - 317)) & ~0x3f) == 0 && ((1L << (_la - 317)) & ((1L << (DUMPFILE - 317)) | (1L << (DUPLICATE - 317)) | (1L << (DYNAMIC - 317)) | (1L << (ENABLE - 317)) | (1L << (ENCRYPTION - 317)) | (1L << (END - 317)) | (1L << (ENDS - 317)) | (1L << (ENGINE - 317)) | (1L << (ENGINES - 317)) | (1L << (ERROR - 317)) | (1L << (ERRORS - 317)) | (1L << (ESCAPE - 317)) | (1L << (EVEN - 317)) | (1L << (EVENT - 317)) | (1L << (EVENTS - 317)) | (1L << (EVERY - 317)) | (1L << (EXCHANGE - 317)) | (1L << (EXCLUSIVE - 317)) | (1L << (EXPIRE - 317)) | (1L << (EXPORT - 317)) | (1L << (EXTENDED - 317)) | (1L << (EXTENT_SIZE - 317)) | (1L << (FAST - 317)) | (1L << (FAULTS - 317)) | (1L << (FIELDS - 317)) | (1L << (FILE_BLOCK_SIZE - 317)) | (1L << (FILTER - 317)) | (1L << (FIRST - 317)) | (1L << (FIXED - 317)) | (1L << (FLUSH - 317)) | (1L << (FOLLOWS - 317)) | (1L << (FOUND - 317)) | (1L << (FULL - 317)) | (1L << (FUNCTION - 317)) | (1L << (GENERAL - 317)) | (1L << (GLOBAL - 317)) | (1L << (GRANTS - 317)) | (1L << (GROUP_REPLICATION - 317)) | (1L << (HANDLER - 317)) | (1L << (HASH - 317)) | (1L << (HELP - 317)) | (1L << (HOST - 317)) | (1L << (HOSTS - 317)) | (1L << (IDENTIFIED - 317)) | (1L << (IGNORE_SERVER_IDS - 317)) | (1L << (IMPORT - 317)) | (1L << (INDEXES - 317)) | (1L << (INITIAL_SIZE - 317)) | (1L << (INPLACE - 317)) | (1L << (INSERT_METHOD - 317)) | (1L << (INSTALL - 317)) | (1L << (INSTANCE - 317)) | (1L << (INVISIBLE - 317)) | (1L << (INVOKER - 317)) | (1L << (IO - 317)) | (1L << (IO_THREAD - 317)) | (1L << (IPC - 317)) | (1L << (ISOLATION - 317)) | (1L << (ISSUER - 317)) | (1L << (JSON - 317)) | (1L << (KEY_BLOCK_SIZE - 317)) | (1L << (LANGUAGE - 317)) | (1L << (LAST - 317)) | (1L << (LEAVES - 317)))) != 0) || ((((_la - 381)) & ~0x3f) == 0 && ((1L << (_la - 381)) & ((1L << (LESS - 381)) | (1L << (LEVEL - 381)) | (1L << (LIST - 381)) | (1L << (LOCAL - 381)) | (1L << (LOGFILE - 381)) | (1L << (LOGS - 381)) | (1L << (MASTER - 381)) | (1L << (MASTER_AUTO_POSITION - 381)) | (1L << (MASTER_CONNECT_RETRY - 381)) | (1L << (MASTER_DELAY - 381)) | (1L << (MASTER_HEARTBEAT_PERIOD - 381)) | (1L << (MASTER_HOST - 381)) | (1L << (MASTER_LOG_FILE - 381)) | (1L << (MASTER_LOG_POS - 381)) | (1L << (MASTER_PASSWORD - 381)) | (1L << (MASTER_PORT - 381)) | (1L << (MASTER_RETRY_COUNT - 381)) | (1L << (MASTER_SSL - 381)) | (1L << (MASTER_SSL_CA - 381)) | (1L << (MASTER_SSL_CAPATH - 381)) | (1L << (MASTER_SSL_CERT - 381)) | (1L << (MASTER_SSL_CIPHER - 381)) | (1L << (MASTER_SSL_CRL - 381)) | (1L << (MASTER_SSL_CRLPATH - 381)) | (1L << (MASTER_SSL_KEY - 381)) | (1L << (MASTER_TLS_VERSION - 381)) | (1L << (MASTER_USER - 381)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 381)) | (1L << (MAX_QUERIES_PER_HOUR - 381)) | (1L << (MAX_ROWS - 381)) | (1L << (MAX_SIZE - 381)) | (1L << (MAX_UPDATES_PER_HOUR - 381)) | (1L << (MAX_USER_CONNECTIONS - 381)) | (1L << (MEDIUM - 381)) | (1L << (MERGE - 381)) | (1L << (MESSAGE_TEXT - 381)) | (1L << (MID - 381)) | (1L << (MIGRATE - 381)) | (1L << (MIN_ROWS - 381)) | (1L << (MODE - 381)) | (1L << (MODIFY - 381)) | (1L << (MUTEX - 381)) | (1L << (MYSQL - 381)) | (1L << (MYSQL_ERRNO - 381)) | (1L << (NAME - 381)) | (1L << (NAMES - 381)) | (1L << (NCHAR - 381)) | (1L << (NEVER - 381)) | (1L << (NEXT - 381)) | (1L << (NO - 381)) | (1L << (NODEGROUP - 381)) | (1L << (NONE - 381)) | (1L << (OFFLINE - 381)) | (1L << (OFFSET - 381)) | (1L << (OJ - 381)) | (1L << (OLD_PASSWORD - 381)) | (1L << (ONE - 381)) | (1L << (ONLINE - 381)) | (1L << (ONLY - 381)) | (1L << (OPEN - 381)) | (1L << (OPTIMIZER_COSTS - 381)) | (1L << (OPTIONS - 381)) | (1L << (OWNER - 381)) | (1L << (PACK_KEYS - 381)))) != 0) || ((((_la - 445)) & ~0x3f) == 0 && ((1L << (_la - 445)) & ((1L << (PAGE - 445)) | (1L << (PARSER - 445)) | (1L << (PARTIAL - 445)) | (1L << (PARTITIONING - 445)) | (1L << (PARTITIONS - 445)) | (1L << (PASSWORD - 445)) | (1L << (PHASE - 445)) | (1L << (PLUGIN - 445)) | (1L << (PLUGIN_DIR - 445)) | (1L << (PLUGINS - 445)) | (1L << (PORT - 445)) | (1L << (PRECEDES - 445)) | (1L << (PREPARE - 445)) | (1L << (PRESERVE - 445)) | (1L << (PREV - 445)) | (1L << (PROCESSLIST - 445)) | (1L << (PROFILE - 445)) | (1L << (PROFILES - 445)) | (1L << (PROXY - 445)) | (1L << (QUERY - 445)) | (1L << (QUICK - 445)) | (1L << (REBUILD - 445)) | (1L << (RECOVER - 445)) | (1L << (REDO_BUFFER_SIZE - 445)) | (1L << (REDUNDANT - 445)) | (1L << (RELAY - 445)) | (1L << (RELAY_LOG_FILE - 445)) | (1L << (RELAY_LOG_POS - 445)) | (1L << (RELAYLOG - 445)) | (1L << (REMOVE - 445)) | (1L << (REORGANIZE - 445)) | (1L << (REPAIR - 445)) | (1L << (REPLICATE_DO_DB - 445)) | (1L << (REPLICATE_DO_TABLE - 445)) | (1L << (REPLICATE_IGNORE_DB - 445)) | (1L << (REPLICATE_IGNORE_TABLE - 445)) | (1L << (REPLICATE_REWRITE_DB - 445)) | (1L << (REPLICATE_WILD_DO_TABLE - 445)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 445)) | (1L << (REPLICATION - 445)) | (1L << (RESET - 445)) | (1L << (RESUME - 445)) | (1L << (RETURNS - 445)) | (1L << (ROLLBACK - 445)) | (1L << (ROLLUP - 445)) | (1L << (ROTATE - 445)) | (1L << (ROW - 445)) | (1L << (ROWS - 445)) | (1L << (ROW_FORMAT - 445)) | (1L << (SAVEPOINT - 445)) | (1L << (SCHEDULE - 445)) | (1L << (SECURITY - 445)) | (1L << (SERVER - 445)) | (1L << (SESSION - 445)) | (1L << (SHARE - 445)) | (1L << (SHARED - 445)) | (1L << (SIGNED - 445)) | (1L << (SIMPLE - 445)) | (1L << (SLAVE - 445)) | (1L << (SLOW - 445)) | (1L << (SNAPSHOT - 445)) | (1L << (SOCKET - 445)) | (1L << (SOME - 445)) | (1L << (SONAME - 445)))) != 0) || ((((_la - 509)) & ~0x3f) == 0 && ((1L << (_la - 509)) & ((1L << (SOUNDS - 509)) | (1L << (SOURCE - 509)) | (1L << (SQL_AFTER_GTIDS - 509)) | (1L << (SQL_AFTER_MTS_GAPS - 509)) | (1L << (SQL_BEFORE_GTIDS - 509)) | (1L << (SQL_BUFFER_RESULT - 509)) | (1L << (SQL_CACHE - 509)) | (1L << (SQL_NO_CACHE - 509)) | (1L << (SQL_THREAD - 509)) | (1L << (START - 509)) | (1L << (STARTS - 509)) | (1L << (STATS_AUTO_RECALC - 509)) | (1L << (STATS_PERSISTENT - 509)) | (1L << (STATS_SAMPLE_PAGES - 509)) | (1L << (STATUS - 509)) | (1L << (STOP - 509)) | (1L << (STORAGE - 509)) | (1L << (STRING - 509)) | (1L << (SUBCLASS_ORIGIN - 509)) | (1L << (SUBJECT - 509)) | (1L << (SUBPARTITION - 509)) | (1L << (SUBPARTITIONS - 509)) | (1L << (SUSPEND - 509)) | (1L << (SWAPS - 509)) | (1L << (SWITCHES - 509)) | (1L << (TABLE_NAME - 509)) | (1L << (TABLESPACE - 509)) | (1L << (TEMPORARY - 509)) | (1L << (TEMPTABLE - 509)) | (1L << (THAN - 509)) | (1L << (TRADITIONAL - 509)) | (1L << (TRANSACTION - 509)) | (1L << (TRIGGERS - 509)) | (1L << (TRUNCATE - 509)) | (1L << (UNDEFINED - 509)) | (1L << (UNDOFILE - 509)) | (1L << (UNDO_BUFFER_SIZE - 509)) | (1L << (UNINSTALL - 509)) | (1L << (UNKNOWN - 509)) | (1L << (UNTIL - 509)) | (1L << (UPGRADE - 509)) | (1L << (USER - 509)) | (1L << (USE_FRM - 509)) | (1L << (USER_RESOURCES - 509)) | (1L << (VALIDATION - 509)) | (1L << (VALUE - 509)) | (1L << (VARIABLES - 509)) | (1L << (VIEW - 509)) | (1L << (VISIBLE - 509)) | (1L << (WAIT - 509)) | (1L << (WARNINGS - 509)) | (1L << (WITHOUT - 509)) | (1L << (WORK - 509)) | (1L << (WRAPPER - 509)) | (1L << (X509 - 509)) | (1L << (XA - 509)) | (1L << (XML - 509)) | (1L << (INTERNAL - 509)))) != 0) || ((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)) | (1L << (TABLES - 573)) | (1L << (ROUTINE - 573)) | (1L << (EXECUTE - 573)) | (1L << (FILE - 573)) | (1L << (PROCESS - 573)) | (1L << (RELOAD - 573)) | (1L << (SHUTDOWN - 573)) | (1L << (SUPER - 573)) | (1L << (PRIVILEGES - 573)) | (1L << (SESSION_VARIABLES_ADMIN - 573)) | (1L << (ARMSCII8 - 573)) | (1L << (ASCII - 573)) | (1L << (BIG5 - 573)) | (1L << (CP1250 - 573)) | (1L << (CP1251 - 573)) | (1L << (CP1256 - 573)) | (1L << (CP1257 - 573)) | (1L << (CP850 - 573)) | (1L << (CP852 - 573)) | (1L << (CP866 - 573)) | (1L << (CP932 - 573)) | (1L << (DEC8 - 573)) | (1L << (EUCJPMS - 573)) | (1L << (EUCKR - 573)) | (1L << (GB2312 - 573)) | (1L << (GBK - 573)) | (1L << (GEOSTD8 - 573)) | (1L << (GREEK - 573)) | (1L << (HEBREW - 573)) | (1L << (HP8 - 573)) | (1L << (KEYBCS2 - 573)) | (1L << (KOI8R - 573)) | (1L << (KOI8U - 573)) | (1L << (LATIN1 - 573)) | (1L << (LATIN2 - 573)) | (1L << (LATIN5 - 573)) | (1L << (LATIN7 - 573)) | (1L << (MACCE - 573)) | (1L << (MACROMAN - 573)) | (1L << (SJIS - 573)) | (1L << (SWE7 - 573)) | (1L << (TIS620 - 573)) | (1L << (UCS2 - 573)) | (1L << (UJIS - 573)) | (1L << (UTF16 - 573)) | (1L << (UTF16LE - 573)) | (1L << (UTF32 - 573)) | (1L << (UTF8 - 573)) | (1L << (UTF8MB3 - 573)) | (1L << (UTF8MB4 - 573)) | (1L << (ARCHIVE - 573)) | (1L << (BLACKHOLE - 573)) | (1L << (CSV - 573)) | (1L << (FEDERATED - 573)) | (1L << (INNODB - 573)) | (1L << (MEMORY - 573)))) != 0) || ((((_la - 637)) & ~0x3f) == 0 && ((1L << (_la - 637)) & ((1L << (MRG_MYISAM - 637)) | (1L << (MYISAM - 637)) | (1L << (NDB - 637)) | (1L << (NDBCLUSTER - 637)) | (1L << (PERFORMANCE_SCHEMA - 637)) | (1L << (TOKUDB - 637)) | (1L << (REPEATABLE - 637)) | (1L << (COMMITTED - 637)) | (1L << (UNCOMMITTED - 637)) | (1L << (SERIALIZABLE - 637)) | (1L << (GEOMETRYCOLLECTION - 637)) | (1L << (LINESTRING - 637)) | (1L << (MULTILINESTRING - 637)) | (1L << (MULTIPOINT - 637)) | (1L << (MULTIPOLYGON - 637)) | (1L << (POINT - 637)) | (1L << (POLYGON - 637)) | (1L << (ABS - 637)) | (1L << (ACOS - 637)) | (1L << (ADDDATE - 637)) | (1L << (ADDTIME - 637)) | (1L << (AES_DECRYPT - 637)) | (1L << (AES_ENCRYPT - 637)) | (1L << (AREA - 637)) | (1L << (ASBINARY - 637)) | (1L << (ASIN - 637)) | (1L << (ASTEXT - 637)) | (1L << (ASWKB - 637)) | (1L << (ASWKT - 637)) | (1L << (ASYMMETRIC_DECRYPT - 637)) | (1L << (ASYMMETRIC_DERIVE - 637)) | (1L << (ASYMMETRIC_ENCRYPT - 637)) | (1L << (ASYMMETRIC_SIGN - 637)) | (1L << (ASYMMETRIC_VERIFY - 637)) | (1L << (ATAN - 637)) | (1L << (ATAN2 - 637)) | (1L << (BENCHMARK - 637)) | (1L << (BIN - 637)) | (1L << (BIT_COUNT - 637)) | (1L << (BIT_LENGTH - 637)) | (1L << (BUFFER - 637)) | (1L << (CATALOG_NAME - 637)) | (1L << (CEIL - 637)) | (1L << (CEILING - 637)) | (1L << (CENTROID - 637)) | (1L << (CHARACTER_LENGTH - 637)) | (1L << (CHARSET - 637)) | (1L << (CHAR_LENGTH - 637)) | (1L << (COERCIBILITY - 637)) | (1L << (COLLATION - 637)) | (1L << (COMPRESS - 637)) | (1L << (CONCAT - 637)) | (1L << (CONCAT_WS - 637)) | (1L << (CONNECTION_ID - 637)) | (1L << (CONV - 637)) | (1L << (CONVERT_TZ - 637)) | (1L << (COS - 637)) | (1L << (COT - 637)) | (1L << (CRC32 - 637)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 637)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 637)) | (1L << (CREATE_DH_PARAMETERS - 637)))) != 0) || ((((_la - 701)) & ~0x3f) == 0 && ((1L << (_la - 701)) & ((1L << (CREATE_DIGEST - 701)) | (1L << (CROSSES - 701)) | (1L << (DATEDIFF - 701)) | (1L << (DATE_FORMAT - 701)) | (1L << (DAYNAME - 701)) | (1L << (DAYOFMONTH - 701)) | (1L << (DAYOFWEEK - 701)) | (1L << (DAYOFYEAR - 701)) | (1L << (DECODE - 701)) | (1L << (DEGREES - 701)) | (1L << (DES_DECRYPT - 701)) | (1L << (DES_ENCRYPT - 701)) | (1L << (DIMENSION - 701)) | (1L << (DISJOINT - 701)) | (1L << (ELT - 701)) | (1L << (ENCODE - 701)) | (1L << (ENCRYPT - 701)) | (1L << (ENDPOINT - 701)) | (1L << (ENVELOPE - 701)) | (1L << (EQUALS - 701)) | (1L << (EXP - 701)) | (1L << (EXPORT_SET - 701)) | (1L << (EXTERIORRING - 701)) | (1L << (EXTRACTVALUE - 701)) | (1L << (FIELD - 701)) | (1L << (FIND_IN_SET - 701)) | (1L << (FLOOR - 701)) | (1L << (FORMAT - 701)) | (1L << (FOUND_ROWS - 701)) | (1L << (FROM_BASE64 - 701)) | (1L << (FROM_DAYS - 701)) | (1L << (FROM_UNIXTIME - 701)) | (1L << (GEOMCOLLFROMTEXT - 701)) | (1L << (GEOMCOLLFROMWKB - 701)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 701)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 701)) | (1L << (GEOMETRYFROMTEXT - 701)) | (1L << (GEOMETRYFROMWKB - 701)) | (1L << (GEOMETRYN - 701)) | (1L << (GEOMETRYTYPE - 701)) | (1L << (GEOMFROMTEXT - 701)) | (1L << (GEOMFROMWKB - 701)) | (1L << (GET_FORMAT - 701)) | (1L << (GET_LOCK - 701)) | (1L << (GLENGTH - 701)) | (1L << (GREATEST - 701)) | (1L << (GTID_SUBSET - 701)) | (1L << (GTID_SUBTRACT - 701)) | (1L << (HEX - 701)) | (1L << (IFNULL - 701)) | (1L << (INET6_ATON - 701)) | (1L << (INET6_NTOA - 701)) | (1L << (INET_ATON - 701)) | (1L << (INET_NTOA - 701)) | (1L << (INSTR - 701)) | (1L << (INTERIORRINGN - 701)) | (1L << (INTERSECTS - 701)) | (1L << (ISCLOSED - 701)) | (1L << (ISEMPTY - 701)) | (1L << (ISNULL - 701)) | (1L << (ISSIMPLE - 701)) | (1L << (IS_FREE_LOCK - 701)) | (1L << (IS_IPV4 - 701)) | (1L << (IS_IPV4_COMPAT - 701)))) != 0) || ((((_la - 765)) & ~0x3f) == 0 && ((1L << (_la - 765)) & ((1L << (IS_IPV4_MAPPED - 765)) | (1L << (IS_IPV6 - 765)) | (1L << (IS_USED_LOCK - 765)) | (1L << (LAST_INSERT_ID - 765)) | (1L << (LCASE - 765)) | (1L << (LEAST - 765)) | (1L << (LENGTH - 765)) | (1L << (LINEFROMTEXT - 765)) | (1L << (LINEFROMWKB - 765)) | (1L << (LINESTRINGFROMTEXT - 765)) | (1L << (LINESTRINGFROMWKB - 765)) | (1L << (LN - 765)) | (1L << (LOAD_FILE - 765)) | (1L << (LOCATE - 765)) | (1L << (LOG - 765)) | (1L << (LOG10 - 765)) | (1L << (LOG2 - 765)) | (1L << (LOWER - 765)) | (1L << (LPAD - 765)) | (1L << (LTRIM - 765)) | (1L << (MAKEDATE - 765)) | (1L << (MAKETIME - 765)) | (1L << (MAKE_SET - 765)) | (1L << (MASTER_POS_WAIT - 765)) | (1L << (MBRCONTAINS - 765)) | (1L << (MBRDISJOINT - 765)) | (1L << (MBREQUAL - 765)) | (1L << (MBRINTERSECTS - 765)) | (1L << (MBROVERLAPS - 765)) | (1L << (MBRTOUCHES - 765)) | (1L << (MBRWITHIN - 765)) | (1L << (MD5 - 765)) | (1L << (MLINEFROMTEXT - 765)) | (1L << (MLINEFROMWKB - 765)) | (1L << (MONTHNAME - 765)) | (1L << (MPOINTFROMTEXT - 765)) | (1L << (MPOINTFROMWKB - 765)) | (1L << (MPOLYFROMTEXT - 765)) | (1L << (MPOLYFROMWKB - 765)) | (1L << (MULTILINESTRINGFROMTEXT - 765)) | (1L << (MULTILINESTRINGFROMWKB - 765)) | (1L << (MULTIPOINTFROMTEXT - 765)) | (1L << (MULTIPOINTFROMWKB - 765)) | (1L << (MULTIPOLYGONFROMTEXT - 765)) | (1L << (MULTIPOLYGONFROMWKB - 765)) | (1L << (NAME_CONST - 765)) | (1L << (NULLIF - 765)) | (1L << (NUMGEOMETRIES - 765)) | (1L << (NUMINTERIORRINGS - 765)) | (1L << (NUMPOINTS - 765)) | (1L << (OCT - 765)) | (1L << (OCTET_LENGTH - 765)) | (1L << (ORD - 765)) | (1L << (OVERLAPS - 765)) | (1L << (PERIOD_ADD - 765)) | (1L << (PERIOD_DIFF - 765)) | (1L << (PI - 765)) | (1L << (POINTFROMTEXT - 765)) | (1L << (POINTFROMWKB - 765)) | (1L << (POINTN - 765)) | (1L << (POLYFROMTEXT - 765)) | (1L << (POLYFROMWKB - 765)) | (1L << (POLYGONFROMTEXT - 765)) | (1L << (POLYGONFROMWKB - 765)))) != 0) || ((((_la - 829)) & ~0x3f) == 0 && ((1L << (_la - 829)) & ((1L << (POW - 829)) | (1L << (POWER - 829)) | (1L << (QUOTE - 829)) | (1L << (RADIANS - 829)) | (1L << (RAND - 829)) | (1L << (RANDOM_BYTES - 829)) | (1L << (RELEASE_LOCK - 829)) | (1L << (REVERSE - 829)) | (1L << (ROUND - 829)) | (1L << (ROW_COUNT - 829)) | (1L << (RPAD - 829)) | (1L << (RTRIM - 829)) | (1L << (SEC_TO_TIME - 829)) | (1L << (SESSION_USER - 829)) | (1L << (SHA - 829)) | (1L << (SHA1 - 829)) | (1L << (SHA2 - 829)) | (1L << (SCHEMA_NAME - 829)) | (1L << (SIGN - 829)) | (1L << (SIN - 829)) | (1L << (SLEEP - 829)) | (1L << (SOUNDEX - 829)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 829)) | (1L << (SQRT - 829)) | (1L << (SRID - 829)) | (1L << (STARTPOINT - 829)) | (1L << (STRCMP - 829)) | (1L << (STR_TO_DATE - 829)) | (1L << (ST_AREA - 829)) | (1L << (ST_ASBINARY - 829)) | (1L << (ST_ASTEXT - 829)) | (1L << (ST_ASWKB - 829)) | (1L << (ST_ASWKT - 829)) | (1L << (ST_BUFFER - 829)) | (1L << (ST_CENTROID - 829)) | (1L << (ST_CONTAINS - 829)) | (1L << (ST_CROSSES - 829)) | (1L << (ST_DIFFERENCE - 829)) | (1L << (ST_DIMENSION - 829)) | (1L << (ST_DISJOINT - 829)) | (1L << (ST_DISTANCE - 829)) | (1L << (ST_ENDPOINT - 829)) | (1L << (ST_ENVELOPE - 829)) | (1L << (ST_EQUALS - 829)) | (1L << (ST_EXTERIORRING - 829)) | (1L << (ST_GEOMCOLLFROMTEXT - 829)) | (1L << (ST_GEOMCOLLFROMTXT - 829)) | (1L << (ST_GEOMCOLLFROMWKB - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 829)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 829)) | (1L << (ST_GEOMETRYFROMTEXT - 829)) | (1L << (ST_GEOMETRYFROMWKB - 829)) | (1L << (ST_GEOMETRYN - 829)) | (1L << (ST_GEOMETRYTYPE - 829)) | (1L << (ST_GEOMFROMTEXT - 829)) | (1L << (ST_GEOMFROMWKB - 829)) | (1L << (ST_INTERIORRINGN - 829)) | (1L << (ST_INTERSECTION - 829)) | (1L << (ST_INTERSECTS - 829)) | (1L << (ST_ISCLOSED - 829)) | (1L << (ST_ISEMPTY - 829)) | (1L << (ST_ISSIMPLE - 829)) | (1L << (ST_LINEFROMTEXT - 829)) | (1L << (ST_LINEFROMWKB - 829)))) != 0) || ((((_la - 893)) & ~0x3f) == 0 && ((1L << (_la - 893)) & ((1L << (ST_LINESTRINGFROMTEXT - 893)) | (1L << (ST_LINESTRINGFROMWKB - 893)) | (1L << (ST_NUMGEOMETRIES - 893)) | (1L << (ST_NUMINTERIORRING - 893)) | (1L << (ST_NUMINTERIORRINGS - 893)) | (1L << (ST_NUMPOINTS - 893)) | (1L << (ST_OVERLAPS - 893)) | (1L << (ST_POINTFROMTEXT - 893)) | (1L << (ST_POINTFROMWKB - 893)) | (1L << (ST_POINTN - 893)) | (1L << (ST_POLYFROMTEXT - 893)) | (1L << (ST_POLYFROMWKB - 893)) | (1L << (ST_POLYGONFROMTEXT - 893)) | (1L << (ST_POLYGONFROMWKB - 893)) | (1L << (ST_SRID - 893)) | (1L << (ST_STARTPOINT - 893)) | (1L << (ST_SYMDIFFERENCE - 893)) | (1L << (ST_TOUCHES - 893)) | (1L << (ST_UNION - 893)) | (1L << (ST_WITHIN - 893)) | (1L << (ST_X - 893)) | (1L << (ST_Y - 893)) | (1L << (SUBDATE - 893)) | (1L << (SUBSTRING_INDEX - 893)) | (1L << (SUBTIME - 893)) | (1L << (SYSTEM_USER - 893)) | (1L << (TAN - 893)) | (1L << (TIMEDIFF - 893)) | (1L << (TIMESTAMPADD - 893)) | (1L << (TIMESTAMPDIFF - 893)) | (1L << (TIME_FORMAT - 893)) | (1L << (TIME_TO_SEC - 893)) | (1L << (TOUCHES - 893)) | (1L << (TO_BASE64 - 893)) | (1L << (TO_DAYS - 893)) | (1L << (TO_SECONDS - 893)) | (1L << (UCASE - 893)) | (1L << (UNCOMPRESS - 893)) | (1L << (UNCOMPRESSED_LENGTH - 893)) | (1L << (UNHEX - 893)) | (1L << (UNIX_TIMESTAMP - 893)) | (1L << (UPDATEXML - 893)) | (1L << (UPPER - 893)) | (1L << (UUID - 893)) | (1L << (UUID_SHORT - 893)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 893)) | (1L << (VERSION - 893)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 893)) | (1L << (WEEKDAY - 893)) | (1L << (WEEKOFYEAR - 893)) | (1L << (WEIGHT_STRING - 893)) | (1L << (WITHIN - 893)) | (1L << (YEARWEEK - 893)) | (1L << (Y_FUNCTION - 893)) | (1L << (X_FUNCTION - 893)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)))) != 0)) {
				{
				State = 4230; uid();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CursorStatementContext : ParserRuleContext {
		public CursorStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursorStatement; } }
	 
		public CursorStatementContext() { }
		public virtual void CopyFrom(CursorStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CloseCursorContext : CursorStatementContext {
		public ITerminalNode CLOSE() { return GetToken(MySqlParser.CLOSE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public CloseCursorContext(CursorStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCloseCursor(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCloseCursor(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCloseCursor(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpenCursorContext : CursorStatementContext {
		public ITerminalNode OPEN() { return GetToken(MySqlParser.OPEN, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public OpenCursorContext(CursorStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterOpenCursor(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitOpenCursor(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpenCursor(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FetchCursorContext : CursorStatementContext {
		public ITerminalNode FETCH() { return GetToken(MySqlParser.FETCH, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode NEXT() { return GetToken(MySqlParser.NEXT, 0); }
		public FetchCursorContext(CursorStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFetchCursor(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFetchCursor(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFetchCursor(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CursorStatementContext cursorStatement() {
		CursorStatementContext _localctx = new CursorStatementContext(Context, State);
		EnterRule(_localctx, 364, RULE_cursorStatement);
		int _la;
		try {
			State = 4248;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CLOSE:
				_localctx = new CloseCursorContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4233; Match(CLOSE);
				State = 4234; uid();
				}
				break;
			case FETCH:
				_localctx = new FetchCursorContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4235; Match(FETCH);
				State = 4240;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,610,Context) ) {
				case 1:
					{
					State = 4237;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NEXT) {
						{
						State = 4236; Match(NEXT);
						}
					}

					State = 4239; Match(FROM);
					}
					break;
				}
				State = 4242; uid();
				State = 4243; Match(INTO);
				State = 4244; uidList();
				}
				break;
			case OPEN:
				_localctx = new OpenCursorContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 4246; Match(OPEN);
				State = 4247; uid();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclareVariableContext : ParserRuleContext {
		public ITerminalNode DECLARE() { return GetToken(MySqlParser.DECLARE, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public DefaultValueContext defaultValue() {
			return GetRuleContext<DefaultValueContext>(0);
		}
		public DeclareVariableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declareVariable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDeclareVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDeclareVariable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclareVariable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclareVariableContext declareVariable() {
		DeclareVariableContext _localctx = new DeclareVariableContext(Context, State);
		EnterRule(_localctx, 366, RULE_declareVariable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4250; Match(DECLARE);
			State = 4251; uidList();
			State = 4252; dataType();
			State = 4255;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT) {
				{
				State = 4253; Match(DEFAULT);
				State = 4254; defaultValue();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclareConditionContext : ParserRuleContext {
		public ITerminalNode DECLARE() { return GetToken(MySqlParser.DECLARE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode CONDITION() { return GetToken(MySqlParser.CONDITION, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode SQLSTATE() { return GetToken(MySqlParser.SQLSTATE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode VALUE() { return GetToken(MySqlParser.VALUE, 0); }
		public DeclareConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declareCondition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDeclareCondition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDeclareCondition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclareCondition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclareConditionContext declareCondition() {
		DeclareConditionContext _localctx = new DeclareConditionContext(Context, State);
		EnterRule(_localctx, 368, RULE_declareCondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4257; Match(DECLARE);
			State = 4258; uid();
			State = 4259; Match(CONDITION);
			State = 4260; Match(FOR);
			State = 4267;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case DECIMAL_LITERAL:
				{
				State = 4261; decimalLiteral();
				}
				break;
			case SQLSTATE:
				{
				State = 4262; Match(SQLSTATE);
				State = 4264;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==VALUE) {
					{
					State = 4263; Match(VALUE);
					}
				}

				State = 4266; Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclareCursorContext : ParserRuleContext {
		public ITerminalNode DECLARE() { return GetToken(MySqlParser.DECLARE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode CURSOR() { return GetToken(MySqlParser.CURSOR, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public DeclareCursorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declareCursor; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDeclareCursor(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDeclareCursor(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclareCursor(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclareCursorContext declareCursor() {
		DeclareCursorContext _localctx = new DeclareCursorContext(Context, State);
		EnterRule(_localctx, 370, RULE_declareCursor);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4269; Match(DECLARE);
			State = 4270; uid();
			State = 4271; Match(CURSOR);
			State = 4272; Match(FOR);
			State = 4273; selectStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclareHandlerContext : ParserRuleContext {
		public IToken handlerAction;
		public ITerminalNode DECLARE() { return GetToken(MySqlParser.DECLARE, 0); }
		public ITerminalNode HANDLER() { return GetToken(MySqlParser.HANDLER, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public HandlerConditionValueContext[] handlerConditionValue() {
			return GetRuleContexts<HandlerConditionValueContext>();
		}
		public HandlerConditionValueContext handlerConditionValue(int i) {
			return GetRuleContext<HandlerConditionValueContext>(i);
		}
		public RoutineBodyContext routineBody() {
			return GetRuleContext<RoutineBodyContext>(0);
		}
		public ITerminalNode CONTINUE() { return GetToken(MySqlParser.CONTINUE, 0); }
		public ITerminalNode EXIT() { return GetToken(MySqlParser.EXIT, 0); }
		public ITerminalNode UNDO() { return GetToken(MySqlParser.UNDO, 0); }
		public DeclareHandlerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declareHandler; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDeclareHandler(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDeclareHandler(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclareHandler(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclareHandlerContext declareHandler() {
		DeclareHandlerContext _localctx = new DeclareHandlerContext(Context, State);
		EnterRule(_localctx, 372, RULE_declareHandler);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4275; Match(DECLARE);
			State = 4276;
			_localctx.handlerAction = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==CONTINUE || _la==EXIT || _la==UNDO) ) {
				_localctx.handlerAction = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4277; Match(HANDLER);
			State = 4278; Match(FOR);
			State = 4279; handlerConditionValue();
			State = 4284;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4280; Match(COMMA);
				State = 4281; handlerConditionValue();
				}
				}
				State = 4286;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4287; routineBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HandlerConditionValueContext : ParserRuleContext {
		public HandlerConditionValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_handlerConditionValue; } }
	 
		public HandlerConditionValueContext() { }
		public virtual void CopyFrom(HandlerConditionValueContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class HandlerConditionWarningContext : HandlerConditionValueContext {
		public ITerminalNode SQLWARNING() { return GetToken(MySqlParser.SQLWARNING, 0); }
		public HandlerConditionWarningContext(HandlerConditionValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerConditionWarning(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerConditionWarning(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHandlerConditionWarning(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class HandlerConditionCodeContext : HandlerConditionValueContext {
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public HandlerConditionCodeContext(HandlerConditionValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerConditionCode(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerConditionCode(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHandlerConditionCode(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class HandlerConditionNotfoundContext : HandlerConditionValueContext {
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public ITerminalNode FOUND() { return GetToken(MySqlParser.FOUND, 0); }
		public HandlerConditionNotfoundContext(HandlerConditionValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerConditionNotfound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerConditionNotfound(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHandlerConditionNotfound(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class HandlerConditionStateContext : HandlerConditionValueContext {
		public ITerminalNode SQLSTATE() { return GetToken(MySqlParser.SQLSTATE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode VALUE() { return GetToken(MySqlParser.VALUE, 0); }
		public HandlerConditionStateContext(HandlerConditionValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerConditionState(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerConditionState(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHandlerConditionState(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class HandlerConditionExceptionContext : HandlerConditionValueContext {
		public ITerminalNode SQLEXCEPTION() { return GetToken(MySqlParser.SQLEXCEPTION, 0); }
		public HandlerConditionExceptionContext(HandlerConditionValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerConditionException(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerConditionException(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHandlerConditionException(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class HandlerConditionNameContext : HandlerConditionValueContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public HandlerConditionNameContext(HandlerConditionValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHandlerConditionName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHandlerConditionName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHandlerConditionName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HandlerConditionValueContext handlerConditionValue() {
		HandlerConditionValueContext _localctx = new HandlerConditionValueContext(Context, State);
		EnterRule(_localctx, 374, RULE_handlerConditionValue);
		int _la;
		try {
			State = 4300;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case DECIMAL_LITERAL:
				_localctx = new HandlerConditionCodeContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4289; decimalLiteral();
				}
				break;
			case SQLSTATE:
				_localctx = new HandlerConditionStateContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4290; Match(SQLSTATE);
				State = 4292;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==VALUE) {
					{
					State = 4291; Match(VALUE);
					}
				}

				State = 4294; Match(STRING_LITERAL);
				}
				break;
			case DATABASE:
			case LEFT:
			case RIGHT:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case TEXT:
			case ENUM:
			case SERIAL:
			case COUNT:
			case POSITION:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLASS_ORIGIN:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COLUMN_NAME:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONSTRAINT_CATALOG:
			case CONSTRAINT_SCHEMA:
			case CONSTRAINT_NAME:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVISIBLE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MESSAGE_TEXT:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case MYSQL_ERRNO:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBCLASS_ORIGIN:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLE_NAME:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case VISIBLE:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case SESSION_VARIABLES_ADMIN:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CATALOG_NAME:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SCHEMA_NAME:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case CHARSET_REVERSE_QOUTE_STRING:
			case STRING_LITERAL:
			case ID:
			case REVERSE_QUOTE_ID:
				_localctx = new HandlerConditionNameContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 4295; uid();
				}
				break;
			case SQLWARNING:
				_localctx = new HandlerConditionWarningContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 4296; Match(SQLWARNING);
				}
				break;
			case NOT:
				_localctx = new HandlerConditionNotfoundContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 4297; Match(NOT);
				State = 4298; Match(FOUND);
				}
				break;
			case SQLEXCEPTION:
				_localctx = new HandlerConditionExceptionContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 4299; Match(SQLEXCEPTION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureSqlStatementContext : ParserRuleContext {
		public ITerminalNode SEMI() { return GetToken(MySqlParser.SEMI, 0); }
		public CompoundStatementContext compoundStatement() {
			return GetRuleContext<CompoundStatementContext>(0);
		}
		public SqlStatementContext sqlStatement() {
			return GetRuleContext<SqlStatementContext>(0);
		}
		public ProcedureSqlStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureSqlStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterProcedureSqlStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitProcedureSqlStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedureSqlStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureSqlStatementContext procedureSqlStatement() {
		ProcedureSqlStatementContext _localctx = new ProcedureSqlStatementContext(Context, State);
		EnterRule(_localctx, 376, RULE_procedureSqlStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4304;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,618,Context) ) {
			case 1:
				{
				State = 4302; compoundStatement();
				}
				break;
			case 2:
				{
				State = 4303; sqlStatement();
				}
				break;
			}
			State = 4306; Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseAlternativeContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(MySqlParser.WHEN, 0); }
		public ITerminalNode THEN() { return GetToken(MySqlParser.THEN, 0); }
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public CaseAlternativeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseAlternative; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCaseAlternative(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCaseAlternative(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseAlternative(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaseAlternativeContext caseAlternative() {
		CaseAlternativeContext _localctx = new CaseAlternativeContext(Context, State);
		EnterRule(_localctx, 378, RULE_caseAlternative);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4308; Match(WHEN);
			State = 4311;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,619,Context) ) {
			case 1:
				{
				State = 4309; constant();
				}
				break;
			case 2:
				{
				State = 4310; expression(0);
				}
				break;
			}
			State = 4313; Match(THEN);
			State = 4315;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4314; procedureSqlStatement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4317;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,620,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElifAlternativeContext : ParserRuleContext {
		public ITerminalNode ELSEIF() { return GetToken(MySqlParser.ELSEIF, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(MySqlParser.THEN, 0); }
		public ProcedureSqlStatementContext[] procedureSqlStatement() {
			return GetRuleContexts<ProcedureSqlStatementContext>();
		}
		public ProcedureSqlStatementContext procedureSqlStatement(int i) {
			return GetRuleContext<ProcedureSqlStatementContext>(i);
		}
		public ElifAlternativeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elifAlternative; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterElifAlternative(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitElifAlternative(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElifAlternative(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElifAlternativeContext elifAlternative() {
		ElifAlternativeContext _localctx = new ElifAlternativeContext(Context, State);
		EnterRule(_localctx, 380, RULE_elifAlternative);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4319; Match(ELSEIF);
			State = 4320; expression(0);
			State = 4321; Match(THEN);
			State = 4323;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 4322; procedureSqlStatement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4325;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,621,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterUserContext : ParserRuleContext {
		public AlterUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterUser; } }
	 
		public AlterUserContext() { }
		public virtual void CopyFrom(AlterUserContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AlterUserMysqlV56Context : AlterUserContext {
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public UserSpecificationContext[] userSpecification() {
			return GetRuleContexts<UserSpecificationContext>();
		}
		public UserSpecificationContext userSpecification(int i) {
			return GetRuleContext<UserSpecificationContext>(i);
		}
		public AlterUserMysqlV56Context(AlterUserContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterUserMysqlV56(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterUserMysqlV56(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterUserMysqlV56(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AlterUserMysqlV57Context : AlterUserContext {
		public IToken tlsNone;
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public UserAuthOptionContext[] userAuthOption() {
			return GetRuleContexts<UserAuthOptionContext>();
		}
		public UserAuthOptionContext userAuthOption(int i) {
			return GetRuleContext<UserAuthOptionContext>(i);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public ITerminalNode REQUIRE() { return GetToken(MySqlParser.REQUIRE, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public UserPasswordOptionContext[] userPasswordOption() {
			return GetRuleContexts<UserPasswordOptionContext>();
		}
		public UserPasswordOptionContext userPasswordOption(int i) {
			return GetRuleContext<UserPasswordOptionContext>(i);
		}
		public UserLockOptionContext[] userLockOption() {
			return GetRuleContexts<UserLockOptionContext>();
		}
		public UserLockOptionContext userLockOption(int i) {
			return GetRuleContext<UserLockOptionContext>(i);
		}
		public TlsOptionContext[] tlsOption() {
			return GetRuleContexts<TlsOptionContext>();
		}
		public TlsOptionContext tlsOption(int i) {
			return GetRuleContext<TlsOptionContext>(i);
		}
		public ITerminalNode NONE() { return GetToken(MySqlParser.NONE, 0); }
		public UserResourceOptionContext[] userResourceOption() {
			return GetRuleContexts<UserResourceOptionContext>();
		}
		public UserResourceOptionContext userResourceOption(int i) {
			return GetRuleContext<UserResourceOptionContext>(i);
		}
		public ITerminalNode[] AND() { return GetTokens(MySqlParser.AND); }
		public ITerminalNode AND(int i) {
			return GetToken(MySqlParser.AND, i);
		}
		public AlterUserMysqlV57Context(AlterUserContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAlterUserMysqlV57(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAlterUserMysqlV57(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterUserMysqlV57(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterUserContext alterUser() {
		AlterUserContext _localctx = new AlterUserContext(Context, State);
		EnterRule(_localctx, 382, RULE_alterUser);
		int _la;
		try {
			State = 4381;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,633,Context) ) {
			case 1:
				_localctx = new AlterUserMysqlV56Context(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4327; Match(ALTER);
				State = 4328; Match(USER);
				State = 4329; userSpecification();
				State = 4334;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4330; Match(COMMA);
					State = 4331; userSpecification();
					}
					}
					State = 4336;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new AlterUserMysqlV57Context(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4337; Match(ALTER);
				State = 4338; Match(USER);
				State = 4340;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IF) {
					{
					State = 4339; ifExists();
					}
				}

				State = 4342; userAuthOption();
				State = 4347;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4343; Match(COMMA);
					State = 4344; userAuthOption();
					}
					}
					State = 4349;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4364;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==REQUIRE) {
					{
					State = 4350; Match(REQUIRE);
					State = 4362;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case NONE:
						{
						State = 4351; ((AlterUserMysqlV57Context)_localctx).tlsNone = Match(NONE);
						}
						break;
					case SSL:
					case CIPHER:
					case ISSUER:
					case SUBJECT:
					case X509:
						{
						State = 4352; tlsOption();
						State = 4359;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==AND || _la==SSL || _la==CIPHER || _la==ISSUER || _la==SUBJECT || _la==X509) {
							{
							{
							State = 4354;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (_la==AND) {
								{
								State = 4353; Match(AND);
								}
							}

							State = 4356; tlsOption();
							}
							}
							State = 4361;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				State = 4372;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH) {
					{
					State = 4366; Match(WITH);
					State = 4368;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 4367; userResourceOption();
						}
						}
						State = 4370;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( ((((_la - 408)) & ~0x3f) == 0 && ((1L << (_la - 408)) & ((1L << (MAX_CONNECTIONS_PER_HOUR - 408)) | (1L << (MAX_QUERIES_PER_HOUR - 408)) | (1L << (MAX_UPDATES_PER_HOUR - 408)) | (1L << (MAX_USER_CONNECTIONS - 408)))) != 0) );
					}
				}

				State = 4378;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==ACCOUNT || _la==PASSWORD) {
					{
					State = 4376;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case PASSWORD:
						{
						State = 4374; userPasswordOption();
						}
						break;
					case ACCOUNT:
						{
						State = 4375; userLockOption();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 4380;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserContext : ParserRuleContext {
		public CreateUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUser; } }
	 
		public CreateUserContext() { }
		public virtual void CopyFrom(CreateUserContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CreateUserMysqlV57Context : CreateUserContext {
		public IToken tlsNone;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public UserAuthOptionContext[] userAuthOption() {
			return GetRuleContexts<UserAuthOptionContext>();
		}
		public UserAuthOptionContext userAuthOption(int i) {
			return GetRuleContext<UserAuthOptionContext>(i);
		}
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public ITerminalNode REQUIRE() { return GetToken(MySqlParser.REQUIRE, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public UserPasswordOptionContext[] userPasswordOption() {
			return GetRuleContexts<UserPasswordOptionContext>();
		}
		public UserPasswordOptionContext userPasswordOption(int i) {
			return GetRuleContext<UserPasswordOptionContext>(i);
		}
		public UserLockOptionContext[] userLockOption() {
			return GetRuleContexts<UserLockOptionContext>();
		}
		public UserLockOptionContext userLockOption(int i) {
			return GetRuleContext<UserLockOptionContext>(i);
		}
		public TlsOptionContext[] tlsOption() {
			return GetRuleContexts<TlsOptionContext>();
		}
		public TlsOptionContext tlsOption(int i) {
			return GetRuleContext<TlsOptionContext>(i);
		}
		public ITerminalNode NONE() { return GetToken(MySqlParser.NONE, 0); }
		public UserResourceOptionContext[] userResourceOption() {
			return GetRuleContexts<UserResourceOptionContext>();
		}
		public UserResourceOptionContext userResourceOption(int i) {
			return GetRuleContext<UserResourceOptionContext>(i);
		}
		public ITerminalNode[] AND() { return GetTokens(MySqlParser.AND); }
		public ITerminalNode AND(int i) {
			return GetToken(MySqlParser.AND, i);
		}
		public CreateUserMysqlV57Context(CreateUserContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateUserMysqlV57(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateUserMysqlV57(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateUserMysqlV57(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CreateUserMysqlV56Context : CreateUserContext {
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public UserAuthOptionContext[] userAuthOption() {
			return GetRuleContexts<UserAuthOptionContext>();
		}
		public UserAuthOptionContext userAuthOption(int i) {
			return GetRuleContext<UserAuthOptionContext>(i);
		}
		public CreateUserMysqlV56Context(CreateUserContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateUserMysqlV56(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateUserMysqlV56(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateUserMysqlV56(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserContext createUser() {
		CreateUserContext _localctx = new CreateUserContext(Context, State);
		EnterRule(_localctx, 384, RULE_createUser);
		int _la;
		try {
			State = 4437;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,645,Context) ) {
			case 1:
				_localctx = new CreateUserMysqlV56Context(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4383; Match(CREATE);
				State = 4384; Match(USER);
				State = 4385; userAuthOption();
				State = 4390;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4386; Match(COMMA);
					State = 4387; userAuthOption();
					}
					}
					State = 4392;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new CreateUserMysqlV57Context(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4393; Match(CREATE);
				State = 4394; Match(USER);
				State = 4396;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IF) {
					{
					State = 4395; ifNotExists();
					}
				}

				State = 4398; userAuthOption();
				State = 4403;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4399; Match(COMMA);
					State = 4400; userAuthOption();
					}
					}
					State = 4405;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4420;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==REQUIRE) {
					{
					State = 4406; Match(REQUIRE);
					State = 4418;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case NONE:
						{
						State = 4407; ((CreateUserMysqlV57Context)_localctx).tlsNone = Match(NONE);
						}
						break;
					case SSL:
					case CIPHER:
					case ISSUER:
					case SUBJECT:
					case X509:
						{
						State = 4408; tlsOption();
						State = 4415;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==AND || _la==SSL || _la==CIPHER || _la==ISSUER || _la==SUBJECT || _la==X509) {
							{
							{
							State = 4410;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (_la==AND) {
								{
								State = 4409; Match(AND);
								}
							}

							State = 4412; tlsOption();
							}
							}
							State = 4417;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				State = 4428;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH) {
					{
					State = 4422; Match(WITH);
					State = 4424;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 4423; userResourceOption();
						}
						}
						State = 4426;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( ((((_la - 408)) & ~0x3f) == 0 && ((1L << (_la - 408)) & ((1L << (MAX_CONNECTIONS_PER_HOUR - 408)) | (1L << (MAX_QUERIES_PER_HOUR - 408)) | (1L << (MAX_UPDATES_PER_HOUR - 408)) | (1L << (MAX_USER_CONNECTIONS - 408)))) != 0) );
					}
				}

				State = 4434;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==ACCOUNT || _la==PASSWORD) {
					{
					State = 4432;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case PASSWORD:
						{
						State = 4430; userPasswordOption();
						}
						break;
					case ACCOUNT:
						{
						State = 4431; userLockOption();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 4436;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropUserContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public UserNameContext[] userName() {
			return GetRuleContexts<UserNameContext>();
		}
		public UserNameContext userName(int i) {
			return GetRuleContext<UserNameContext>(i);
		}
		public IfExistsContext ifExists() {
			return GetRuleContext<IfExistsContext>(0);
		}
		public DropUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropUser; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDropUser(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDropUser(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropUser(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropUserContext dropUser() {
		DropUserContext _localctx = new DropUserContext(Context, State);
		EnterRule(_localctx, 386, RULE_dropUser);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4439; Match(DROP);
			State = 4440; Match(USER);
			State = 4442;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 4441; ifExists();
				}
			}

			State = 4444; userName();
			State = 4449;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4445; Match(COMMA);
				State = 4446; userName();
				}
				}
				State = 4451;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GrantStatementContext : ParserRuleContext {
		public IToken privilegeObject;
		public IToken tlsNone;
		public ITerminalNode[] GRANT() { return GetTokens(MySqlParser.GRANT); }
		public ITerminalNode GRANT(int i) {
			return GetToken(MySqlParser.GRANT, i);
		}
		public PrivelegeClauseContext[] privelegeClause() {
			return GetRuleContexts<PrivelegeClauseContext>();
		}
		public PrivelegeClauseContext privelegeClause(int i) {
			return GetRuleContext<PrivelegeClauseContext>(i);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public PrivilegeLevelContext privilegeLevel() {
			return GetRuleContext<PrivilegeLevelContext>(0);
		}
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public UserAuthOptionContext[] userAuthOption() {
			return GetRuleContexts<UserAuthOptionContext>();
		}
		public UserAuthOptionContext userAuthOption(int i) {
			return GetRuleContext<UserAuthOptionContext>(i);
		}
		public ITerminalNode REQUIRE() { return GetToken(MySqlParser.REQUIRE, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public TlsOptionContext[] tlsOption() {
			return GetRuleContexts<TlsOptionContext>();
		}
		public TlsOptionContext tlsOption(int i) {
			return GetRuleContext<TlsOptionContext>(i);
		}
		public ITerminalNode NONE() { return GetToken(MySqlParser.NONE, 0); }
		public ITerminalNode[] OPTION() { return GetTokens(MySqlParser.OPTION); }
		public ITerminalNode OPTION(int i) {
			return GetToken(MySqlParser.OPTION, i);
		}
		public UserResourceOptionContext[] userResourceOption() {
			return GetRuleContexts<UserResourceOptionContext>();
		}
		public UserResourceOptionContext userResourceOption(int i) {
			return GetRuleContext<UserResourceOptionContext>(i);
		}
		public ITerminalNode[] AND() { return GetTokens(MySqlParser.AND); }
		public ITerminalNode AND(int i) {
			return GetToken(MySqlParser.AND, i);
		}
		public GrantStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grantStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGrantStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGrantStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrantStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GrantStatementContext grantStatement() {
		GrantStatementContext _localctx = new GrantStatementContext(Context, State);
		EnterRule(_localctx, 388, RULE_grantStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4452; Match(GRANT);
			State = 4453; privelegeClause();
			State = 4458;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4454; Match(COMMA);
				State = 4455; privelegeClause();
				}
				}
				State = 4460;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4461; Match(ON);
			State = 4463;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,649,Context) ) {
			case 1:
				{
				State = 4462;
				_localctx.privilegeObject = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==PROCEDURE || _la==TABLE || _la==FUNCTION) ) {
					_localctx.privilegeObject = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 4465; privilegeLevel();
			State = 4466; Match(TO);
			State = 4467; userAuthOption();
			State = 4472;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4468; Match(COMMA);
				State = 4469; userAuthOption();
				}
				}
				State = 4474;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4489;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REQUIRE) {
				{
				State = 4475; Match(REQUIRE);
				State = 4487;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case NONE:
					{
					State = 4476; _localctx.tlsNone = Match(NONE);
					}
					break;
				case SSL:
				case CIPHER:
				case ISSUER:
				case SUBJECT:
				case X509:
					{
					State = 4477; tlsOption();
					State = 4484;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==AND || _la==SSL || _la==CIPHER || _la==ISSUER || _la==SUBJECT || _la==X509) {
						{
						{
						State = 4479;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==AND) {
							{
							State = 4478; Match(AND);
							}
						}

						State = 4481; tlsOption();
						}
						}
						State = 4486;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			State = 4500;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 4491; Match(WITH);
				State = 4497;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,656,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						State = 4495;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case GRANT:
							{
							State = 4492; Match(GRANT);
							State = 4493; Match(OPTION);
							}
							break;
						case MAX_CONNECTIONS_PER_HOUR:
						case MAX_QUERIES_PER_HOUR:
						case MAX_UPDATES_PER_HOUR:
						case MAX_USER_CONNECTIONS:
							{
							State = 4494; userResourceOption();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						} 
					}
					State = 4499;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,656,Context);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GrantProxyContext : ParserRuleContext {
		public UserNameContext fromFirst;
		public UserNameContext toFirst;
		public UserNameContext _userName;
		public IList<UserNameContext> _toOther = new List<UserNameContext>();
		public ITerminalNode[] GRANT() { return GetTokens(MySqlParser.GRANT); }
		public ITerminalNode GRANT(int i) {
			return GetToken(MySqlParser.GRANT, i);
		}
		public ITerminalNode PROXY() { return GetToken(MySqlParser.PROXY, 0); }
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public UserNameContext[] userName() {
			return GetRuleContexts<UserNameContext>();
		}
		public UserNameContext userName(int i) {
			return GetRuleContext<UserNameContext>(i);
		}
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode OPTION() { return GetToken(MySqlParser.OPTION, 0); }
		public GrantProxyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grantProxy; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGrantProxy(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGrantProxy(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrantProxy(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GrantProxyContext grantProxy() {
		GrantProxyContext _localctx = new GrantProxyContext(Context, State);
		EnterRule(_localctx, 390, RULE_grantProxy);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4502; Match(GRANT);
			State = 4503; Match(PROXY);
			State = 4504; Match(ON);
			State = 4505; _localctx.fromFirst = userName();
			State = 4506; Match(TO);
			State = 4507; _localctx.toFirst = userName();
			State = 4512;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4508; Match(COMMA);
				State = 4509; _localctx._userName = userName();
				_localctx._toOther.Add(_localctx._userName);
				}
				}
				State = 4514;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 4518;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 4515; Match(WITH);
				State = 4516; Match(GRANT);
				State = 4517; Match(OPTION);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameUserContext : ParserRuleContext {
		public ITerminalNode RENAME() { return GetToken(MySqlParser.RENAME, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public RenameUserClauseContext[] renameUserClause() {
			return GetRuleContexts<RenameUserClauseContext>();
		}
		public RenameUserClauseContext renameUserClause(int i) {
			return GetRuleContext<RenameUserClauseContext>(i);
		}
		public RenameUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameUser; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRenameUser(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRenameUser(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRenameUser(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RenameUserContext renameUser() {
		RenameUserContext _localctx = new RenameUserContext(Context, State);
		EnterRule(_localctx, 392, RULE_renameUser);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4520; Match(RENAME);
			State = 4521; Match(USER);
			State = 4522; renameUserClause();
			State = 4527;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4523; Match(COMMA);
				State = 4524; renameUserClause();
				}
				}
				State = 4529;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RevokeStatementContext : ParserRuleContext {
		public RevokeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_revokeStatement; } }
	 
		public RevokeStatementContext() { }
		public virtual void CopyFrom(RevokeStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DetailRevokeContext : RevokeStatementContext {
		public IToken privilegeObject;
		public ITerminalNode REVOKE() { return GetToken(MySqlParser.REVOKE, 0); }
		public PrivelegeClauseContext[] privelegeClause() {
			return GetRuleContexts<PrivelegeClauseContext>();
		}
		public PrivelegeClauseContext privelegeClause(int i) {
			return GetRuleContext<PrivelegeClauseContext>(i);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public PrivilegeLevelContext privilegeLevel() {
			return GetRuleContext<PrivilegeLevelContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public UserNameContext[] userName() {
			return GetRuleContexts<UserNameContext>();
		}
		public UserNameContext userName(int i) {
			return GetRuleContext<UserNameContext>(i);
		}
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public DetailRevokeContext(RevokeStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDetailRevoke(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDetailRevoke(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDetailRevoke(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShortRevokeContext : RevokeStatementContext {
		public ITerminalNode REVOKE() { return GetToken(MySqlParser.REVOKE, 0); }
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode GRANT() { return GetToken(MySqlParser.GRANT, 0); }
		public ITerminalNode OPTION() { return GetToken(MySqlParser.OPTION, 0); }
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public UserNameContext[] userName() {
			return GetRuleContexts<UserNameContext>();
		}
		public UserNameContext userName(int i) {
			return GetRuleContext<UserNameContext>(i);
		}
		public ITerminalNode PRIVILEGES() { return GetToken(MySqlParser.PRIVILEGES, 0); }
		public ShortRevokeContext(RevokeStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShortRevoke(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShortRevoke(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortRevoke(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RevokeStatementContext revokeStatement() {
		RevokeStatementContext _localctx = new RevokeStatementContext(Context, State);
		EnterRule(_localctx, 394, RULE_revokeStatement);
		int _la;
		try {
			State = 4570;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,666,Context) ) {
			case 1:
				_localctx = new DetailRevokeContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4530; Match(REVOKE);
				State = 4531; privelegeClause();
				State = 4536;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4532; Match(COMMA);
					State = 4533; privelegeClause();
					}
					}
					State = 4538;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4539; Match(ON);
				State = 4541;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,662,Context) ) {
				case 1:
					{
					State = 4540;
					((DetailRevokeContext)_localctx).privilegeObject = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==PROCEDURE || _la==TABLE || _la==FUNCTION) ) {
						((DetailRevokeContext)_localctx).privilegeObject = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 4543; privilegeLevel();
				State = 4544; Match(FROM);
				State = 4545; userName();
				State = 4550;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4546; Match(COMMA);
					State = 4547; userName();
					}
					}
					State = 4552;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new ShortRevokeContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4553; Match(REVOKE);
				State = 4554; Match(ALL);
				State = 4556;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PRIVILEGES) {
					{
					State = 4555; Match(PRIVILEGES);
					}
				}

				State = 4558; Match(COMMA);
				State = 4559; Match(GRANT);
				State = 4560; Match(OPTION);
				State = 4561; Match(FROM);
				State = 4562; userName();
				State = 4567;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4563; Match(COMMA);
					State = 4564; userName();
					}
					}
					State = 4569;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RevokeProxyContext : ParserRuleContext {
		public UserNameContext onUser;
		public UserNameContext fromFirst;
		public UserNameContext _userName;
		public IList<UserNameContext> _fromOther = new List<UserNameContext>();
		public ITerminalNode REVOKE() { return GetToken(MySqlParser.REVOKE, 0); }
		public ITerminalNode PROXY() { return GetToken(MySqlParser.PROXY, 0); }
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public UserNameContext[] userName() {
			return GetRuleContexts<UserNameContext>();
		}
		public UserNameContext userName(int i) {
			return GetRuleContext<UserNameContext>(i);
		}
		public RevokeProxyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_revokeProxy; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRevokeProxy(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRevokeProxy(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRevokeProxy(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RevokeProxyContext revokeProxy() {
		RevokeProxyContext _localctx = new RevokeProxyContext(Context, State);
		EnterRule(_localctx, 396, RULE_revokeProxy);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4572; Match(REVOKE);
			State = 4573; Match(PROXY);
			State = 4574; Match(ON);
			State = 4575; _localctx.onUser = userName();
			State = 4576; Match(FROM);
			State = 4577; _localctx.fromFirst = userName();
			State = 4582;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4578; Match(COMMA);
				State = 4579; _localctx._userName = userName();
				_localctx._fromOther.Add(_localctx._userName);
				}
				}
				State = 4584;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetPasswordStatementContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public PasswordFunctionClauseContext passwordFunctionClause() {
			return GetRuleContext<PasswordFunctionClauseContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public SetPasswordStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setPasswordStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetPasswordStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetPasswordStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetPasswordStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SetPasswordStatementContext setPasswordStatement() {
		SetPasswordStatementContext _localctx = new SetPasswordStatementContext(Context, State);
		EnterRule(_localctx, 398, RULE_setPasswordStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4585; Match(SET);
			State = 4586; Match(PASSWORD);
			State = 4589;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 4587; Match(FOR);
				State = 4588; userName();
				}
			}

			State = 4591; Match(EQUAL_SYMBOL);
			State = 4594;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case OLD_PASSWORD:
			case PASSWORD:
				{
				State = 4592; passwordFunctionClause();
				}
				break;
			case STRING_LITERAL:
				{
				State = 4593; Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserSpecificationContext : ParserRuleContext {
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public UserPasswordOptionContext userPasswordOption() {
			return GetRuleContext<UserPasswordOptionContext>(0);
		}
		public UserSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userSpecification; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserSpecification(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserSpecification(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUserSpecification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UserSpecificationContext userSpecification() {
		UserSpecificationContext _localctx = new UserSpecificationContext(Context, State);
		EnterRule(_localctx, 400, RULE_userSpecification);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4596; userName();
			State = 4597; userPasswordOption();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserAuthOptionContext : ParserRuleContext {
		public UserAuthOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userAuthOption; } }
	 
		public UserAuthOptionContext() { }
		public virtual void CopyFrom(UserAuthOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SimpleAuthOptionContext : UserAuthOptionContext {
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public SimpleAuthOptionContext(UserAuthOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleAuthOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleAuthOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleAuthOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PasswordAuthOptionContext : UserAuthOptionContext {
		public IToken hashed;
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public ITerminalNode IDENTIFIED() { return GetToken(MySqlParser.IDENTIFIED, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public PasswordAuthOptionContext(UserAuthOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPasswordAuthOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPasswordAuthOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPasswordAuthOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StringAuthOptionContext : UserAuthOptionContext {
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public ITerminalNode IDENTIFIED() { return GetToken(MySqlParser.IDENTIFIED, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public AuthPluginContext authPlugin() {
			return GetRuleContext<AuthPluginContext>(0);
		}
		public StringAuthOptionContext(UserAuthOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStringAuthOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStringAuthOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringAuthOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class HashAuthOptionContext : UserAuthOptionContext {
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public ITerminalNode IDENTIFIED() { return GetToken(MySqlParser.IDENTIFIED, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public AuthPluginContext authPlugin() {
			return GetRuleContext<AuthPluginContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public HashAuthOptionContext(UserAuthOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHashAuthOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHashAuthOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHashAuthOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UserAuthOptionContext userAuthOption() {
		UserAuthOptionContext _localctx = new UserAuthOptionContext(Context, State);
		EnterRule(_localctx, 402, RULE_userAuthOption);
		int _la;
		try {
			State = 4623;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,672,Context) ) {
			case 1:
				_localctx = new PasswordAuthOptionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4599; userName();
				State = 4600; Match(IDENTIFIED);
				State = 4601; Match(BY);
				State = 4602; Match(PASSWORD);
				State = 4603; ((PasswordAuthOptionContext)_localctx).hashed = Match(STRING_LITERAL);
				}
				break;
			case 2:
				_localctx = new StringAuthOptionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4605; userName();
				State = 4606; Match(IDENTIFIED);
				State = 4609;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH) {
					{
					State = 4607; Match(WITH);
					State = 4608; authPlugin();
					}
				}

				State = 4611; Match(BY);
				State = 4612; Match(STRING_LITERAL);
				}
				break;
			case 3:
				_localctx = new HashAuthOptionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 4614; userName();
				State = 4615; Match(IDENTIFIED);
				State = 4616; Match(WITH);
				State = 4617; authPlugin();
				State = 4620;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 4618; Match(AS);
					State = 4619; Match(STRING_LITERAL);
					}
				}

				}
				break;
			case 4:
				_localctx = new SimpleAuthOptionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 4622; userName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TlsOptionContext : ParserRuleContext {
		public ITerminalNode SSL() { return GetToken(MySqlParser.SSL, 0); }
		public ITerminalNode X509() { return GetToken(MySqlParser.X509, 0); }
		public ITerminalNode CIPHER() { return GetToken(MySqlParser.CIPHER, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode ISSUER() { return GetToken(MySqlParser.ISSUER, 0); }
		public ITerminalNode SUBJECT() { return GetToken(MySqlParser.SUBJECT, 0); }
		public TlsOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tlsOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTlsOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTlsOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTlsOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TlsOptionContext tlsOption() {
		TlsOptionContext _localctx = new TlsOptionContext(Context, State);
		EnterRule(_localctx, 404, RULE_tlsOption);
		try {
			State = 4633;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SSL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4625; Match(SSL);
				}
				break;
			case X509:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4626; Match(X509);
				}
				break;
			case CIPHER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4627; Match(CIPHER);
				State = 4628; Match(STRING_LITERAL);
				}
				break;
			case ISSUER:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4629; Match(ISSUER);
				State = 4630; Match(STRING_LITERAL);
				}
				break;
			case SUBJECT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4631; Match(SUBJECT);
				State = 4632; Match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserResourceOptionContext : ParserRuleContext {
		public ITerminalNode MAX_QUERIES_PER_HOUR() { return GetToken(MySqlParser.MAX_QUERIES_PER_HOUR, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode MAX_UPDATES_PER_HOUR() { return GetToken(MySqlParser.MAX_UPDATES_PER_HOUR, 0); }
		public ITerminalNode MAX_CONNECTIONS_PER_HOUR() { return GetToken(MySqlParser.MAX_CONNECTIONS_PER_HOUR, 0); }
		public ITerminalNode MAX_USER_CONNECTIONS() { return GetToken(MySqlParser.MAX_USER_CONNECTIONS, 0); }
		public UserResourceOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userResourceOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserResourceOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserResourceOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUserResourceOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UserResourceOptionContext userResourceOption() {
		UserResourceOptionContext _localctx = new UserResourceOptionContext(Context, State);
		EnterRule(_localctx, 406, RULE_userResourceOption);
		try {
			State = 4643;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MAX_QUERIES_PER_HOUR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4635; Match(MAX_QUERIES_PER_HOUR);
				State = 4636; decimalLiteral();
				}
				break;
			case MAX_UPDATES_PER_HOUR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4637; Match(MAX_UPDATES_PER_HOUR);
				State = 4638; decimalLiteral();
				}
				break;
			case MAX_CONNECTIONS_PER_HOUR:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4639; Match(MAX_CONNECTIONS_PER_HOUR);
				State = 4640; decimalLiteral();
				}
				break;
			case MAX_USER_CONNECTIONS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4641; Match(MAX_USER_CONNECTIONS);
				State = 4642; decimalLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserPasswordOptionContext : ParserRuleContext {
		public IToken expireType;
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode EXPIRE() { return GetToken(MySqlParser.EXPIRE, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode DAY() { return GetToken(MySqlParser.DAY, 0); }
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode NEVER() { return GetToken(MySqlParser.NEVER, 0); }
		public ITerminalNode INTERVAL() { return GetToken(MySqlParser.INTERVAL, 0); }
		public UserPasswordOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userPasswordOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserPasswordOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserPasswordOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUserPasswordOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UserPasswordOptionContext userPasswordOption() {
		UserPasswordOptionContext _localctx = new UserPasswordOptionContext(Context, State);
		EnterRule(_localctx, 408, RULE_userPasswordOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4645; Match(PASSWORD);
			State = 4646; Match(EXPIRE);
			State = 4653;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
				{
				State = 4647; _localctx.expireType = Match(DEFAULT);
				}
				break;
			case NEVER:
				{
				State = 4648; _localctx.expireType = Match(NEVER);
				}
				break;
			case INTERVAL:
				{
				State = 4649; _localctx.expireType = Match(INTERVAL);
				State = 4650; decimalLiteral();
				State = 4651; Match(DAY);
				}
				break;
			case Eof:
			case ALTER:
			case ANALYZE:
			case CALL:
			case CHANGE:
			case CHECK:
			case CREATE:
			case DELETE:
			case DESC:
			case DESCRIBE:
			case DROP:
			case EXPLAIN:
			case GRANT:
			case INSERT:
			case KILL:
			case LOAD:
			case LOCK:
			case OPTIMIZE:
			case PURGE:
			case RELEASE:
			case RENAME:
			case REPLACE:
			case REVOKE:
			case SELECT:
			case SET:
			case SHOW:
			case SIGNAL:
			case UNLOCK:
			case UPDATE:
			case USE:
			case ACCOUNT:
			case BEGIN:
			case BINLOG:
			case CACHE:
			case CHECKSUM:
			case COMMIT:
			case DEALLOCATE:
			case DO:
			case FLUSH:
			case HANDLER:
			case HELP:
			case INSTALL:
			case PASSWORD:
			case PREPARE:
			case REPAIR:
			case RESET:
			case ROLLBACK:
			case SAVEPOINT:
			case START:
			case STOP:
			case TRUNCATE:
			case UNINSTALL:
			case XA:
			case EXECUTE:
			case SHUTDOWN:
			case MINUSMINUS:
			case LR_BRACKET:
			case COMMA:
			case SEMI:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserLockOptionContext : ParserRuleContext {
		public IToken lockType;
		public ITerminalNode ACCOUNT() { return GetToken(MySqlParser.ACCOUNT, 0); }
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode UNLOCK() { return GetToken(MySqlParser.UNLOCK, 0); }
		public UserLockOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userLockOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserLockOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserLockOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUserLockOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UserLockOptionContext userLockOption() {
		UserLockOptionContext _localctx = new UserLockOptionContext(Context, State);
		EnterRule(_localctx, 410, RULE_userLockOption);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4655; Match(ACCOUNT);
			State = 4656;
			_localctx.lockType = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==LOCK || _la==UNLOCK) ) {
				_localctx.lockType = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrivelegeClauseContext : ParserRuleContext {
		public PrivilegeContext privilege() {
			return GetRuleContext<PrivilegeContext>(0);
		}
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public PrivelegeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_privelegeClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPrivelegeClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPrivelegeClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrivelegeClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrivelegeClauseContext privelegeClause() {
		PrivelegeClauseContext _localctx = new PrivelegeClauseContext(Context, State);
		EnterRule(_localctx, 412, RULE_privelegeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4658; privilege();
			State = 4663;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LR_BRACKET) {
				{
				State = 4659; Match(LR_BRACKET);
				State = 4660; uidList();
				State = 4661; Match(RR_BRACKET);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrivilegeContext : ParserRuleContext {
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode PRIVILEGES() { return GetToken(MySqlParser.PRIVILEGES, 0); }
		public ITerminalNode ALTER() { return GetToken(MySqlParser.ALTER, 0); }
		public ITerminalNode ROUTINE() { return GetToken(MySqlParser.ROUTINE, 0); }
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode TEMPORARY() { return GetToken(MySqlParser.TEMPORARY, 0); }
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public ITerminalNode VIEW() { return GetToken(MySqlParser.VIEW, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public ITerminalNode DELETE() { return GetToken(MySqlParser.DELETE, 0); }
		public ITerminalNode DROP() { return GetToken(MySqlParser.DROP, 0); }
		public ITerminalNode EVENT() { return GetToken(MySqlParser.EVENT, 0); }
		public ITerminalNode EXECUTE() { return GetToken(MySqlParser.EXECUTE, 0); }
		public ITerminalNode FILE() { return GetToken(MySqlParser.FILE, 0); }
		public ITerminalNode GRANT() { return GetToken(MySqlParser.GRANT, 0); }
		public ITerminalNode OPTION() { return GetToken(MySqlParser.OPTION, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode INSERT() { return GetToken(MySqlParser.INSERT, 0); }
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode PROCESS() { return GetToken(MySqlParser.PROCESS, 0); }
		public ITerminalNode PROXY() { return GetToken(MySqlParser.PROXY, 0); }
		public ITerminalNode REFERENCES() { return GetToken(MySqlParser.REFERENCES, 0); }
		public ITerminalNode RELOAD() { return GetToken(MySqlParser.RELOAD, 0); }
		public ITerminalNode REPLICATION() { return GetToken(MySqlParser.REPLICATION, 0); }
		public ITerminalNode CLIENT() { return GetToken(MySqlParser.CLIENT, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ITerminalNode SELECT() { return GetToken(MySqlParser.SELECT, 0); }
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode DATABASES() { return GetToken(MySqlParser.DATABASES, 0); }
		public ITerminalNode SHUTDOWN() { return GetToken(MySqlParser.SHUTDOWN, 0); }
		public ITerminalNode SUPER() { return GetToken(MySqlParser.SUPER, 0); }
		public ITerminalNode TRIGGER() { return GetToken(MySqlParser.TRIGGER, 0); }
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public ITerminalNode USAGE() { return GetToken(MySqlParser.USAGE, 0); }
		public ITerminalNode SESSION_VARIABLES_ADMIN() { return GetToken(MySqlParser.SESSION_VARIABLES_ADMIN, 0); }
		public PrivilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_privilege; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPrivilege(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPrivilege(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrivilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrivilegeContext privilege() {
		PrivilegeContext _localctx = new PrivilegeContext(Context, State);
		EnterRule(_localctx, 414, RULE_privilege);
		int _la;
		try {
			State = 4708;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4665; Match(ALL);
				State = 4667;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PRIVILEGES) {
					{
					State = 4666; Match(PRIVILEGES);
					}
				}

				}
				break;
			case ALTER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4669; Match(ALTER);
				State = 4671;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ROUTINE) {
					{
					State = 4670; Match(ROUTINE);
					}
				}

				}
				break;
			case CREATE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4673; Match(CREATE);
				State = 4680;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TEMPORARY:
					{
					State = 4674; Match(TEMPORARY);
					State = 4675; Match(TABLES);
					}
					break;
				case ROUTINE:
					{
					State = 4676; Match(ROUTINE);
					}
					break;
				case VIEW:
					{
					State = 4677; Match(VIEW);
					}
					break;
				case USER:
					{
					State = 4678; Match(USER);
					}
					break;
				case TABLESPACE:
					{
					State = 4679; Match(TABLESPACE);
					}
					break;
				case ON:
				case LR_BRACKET:
				case COMMA:
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case DELETE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4682; Match(DELETE);
				}
				break;
			case DROP:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4683; Match(DROP);
				}
				break;
			case EVENT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4684; Match(EVENT);
				}
				break;
			case EXECUTE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 4685; Match(EXECUTE);
				}
				break;
			case FILE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 4686; Match(FILE);
				}
				break;
			case GRANT:
				EnterOuterAlt(_localctx, 9);
				{
				State = 4687; Match(GRANT);
				State = 4688; Match(OPTION);
				}
				break;
			case INDEX:
				EnterOuterAlt(_localctx, 10);
				{
				State = 4689; Match(INDEX);
				}
				break;
			case INSERT:
				EnterOuterAlt(_localctx, 11);
				{
				State = 4690; Match(INSERT);
				}
				break;
			case LOCK:
				EnterOuterAlt(_localctx, 12);
				{
				State = 4691; Match(LOCK);
				State = 4692; Match(TABLES);
				}
				break;
			case PROCESS:
				EnterOuterAlt(_localctx, 13);
				{
				State = 4693; Match(PROCESS);
				}
				break;
			case PROXY:
				EnterOuterAlt(_localctx, 14);
				{
				State = 4694; Match(PROXY);
				}
				break;
			case REFERENCES:
				EnterOuterAlt(_localctx, 15);
				{
				State = 4695; Match(REFERENCES);
				}
				break;
			case RELOAD:
				EnterOuterAlt(_localctx, 16);
				{
				State = 4696; Match(RELOAD);
				}
				break;
			case REPLICATION:
				EnterOuterAlt(_localctx, 17);
				{
				State = 4697; Match(REPLICATION);
				State = 4698;
				_la = TokenStream.LA(1);
				if ( !(_la==CLIENT || _la==SLAVE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case SELECT:
				EnterOuterAlt(_localctx, 18);
				{
				State = 4699; Match(SELECT);
				}
				break;
			case SHOW:
				EnterOuterAlt(_localctx, 19);
				{
				State = 4700; Match(SHOW);
				State = 4701;
				_la = TokenStream.LA(1);
				if ( !(_la==DATABASES || _la==VIEW) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case SHUTDOWN:
				EnterOuterAlt(_localctx, 20);
				{
				State = 4702; Match(SHUTDOWN);
				}
				break;
			case SUPER:
				EnterOuterAlt(_localctx, 21);
				{
				State = 4703; Match(SUPER);
				}
				break;
			case TRIGGER:
				EnterOuterAlt(_localctx, 22);
				{
				State = 4704; Match(TRIGGER);
				}
				break;
			case UPDATE:
				EnterOuterAlt(_localctx, 23);
				{
				State = 4705; Match(UPDATE);
				}
				break;
			case USAGE:
				EnterOuterAlt(_localctx, 24);
				{
				State = 4706; Match(USAGE);
				}
				break;
			case SESSION_VARIABLES_ADMIN:
				EnterOuterAlt(_localctx, 25);
				{
				State = 4707; Match(SESSION_VARIABLES_ADMIN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrivilegeLevelContext : ParserRuleContext {
		public PrivilegeLevelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_privilegeLevel; } }
	 
		public PrivilegeLevelContext() { }
		public virtual void CopyFrom(PrivilegeLevelContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DefiniteSchemaPrivLevelContext : PrivilegeLevelContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DefiniteSchemaPrivLevelContext(PrivilegeLevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDefiniteSchemaPrivLevel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDefiniteSchemaPrivLevel(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefiniteSchemaPrivLevel(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DefiniteFullTablePrivLevel2Context : PrivilegeLevelContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DottedIdContext dottedId() {
			return GetRuleContext<DottedIdContext>(0);
		}
		public DefiniteFullTablePrivLevel2Context(PrivilegeLevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDefiniteFullTablePrivLevel2(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDefiniteFullTablePrivLevel2(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefiniteFullTablePrivLevel2(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DefiniteFullTablePrivLevelContext : PrivilegeLevelContext {
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public DefiniteFullTablePrivLevelContext(PrivilegeLevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDefiniteFullTablePrivLevel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDefiniteFullTablePrivLevel(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefiniteFullTablePrivLevel(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class GlobalPrivLevelContext : PrivilegeLevelContext {
		public GlobalPrivLevelContext(PrivilegeLevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGlobalPrivLevel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGlobalPrivLevel(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGlobalPrivLevel(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DefiniteTablePrivLevelContext : PrivilegeLevelContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DefiniteTablePrivLevelContext(PrivilegeLevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDefiniteTablePrivLevel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDefiniteTablePrivLevel(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefiniteTablePrivLevel(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CurrentSchemaPriviLevelContext : PrivilegeLevelContext {
		public CurrentSchemaPriviLevelContext(PrivilegeLevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCurrentSchemaPriviLevel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCurrentSchemaPriviLevel(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCurrentSchemaPriviLevel(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrivilegeLevelContext privilegeLevel() {
		PrivilegeLevelContext _localctx = new PrivilegeLevelContext(Context, State);
		EnterRule(_localctx, 416, RULE_privilegeLevel);
		try {
			State = 4726;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,681,Context) ) {
			case 1:
				_localctx = new CurrentSchemaPriviLevelContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4710; Match(STAR);
				}
				break;
			case 2:
				_localctx = new GlobalPrivLevelContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4711; Match(STAR);
				State = 4712; Match(DOT);
				State = 4713; Match(STAR);
				}
				break;
			case 3:
				_localctx = new DefiniteSchemaPrivLevelContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 4714; uid();
				State = 4715; Match(DOT);
				State = 4716; Match(STAR);
				}
				break;
			case 4:
				_localctx = new DefiniteFullTablePrivLevelContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 4718; uid();
				State = 4719; Match(DOT);
				State = 4720; uid();
				}
				break;
			case 5:
				_localctx = new DefiniteFullTablePrivLevel2Context(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 4722; uid();
				State = 4723; dottedId();
				}
				break;
			case 6:
				_localctx = new DefiniteTablePrivLevelContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 4725; uid();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameUserClauseContext : ParserRuleContext {
		public UserNameContext fromFirst;
		public UserNameContext toFirst;
		public ITerminalNode TO() { return GetToken(MySqlParser.TO, 0); }
		public UserNameContext[] userName() {
			return GetRuleContexts<UserNameContext>();
		}
		public UserNameContext userName(int i) {
			return GetRuleContext<UserNameContext>(i);
		}
		public RenameUserClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameUserClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRenameUserClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRenameUserClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRenameUserClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RenameUserClauseContext renameUserClause() {
		RenameUserClauseContext _localctx = new RenameUserClauseContext(Context, State);
		EnterRule(_localctx, 418, RULE_renameUserClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4728; _localctx.fromFirst = userName();
			State = 4729; Match(TO);
			State = 4730; _localctx.toFirst = userName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AnalyzeTableContext : ParserRuleContext {
		public IToken actionOption;
		public ITerminalNode ANALYZE() { return GetToken(MySqlParser.ANALYZE, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public ITerminalNode NO_WRITE_TO_BINLOG() { return GetToken(MySqlParser.NO_WRITE_TO_BINLOG, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public AnalyzeTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_analyzeTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAnalyzeTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAnalyzeTable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnalyzeTable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AnalyzeTableContext analyzeTable() {
		AnalyzeTableContext _localctx = new AnalyzeTableContext(Context, State);
		EnterRule(_localctx, 420, RULE_analyzeTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4732; Match(ANALYZE);
			State = 4734;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NO_WRITE_TO_BINLOG || _la==LOCAL) {
				{
				State = 4733;
				_localctx.actionOption = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==NO_WRITE_TO_BINLOG || _la==LOCAL) ) {
					_localctx.actionOption = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 4736; Match(TABLE);
			State = 4737; tables();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CheckTableContext : ParserRuleContext {
		public ITerminalNode CHECK() { return GetToken(MySqlParser.CHECK, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public CheckTableOptionContext[] checkTableOption() {
			return GetRuleContexts<CheckTableOptionContext>();
		}
		public CheckTableOptionContext checkTableOption(int i) {
			return GetRuleContext<CheckTableOptionContext>(i);
		}
		public CheckTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_checkTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCheckTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCheckTable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCheckTable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CheckTableContext checkTable() {
		CheckTableContext _localctx = new CheckTableContext(Context, State);
		EnterRule(_localctx, 422, RULE_checkTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4739; Match(CHECK);
			State = 4740; Match(TABLE);
			State = 4741; tables();
			State = 4745;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==FOR || _la==CHANGED || _la==EXTENDED || _la==FAST || _la==MEDIUM || _la==QUICK) {
				{
				{
				State = 4742; checkTableOption();
				}
				}
				State = 4747;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ChecksumTableContext : ParserRuleContext {
		public IToken actionOption;
		public ITerminalNode CHECKSUM() { return GetToken(MySqlParser.CHECKSUM, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public ITerminalNode QUICK() { return GetToken(MySqlParser.QUICK, 0); }
		public ITerminalNode EXTENDED() { return GetToken(MySqlParser.EXTENDED, 0); }
		public ChecksumTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_checksumTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterChecksumTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitChecksumTable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChecksumTable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ChecksumTableContext checksumTable() {
		ChecksumTableContext _localctx = new ChecksumTableContext(Context, State);
		EnterRule(_localctx, 424, RULE_checksumTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4748; Match(CHECKSUM);
			State = 4749; Match(TABLE);
			State = 4750; tables();
			State = 4752;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXTENDED || _la==QUICK) {
				{
				State = 4751;
				_localctx.actionOption = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==EXTENDED || _la==QUICK) ) {
					_localctx.actionOption = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptimizeTableContext : ParserRuleContext {
		public IToken actionOption;
		public ITerminalNode OPTIMIZE() { return GetToken(MySqlParser.OPTIMIZE, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public ITerminalNode NO_WRITE_TO_BINLOG() { return GetToken(MySqlParser.NO_WRITE_TO_BINLOG, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public OptimizeTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optimizeTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterOptimizeTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitOptimizeTable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptimizeTable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptimizeTableContext optimizeTable() {
		OptimizeTableContext _localctx = new OptimizeTableContext(Context, State);
		EnterRule(_localctx, 426, RULE_optimizeTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4754; Match(OPTIMIZE);
			State = 4756;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NO_WRITE_TO_BINLOG || _la==LOCAL) {
				{
				State = 4755;
				_localctx.actionOption = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==NO_WRITE_TO_BINLOG || _la==LOCAL) ) {
					_localctx.actionOption = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 4758; Match(TABLE);
			State = 4759; tables();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RepairTableContext : ParserRuleContext {
		public IToken actionOption;
		public ITerminalNode REPAIR() { return GetToken(MySqlParser.REPAIR, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public ITerminalNode QUICK() { return GetToken(MySqlParser.QUICK, 0); }
		public ITerminalNode EXTENDED() { return GetToken(MySqlParser.EXTENDED, 0); }
		public ITerminalNode USE_FRM() { return GetToken(MySqlParser.USE_FRM, 0); }
		public ITerminalNode NO_WRITE_TO_BINLOG() { return GetToken(MySqlParser.NO_WRITE_TO_BINLOG, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public RepairTableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_repairTable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRepairTable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRepairTable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRepairTable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RepairTableContext repairTable() {
		RepairTableContext _localctx = new RepairTableContext(Context, State);
		EnterRule(_localctx, 428, RULE_repairTable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4761; Match(REPAIR);
			State = 4763;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NO_WRITE_TO_BINLOG || _la==LOCAL) {
				{
				State = 4762;
				_localctx.actionOption = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==NO_WRITE_TO_BINLOG || _la==LOCAL) ) {
					_localctx.actionOption = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 4765; Match(TABLE);
			State = 4766; tables();
			State = 4768;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==QUICK) {
				{
				State = 4767; Match(QUICK);
				}
			}

			State = 4771;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXTENDED) {
				{
				State = 4770; Match(EXTENDED);
				}
			}

			State = 4774;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USE_FRM) {
				{
				State = 4773; Match(USE_FRM);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CheckTableOptionContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode UPGRADE() { return GetToken(MySqlParser.UPGRADE, 0); }
		public ITerminalNode QUICK() { return GetToken(MySqlParser.QUICK, 0); }
		public ITerminalNode FAST() { return GetToken(MySqlParser.FAST, 0); }
		public ITerminalNode MEDIUM() { return GetToken(MySqlParser.MEDIUM, 0); }
		public ITerminalNode EXTENDED() { return GetToken(MySqlParser.EXTENDED, 0); }
		public ITerminalNode CHANGED() { return GetToken(MySqlParser.CHANGED, 0); }
		public CheckTableOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_checkTableOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCheckTableOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCheckTableOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCheckTableOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CheckTableOptionContext checkTableOption() {
		CheckTableOptionContext _localctx = new CheckTableOptionContext(Context, State);
		EnterRule(_localctx, 430, RULE_checkTableOption);
		try {
			State = 4783;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FOR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4776; Match(FOR);
				State = 4777; Match(UPGRADE);
				}
				break;
			case QUICK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4778; Match(QUICK);
				}
				break;
			case FAST:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4779; Match(FAST);
				}
				break;
			case MEDIUM:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4780; Match(MEDIUM);
				}
				break;
			case EXTENDED:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4781; Match(EXTENDED);
				}
				break;
			case CHANGED:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4782; Match(CHANGED);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUdfunctionContext : ParserRuleContext {
		public IToken returnType;
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode RETURNS() { return GetToken(MySqlParser.RETURNS, 0); }
		public ITerminalNode SONAME() { return GetToken(MySqlParser.SONAME, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode STRING() { return GetToken(MySqlParser.STRING, 0); }
		public ITerminalNode INTEGER() { return GetToken(MySqlParser.INTEGER, 0); }
		public ITerminalNode REAL() { return GetToken(MySqlParser.REAL, 0); }
		public ITerminalNode DECIMAL() { return GetToken(MySqlParser.DECIMAL, 0); }
		public ITerminalNode AGGREGATE() { return GetToken(MySqlParser.AGGREGATE, 0); }
		public CreateUdfunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUdfunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCreateUdfunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCreateUdfunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateUdfunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateUdfunctionContext createUdfunction() {
		CreateUdfunctionContext _localctx = new CreateUdfunctionContext(Context, State);
		EnterRule(_localctx, 432, RULE_createUdfunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4785; Match(CREATE);
			State = 4787;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AGGREGATE) {
				{
				State = 4786; Match(AGGREGATE);
				}
			}

			State = 4789; Match(FUNCTION);
			State = 4790; uid();
			State = 4791; Match(RETURNS);
			State = 4792;
			_localctx.returnType = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(((((_la - 176)) & ~0x3f) == 0 && ((1L << (_la - 176)) & ((1L << (INTEGER - 176)) | (1L << (REAL - 176)) | (1L << (DECIMAL - 176)))) != 0) || _la==STRING) ) {
				_localctx.returnType = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4793; Match(SONAME);
			State = 4794; Match(STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InstallPluginContext : ParserRuleContext {
		public ITerminalNode INSTALL() { return GetToken(MySqlParser.INSTALL, 0); }
		public ITerminalNode PLUGIN() { return GetToken(MySqlParser.PLUGIN, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode SONAME() { return GetToken(MySqlParser.SONAME, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public InstallPluginContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_installPlugin; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterInstallPlugin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitInstallPlugin(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstallPlugin(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InstallPluginContext installPlugin() {
		InstallPluginContext _localctx = new InstallPluginContext(Context, State);
		EnterRule(_localctx, 434, RULE_installPlugin);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4796; Match(INSTALL);
			State = 4797; Match(PLUGIN);
			State = 4798; uid();
			State = 4799; Match(SONAME);
			State = 4800; Match(STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UninstallPluginContext : ParserRuleContext {
		public ITerminalNode UNINSTALL() { return GetToken(MySqlParser.UNINSTALL, 0); }
		public ITerminalNode PLUGIN() { return GetToken(MySqlParser.PLUGIN, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public UninstallPluginContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uninstallPlugin; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUninstallPlugin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUninstallPlugin(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUninstallPlugin(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UninstallPluginContext uninstallPlugin() {
		UninstallPluginContext _localctx = new UninstallPluginContext(Context, State);
		EnterRule(_localctx, 436, RULE_uninstallPlugin);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4802; Match(UNINSTALL);
			State = 4803; Match(PLUGIN);
			State = 4804; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetStatementContext : ParserRuleContext {
		public SetStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setStatement; } }
	 
		public SetStatementContext() { }
		public virtual void CopyFrom(SetStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SetTransactionContext : SetStatementContext {
		public SetTransactionStatementContext setTransactionStatement() {
			return GetRuleContext<SetTransactionStatementContext>(0);
		}
		public SetTransactionContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetTransaction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetTransaction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetTransaction(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SetCharsetContext : SetStatementContext {
		public ITerminalNode[] SET() { return GetTokens(MySqlParser.SET); }
		public ITerminalNode SET(int i) {
			return GetToken(MySqlParser.SET, i);
		}
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public SetCharsetContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetCharset(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetCharset(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetCharset(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SetNamesContext : SetStatementContext {
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode NAMES() { return GetToken(MySqlParser.NAMES, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public SetNamesContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetNames(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetNames(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetNames(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SetPasswordContext : SetStatementContext {
		public SetPasswordStatementContext setPasswordStatement() {
			return GetRuleContext<SetPasswordStatementContext>(0);
		}
		public SetPasswordContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetPassword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetPassword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetPassword(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SetAutocommitContext : SetStatementContext {
		public SetAutocommitStatementContext setAutocommitStatement() {
			return GetRuleContext<SetAutocommitStatementContext>(0);
		}
		public SetAutocommitContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetAutocommit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetAutocommit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetAutocommit(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SetNewValueInsideTriggerContext : SetStatementContext {
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SetNewValueInsideTriggerContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetNewValueInsideTrigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetNewValueInsideTrigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetNewValueInsideTrigger(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SetVariableContext : SetStatementContext {
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public VariableClauseContext[] variableClause() {
			return GetRuleContexts<VariableClauseContext>();
		}
		public VariableClauseContext variableClause(int i) {
			return GetRuleContext<VariableClauseContext>(i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public SetVariableContext(SetStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSetVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSetVariable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetVariable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SetStatementContext setStatement() {
		SetStatementContext _localctx = new SetStatementContext(Context, State);
		EnterRule(_localctx, 438, RULE_setStatement);
		int _la;
		try {
			State = 4848;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,697,Context) ) {
			case 1:
				_localctx = new SetVariableContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4806; Match(SET);
				State = 4807; variableClause();
				State = 4808;
				_la = TokenStream.LA(1);
				if ( !(_la==VAR_ASSIGN || _la==EQUAL_SYMBOL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4809; expression(0);
				State = 4817;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4810; Match(COMMA);
					State = 4811; variableClause();
					State = 4812;
					_la = TokenStream.LA(1);
					if ( !(_la==VAR_ASSIGN || _la==EQUAL_SYMBOL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 4813; expression(0);
					}
					}
					State = 4819;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new SetCharsetContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4820; Match(SET);
				State = 4824;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case CHARACTER:
					{
					State = 4821; Match(CHARACTER);
					State = 4822; Match(SET);
					}
					break;
				case CHARSET:
					{
					State = 4823; Match(CHARSET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4828;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case BINARY:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
					{
					State = 4826; charsetName();
					}
					break;
				case DEFAULT:
					{
					State = 4827; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 3:
				_localctx = new SetNamesContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 4830; Match(SET);
				State = 4831; Match(NAMES);
				State = 4838;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case BINARY:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
					{
					State = 4832; charsetName();
					State = 4835;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COLLATE) {
						{
						State = 4833; Match(COLLATE);
						State = 4834; collationName();
						}
					}

					}
					break;
				case DEFAULT:
					{
					State = 4837; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 4:
				_localctx = new SetPasswordContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 4840; setPasswordStatement();
				}
				break;
			case 5:
				_localctx = new SetTransactionContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 4841; setTransactionStatement();
				}
				break;
			case 6:
				_localctx = new SetAutocommitContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 4842; setAutocommitStatement();
				}
				break;
			case 7:
				_localctx = new SetNewValueInsideTriggerContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 4843; Match(SET);
				State = 4844; fullId();
				State = 4845;
				_la = TokenStream.LA(1);
				if ( !(_la==VAR_ASSIGN || _la==EQUAL_SYMBOL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4846; expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowStatementContext : ParserRuleContext {
		public ShowStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showStatement; } }
	 
		public ShowStatementContext() { }
		public virtual void CopyFrom(ShowStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ShowOpenTablesContext : ShowStatementContext {
		public IToken schemaFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode OPEN() { return GetToken(MySqlParser.OPEN, 0); }
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ShowFilterContext showFilter() {
			return GetRuleContext<ShowFilterContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public ShowOpenTablesContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowOpenTables(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowOpenTables(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowOpenTables(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowGlobalInfoContext : ShowStatementContext {
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ShowGlobalInfoClauseContext showGlobalInfoClause() {
			return GetRuleContext<ShowGlobalInfoClauseContext>(0);
		}
		public ShowGlobalInfoContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowGlobalInfo(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowGlobalInfo(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowGlobalInfo(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowCreateFullIdObjectContext : ShowStatementContext {
		public IToken namedEntity;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode EVENT() { return GetToken(MySqlParser.EVENT, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public ITerminalNode TRIGGER() { return GetToken(MySqlParser.TRIGGER, 0); }
		public ITerminalNode VIEW() { return GetToken(MySqlParser.VIEW, 0); }
		public ShowCreateFullIdObjectContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowCreateFullIdObject(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowCreateFullIdObject(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowCreateFullIdObject(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowCreateUserContext : ShowStatementContext {
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public ShowCreateUserContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowCreateUser(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowCreateUser(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowCreateUser(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowErrorsContext : ShowStatementContext {
		public IToken errorFormat;
		public DecimalLiteralContext offset;
		public DecimalLiteralContext rowCount;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode ERRORS() { return GetToken(MySqlParser.ERRORS, 0); }
		public ITerminalNode WARNINGS() { return GetToken(MySqlParser.WARNINGS, 0); }
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public ShowErrorsContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowErrors(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowErrors(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowErrors(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowCountErrorsContext : ShowStatementContext {
		public IToken errorFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode COUNT() { return GetToken(MySqlParser.COUNT, 0); }
		public ITerminalNode ERRORS() { return GetToken(MySqlParser.ERRORS, 0); }
		public ITerminalNode WARNINGS() { return GetToken(MySqlParser.WARNINGS, 0); }
		public ShowCountErrorsContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowCountErrors(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowCountErrors(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowCountErrors(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowObjectFilterContext : ShowStatementContext {
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ShowCommonEntityContext showCommonEntity() {
			return GetRuleContext<ShowCommonEntityContext>(0);
		}
		public ShowFilterContext showFilter() {
			return GetRuleContext<ShowFilterContext>(0);
		}
		public ShowObjectFilterContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowObjectFilter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowObjectFilter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowObjectFilter(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowCreateDbContext : ShowStatementContext {
		public IToken schemaFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode CREATE() { return GetToken(MySqlParser.CREATE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(MySqlParser.SCHEMA, 0); }
		public IfNotExistsContext ifNotExists() {
			return GetRuleContext<IfNotExistsContext>(0);
		}
		public ShowCreateDbContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowCreateDb(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowCreateDb(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowCreateDb(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowEngineContext : ShowStatementContext {
		public IToken engineOption;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode MUTEX() { return GetToken(MySqlParser.MUTEX, 0); }
		public ShowEngineContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowEngine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowEngine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowEngine(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowSchemaFilterContext : ShowStatementContext {
		public IToken schemaFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ShowSchemaEntityContext showSchemaEntity() {
			return GetRuleContext<ShowSchemaEntityContext>(0);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ShowFilterContext showFilter() {
			return GetRuleContext<ShowFilterContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public ShowSchemaFilterContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowSchemaFilter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowSchemaFilter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowSchemaFilter(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowIndexesContext : ShowStatementContext {
		public IToken indexFormat;
		public IToken tableFormat;
		public IToken schemaFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode INDEXES() { return GetToken(MySqlParser.INDEXES, 0); }
		public ITerminalNode KEYS() { return GetToken(MySqlParser.KEYS, 0); }
		public ITerminalNode[] FROM() { return GetTokens(MySqlParser.FROM); }
		public ITerminalNode FROM(int i) {
			return GetToken(MySqlParser.FROM, i);
		}
		public ITerminalNode[] IN() { return GetTokens(MySqlParser.IN); }
		public ITerminalNode IN(int i) {
			return GetToken(MySqlParser.IN, i);
		}
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ShowIndexesContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowIndexes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowIndexes(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowIndexes(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowLogEventsContext : ShowStatementContext {
		public IToken logFormat;
		public IToken filename;
		public DecimalLiteralContext fromPosition;
		public DecimalLiteralContext offset;
		public DecimalLiteralContext rowCount;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode EVENTS() { return GetToken(MySqlParser.EVENTS, 0); }
		public ITerminalNode BINLOG() { return GetToken(MySqlParser.BINLOG, 0); }
		public ITerminalNode RELAYLOG() { return GetToken(MySqlParser.RELAYLOG, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public ShowLogEventsContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowLogEvents(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowLogEvents(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowLogEvents(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowMasterLogsContext : ShowStatementContext {
		public IToken logFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode LOGS() { return GetToken(MySqlParser.LOGS, 0); }
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ShowMasterLogsContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowMasterLogs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowMasterLogs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowMasterLogs(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowGrantsContext : ShowStatementContext {
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode GRANTS() { return GetToken(MySqlParser.GRANTS, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public UserNameContext userName() {
			return GetRuleContext<UserNameContext>(0);
		}
		public ShowGrantsContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowGrants(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowGrants(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowGrants(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowSlaveStatusContext : ShowStatementContext {
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode CHANNEL() { return GetToken(MySqlParser.CHANNEL, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ShowSlaveStatusContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowSlaveStatus(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowSlaveStatus(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowSlaveStatus(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowRoutineContext : ShowStatementContext {
		public IToken routine;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode CODE() { return GetToken(MySqlParser.CODE, 0); }
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public ShowRoutineContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowRoutine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowRoutine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowRoutine(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowProfileContext : ShowStatementContext {
		public DecimalLiteralContext queryCount;
		public DecimalLiteralContext offset;
		public DecimalLiteralContext rowCount;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public ITerminalNode PROFILE() { return GetToken(MySqlParser.PROFILE, 0); }
		public ShowProfileTypeContext[] showProfileType() {
			return GetRuleContexts<ShowProfileTypeContext>();
		}
		public ShowProfileTypeContext showProfileType(int i) {
			return GetRuleContext<ShowProfileTypeContext>(i);
		}
		public ITerminalNode LIMIT() { return GetToken(MySqlParser.LIMIT, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode QUERY() { return GetToken(MySqlParser.QUERY, 0); }
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public ShowProfileContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowProfile(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowProfile(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowProfile(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowColumnsContext : ShowStatementContext {
		public IToken columnsFormat;
		public IToken tableFormat;
		public IToken schemaFormat;
		public ITerminalNode SHOW() { return GetToken(MySqlParser.SHOW, 0); }
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode COLUMNS() { return GetToken(MySqlParser.COLUMNS, 0); }
		public ITerminalNode FIELDS() { return GetToken(MySqlParser.FIELDS, 0); }
		public ITerminalNode[] FROM() { return GetTokens(MySqlParser.FROM); }
		public ITerminalNode FROM(int i) {
			return GetToken(MySqlParser.FROM, i);
		}
		public ITerminalNode[] IN() { return GetTokens(MySqlParser.IN); }
		public ITerminalNode IN(int i) {
			return GetToken(MySqlParser.IN, i);
		}
		public ITerminalNode FULL() { return GetToken(MySqlParser.FULL, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ShowFilterContext showFilter() {
			return GetRuleContext<ShowFilterContext>(0);
		}
		public ShowColumnsContext(ShowStatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowColumns(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowColumns(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowColumns(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowStatementContext showStatement() {
		ShowStatementContext _localctx = new ShowStatementContext(Context, State);
		EnterRule(_localctx, 440, RULE_showStatement);
		int _la;
		try {
			State = 5001;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,719,Context) ) {
			case 1:
				_localctx = new ShowMasterLogsContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 4850; Match(SHOW);
				State = 4851;
				((ShowMasterLogsContext)_localctx).logFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==BINARY || _la==MASTER) ) {
					((ShowMasterLogsContext)_localctx).logFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4852; Match(LOGS);
				}
				break;
			case 2:
				_localctx = new ShowLogEventsContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 4853; Match(SHOW);
				State = 4854;
				((ShowLogEventsContext)_localctx).logFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==BINLOG || _la==RELAYLOG) ) {
					((ShowLogEventsContext)_localctx).logFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4855; Match(EVENTS);
				State = 4858;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IN) {
					{
					State = 4856; Match(IN);
					State = 4857; ((ShowLogEventsContext)_localctx).filename = Match(STRING_LITERAL);
					}
				}

				State = 4862;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM) {
					{
					State = 4860; Match(FROM);
					State = 4861; ((ShowLogEventsContext)_localctx).fromPosition = decimalLiteral();
					}
				}

				State = 4871;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIMIT) {
					{
					State = 4864; Match(LIMIT);
					State = 4868;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,700,Context) ) {
					case 1:
						{
						State = 4865; ((ShowLogEventsContext)_localctx).offset = decimalLiteral();
						State = 4866; Match(COMMA);
						}
						break;
					}
					State = 4870; ((ShowLogEventsContext)_localctx).rowCount = decimalLiteral();
					}
				}

				}
				break;
			case 3:
				_localctx = new ShowObjectFilterContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 4873; Match(SHOW);
				State = 4874; showCommonEntity();
				State = 4876;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIKE || _la==WHERE) {
					{
					State = 4875; showFilter();
					}
				}

				}
				break;
			case 4:
				_localctx = new ShowColumnsContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 4878; Match(SHOW);
				State = 4880;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FULL) {
					{
					State = 4879; Match(FULL);
					}
				}

				State = 4882;
				((ShowColumnsContext)_localctx).columnsFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==COLUMNS || _la==FIELDS) ) {
					((ShowColumnsContext)_localctx).columnsFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4883;
				((ShowColumnsContext)_localctx).tableFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FROM || _la==IN) ) {
					((ShowColumnsContext)_localctx).tableFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4884; tableName();
				State = 4887;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM || _la==IN) {
					{
					State = 4885;
					((ShowColumnsContext)_localctx).schemaFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==FROM || _la==IN) ) {
						((ShowColumnsContext)_localctx).schemaFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 4886; uid();
					}
				}

				State = 4890;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIKE || _la==WHERE) {
					{
					State = 4889; showFilter();
					}
				}

				}
				break;
			case 5:
				_localctx = new ShowCreateDbContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 4892; Match(SHOW);
				State = 4893; Match(CREATE);
				State = 4894;
				((ShowCreateDbContext)_localctx).schemaFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==DATABASE || _la==SCHEMA) ) {
					((ShowCreateDbContext)_localctx).schemaFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4896;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IF) {
					{
					State = 4895; ifNotExists();
					}
				}

				State = 4898; uid();
				}
				break;
			case 6:
				_localctx = new ShowCreateFullIdObjectContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 4899; Match(SHOW);
				State = 4900; Match(CREATE);
				State = 4901;
				((ShowCreateFullIdObjectContext)_localctx).namedEntity = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 113)) & ~0x3f) == 0 && ((1L << (_la - 113)) & ((1L << (PROCEDURE - 113)) | (1L << (TABLE - 113)) | (1L << (TRIGGER - 113)))) != 0) || _la==EVENT || _la==FUNCTION || _la==VIEW) ) {
					((ShowCreateFullIdObjectContext)_localctx).namedEntity = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4902; fullId();
				}
				break;
			case 7:
				_localctx = new ShowCreateUserContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 4903; Match(SHOW);
				State = 4904; Match(CREATE);
				State = 4905; Match(USER);
				State = 4906; userName();
				}
				break;
			case 8:
				_localctx = new ShowEngineContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 4907; Match(SHOW);
				State = 4908; Match(ENGINE);
				State = 4909; engineName();
				State = 4910;
				((ShowEngineContext)_localctx).engineOption = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==MUTEX || _la==STATUS) ) {
					((ShowEngineContext)_localctx).engineOption = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 9:
				_localctx = new ShowGlobalInfoContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 4912; Match(SHOW);
				State = 4913; showGlobalInfoClause();
				}
				break;
			case 10:
				_localctx = new ShowErrorsContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 4914; Match(SHOW);
				State = 4915;
				((ShowErrorsContext)_localctx).errorFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ERRORS || _la==WARNINGS) ) {
					((ShowErrorsContext)_localctx).errorFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				{
				State = 4916; Match(LIMIT);
				State = 4920;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,707,Context) ) {
				case 1:
					{
					State = 4917; ((ShowErrorsContext)_localctx).offset = decimalLiteral();
					State = 4918; Match(COMMA);
					}
					break;
				}
				State = 4922; ((ShowErrorsContext)_localctx).rowCount = decimalLiteral();
				}
				}
				break;
			case 11:
				_localctx = new ShowCountErrorsContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 4923; Match(SHOW);
				State = 4924; Match(COUNT);
				State = 4925; Match(LR_BRACKET);
				State = 4926; Match(STAR);
				State = 4927; Match(RR_BRACKET);
				State = 4928;
				((ShowCountErrorsContext)_localctx).errorFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ERRORS || _la==WARNINGS) ) {
					((ShowCountErrorsContext)_localctx).errorFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 12:
				_localctx = new ShowSchemaFilterContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 4929; Match(SHOW);
				State = 4930; showSchemaEntity();
				State = 4933;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM || _la==IN) {
					{
					State = 4931;
					((ShowSchemaFilterContext)_localctx).schemaFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==FROM || _la==IN) ) {
						((ShowSchemaFilterContext)_localctx).schemaFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 4932; uid();
					}
				}

				State = 4936;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIKE || _la==WHERE) {
					{
					State = 4935; showFilter();
					}
				}

				}
				break;
			case 13:
				_localctx = new ShowRoutineContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 4938; Match(SHOW);
				State = 4939;
				((ShowRoutineContext)_localctx).routine = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==PROCEDURE || _la==FUNCTION) ) {
					((ShowRoutineContext)_localctx).routine = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4940; Match(CODE);
				State = 4941; fullId();
				}
				break;
			case 14:
				_localctx = new ShowGrantsContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 4942; Match(SHOW);
				State = 4943; Match(GRANTS);
				State = 4946;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 4944; Match(FOR);
					State = 4945; userName();
					}
				}

				}
				break;
			case 15:
				_localctx = new ShowIndexesContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 4948; Match(SHOW);
				State = 4949;
				((ShowIndexesContext)_localctx).indexFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==INDEX || _la==KEYS || _la==INDEXES) ) {
					((ShowIndexesContext)_localctx).indexFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4950;
				((ShowIndexesContext)_localctx).tableFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FROM || _la==IN) ) {
					((ShowIndexesContext)_localctx).tableFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4951; tableName();
				State = 4954;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM || _la==IN) {
					{
					State = 4952;
					((ShowIndexesContext)_localctx).schemaFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==FROM || _la==IN) ) {
						((ShowIndexesContext)_localctx).schemaFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 4953; uid();
					}
				}

				State = 4958;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE) {
					{
					State = 4956; Match(WHERE);
					State = 4957; expression(0);
					}
				}

				}
				break;
			case 16:
				_localctx = new ShowOpenTablesContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 4960; Match(SHOW);
				State = 4961; Match(OPEN);
				State = 4962; Match(TABLES);
				State = 4965;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM || _la==IN) {
					{
					State = 4963;
					((ShowOpenTablesContext)_localctx).schemaFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==FROM || _la==IN) ) {
						((ShowOpenTablesContext)_localctx).schemaFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 4964; uid();
					}
				}

				State = 4968;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LIKE || _la==WHERE) {
					{
					State = 4967; showFilter();
					}
				}

				}
				break;
			case 17:
				_localctx = new ShowProfileContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 4970; Match(SHOW);
				State = 4971; Match(PROFILE);
				State = 4972; showProfileType();
				State = 4977;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4973; Match(COMMA);
					State = 4974; showProfileType();
					}
					}
					State = 4979;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 4983;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 4980; Match(FOR);
					State = 4981; Match(QUERY);
					State = 4982; ((ShowProfileContext)_localctx).queryCount = decimalLiteral();
					}
				}

				{
				State = 4985; Match(LIMIT);
				State = 4989;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,717,Context) ) {
				case 1:
					{
					State = 4986; ((ShowProfileContext)_localctx).offset = decimalLiteral();
					State = 4987; Match(COMMA);
					}
					break;
				}
				State = 4991; ((ShowProfileContext)_localctx).rowCount = decimalLiteral();
				}
				}
				break;
			case 18:
				_localctx = new ShowSlaveStatusContext(_localctx);
				EnterOuterAlt(_localctx, 18);
				{
				State = 4993; Match(SHOW);
				State = 4994; Match(SLAVE);
				State = 4995; Match(STATUS);
				State = 4999;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 4996; Match(FOR);
					State = 4997; Match(CHANNEL);
					State = 4998; Match(STRING_LITERAL);
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableClauseContext : ParserRuleContext {
		public ITerminalNode LOCAL_ID() { return GetToken(MySqlParser.LOCAL_ID, 0); }
		public ITerminalNode GLOBAL_ID() { return GetToken(MySqlParser.GLOBAL_ID, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode GLOBAL() { return GetToken(MySqlParser.GLOBAL, 0); }
		public ITerminalNode SESSION() { return GetToken(MySqlParser.SESSION, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public VariableClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterVariableClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitVariableClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariableClauseContext variableClause() {
		VariableClauseContext _localctx = new VariableClauseContext(Context, State);
		EnterRule(_localctx, 442, RULE_variableClause);
		int _la;
		try {
			State = 5013;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LOCAL_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5003; Match(LOCAL_ID);
				}
				break;
			case GLOBAL_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5004; Match(GLOBAL_ID);
				}
				break;
			case DATABASE:
			case LEFT:
			case RIGHT:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case TEXT:
			case ENUM:
			case SERIAL:
			case COUNT:
			case POSITION:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLASS_ORIGIN:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COLUMN_NAME:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONSTRAINT_CATALOG:
			case CONSTRAINT_SCHEMA:
			case CONSTRAINT_NAME:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVISIBLE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MESSAGE_TEXT:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case MYSQL_ERRNO:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBCLASS_ORIGIN:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLE_NAME:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case VISIBLE:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case SESSION_VARIABLES_ADMIN:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CATALOG_NAME:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SCHEMA_NAME:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case AT_SIGN:
			case CHARSET_REVERSE_QOUTE_STRING:
			case STRING_LITERAL:
			case ID:
			case REVERSE_QUOTE_ID:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5010;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,721,Context) ) {
				case 1:
					{
					State = 5007;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AT_SIGN) {
						{
						State = 5005; Match(AT_SIGN);
						State = 5006; Match(AT_SIGN);
						}
					}

					State = 5009;
					_la = TokenStream.LA(1);
					if ( !(_la==GLOBAL || _la==LOCAL || _la==SESSION) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 5012; uid();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowCommonEntityContext : ParserRuleContext {
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode COLLATION() { return GetToken(MySqlParser.COLLATION, 0); }
		public ITerminalNode DATABASES() { return GetToken(MySqlParser.DATABASES, 0); }
		public ITerminalNode SCHEMAS() { return GetToken(MySqlParser.SCHEMAS, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(MySqlParser.PROCEDURE, 0); }
		public ITerminalNode VARIABLES() { return GetToken(MySqlParser.VARIABLES, 0); }
		public ITerminalNode GLOBAL() { return GetToken(MySqlParser.GLOBAL, 0); }
		public ITerminalNode SESSION() { return GetToken(MySqlParser.SESSION, 0); }
		public ShowCommonEntityContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showCommonEntity; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowCommonEntity(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowCommonEntity(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowCommonEntity(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowCommonEntityContext showCommonEntity() {
		ShowCommonEntityContext _localctx = new ShowCommonEntityContext(Context, State);
		EnterRule(_localctx, 444, RULE_showCommonEntity);
		int _la;
		try {
			State = 5028;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CHARACTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5015; Match(CHARACTER);
				State = 5016; Match(SET);
				}
				break;
			case COLLATION:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5017; Match(COLLATION);
				}
				break;
			case DATABASES:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5018; Match(DATABASES);
				}
				break;
			case SCHEMAS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5019; Match(SCHEMAS);
				}
				break;
			case FUNCTION:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5020; Match(FUNCTION);
				State = 5021; Match(STATUS);
				}
				break;
			case PROCEDURE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5022; Match(PROCEDURE);
				State = 5023; Match(STATUS);
				}
				break;
			case GLOBAL:
			case SESSION:
			case STATUS:
			case VARIABLES:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5025;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==GLOBAL || _la==SESSION) {
					{
					State = 5024;
					_la = TokenStream.LA(1);
					if ( !(_la==GLOBAL || _la==SESSION) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 5027;
				_la = TokenStream.LA(1);
				if ( !(_la==STATUS || _la==VARIABLES) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowFilterContext : ParserRuleContext {
		public ITerminalNode LIKE() { return GetToken(MySqlParser.LIKE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode WHERE() { return GetToken(MySqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ShowFilterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showFilter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowFilter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowFilter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowFilter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowFilterContext showFilter() {
		ShowFilterContext _localctx = new ShowFilterContext(Context, State);
		EnterRule(_localctx, 446, RULE_showFilter);
		try {
			State = 5034;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LIKE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5030; Match(LIKE);
				State = 5031; Match(STRING_LITERAL);
				}
				break;
			case WHERE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5032; Match(WHERE);
				State = 5033; expression(0);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowGlobalInfoClauseContext : ParserRuleContext {
		public ITerminalNode ENGINES() { return GetToken(MySqlParser.ENGINES, 0); }
		public ITerminalNode STORAGE() { return GetToken(MySqlParser.STORAGE, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode PLUGINS() { return GetToken(MySqlParser.PLUGINS, 0); }
		public ITerminalNode PRIVILEGES() { return GetToken(MySqlParser.PRIVILEGES, 0); }
		public ITerminalNode PROCESSLIST() { return GetToken(MySqlParser.PROCESSLIST, 0); }
		public ITerminalNode FULL() { return GetToken(MySqlParser.FULL, 0); }
		public ITerminalNode PROFILES() { return GetToken(MySqlParser.PROFILES, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ITerminalNode HOSTS() { return GetToken(MySqlParser.HOSTS, 0); }
		public ITerminalNode AUTHORS() { return GetToken(MySqlParser.AUTHORS, 0); }
		public ITerminalNode CONTRIBUTORS() { return GetToken(MySqlParser.CONTRIBUTORS, 0); }
		public ShowGlobalInfoClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showGlobalInfoClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowGlobalInfoClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowGlobalInfoClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowGlobalInfoClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowGlobalInfoClauseContext showGlobalInfoClause() {
		ShowGlobalInfoClauseContext _localctx = new ShowGlobalInfoClauseContext(Context, State);
		EnterRule(_localctx, 448, RULE_showGlobalInfoClause);
		int _la;
		try {
			State = 5053;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ENGINES:
			case STORAGE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5037;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==STORAGE) {
					{
					State = 5036; Match(STORAGE);
					}
				}

				State = 5039; Match(ENGINES);
				}
				break;
			case MASTER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5040; Match(MASTER);
				State = 5041; Match(STATUS);
				}
				break;
			case PLUGINS:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5042; Match(PLUGINS);
				}
				break;
			case PRIVILEGES:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5043; Match(PRIVILEGES);
				}
				break;
			case FULL:
			case PROCESSLIST:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5045;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FULL) {
					{
					State = 5044; Match(FULL);
					}
				}

				State = 5047; Match(PROCESSLIST);
				}
				break;
			case PROFILES:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5048; Match(PROFILES);
				}
				break;
			case SLAVE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5049; Match(SLAVE);
				State = 5050; Match(HOSTS);
				}
				break;
			case AUTHORS:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5051; Match(AUTHORS);
				}
				break;
			case CONTRIBUTORS:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5052; Match(CONTRIBUTORS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowSchemaEntityContext : ParserRuleContext {
		public ITerminalNode EVENTS() { return GetToken(MySqlParser.EVENTS, 0); }
		public ITerminalNode TABLE() { return GetToken(MySqlParser.TABLE, 0); }
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public ITerminalNode FULL() { return GetToken(MySqlParser.FULL, 0); }
		public ITerminalNode TRIGGERS() { return GetToken(MySqlParser.TRIGGERS, 0); }
		public ShowSchemaEntityContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showSchemaEntity; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowSchemaEntity(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowSchemaEntity(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowSchemaEntity(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowSchemaEntityContext showSchemaEntity() {
		ShowSchemaEntityContext _localctx = new ShowSchemaEntityContext(Context, State);
		EnterRule(_localctx, 450, RULE_showSchemaEntity);
		int _la;
		try {
			State = 5063;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EVENTS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5055; Match(EVENTS);
				}
				break;
			case TABLE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5056; Match(TABLE);
				State = 5057; Match(STATUS);
				}
				break;
			case FULL:
			case TABLES:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5059;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FULL) {
					{
					State = 5058; Match(FULL);
					}
				}

				State = 5061; Match(TABLES);
				}
				break;
			case TRIGGERS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5062; Match(TRIGGERS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowProfileTypeContext : ParserRuleContext {
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode BLOCK() { return GetToken(MySqlParser.BLOCK, 0); }
		public ITerminalNode IO() { return GetToken(MySqlParser.IO, 0); }
		public ITerminalNode CONTEXT() { return GetToken(MySqlParser.CONTEXT, 0); }
		public ITerminalNode SWITCHES() { return GetToken(MySqlParser.SWITCHES, 0); }
		public ITerminalNode CPU() { return GetToken(MySqlParser.CPU, 0); }
		public ITerminalNode IPC() { return GetToken(MySqlParser.IPC, 0); }
		public ITerminalNode MEMORY() { return GetToken(MySqlParser.MEMORY, 0); }
		public ITerminalNode PAGE() { return GetToken(MySqlParser.PAGE, 0); }
		public ITerminalNode FAULTS() { return GetToken(MySqlParser.FAULTS, 0); }
		public ITerminalNode SOURCE() { return GetToken(MySqlParser.SOURCE, 0); }
		public ITerminalNode SWAPS() { return GetToken(MySqlParser.SWAPS, 0); }
		public ShowProfileTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showProfileType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShowProfileType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShowProfileType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowProfileType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowProfileTypeContext showProfileType() {
		ShowProfileTypeContext _localctx = new ShowProfileTypeContext(Context, State);
		EnterRule(_localctx, 452, RULE_showProfileType);
		try {
			State = 5077;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5065; Match(ALL);
				}
				break;
			case BLOCK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5066; Match(BLOCK);
				State = 5067; Match(IO);
				}
				break;
			case CONTEXT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5068; Match(CONTEXT);
				State = 5069; Match(SWITCHES);
				}
				break;
			case CPU:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5070; Match(CPU);
				}
				break;
			case IPC:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5071; Match(IPC);
				}
				break;
			case MEMORY:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5072; Match(MEMORY);
				}
				break;
			case PAGE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5073; Match(PAGE);
				State = 5074; Match(FAULTS);
				}
				break;
			case SOURCE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5075; Match(SOURCE);
				}
				break;
			case SWAPS:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5076; Match(SWAPS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BinlogStatementContext : ParserRuleContext {
		public ITerminalNode BINLOG() { return GetToken(MySqlParser.BINLOG, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public BinlogStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_binlogStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBinlogStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBinlogStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBinlogStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BinlogStatementContext binlogStatement() {
		BinlogStatementContext _localctx = new BinlogStatementContext(Context, State);
		EnterRule(_localctx, 454, RULE_binlogStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5079; Match(BINLOG);
			State = 5080; Match(STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CacheIndexStatementContext : ParserRuleContext {
		public UidContext schema;
		public ITerminalNode CACHE() { return GetToken(MySqlParser.CACHE, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public TableIndexesContext[] tableIndexes() {
			return GetRuleContexts<TableIndexesContext>();
		}
		public TableIndexesContext tableIndexes(int i) {
			return GetRuleContext<TableIndexesContext>(i);
		}
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public CacheIndexStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cacheIndexStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCacheIndexStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCacheIndexStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCacheIndexStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CacheIndexStatementContext cacheIndexStatement() {
		CacheIndexStatementContext _localctx = new CacheIndexStatementContext(Context, State);
		EnterRule(_localctx, 456, RULE_cacheIndexStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5082; Match(CACHE);
			State = 5083; Match(INDEX);
			State = 5084; tableIndexes();
			State = 5089;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5085; Match(COMMA);
				State = 5086; tableIndexes();
				}
				}
				State = 5091;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5099;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 5092; Match(PARTITION);
				State = 5093; Match(LR_BRACKET);
				State = 5096;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLASS_ORIGIN:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COLUMN_NAME:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONSTRAINT_CATALOG:
				case CONSTRAINT_SCHEMA:
				case CONSTRAINT_NAME:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVISIBLE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MESSAGE_TEXT:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case MYSQL_ERRNO:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBCLASS_ORIGIN:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLE_NAME:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case VISIBLE:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case SESSION_VARIABLES_ADMIN:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CATALOG_NAME:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SCHEMA_NAME:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 5094; uidList();
					}
					break;
				case ALL:
					{
					State = 5095; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5098; Match(RR_BRACKET);
				}
			}

			State = 5101; Match(IN);
			State = 5102; _localctx.schema = uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlushStatementContext : ParserRuleContext {
		public IToken flushFormat;
		public ITerminalNode FLUSH() { return GetToken(MySqlParser.FLUSH, 0); }
		public FlushOptionContext[] flushOption() {
			return GetRuleContexts<FlushOptionContext>();
		}
		public FlushOptionContext flushOption(int i) {
			return GetRuleContext<FlushOptionContext>(i);
		}
		public ITerminalNode NO_WRITE_TO_BINLOG() { return GetToken(MySqlParser.NO_WRITE_TO_BINLOG, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public FlushStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flushStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFlushStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFlushStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFlushStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FlushStatementContext flushStatement() {
		FlushStatementContext _localctx = new FlushStatementContext(Context, State);
		EnterRule(_localctx, 458, RULE_flushStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5104; Match(FLUSH);
			State = 5106;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NO_WRITE_TO_BINLOG || _la==LOCAL) {
				{
				State = 5105;
				_localctx.flushFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==NO_WRITE_TO_BINLOG || _la==LOCAL) ) {
					_localctx.flushFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 5108; flushOption();
			State = 5113;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5109; Match(COMMA);
				State = 5110; flushOption();
				}
				}
				State = 5115;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KillStatementContext : ParserRuleContext {
		public IToken connectionFormat;
		public ITerminalNode KILL() { return GetToken(MySqlParser.KILL, 0); }
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public ITerminalNode CONNECTION() { return GetToken(MySqlParser.CONNECTION, 0); }
		public ITerminalNode QUERY() { return GetToken(MySqlParser.QUERY, 0); }
		public KillStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_killStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterKillStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitKillStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKillStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KillStatementContext killStatement() {
		KillStatementContext _localctx = new KillStatementContext(Context, State);
		EnterRule(_localctx, 460, RULE_killStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5116; Match(KILL);
			State = 5118;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONNECTION || _la==QUERY) {
				{
				State = 5117;
				_localctx.connectionFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==CONNECTION || _la==QUERY) ) {
					_localctx.connectionFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 5121;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 5120; decimalLiteral();
				}
				}
				State = 5123;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( ((((_la - 979)) & ~0x3f) == 0 && ((1L << (_la - 979)) & ((1L << (ZERO_DECIMAL - 979)) | (1L << (ONE_DECIMAL - 979)) | (1L << (TWO_DECIMAL - 979)) | (1L << (DECIMAL_LITERAL - 979)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoadIndexIntoCacheContext : ParserRuleContext {
		public ITerminalNode LOAD() { return GetToken(MySqlParser.LOAD, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode INTO() { return GetToken(MySqlParser.INTO, 0); }
		public ITerminalNode CACHE() { return GetToken(MySqlParser.CACHE, 0); }
		public LoadedTableIndexesContext[] loadedTableIndexes() {
			return GetRuleContexts<LoadedTableIndexesContext>();
		}
		public LoadedTableIndexesContext loadedTableIndexes(int i) {
			return GetRuleContext<LoadedTableIndexesContext>(i);
		}
		public LoadIndexIntoCacheContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loadIndexIntoCache; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLoadIndexIntoCache(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLoadIndexIntoCache(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoadIndexIntoCache(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoadIndexIntoCacheContext loadIndexIntoCache() {
		LoadIndexIntoCacheContext _localctx = new LoadIndexIntoCacheContext(Context, State);
		EnterRule(_localctx, 462, RULE_loadIndexIntoCache);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5125; Match(LOAD);
			State = 5126; Match(INDEX);
			State = 5127; Match(INTO);
			State = 5128; Match(CACHE);
			State = 5129; loadedTableIndexes();
			State = 5134;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5130; Match(COMMA);
				State = 5131; loadedTableIndexes();
				}
				}
				State = 5136;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResetStatementContext : ParserRuleContext {
		public ITerminalNode RESET() { return GetToken(MySqlParser.RESET, 0); }
		public ITerminalNode QUERY() { return GetToken(MySqlParser.QUERY, 0); }
		public ITerminalNode CACHE() { return GetToken(MySqlParser.CACHE, 0); }
		public ResetStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_resetStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterResetStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitResetStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitResetStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ResetStatementContext resetStatement() {
		ResetStatementContext _localctx = new ResetStatementContext(Context, State);
		EnterRule(_localctx, 464, RULE_resetStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5137; Match(RESET);
			State = 5138; Match(QUERY);
			State = 5139; Match(CACHE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShutdownStatementContext : ParserRuleContext {
		public ITerminalNode SHUTDOWN() { return GetToken(MySqlParser.SHUTDOWN, 0); }
		public ShutdownStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shutdownStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterShutdownStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitShutdownStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShutdownStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShutdownStatementContext shutdownStatement() {
		ShutdownStatementContext _localctx = new ShutdownStatementContext(Context, State);
		EnterRule(_localctx, 466, RULE_shutdownStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5141; Match(SHUTDOWN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableIndexesContext : ParserRuleContext {
		public IToken indexFormat;
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public UidListContext uidList() {
			return GetRuleContext<UidListContext>(0);
		}
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public TableIndexesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableIndexes; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableIndexes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableIndexes(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableIndexes(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TableIndexesContext tableIndexes() {
		TableIndexesContext _localctx = new TableIndexesContext(Context, State);
		EnterRule(_localctx, 468, RULE_tableIndexes);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5143; tableName();
			State = 5151;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INDEX || _la==KEY || _la==LR_BRACKET) {
				{
				State = 5145;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDEX || _la==KEY) {
					{
					State = 5144;
					_localctx.indexFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==INDEX || _la==KEY) ) {
						_localctx.indexFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 5147; Match(LR_BRACKET);
				State = 5148; uidList();
				State = 5149; Match(RR_BRACKET);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlushOptionContext : ParserRuleContext {
		public FlushOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flushOption; } }
	 
		public FlushOptionContext() { }
		public virtual void CopyFrom(FlushOptionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TableFlushOptionContext : FlushOptionContext {
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public TablesContext tables() {
			return GetRuleContext<TablesContext>(0);
		}
		public FlushTableOptionContext flushTableOption() {
			return GetRuleContext<FlushTableOptionContext>(0);
		}
		public TableFlushOptionContext(FlushOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableFlushOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableFlushOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableFlushOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ChannelFlushOptionContext : FlushOptionContext {
		public ITerminalNode RELAY() { return GetToken(MySqlParser.RELAY, 0); }
		public ITerminalNode LOGS() { return GetToken(MySqlParser.LOGS, 0); }
		public ChannelOptionContext channelOption() {
			return GetRuleContext<ChannelOptionContext>(0);
		}
		public ChannelFlushOptionContext(FlushOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterChannelFlushOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitChannelFlushOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChannelFlushOption(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SimpleFlushOptionContext : FlushOptionContext {
		public ITerminalNode DES_KEY_FILE() { return GetToken(MySqlParser.DES_KEY_FILE, 0); }
		public ITerminalNode HOSTS() { return GetToken(MySqlParser.HOSTS, 0); }
		public ITerminalNode LOGS() { return GetToken(MySqlParser.LOGS, 0); }
		public ITerminalNode OPTIMIZER_COSTS() { return GetToken(MySqlParser.OPTIMIZER_COSTS, 0); }
		public ITerminalNode PRIVILEGES() { return GetToken(MySqlParser.PRIVILEGES, 0); }
		public ITerminalNode QUERY() { return GetToken(MySqlParser.QUERY, 0); }
		public ITerminalNode CACHE() { return GetToken(MySqlParser.CACHE, 0); }
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode USER_RESOURCES() { return GetToken(MySqlParser.USER_RESOURCES, 0); }
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public ITerminalNode ERROR() { return GetToken(MySqlParser.ERROR, 0); }
		public ITerminalNode GENERAL() { return GetToken(MySqlParser.GENERAL, 0); }
		public ITerminalNode RELAY() { return GetToken(MySqlParser.RELAY, 0); }
		public ITerminalNode SLOW() { return GetToken(MySqlParser.SLOW, 0); }
		public SimpleFlushOptionContext(FlushOptionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleFlushOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleFlushOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleFlushOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FlushOptionContext flushOption() {
		FlushOptionContext _localctx = new FlushOptionContext(Context, State);
		EnterRule(_localctx, 470, RULE_flushOption);
		int _la;
		try {
			State = 5183;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,747,Context) ) {
			case 1:
				_localctx = new SimpleFlushOptionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 5171;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DES_KEY_FILE:
					{
					State = 5153; Match(DES_KEY_FILE);
					}
					break;
				case HOSTS:
					{
					State = 5154; Match(HOSTS);
					}
					break;
				case BINARY:
				case ENGINE:
				case ERROR:
				case GENERAL:
				case LOGS:
				case RELAY:
				case SLOW:
					{
					State = 5156;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==BINARY || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (ENGINE - 324)) | (1L << (ERROR - 324)) | (1L << (GENERAL - 324)))) != 0) || _la==RELAY || _la==SLOW) {
						{
						State = 5155;
						_la = TokenStream.LA(1);
						if ( !(_la==BINARY || ((((_la - 324)) & ~0x3f) == 0 && ((1L << (_la - 324)) & ((1L << (ENGINE - 324)) | (1L << (ERROR - 324)) | (1L << (GENERAL - 324)))) != 0) || _la==RELAY || _la==SLOW) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					State = 5158; Match(LOGS);
					}
					break;
				case OPTIMIZER_COSTS:
					{
					State = 5159; Match(OPTIMIZER_COSTS);
					}
					break;
				case PRIVILEGES:
					{
					State = 5160; Match(PRIVILEGES);
					}
					break;
				case QUERY:
					{
					State = 5161; Match(QUERY);
					State = 5162; Match(CACHE);
					}
					break;
				case STATUS:
					{
					State = 5163; Match(STATUS);
					}
					break;
				case USER_RESOURCES:
					{
					State = 5164; Match(USER_RESOURCES);
					}
					break;
				case TABLES:
					{
					State = 5165; Match(TABLES);
					State = 5169;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==WITH) {
						{
						State = 5166; Match(WITH);
						State = 5167; Match(READ);
						State = 5168; Match(LOCK);
						}
					}

					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				_localctx = new ChannelFlushOptionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 5173; Match(RELAY);
				State = 5174; Match(LOGS);
				State = 5176;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 5175; channelOption();
					}
				}

				}
				break;
			case 3:
				_localctx = new TableFlushOptionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 5178; Match(TABLES);
				State = 5179; tables();
				State = 5181;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR || _la==WITH) {
					{
					State = 5180; flushTableOption();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlushTableOptionContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(MySqlParser.WITH, 0); }
		public ITerminalNode READ() { return GetToken(MySqlParser.READ, 0); }
		public ITerminalNode LOCK() { return GetToken(MySqlParser.LOCK, 0); }
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode EXPORT() { return GetToken(MySqlParser.EXPORT, 0); }
		public FlushTableOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flushTableOption; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFlushTableOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFlushTableOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFlushTableOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FlushTableOptionContext flushTableOption() {
		FlushTableOptionContext _localctx = new FlushTableOptionContext(Context, State);
		EnterRule(_localctx, 472, RULE_flushTableOption);
		try {
			State = 5190;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WITH:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5185; Match(WITH);
				State = 5186; Match(READ);
				State = 5187; Match(LOCK);
				}
				break;
			case FOR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5188; Match(FOR);
				State = 5189; Match(EXPORT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoadedTableIndexesContext : ParserRuleContext {
		public UidListContext partitionList;
		public IToken indexFormat;
		public UidListContext indexList;
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode PARTITION() { return GetToken(MySqlParser.PARTITION, 0); }
		public ITerminalNode IGNORE() { return GetToken(MySqlParser.IGNORE, 0); }
		public ITerminalNode LEAVES() { return GetToken(MySqlParser.LEAVES, 0); }
		public UidListContext[] uidList() {
			return GetRuleContexts<UidListContext>();
		}
		public UidListContext uidList(int i) {
			return GetRuleContext<UidListContext>(i);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode INDEX() { return GetToken(MySqlParser.INDEX, 0); }
		public ITerminalNode KEY() { return GetToken(MySqlParser.KEY, 0); }
		public LoadedTableIndexesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loadedTableIndexes; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLoadedTableIndexes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLoadedTableIndexes(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoadedTableIndexes(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoadedTableIndexesContext loadedTableIndexes() {
		LoadedTableIndexesContext _localctx = new LoadedTableIndexesContext(Context, State);
		EnterRule(_localctx, 474, RULE_loadedTableIndexes);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5192; tableName();
			State = 5200;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 5193; Match(PARTITION);
				State = 5194; Match(LR_BRACKET);
				State = 5197;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case DATABASE:
				case LEFT:
				case RIGHT:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case TEXT:
				case ENUM:
				case SERIAL:
				case COUNT:
				case POSITION:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLASS_ORIGIN:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COLUMN_NAME:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONSTRAINT_CATALOG:
				case CONSTRAINT_SCHEMA:
				case CONSTRAINT_NAME:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVISIBLE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MESSAGE_TEXT:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case MYSQL_ERRNO:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBCLASS_ORIGIN:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLE_NAME:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case VISIBLE:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case SESSION_VARIABLES_ADMIN:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CATALOG_NAME:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SCHEMA_NAME:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case CHARSET_REVERSE_QOUTE_STRING:
				case STRING_LITERAL:
				case ID:
				case REVERSE_QUOTE_ID:
					{
					State = 5195; _localctx.partitionList = uidList();
					}
					break;
				case ALL:
					{
					State = 5196; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5199; Match(RR_BRACKET);
				}
			}

			State = 5209;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,752,Context) ) {
			case 1:
				{
				State = 5203;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INDEX || _la==KEY) {
					{
					State = 5202;
					_localctx.indexFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==INDEX || _la==KEY) ) {
						_localctx.indexFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 5205; Match(LR_BRACKET);
				State = 5206; _localctx.indexList = uidList();
				State = 5207; Match(RR_BRACKET);
				}
				break;
			}
			State = 5213;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IGNORE) {
				{
				State = 5211; Match(IGNORE);
				State = 5212; Match(LEAVES);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleDescribeStatementContext : ParserRuleContext {
		public IToken command;
		public UidContext column;
		public IToken pattern;
		public TableNameContext tableName() {
			return GetRuleContext<TableNameContext>(0);
		}
		public ITerminalNode EXPLAIN() { return GetToken(MySqlParser.EXPLAIN, 0); }
		public ITerminalNode DESCRIBE() { return GetToken(MySqlParser.DESCRIBE, 0); }
		public ITerminalNode DESC() { return GetToken(MySqlParser.DESC, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public SimpleDescribeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleDescribeStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleDescribeStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleDescribeStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleDescribeStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleDescribeStatementContext simpleDescribeStatement() {
		SimpleDescribeStatementContext _localctx = new SimpleDescribeStatementContext(Context, State);
		EnterRule(_localctx, 476, RULE_simpleDescribeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5215;
			_localctx.command = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DESC) | (1L << DESCRIBE) | (1L << EXPLAIN))) != 0)) ) {
				_localctx.command = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5216; tableName();
			State = 5219;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,754,Context) ) {
			case 1:
				{
				State = 5217; _localctx.column = uid();
				}
				break;
			case 2:
				{
				State = 5218; _localctx.pattern = Match(STRING_LITERAL);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullDescribeStatementContext : ParserRuleContext {
		public IToken command;
		public IToken formatType;
		public IToken formatValue;
		public DescribeObjectClauseContext describeObjectClause() {
			return GetRuleContext<DescribeObjectClauseContext>(0);
		}
		public ITerminalNode EXPLAIN() { return GetToken(MySqlParser.EXPLAIN, 0); }
		public ITerminalNode DESCRIBE() { return GetToken(MySqlParser.DESCRIBE, 0); }
		public ITerminalNode DESC() { return GetToken(MySqlParser.DESC, 0); }
		public ITerminalNode EXTENDED() { return GetToken(MySqlParser.EXTENDED, 0); }
		public ITerminalNode PARTITIONS() { return GetToken(MySqlParser.PARTITIONS, 0); }
		public ITerminalNode FORMAT() { return GetToken(MySqlParser.FORMAT, 0); }
		public ITerminalNode TRADITIONAL() { return GetToken(MySqlParser.TRADITIONAL, 0); }
		public ITerminalNode JSON() { return GetToken(MySqlParser.JSON, 0); }
		public FullDescribeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullDescribeStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFullDescribeStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFullDescribeStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFullDescribeStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FullDescribeStatementContext fullDescribeStatement() {
		FullDescribeStatementContext _localctx = new FullDescribeStatementContext(Context, State);
		EnterRule(_localctx, 478, RULE_fullDescribeStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5221;
			_localctx.command = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DESC) | (1L << DESCRIBE) | (1L << EXPLAIN))) != 0)) ) {
				_localctx.command = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5225;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXTENDED || _la==PARTITIONS || _la==FORMAT) {
				{
				State = 5222;
				_localctx.formatType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==EXTENDED || _la==PARTITIONS || _la==FORMAT) ) {
					_localctx.formatType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5223; Match(EQUAL_SYMBOL);
				State = 5224;
				_localctx.formatValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==JSON || _la==TRADITIONAL) ) {
					_localctx.formatValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 5227; describeObjectClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HelpStatementContext : ParserRuleContext {
		public ITerminalNode HELP() { return GetToken(MySqlParser.HELP, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public HelpStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_helpStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHelpStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHelpStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHelpStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HelpStatementContext helpStatement() {
		HelpStatementContext _localctx = new HelpStatementContext(Context, State);
		EnterRule(_localctx, 480, RULE_helpStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5229; Match(HELP);
			State = 5230; Match(STRING_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UseStatementContext : ParserRuleContext {
		public ITerminalNode USE() { return GetToken(MySqlParser.USE, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public UseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_useStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUseStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUseStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UseStatementContext useStatement() {
		UseStatementContext _localctx = new UseStatementContext(Context, State);
		EnterRule(_localctx, 482, RULE_useStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5232; Match(USE);
			State = 5233; uid();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SignalStatementContext : ParserRuleContext {
		public ITerminalNode SIGNAL() { return GetToken(MySqlParser.SIGNAL, 0); }
		public ITerminalNode ID() { return GetToken(MySqlParser.ID, 0); }
		public ITerminalNode REVERSE_QUOTE_ID() { return GetToken(MySqlParser.REVERSE_QUOTE_ID, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public SignalConditionInformationContext[] signalConditionInformation() {
			return GetRuleContexts<SignalConditionInformationContext>();
		}
		public SignalConditionInformationContext signalConditionInformation(int i) {
			return GetRuleContext<SignalConditionInformationContext>(i);
		}
		public ITerminalNode SQLSTATE() { return GetToken(MySqlParser.SQLSTATE, 0); }
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public ITerminalNode VALUE() { return GetToken(MySqlParser.VALUE, 0); }
		public SignalStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_signalStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSignalStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSignalStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSignalStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SignalStatementContext signalStatement() {
		SignalStatementContext _localctx = new SignalStatementContext(Context, State);
		EnterRule(_localctx, 484, RULE_signalStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5235; Match(SIGNAL);
			State = 5243;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SQLSTATE:
				{
				{
				State = 5236; Match(SQLSTATE);
				State = 5238;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==VALUE) {
					{
					State = 5237; Match(VALUE);
					}
				}

				State = 5240; stringLiteral();
				}
				}
				break;
			case ID:
				{
				State = 5241; Match(ID);
				}
				break;
			case REVERSE_QUOTE_ID:
				{
				State = 5242; Match(REVERSE_QUOTE_ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5254;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,759,Context) ) {
			case 1:
				{
				State = 5245; Match(SET);
				State = 5246; signalConditionInformation();
				State = 5251;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 5247; Match(COMMA);
					State = 5248; signalConditionInformation();
					}
					}
					State = 5253;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SignalConditionInformationContext : ParserRuleContext {
		public ITerminalNode CLASS_ORIGIN() { return GetToken(MySqlParser.CLASS_ORIGIN, 0); }
		public ITerminalNode SUBCLASS_ORIGIN() { return GetToken(MySqlParser.SUBCLASS_ORIGIN, 0); }
		public ITerminalNode MESSAGE_TEXT() { return GetToken(MySqlParser.MESSAGE_TEXT, 0); }
		public ITerminalNode MYSQL_ERRNO() { return GetToken(MySqlParser.MYSQL_ERRNO, 0); }
		public ITerminalNode CONSTRAINT_CATALOG() { return GetToken(MySqlParser.CONSTRAINT_CATALOG, 0); }
		public ITerminalNode CONSTRAINT_SCHEMA() { return GetToken(MySqlParser.CONSTRAINT_SCHEMA, 0); }
		public ITerminalNode CONSTRAINT_NAME() { return GetToken(MySqlParser.CONSTRAINT_NAME, 0); }
		public ITerminalNode CATALOG_NAME() { return GetToken(MySqlParser.CATALOG_NAME, 0); }
		public ITerminalNode SCHEMA_NAME() { return GetToken(MySqlParser.SCHEMA_NAME, 0); }
		public ITerminalNode TABLE_NAME() { return GetToken(MySqlParser.TABLE_NAME, 0); }
		public ITerminalNode COLUMN_NAME() { return GetToken(MySqlParser.COLUMN_NAME, 0); }
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public ITerminalNode DECIMAL_LITERAL() { return GetToken(MySqlParser.DECIMAL_LITERAL, 0); }
		public SignalConditionInformationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_signalConditionInformation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSignalConditionInformation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSignalConditionInformation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSignalConditionInformation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SignalConditionInformationContext signalConditionInformation() {
		SignalConditionInformationContext _localctx = new SignalConditionInformationContext(Context, State);
		EnterRule(_localctx, 486, RULE_signalConditionInformation);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5256;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 280)) & ~0x3f) == 0 && ((1L << (_la - 280)) & ((1L << (CLASS_ORIGIN - 280)) | (1L << (COLUMN_NAME - 280)) | (1L << (CONSTRAINT_CATALOG - 280)) | (1L << (CONSTRAINT_SCHEMA - 280)) | (1L << (CONSTRAINT_NAME - 280)))) != 0) || _la==MESSAGE_TEXT || _la==MYSQL_ERRNO || _la==SUBCLASS_ORIGIN || _la==TABLE_NAME || _la==CATALOG_NAME || _la==SCHEMA_NAME) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5257; Match(EQUAL_SYMBOL);
			State = 5260;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case START_NATIONAL_STRING_LITERAL:
			case STRING_LITERAL:
			case STRING_CHARSET_NAME:
				{
				State = 5258; stringLiteral();
				}
				break;
			case DECIMAL_LITERAL:
				{
				State = 5259; Match(DECIMAL_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DescribeObjectClauseContext : ParserRuleContext {
		public DescribeObjectClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_describeObjectClause; } }
	 
		public DescribeObjectClauseContext() { }
		public virtual void CopyFrom(DescribeObjectClauseContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DescribeStatementsContext : DescribeObjectClauseContext {
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public DeleteStatementContext deleteStatement() {
			return GetRuleContext<DeleteStatementContext>(0);
		}
		public InsertStatementContext insertStatement() {
			return GetRuleContext<InsertStatementContext>(0);
		}
		public ReplaceStatementContext replaceStatement() {
			return GetRuleContext<ReplaceStatementContext>(0);
		}
		public UpdateStatementContext updateStatement() {
			return GetRuleContext<UpdateStatementContext>(0);
		}
		public DescribeStatementsContext(DescribeObjectClauseContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDescribeStatements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDescribeStatements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDescribeStatements(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DescribeConnectionContext : DescribeObjectClauseContext {
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public ITerminalNode CONNECTION() { return GetToken(MySqlParser.CONNECTION, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DescribeConnectionContext(DescribeObjectClauseContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDescribeConnection(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDescribeConnection(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDescribeConnection(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DescribeObjectClauseContext describeObjectClause() {
		DescribeObjectClauseContext _localctx = new DescribeObjectClauseContext(Context, State);
		EnterRule(_localctx, 488, RULE_describeObjectClause);
		try {
			State = 5272;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DELETE:
			case INSERT:
			case REPLACE:
			case SELECT:
			case UPDATE:
			case LR_BRACKET:
				_localctx = new DescribeStatementsContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 5267;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case SELECT:
				case LR_BRACKET:
					{
					State = 5262; selectStatement();
					}
					break;
				case DELETE:
					{
					State = 5263; deleteStatement();
					}
					break;
				case INSERT:
					{
					State = 5264; insertStatement();
					}
					break;
				case REPLACE:
					{
					State = 5265; replaceStatement();
					}
					break;
				case UPDATE:
					{
					State = 5266; updateStatement();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case FOR:
				_localctx = new DescribeConnectionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 5269; Match(FOR);
				State = 5270; Match(CONNECTION);
				State = 5271; uid();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullIdContext : ParserRuleContext {
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public ITerminalNode DOT_ID() { return GetToken(MySqlParser.DOT_ID, 0); }
		public FullIdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullId; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFullId(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFullId(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFullId(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FullIdContext fullId() {
		FullIdContext _localctx = new FullIdContext(Context, State);
		EnterRule(_localctx, 490, RULE_fullId);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5274; uid();
			State = 5278;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,763,Context) ) {
			case 1:
				{
				State = 5275; Match(DOT_ID);
				}
				break;
			case 2:
				{
				State = 5276; Match(DOT);
				State = 5277; uid();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableNameContext : ParserRuleContext {
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public TableNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTableName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTableName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TableNameContext tableName() {
		TableNameContext _localctx = new TableNameContext(Context, State);
		EnterRule(_localctx, 492, RULE_tableName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5280; fullId();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullColumnNameContext : ParserRuleContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DottedIdContext[] dottedId() {
			return GetRuleContexts<DottedIdContext>();
		}
		public DottedIdContext dottedId(int i) {
			return GetRuleContext<DottedIdContext>(i);
		}
		public FullColumnNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullColumnName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFullColumnName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFullColumnName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFullColumnName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FullColumnNameContext fullColumnName() {
		FullColumnNameContext _localctx = new FullColumnNameContext(Context, State);
		EnterRule(_localctx, 494, RULE_fullColumnName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5282; uid();
			State = 5287;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,765,Context) ) {
			case 1:
				{
				State = 5283; dottedId();
				State = 5285;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,764,Context) ) {
				case 1:
					{
					State = 5284; dottedId();
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexColumnNameContext : ParserRuleContext {
		public IToken sortType;
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode ASC() { return GetToken(MySqlParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(MySqlParser.DESC, 0); }
		public IndexColumnNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexColumnName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexColumnName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexColumnName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexColumnName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexColumnNameContext indexColumnName() {
		IndexColumnNameContext _localctx = new IndexColumnNameContext(Context, State);
		EnterRule(_localctx, 496, RULE_indexColumnName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5291;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,766,Context) ) {
			case 1:
				{
				State = 5289; uid();
				}
				break;
			case 2:
				{
				State = 5290; Match(STRING_LITERAL);
				}
				break;
			}
			State = 5297;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LR_BRACKET) {
				{
				State = 5293; Match(LR_BRACKET);
				State = 5294; decimalLiteral();
				State = 5295; Match(RR_BRACKET);
				}
			}

			State = 5300;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASC || _la==DESC) {
				{
				State = 5299;
				_localctx.sortType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ASC || _la==DESC) ) {
					_localctx.sortType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserNameContext : ParserRuleContext {
		public ITerminalNode STRING_USER_NAME() { return GetToken(MySqlParser.STRING_USER_NAME, 0); }
		public ITerminalNode ID() { return GetToken(MySqlParser.ID, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public UserNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUserName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UserNameContext userName() {
		UserNameContext _localctx = new UserNameContext(Context, State);
		EnterRule(_localctx, 498, RULE_userName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5302;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 989)) & ~0x3f) == 0 && ((1L << (_la - 989)) & ((1L << (STRING_LITERAL - 989)) | (1L << (ID - 989)) | (1L << (STRING_USER_NAME - 989)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MysqlVariableContext : ParserRuleContext {
		public ITerminalNode LOCAL_ID() { return GetToken(MySqlParser.LOCAL_ID, 0); }
		public ITerminalNode GLOBAL_ID() { return GetToken(MySqlParser.GLOBAL_ID, 0); }
		public MysqlVariableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mysqlVariable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMysqlVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMysqlVariable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMysqlVariable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MysqlVariableContext mysqlVariable() {
		MysqlVariableContext _localctx = new MysqlVariableContext(Context, State);
		EnterRule(_localctx, 500, RULE_mysqlVariable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5304;
			_la = TokenStream.LA(1);
			if ( !(_la==LOCAL_ID || _la==GLOBAL_ID) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CharsetNameContext : ParserRuleContext {
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public CharsetNameBaseContext charsetNameBase() {
			return GetRuleContext<CharsetNameBaseContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode CHARSET_REVERSE_QOUTE_STRING() { return GetToken(MySqlParser.CHARSET_REVERSE_QOUTE_STRING, 0); }
		public CharsetNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_charsetName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCharsetName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCharsetName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCharsetName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CharsetNameContext charsetName() {
		CharsetNameContext _localctx = new CharsetNameContext(Context, State);
		EnterRule(_localctx, 502, RULE_charsetName);
		try {
			State = 5310;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BINARY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5306; Match(BINARY);
				}
				break;
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5307; charsetNameBase();
				}
				break;
			case STRING_LITERAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5308; Match(STRING_LITERAL);
				}
				break;
			case CHARSET_REVERSE_QOUTE_STRING:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5309; Match(CHARSET_REVERSE_QOUTE_STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollationNameContext : ParserRuleContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public CollationNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collationName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCollationName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCollationName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollationName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CollationNameContext collationName() {
		CollationNameContext _localctx = new CollationNameContext(Context, State);
		EnterRule(_localctx, 504, RULE_collationName);
		try {
			State = 5314;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,770,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5312; uid();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5313; Match(STRING_LITERAL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EngineNameContext : ParserRuleContext {
		public ITerminalNode ARCHIVE() { return GetToken(MySqlParser.ARCHIVE, 0); }
		public ITerminalNode BLACKHOLE() { return GetToken(MySqlParser.BLACKHOLE, 0); }
		public ITerminalNode CSV() { return GetToken(MySqlParser.CSV, 0); }
		public ITerminalNode FEDERATED() { return GetToken(MySqlParser.FEDERATED, 0); }
		public ITerminalNode INNODB() { return GetToken(MySqlParser.INNODB, 0); }
		public ITerminalNode MEMORY() { return GetToken(MySqlParser.MEMORY, 0); }
		public ITerminalNode MRG_MYISAM() { return GetToken(MySqlParser.MRG_MYISAM, 0); }
		public ITerminalNode MYISAM() { return GetToken(MySqlParser.MYISAM, 0); }
		public ITerminalNode NDB() { return GetToken(MySqlParser.NDB, 0); }
		public ITerminalNode NDBCLUSTER() { return GetToken(MySqlParser.NDBCLUSTER, 0); }
		public ITerminalNode PERFORMANCE_SCHEMA() { return GetToken(MySqlParser.PERFORMANCE_SCHEMA, 0); }
		public ITerminalNode TOKUDB() { return GetToken(MySqlParser.TOKUDB, 0); }
		public ITerminalNode ID() { return GetToken(MySqlParser.ID, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode REVERSE_QUOTE_ID() { return GetToken(MySqlParser.REVERSE_QUOTE_ID, 0); }
		public EngineNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_engineName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterEngineName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitEngineName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEngineName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EngineNameContext engineName() {
		EngineNameContext _localctx = new EngineNameContext(Context, State);
		EnterRule(_localctx, 506, RULE_engineName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5316;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 631)) & ~0x3f) == 0 && ((1L << (_la - 631)) & ((1L << (ARCHIVE - 631)) | (1L << (BLACKHOLE - 631)) | (1L << (CSV - 631)) | (1L << (FEDERATED - 631)) | (1L << (INNODB - 631)) | (1L << (MEMORY - 631)) | (1L << (MRG_MYISAM - 631)) | (1L << (MYISAM - 631)) | (1L << (NDB - 631)) | (1L << (NDBCLUSTER - 631)) | (1L << (PERFORMANCE_SCHEMA - 631)) | (1L << (TOKUDB - 631)))) != 0) || ((((_la - 989)) & ~0x3f) == 0 && ((1L << (_la - 989)) & ((1L << (STRING_LITERAL - 989)) | (1L << (ID - 989)) | (1L << (REVERSE_QUOTE_ID - 989)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UuidSetContext : ParserRuleContext {
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public UuidSetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uuidSet; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUuidSet(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUuidSet(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUuidSet(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UuidSetContext uuidSet() {
		UuidSetContext _localctx = new UuidSetContext(Context, State);
		EnterRule(_localctx, 508, RULE_uuidSet);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5318; decimalLiteral();
			State = 5319; Match(MINUS);
			State = 5320; decimalLiteral();
			State = 5321; Match(MINUS);
			State = 5322; decimalLiteral();
			State = 5323; Match(MINUS);
			State = 5324; decimalLiteral();
			State = 5325; Match(MINUS);
			State = 5326; decimalLiteral();
			State = 5332;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 5327; Match(COLON_SYMB);
				State = 5328; decimalLiteral();
				State = 5329; Match(MINUS);
				State = 5330; decimalLiteral();
				}
				}
				State = 5334;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COLON_SYMB );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XidContext : ParserRuleContext {
		public XuidStringIdContext globalTableUid;
		public XuidStringIdContext qualifier;
		public DecimalLiteralContext idFormat;
		public XuidStringIdContext[] xuidStringId() {
			return GetRuleContexts<XuidStringIdContext>();
		}
		public XuidStringIdContext xuidStringId(int i) {
			return GetRuleContext<XuidStringIdContext>(i);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public XidContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xid; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXid(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXid(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXid(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public XidContext xid() {
		XidContext _localctx = new XidContext(Context, State);
		EnterRule(_localctx, 510, RULE_xid);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5336; _localctx.globalTableUid = xuidStringId();
			State = 5343;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 5337; Match(COMMA);
				State = 5338; _localctx.qualifier = xuidStringId();
				State = 5341;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 5339; Match(COMMA);
					State = 5340; _localctx.idFormat = decimalLiteral();
					}
				}

				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XuidStringIdContext : ParserRuleContext {
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public ITerminalNode BIT_STRING() { return GetToken(MySqlParser.BIT_STRING, 0); }
		public ITerminalNode[] HEXADECIMAL_LITERAL() { return GetTokens(MySqlParser.HEXADECIMAL_LITERAL); }
		public ITerminalNode HEXADECIMAL_LITERAL(int i) {
			return GetToken(MySqlParser.HEXADECIMAL_LITERAL, i);
		}
		public XuidStringIdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xuidStringId; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterXuidStringId(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitXuidStringId(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXuidStringId(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public XuidStringIdContext xuidStringId() {
		XuidStringIdContext _localctx = new XuidStringIdContext(Context, State);
		EnterRule(_localctx, 512, RULE_xuidStringId);
		int _la;
		try {
			State = 5352;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STRING_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5345; Match(STRING_LITERAL);
				}
				break;
			case BIT_STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5346; Match(BIT_STRING);
				}
				break;
			case HEXADECIMAL_LITERAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5348;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 5347; Match(HEXADECIMAL_LITERAL);
					}
					}
					State = 5350;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==HEXADECIMAL_LITERAL );
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AuthPluginContext : ParserRuleContext {
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public AuthPluginContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_authPlugin; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAuthPlugin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAuthPlugin(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAuthPlugin(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AuthPluginContext authPlugin() {
		AuthPluginContext _localctx = new AuthPluginContext(Context, State);
		EnterRule(_localctx, 514, RULE_authPlugin);
		try {
			State = 5356;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,776,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5354; uid();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5355; Match(STRING_LITERAL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UidContext : ParserRuleContext {
		public SimpleIdContext simpleId() {
			return GetRuleContext<SimpleIdContext>(0);
		}
		public ITerminalNode REVERSE_QUOTE_ID() { return GetToken(MySqlParser.REVERSE_QUOTE_ID, 0); }
		public ITerminalNode CHARSET_REVERSE_QOUTE_STRING() { return GetToken(MySqlParser.CHARSET_REVERSE_QOUTE_STRING, 0); }
		public UidContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uid; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUid(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUid(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUid(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UidContext uid() {
		UidContext _localctx = new UidContext(Context, State);
		EnterRule(_localctx, 516, RULE_uid);
		try {
			State = 5361;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,777,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5358; simpleId();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5359; Match(REVERSE_QUOTE_ID);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5360; Match(CHARSET_REVERSE_QOUTE_STRING);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleIdContext : ParserRuleContext {
		public ITerminalNode ID() { return GetToken(MySqlParser.ID, 0); }
		public CharsetNameBaseContext charsetNameBase() {
			return GetRuleContext<CharsetNameBaseContext>(0);
		}
		public TransactionLevelBaseContext transactionLevelBase() {
			return GetRuleContext<TransactionLevelBaseContext>(0);
		}
		public EngineNameContext engineName() {
			return GetRuleContext<EngineNameContext>(0);
		}
		public PrivilegesBaseContext privilegesBase() {
			return GetRuleContext<PrivilegesBaseContext>(0);
		}
		public IntervalTypeBaseContext intervalTypeBase() {
			return GetRuleContext<IntervalTypeBaseContext>(0);
		}
		public DataTypeBaseContext dataTypeBase() {
			return GetRuleContext<DataTypeBaseContext>(0);
		}
		public KeywordsCanBeIdContext keywordsCanBeId() {
			return GetRuleContext<KeywordsCanBeIdContext>(0);
		}
		public FunctionNameBaseContext functionNameBase() {
			return GetRuleContext<FunctionNameBaseContext>(0);
		}
		public SimpleIdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleId; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleId(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleId(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleId(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleIdContext simpleId() {
		SimpleIdContext _localctx = new SimpleIdContext(Context, State);
		EnterRule(_localctx, 518, RULE_simpleId);
		try {
			State = 5372;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,778,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5363; Match(ID);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5364; charsetNameBase();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5365; transactionLevelBase();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5366; engineName();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5367; privilegesBase();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5368; intervalTypeBase();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5369; dataTypeBase();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5370; keywordsCanBeId();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5371; functionNameBase();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DottedIdContext : ParserRuleContext {
		public ITerminalNode DOT_ID() { return GetToken(MySqlParser.DOT_ID, 0); }
		public UidContext uid() {
			return GetRuleContext<UidContext>(0);
		}
		public DottedIdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dottedId; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDottedId(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDottedId(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDottedId(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DottedIdContext dottedId() {
		DottedIdContext _localctx = new DottedIdContext(Context, State);
		EnterRule(_localctx, 520, RULE_dottedId);
		try {
			State = 5377;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DOT_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5374; Match(DOT_ID);
				}
				break;
			case DOT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5375; Match(DOT);
				State = 5376; uid();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DecimalLiteralContext : ParserRuleContext {
		public ITerminalNode DECIMAL_LITERAL() { return GetToken(MySqlParser.DECIMAL_LITERAL, 0); }
		public ITerminalNode ZERO_DECIMAL() { return GetToken(MySqlParser.ZERO_DECIMAL, 0); }
		public ITerminalNode ONE_DECIMAL() { return GetToken(MySqlParser.ONE_DECIMAL, 0); }
		public ITerminalNode TWO_DECIMAL() { return GetToken(MySqlParser.TWO_DECIMAL, 0); }
		public DecimalLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_decimalLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDecimalLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDecimalLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDecimalLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DecimalLiteralContext decimalLiteral() {
		DecimalLiteralContext _localctx = new DecimalLiteralContext(Context, State);
		EnterRule(_localctx, 522, RULE_decimalLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5379;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 979)) & ~0x3f) == 0 && ((1L << (_la - 979)) & ((1L << (ZERO_DECIMAL - 979)) | (1L << (ONE_DECIMAL - 979)) | (1L << (TWO_DECIMAL - 979)) | (1L << (DECIMAL_LITERAL - 979)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FileSizeLiteralContext : ParserRuleContext {
		public ITerminalNode FILESIZE_LITERAL() { return GetToken(MySqlParser.FILESIZE_LITERAL, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public FileSizeLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fileSizeLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFileSizeLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFileSizeLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFileSizeLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FileSizeLiteralContext fileSizeLiteral() {
		FileSizeLiteralContext _localctx = new FileSizeLiteralContext(Context, State);
		EnterRule(_localctx, 524, RULE_fileSizeLiteral);
		try {
			State = 5383;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FILESIZE_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5381; Match(FILESIZE_LITERAL);
				}
				break;
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case DECIMAL_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5382; decimalLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringLiteralContext : ParserRuleContext {
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(MySqlParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(MySqlParser.STRING_LITERAL, i);
		}
		public ITerminalNode START_NATIONAL_STRING_LITERAL() { return GetToken(MySqlParser.START_NATIONAL_STRING_LITERAL, 0); }
		public ITerminalNode STRING_CHARSET_NAME() { return GetToken(MySqlParser.STRING_CHARSET_NAME, 0); }
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public StringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStringLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStringLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringLiteralContext stringLiteral() {
		StringLiteralContext _localctx = new StringLiteralContext(Context, State);
		EnterRule(_localctx, 526, RULE_stringLiteral);
		int _la;
		try {
			int _alt;
			State = 5408;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,787,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5390;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case STRING_LITERAL:
				case STRING_CHARSET_NAME:
					{
					State = 5386;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==STRING_CHARSET_NAME) {
						{
						State = 5385; Match(STRING_CHARSET_NAME);
						}
					}

					State = 5388; Match(STRING_LITERAL);
					}
					break;
				case START_NATIONAL_STRING_LITERAL:
					{
					State = 5389; Match(START_NATIONAL_STRING_LITERAL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5393;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 5392; Match(STRING_LITERAL);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5395;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,783,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5402;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case STRING_LITERAL:
				case STRING_CHARSET_NAME:
					{
					State = 5398;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==STRING_CHARSET_NAME) {
						{
						State = 5397; Match(STRING_CHARSET_NAME);
						}
					}

					State = 5400; Match(STRING_LITERAL);
					}
					break;
				case START_NATIONAL_STRING_LITERAL:
					{
					State = 5401; Match(START_NATIONAL_STRING_LITERAL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5406;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,786,Context) ) {
				case 1:
					{
					State = 5404; Match(COLLATE);
					State = 5405; collationName();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanLiteralContext : ParserRuleContext {
		public ITerminalNode TRUE() { return GetToken(MySqlParser.TRUE, 0); }
		public ITerminalNode FALSE() { return GetToken(MySqlParser.FALSE, 0); }
		public BooleanLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booleanLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBooleanLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBooleanLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBooleanLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BooleanLiteralContext booleanLiteral() {
		BooleanLiteralContext _localctx = new BooleanLiteralContext(Context, State);
		EnterRule(_localctx, 528, RULE_booleanLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5410;
			_la = TokenStream.LA(1);
			if ( !(_la==FALSE || _la==TRUE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HexadecimalLiteralContext : ParserRuleContext {
		public ITerminalNode HEXADECIMAL_LITERAL() { return GetToken(MySqlParser.HEXADECIMAL_LITERAL, 0); }
		public ITerminalNode STRING_CHARSET_NAME() { return GetToken(MySqlParser.STRING_CHARSET_NAME, 0); }
		public HexadecimalLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hexadecimalLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterHexadecimalLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitHexadecimalLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHexadecimalLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HexadecimalLiteralContext hexadecimalLiteral() {
		HexadecimalLiteralContext _localctx = new HexadecimalLiteralContext(Context, State);
		EnterRule(_localctx, 530, RULE_hexadecimalLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5413;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STRING_CHARSET_NAME) {
				{
				State = 5412; Match(STRING_CHARSET_NAME);
				}
			}

			State = 5415; Match(HEXADECIMAL_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NullNotnullContext : ParserRuleContext {
		public ITerminalNode NULL_LITERAL() { return GetToken(MySqlParser.NULL_LITERAL, 0); }
		public ITerminalNode NULL_SPEC_LITERAL() { return GetToken(MySqlParser.NULL_SPEC_LITERAL, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public NullNotnullContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nullNotnull; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNullNotnull(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNullNotnull(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNullNotnull(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NullNotnullContext nullNotnull() {
		NullNotnullContext _localctx = new NullNotnullContext(Context, State);
		EnterRule(_localctx, 532, RULE_nullNotnull);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5418;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 5417; Match(NOT);
				}
			}

			State = 5420;
			_la = TokenStream.LA(1);
			if ( !(_la==NULL_LITERAL || _la==NULL_SPEC_LITERAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public IToken nullLiteral;
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public HexadecimalLiteralContext hexadecimalLiteral() {
			return GetRuleContext<HexadecimalLiteralContext>(0);
		}
		public BooleanLiteralContext booleanLiteral() {
			return GetRuleContext<BooleanLiteralContext>(0);
		}
		public ITerminalNode REAL_LITERAL() { return GetToken(MySqlParser.REAL_LITERAL, 0); }
		public ITerminalNode BIT_STRING() { return GetToken(MySqlParser.BIT_STRING, 0); }
		public ITerminalNode NULL_LITERAL() { return GetToken(MySqlParser.NULL_LITERAL, 0); }
		public ITerminalNode NULL_SPEC_LITERAL() { return GetToken(MySqlParser.NULL_SPEC_LITERAL, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(Context, State);
		EnterRule(_localctx, 534, RULE_constant);
		int _la;
		try {
			State = 5434;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,791,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5422; stringLiteral();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5423; decimalLiteral();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5424; Match(MINUS);
				State = 5425; decimalLiteral();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5426; hexadecimalLiteral();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5427; booleanLiteral();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5428; Match(REAL_LITERAL);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5429; Match(BIT_STRING);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5431;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 5430; Match(NOT);
					}
				}

				State = 5433;
				_localctx.nullLiteral = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==NULL_LITERAL || _la==NULL_SPEC_LITERAL) ) {
					_localctx.nullLiteral = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DataTypeContext : ParserRuleContext {
		public DataTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dataType; } }
	 
		public DataTypeContext() { }
		public virtual void CopyFrom(DataTypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SpatialDataTypeContext : DataTypeContext {
		public IToken typeName;
		public ITerminalNode GEOMETRYCOLLECTION() { return GetToken(MySqlParser.GEOMETRYCOLLECTION, 0); }
		public ITerminalNode GEOMCOLLECTION() { return GetToken(MySqlParser.GEOMCOLLECTION, 0); }
		public ITerminalNode LINESTRING() { return GetToken(MySqlParser.LINESTRING, 0); }
		public ITerminalNode MULTILINESTRING() { return GetToken(MySqlParser.MULTILINESTRING, 0); }
		public ITerminalNode MULTIPOINT() { return GetToken(MySqlParser.MULTIPOINT, 0); }
		public ITerminalNode MULTIPOLYGON() { return GetToken(MySqlParser.MULTIPOLYGON, 0); }
		public ITerminalNode POINT() { return GetToken(MySqlParser.POINT, 0); }
		public ITerminalNode POLYGON() { return GetToken(MySqlParser.POLYGON, 0); }
		public ITerminalNode JSON() { return GetToken(MySqlParser.JSON, 0); }
		public ITerminalNode GEOMETRY() { return GetToken(MySqlParser.GEOMETRY, 0); }
		public SpatialDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSpatialDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSpatialDataType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpatialDataType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CollectionDataTypeContext : DataTypeContext {
		public IToken typeName;
		public CollectionOptionsContext collectionOptions() {
			return GetRuleContext<CollectionOptionsContext>(0);
		}
		public ITerminalNode ENUM() { return GetToken(MySqlParser.ENUM, 0); }
		public ITerminalNode[] SET() { return GetTokens(MySqlParser.SET); }
		public ITerminalNode SET(int i) {
			return GetToken(MySqlParser.SET, i);
		}
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public CollectionDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCollectionDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCollectionDataType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollectionDataType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NationalVaryingStringDataTypeContext : DataTypeContext {
		public IToken typeName;
		public ITerminalNode NATIONAL() { return GetToken(MySqlParser.NATIONAL, 0); }
		public ITerminalNode VARYING() { return GetToken(MySqlParser.VARYING, 0); }
		public ITerminalNode CHAR() { return GetToken(MySqlParser.CHAR, 0); }
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public LengthOneDimensionContext lengthOneDimension() {
			return GetRuleContext<LengthOneDimensionContext>(0);
		}
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public NationalVaryingStringDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNationalVaryingStringDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNationalVaryingStringDataType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNationalVaryingStringDataType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DimensionDataTypeContext : DataTypeContext {
		public IToken typeName;
		public ITerminalNode TINYINT() { return GetToken(MySqlParser.TINYINT, 0); }
		public ITerminalNode SMALLINT() { return GetToken(MySqlParser.SMALLINT, 0); }
		public ITerminalNode MEDIUMINT() { return GetToken(MySqlParser.MEDIUMINT, 0); }
		public ITerminalNode INT() { return GetToken(MySqlParser.INT, 0); }
		public ITerminalNode INTEGER() { return GetToken(MySqlParser.INTEGER, 0); }
		public ITerminalNode BIGINT() { return GetToken(MySqlParser.BIGINT, 0); }
		public LengthOneDimensionContext lengthOneDimension() {
			return GetRuleContext<LengthOneDimensionContext>(0);
		}
		public ITerminalNode ZEROFILL() { return GetToken(MySqlParser.ZEROFILL, 0); }
		public ITerminalNode SIGNED() { return GetToken(MySqlParser.SIGNED, 0); }
		public ITerminalNode UNSIGNED() { return GetToken(MySqlParser.UNSIGNED, 0); }
		public ITerminalNode REAL() { return GetToken(MySqlParser.REAL, 0); }
		public LengthTwoDimensionContext lengthTwoDimension() {
			return GetRuleContext<LengthTwoDimensionContext>(0);
		}
		public ITerminalNode DOUBLE() { return GetToken(MySqlParser.DOUBLE, 0); }
		public ITerminalNode PRECISION() { return GetToken(MySqlParser.PRECISION, 0); }
		public ITerminalNode DECIMAL() { return GetToken(MySqlParser.DECIMAL, 0); }
		public ITerminalNode DEC() { return GetToken(MySqlParser.DEC, 0); }
		public ITerminalNode FIXED() { return GetToken(MySqlParser.FIXED, 0); }
		public ITerminalNode NUMERIC() { return GetToken(MySqlParser.NUMERIC, 0); }
		public ITerminalNode FLOAT() { return GetToken(MySqlParser.FLOAT, 0); }
		public LengthTwoOptionalDimensionContext lengthTwoOptionalDimension() {
			return GetRuleContext<LengthTwoOptionalDimensionContext>(0);
		}
		public ITerminalNode BIT() { return GetToken(MySqlParser.BIT, 0); }
		public ITerminalNode TIME() { return GetToken(MySqlParser.TIME, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(MySqlParser.TIMESTAMP, 0); }
		public ITerminalNode DATETIME() { return GetToken(MySqlParser.DATETIME, 0); }
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ITerminalNode VARBINARY() { return GetToken(MySqlParser.VARBINARY, 0); }
		public ITerminalNode YEAR() { return GetToken(MySqlParser.YEAR, 0); }
		public DimensionDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDimensionDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDimensionDataType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDimensionDataType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StringDataTypeContext : DataTypeContext {
		public IToken typeName;
		public ITerminalNode CHAR() { return GetToken(MySqlParser.CHAR, 0); }
		public ITerminalNode VARCHAR() { return GetToken(MySqlParser.VARCHAR, 0); }
		public ITerminalNode TINYTEXT() { return GetToken(MySqlParser.TINYTEXT, 0); }
		public ITerminalNode TEXT() { return GetToken(MySqlParser.TEXT, 0); }
		public ITerminalNode MEDIUMTEXT() { return GetToken(MySqlParser.MEDIUMTEXT, 0); }
		public ITerminalNode LONGTEXT() { return GetToken(MySqlParser.LONGTEXT, 0); }
		public ITerminalNode NCHAR() { return GetToken(MySqlParser.NCHAR, 0); }
		public ITerminalNode NVARCHAR() { return GetToken(MySqlParser.NVARCHAR, 0); }
		public LengthOneDimensionContext lengthOneDimension() {
			return GetRuleContext<LengthOneDimensionContext>(0);
		}
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public StringDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterStringDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitStringDataType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringDataType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NationalStringDataTypeContext : DataTypeContext {
		public IToken typeName;
		public ITerminalNode NATIONAL() { return GetToken(MySqlParser.NATIONAL, 0); }
		public ITerminalNode VARCHAR() { return GetToken(MySqlParser.VARCHAR, 0); }
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public LengthOneDimensionContext lengthOneDimension() {
			return GetRuleContext<LengthOneDimensionContext>(0);
		}
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ITerminalNode NCHAR() { return GetToken(MySqlParser.NCHAR, 0); }
		public NationalStringDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNationalStringDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNationalStringDataType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNationalStringDataType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SimpleDataTypeContext : DataTypeContext {
		public IToken typeName;
		public ITerminalNode DATE() { return GetToken(MySqlParser.DATE, 0); }
		public ITerminalNode TINYBLOB() { return GetToken(MySqlParser.TINYBLOB, 0); }
		public ITerminalNode BLOB() { return GetToken(MySqlParser.BLOB, 0); }
		public ITerminalNode MEDIUMBLOB() { return GetToken(MySqlParser.MEDIUMBLOB, 0); }
		public ITerminalNode LONGBLOB() { return GetToken(MySqlParser.LONGBLOB, 0); }
		public ITerminalNode BOOL() { return GetToken(MySqlParser.BOOL, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(MySqlParser.BOOLEAN, 0); }
		public ITerminalNode SERIAL() { return GetToken(MySqlParser.SERIAL, 0); }
		public SimpleDataTypeContext(DataTypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleDataType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleDataType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DataTypeContext dataType() {
		DataTypeContext _localctx = new DataTypeContext(Context, State);
		EnterRule(_localctx, 536, RULE_dataType);
		int _la;
		try {
			State = 5542;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,820,Context) ) {
			case 1:
				_localctx = new StringDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 5436;
				((StringDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 190)) & ~0x3f) == 0 && ((1L << (_la - 190)) & ((1L << (CHAR - 190)) | (1L << (VARCHAR - 190)) | (1L << (NVARCHAR - 190)) | (1L << (TINYTEXT - 190)) | (1L << (TEXT - 190)) | (1L << (MEDIUMTEXT - 190)) | (1L << (LONGTEXT - 190)))) != 0) || _la==NCHAR) ) {
					((StringDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5438;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,792,Context) ) {
				case 1:
					{
					State = 5437; lengthOneDimension();
					}
					break;
				}
				State = 5441;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BINARY) {
					{
					State = 5440; Match(BINARY);
					}
				}

				State = 5449;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,795,Context) ) {
				case 1:
					{
					State = 5446;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case CHARACTER:
						{
						State = 5443; Match(CHARACTER);
						State = 5444; Match(SET);
						}
						break;
					case CHARSET:
						{
						State = 5445; Match(CHARSET);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5448; charsetName();
					}
					break;
				}
				State = 5453;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,796,Context) ) {
				case 1:
					{
					State = 5451; Match(COLLATE);
					State = 5452; collationName();
					}
					break;
				}
				}
				break;
			case 2:
				_localctx = new NationalStringDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 5455; Match(NATIONAL);
				State = 5456;
				((NationalStringDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==CHARACTER || _la==VARCHAR) ) {
					((NationalStringDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5458;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,797,Context) ) {
				case 1:
					{
					State = 5457; lengthOneDimension();
					}
					break;
				}
				State = 5461;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BINARY) {
					{
					State = 5460; Match(BINARY);
					}
				}

				}
				break;
			case 3:
				_localctx = new NationalStringDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 5463; Match(NCHAR);
				State = 5464; ((NationalStringDataTypeContext)_localctx).typeName = Match(VARCHAR);
				State = 5466;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,799,Context) ) {
				case 1:
					{
					State = 5465; lengthOneDimension();
					}
					break;
				}
				State = 5469;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BINARY) {
					{
					State = 5468; Match(BINARY);
					}
				}

				}
				break;
			case 4:
				_localctx = new NationalVaryingStringDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 5471; Match(NATIONAL);
				State = 5472;
				((NationalVaryingStringDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==CHARACTER || _la==CHAR) ) {
					((NationalVaryingStringDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5473; Match(VARYING);
				State = 5475;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,801,Context) ) {
				case 1:
					{
					State = 5474; lengthOneDimension();
					}
					break;
				}
				State = 5478;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BINARY) {
					{
					State = 5477; Match(BINARY);
					}
				}

				}
				break;
			case 5:
				_localctx = new DimensionDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 5480;
				((DimensionDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 172)) & ~0x3f) == 0 && ((1L << (_la - 172)) & ((1L << (TINYINT - 172)) | (1L << (SMALLINT - 172)) | (1L << (MEDIUMINT - 172)) | (1L << (INT - 172)) | (1L << (INTEGER - 172)) | (1L << (BIGINT - 172)))) != 0)) ) {
					((DimensionDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5482;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,803,Context) ) {
				case 1:
					{
					State = 5481; lengthOneDimension();
					}
					break;
				}
				State = 5485;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,804,Context) ) {
				case 1:
					{
					State = 5484;
					_la = TokenStream.LA(1);
					if ( !(_la==UNSIGNED || _la==SIGNED) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 5488;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ZEROFILL) {
					{
					State = 5487; Match(ZEROFILL);
					}
				}

				}
				break;
			case 6:
				_localctx = new DimensionDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 5490; ((DimensionDataTypeContext)_localctx).typeName = Match(REAL);
				State = 5492;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,806,Context) ) {
				case 1:
					{
					State = 5491; lengthTwoDimension();
					}
					break;
				}
				State = 5495;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,807,Context) ) {
				case 1:
					{
					State = 5494;
					_la = TokenStream.LA(1);
					if ( !(_la==UNSIGNED || _la==SIGNED) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 5498;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ZEROFILL) {
					{
					State = 5497; Match(ZEROFILL);
					}
				}

				}
				break;
			case 7:
				_localctx = new DimensionDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 5500; ((DimensionDataTypeContext)_localctx).typeName = Match(DOUBLE);
				State = 5502;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PRECISION) {
					{
					State = 5501; Match(PRECISION);
					}
				}

				State = 5505;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,810,Context) ) {
				case 1:
					{
					State = 5504; lengthTwoDimension();
					}
					break;
				}
				State = 5508;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,811,Context) ) {
				case 1:
					{
					State = 5507;
					_la = TokenStream.LA(1);
					if ( !(_la==UNSIGNED || _la==SIGNED) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 5511;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ZEROFILL) {
					{
					State = 5510; Match(ZEROFILL);
					}
				}

				}
				break;
			case 8:
				_localctx = new DimensionDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 5513;
				((DimensionDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 181)) & ~0x3f) == 0 && ((1L << (_la - 181)) & ((1L << (FLOAT - 181)) | (1L << (DECIMAL - 181)) | (1L << (DEC - 181)) | (1L << (NUMERIC - 181)))) != 0) || _la==FIXED) ) {
					((DimensionDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5515;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,813,Context) ) {
				case 1:
					{
					State = 5514; lengthTwoOptionalDimension();
					}
					break;
				}
				State = 5518;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,814,Context) ) {
				case 1:
					{
					State = 5517;
					_la = TokenStream.LA(1);
					if ( !(_la==UNSIGNED || _la==SIGNED) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 5521;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ZEROFILL) {
					{
					State = 5520; Match(ZEROFILL);
					}
				}

				}
				break;
			case 9:
				_localctx = new SimpleDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 5523;
				((SimpleDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TINYBLOB - 185)) | (1L << (BLOB - 185)) | (1L << (MEDIUMBLOB - 185)) | (1L << (LONGBLOB - 185)) | (1L << (SERIAL - 185)))) != 0) || _la==BOOL || _la==BOOLEAN) ) {
					((SimpleDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 10:
				_localctx = new DimensionDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 5524;
				((DimensionDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 186)) & ~0x3f) == 0 && ((1L << (_la - 186)) & ((1L << (TIME - 186)) | (1L << (TIMESTAMP - 186)) | (1L << (DATETIME - 186)) | (1L << (YEAR - 186)) | (1L << (BINARY - 186)) | (1L << (VARBINARY - 186)))) != 0) || _la==BIT) ) {
					((DimensionDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5526;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,816,Context) ) {
				case 1:
					{
					State = 5525; lengthOneDimension();
					}
					break;
				}
				}
				break;
			case 11:
				_localctx = new CollectionDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 5528;
				((CollectionDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==SET || _la==ENUM) ) {
					((CollectionDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5529; collectionOptions();
				State = 5531;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BINARY) {
					{
					State = 5530; Match(BINARY);
					}
				}

				State = 5539;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,819,Context) ) {
				case 1:
					{
					State = 5536;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case CHARACTER:
						{
						State = 5533; Match(CHARACTER);
						State = 5534; Match(SET);
						}
						break;
					case CHARSET:
						{
						State = 5535; Match(CHARSET);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5538; charsetName();
					}
					break;
				}
				}
				break;
			case 12:
				_localctx = new SpatialDataTypeContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 5541;
				((SpatialDataTypeContext)_localctx).typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==JSON || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (GEOMETRYCOLLECTION - 647)) | (1L << (GEOMCOLLECTION - 647)) | (1L << (GEOMETRY - 647)) | (1L << (LINESTRING - 647)) | (1L << (MULTILINESTRING - 647)) | (1L << (MULTIPOINT - 647)) | (1L << (MULTIPOLYGON - 647)) | (1L << (POINT - 647)) | (1L << (POLYGON - 647)))) != 0)) ) {
					((SpatialDataTypeContext)_localctx).typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectionOptionsContext : ParserRuleContext {
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(MySqlParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(MySqlParser.STRING_LITERAL, i);
		}
		public CollectionOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectionOptions; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCollectionOptions(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCollectionOptions(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollectionOptions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CollectionOptionsContext collectionOptions() {
		CollectionOptionsContext _localctx = new CollectionOptionsContext(Context, State);
		EnterRule(_localctx, 538, RULE_collectionOptions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5544; Match(LR_BRACKET);
			State = 5545; Match(STRING_LITERAL);
			State = 5550;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5546; Match(COMMA);
				State = 5547; Match(STRING_LITERAL);
				}
				}
				State = 5552;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5553; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConvertedDataTypeContext : ParserRuleContext {
		public IToken typeName;
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ITerminalNode NCHAR() { return GetToken(MySqlParser.NCHAR, 0); }
		public LengthOneDimensionContext lengthOneDimension() {
			return GetRuleContext<LengthOneDimensionContext>(0);
		}
		public ITerminalNode CHAR() { return GetToken(MySqlParser.CHAR, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode CHARACTER() { return GetToken(MySqlParser.CHARACTER, 0); }
		public ITerminalNode SET() { return GetToken(MySqlParser.SET, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public ITerminalNode DATE() { return GetToken(MySqlParser.DATE, 0); }
		public ITerminalNode DATETIME() { return GetToken(MySqlParser.DATETIME, 0); }
		public ITerminalNode TIME() { return GetToken(MySqlParser.TIME, 0); }
		public ITerminalNode JSON() { return GetToken(MySqlParser.JSON, 0); }
		public ITerminalNode DECIMAL() { return GetToken(MySqlParser.DECIMAL, 0); }
		public LengthTwoDimensionContext lengthTwoDimension() {
			return GetRuleContext<LengthTwoDimensionContext>(0);
		}
		public ITerminalNode SIGNED() { return GetToken(MySqlParser.SIGNED, 0); }
		public ITerminalNode UNSIGNED() { return GetToken(MySqlParser.UNSIGNED, 0); }
		public ITerminalNode INTEGER() { return GetToken(MySqlParser.INTEGER, 0); }
		public ConvertedDataTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_convertedDataType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterConvertedDataType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitConvertedDataType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConvertedDataType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConvertedDataTypeContext convertedDataType() {
		ConvertedDataTypeContext _localctx = new ConvertedDataTypeContext(Context, State);
		EnterRule(_localctx, 540, RULE_convertedDataType);
		int _la;
		try {
			State = 5580;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BINARY:
			case NCHAR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5555;
				_localctx.typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==BINARY || _la==NCHAR) ) {
					_localctx.typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5557;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LR_BRACKET) {
					{
					State = 5556; lengthOneDimension();
					}
				}

				}
				break;
			case CHAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5559; _localctx.typeName = Match(CHAR);
				State = 5561;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LR_BRACKET) {
					{
					State = 5560; lengthOneDimension();
					}
				}

				State = 5569;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CHARACTER || _la==CHARSET) {
					{
					State = 5566;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case CHARACTER:
						{
						State = 5563; Match(CHARACTER);
						State = 5564; Match(SET);
						}
						break;
					case CHARSET:
						{
						State = 5565; Match(CHARSET);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5568; charsetName();
					}
				}

				}
				break;
			case DATE:
			case TIME:
			case DATETIME:
			case JSON:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5571;
				_localctx.typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (DATETIME - 185)))) != 0) || _la==JSON) ) {
					_localctx.typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case DECIMAL:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5572; _localctx.typeName = Match(DECIMAL);
				State = 5574;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LR_BRACKET) {
					{
					State = 5573; lengthTwoDimension();
					}
				}

				}
				break;
			case UNSIGNED:
			case SIGNED:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5576;
				_la = TokenStream.LA(1);
				if ( !(_la==UNSIGNED || _la==SIGNED) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5578;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INTEGER) {
					{
					State = 5577; Match(INTEGER);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LengthOneDimensionContext : ParserRuleContext {
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public LengthOneDimensionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lengthOneDimension; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLengthOneDimension(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLengthOneDimension(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLengthOneDimension(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LengthOneDimensionContext lengthOneDimension() {
		LengthOneDimensionContext _localctx = new LengthOneDimensionContext(Context, State);
		EnterRule(_localctx, 542, RULE_lengthOneDimension);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5582; Match(LR_BRACKET);
			State = 5583; decimalLiteral();
			State = 5584; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LengthTwoDimensionContext : ParserRuleContext {
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public LengthTwoDimensionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lengthTwoDimension; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLengthTwoDimension(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLengthTwoDimension(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLengthTwoDimension(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LengthTwoDimensionContext lengthTwoDimension() {
		LengthTwoDimensionContext _localctx = new LengthTwoDimensionContext(Context, State);
		EnterRule(_localctx, 544, RULE_lengthTwoDimension);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5586; Match(LR_BRACKET);
			State = 5587; decimalLiteral();
			State = 5588; Match(COMMA);
			State = 5589; decimalLiteral();
			State = 5590; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LengthTwoOptionalDimensionContext : ParserRuleContext {
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public LengthTwoOptionalDimensionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lengthTwoOptionalDimension; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLengthTwoOptionalDimension(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLengthTwoOptionalDimension(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLengthTwoOptionalDimension(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LengthTwoOptionalDimensionContext lengthTwoOptionalDimension() {
		LengthTwoOptionalDimensionContext _localctx = new LengthTwoOptionalDimensionContext(Context, State);
		EnterRule(_localctx, 546, RULE_lengthTwoOptionalDimension);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5592; Match(LR_BRACKET);
			State = 5593; decimalLiteral();
			State = 5596;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 5594; Match(COMMA);
				State = 5595; decimalLiteral();
				}
			}

			State = 5598; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UidListContext : ParserRuleContext {
		public UidContext[] uid() {
			return GetRuleContexts<UidContext>();
		}
		public UidContext uid(int i) {
			return GetRuleContext<UidContext>(i);
		}
		public UidListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uidList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUidList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUidList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUidList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UidListContext uidList() {
		UidListContext _localctx = new UidListContext(Context, State);
		EnterRule(_localctx, 548, RULE_uidList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5600; uid();
			State = 5605;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,830,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 5601; Match(COMMA);
					State = 5602; uid();
					}
					} 
				}
				State = 5607;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,830,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TablesContext : ParserRuleContext {
		public TableNameContext[] tableName() {
			return GetRuleContexts<TableNameContext>();
		}
		public TableNameContext tableName(int i) {
			return GetRuleContext<TableNameContext>(i);
		}
		public TablesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tables; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTables(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTables(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTables(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TablesContext tables() {
		TablesContext _localctx = new TablesContext(Context, State);
		EnterRule(_localctx, 550, RULE_tables);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5608; tableName();
			State = 5613;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,831,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 5609; Match(COMMA);
					State = 5610; tableName();
					}
					} 
				}
				State = 5615;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,831,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexColumnNamesContext : ParserRuleContext {
		public IndexColumnNameContext[] indexColumnName() {
			return GetRuleContexts<IndexColumnNameContext>();
		}
		public IndexColumnNameContext indexColumnName(int i) {
			return GetRuleContext<IndexColumnNameContext>(i);
		}
		public IndexColumnNamesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexColumnNames; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIndexColumnNames(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIndexColumnNames(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexColumnNames(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexColumnNamesContext indexColumnNames() {
		IndexColumnNamesContext _localctx = new IndexColumnNamesContext(Context, State);
		EnterRule(_localctx, 552, RULE_indexColumnNames);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5616; Match(LR_BRACKET);
			State = 5617; indexColumnName();
			State = 5622;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5618; Match(COMMA);
				State = 5619; indexColumnName();
				}
				}
				State = 5624;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 5625; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionsContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ExpressionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressions; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExpressions(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExpressions(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionsContext expressions() {
		ExpressionsContext _localctx = new ExpressionsContext(Context, State);
		EnterRule(_localctx, 554, RULE_expressions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5627; expression(0);
			State = 5632;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5628; Match(COMMA);
				State = 5629; expression(0);
				}
				}
				State = 5634;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionsWithDefaultsContext : ParserRuleContext {
		public ExpressionOrDefaultContext[] expressionOrDefault() {
			return GetRuleContexts<ExpressionOrDefaultContext>();
		}
		public ExpressionOrDefaultContext expressionOrDefault(int i) {
			return GetRuleContext<ExpressionOrDefaultContext>(i);
		}
		public ExpressionsWithDefaultsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionsWithDefaults; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExpressionsWithDefaults(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExpressionsWithDefaults(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionsWithDefaults(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionsWithDefaultsContext expressionsWithDefaults() {
		ExpressionsWithDefaultsContext _localctx = new ExpressionsWithDefaultsContext(Context, State);
		EnterRule(_localctx, 556, RULE_expressionsWithDefaults);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5635; expressionOrDefault();
			State = 5640;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5636; Match(COMMA);
				State = 5637; expressionOrDefault();
				}
				}
				State = 5642;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantsContext : ParserRuleContext {
		public ConstantContext[] constant() {
			return GetRuleContexts<ConstantContext>();
		}
		public ConstantContext constant(int i) {
			return GetRuleContext<ConstantContext>(i);
		}
		public ConstantsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constants; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterConstants(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitConstants(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstants(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantsContext constants() {
		ConstantsContext _localctx = new ConstantsContext(Context, State);
		EnterRule(_localctx, 558, RULE_constants);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5643; constant();
			State = 5648;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5644; Match(COMMA);
				State = 5645; constant();
				}
				}
				State = 5650;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleStringsContext : ParserRuleContext {
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(MySqlParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(MySqlParser.STRING_LITERAL, i);
		}
		public SimpleStringsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleStrings; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleStrings(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleStrings(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleStrings(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleStringsContext simpleStrings() {
		SimpleStringsContext _localctx = new SimpleStringsContext(Context, State);
		EnterRule(_localctx, 560, RULE_simpleStrings);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5651; Match(STRING_LITERAL);
			State = 5656;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5652; Match(COMMA);
				State = 5653; Match(STRING_LITERAL);
				}
				}
				State = 5658;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserVariablesContext : ParserRuleContext {
		public ITerminalNode[] LOCAL_ID() { return GetTokens(MySqlParser.LOCAL_ID); }
		public ITerminalNode LOCAL_ID(int i) {
			return GetToken(MySqlParser.LOCAL_ID, i);
		}
		public UserVariablesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userVariables; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUserVariables(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUserVariables(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUserVariables(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UserVariablesContext userVariables() {
		UserVariablesContext _localctx = new UserVariablesContext(Context, State);
		EnterRule(_localctx, 562, RULE_userVariables);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5659; Match(LOCAL_ID);
			State = 5664;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 5660; Match(COMMA);
				State = 5661; Match(LOCAL_ID);
				}
				}
				State = 5666;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefaultValueContext : ParserRuleContext {
		public ITerminalNode NULL_LITERAL() { return GetToken(MySqlParser.NULL_LITERAL, 0); }
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public UnaryOperatorContext unaryOperator() {
			return GetRuleContext<UnaryOperatorContext>(0);
		}
		public CurrentTimestampContext[] currentTimestamp() {
			return GetRuleContexts<CurrentTimestampContext>();
		}
		public CurrentTimestampContext currentTimestamp(int i) {
			return GetRuleContext<CurrentTimestampContext>(i);
		}
		public ITerminalNode ON() { return GetToken(MySqlParser.ON, 0); }
		public ITerminalNode UPDATE() { return GetToken(MySqlParser.UPDATE, 0); }
		public DefaultValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defaultValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDefaultValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDefaultValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefaultValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DefaultValueContext defaultValue() {
		DefaultValueContext _localctx = new DefaultValueContext(Context, State);
		EnterRule(_localctx, 564, RULE_defaultValue);
		try {
			State = 5678;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,840,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5667; Match(NULL_LITERAL);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5669;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,838,Context) ) {
				case 1:
					{
					State = 5668; unaryOperator();
					}
					break;
				}
				State = 5671; constant();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5672; currentTimestamp();
				State = 5676;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,839,Context) ) {
				case 1:
					{
					State = 5673; Match(ON);
					State = 5674; Match(UPDATE);
					State = 5675; currentTimestamp();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CurrentTimestampContext : ParserRuleContext {
		public ITerminalNode NOW() { return GetToken(MySqlParser.NOW, 0); }
		public ITerminalNode CURRENT_TIMESTAMP() { return GetToken(MySqlParser.CURRENT_TIMESTAMP, 0); }
		public ITerminalNode LOCALTIME() { return GetToken(MySqlParser.LOCALTIME, 0); }
		public ITerminalNode LOCALTIMESTAMP() { return GetToken(MySqlParser.LOCALTIMESTAMP, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public CurrentTimestampContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_currentTimestamp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCurrentTimestamp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCurrentTimestamp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCurrentTimestamp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CurrentTimestampContext currentTimestamp() {
		CurrentTimestampContext _localctx = new CurrentTimestampContext(Context, State);
		EnterRule(_localctx, 566, RULE_currentTimestamp);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5694;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT_TIMESTAMP:
			case LOCALTIME:
			case LOCALTIMESTAMP:
				{
				State = 5680;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 236)) & ~0x3f) == 0 && ((1L << (_la - 236)) & ((1L << (CURRENT_TIMESTAMP - 236)) | (1L << (LOCALTIME - 236)) | (1L << (LOCALTIMESTAMP - 236)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5686;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,842,Context) ) {
				case 1:
					{
					State = 5681; Match(LR_BRACKET);
					State = 5683;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (((((_la - 979)) & ~0x3f) == 0 && ((1L << (_la - 979)) & ((1L << (ZERO_DECIMAL - 979)) | (1L << (ONE_DECIMAL - 979)) | (1L << (TWO_DECIMAL - 979)) | (1L << (DECIMAL_LITERAL - 979)))) != 0)) {
						{
						State = 5682; decimalLiteral();
						}
					}

					State = 5685; Match(RR_BRACKET);
					}
					break;
				}
				}
				break;
			case NOW:
				{
				State = 5688; Match(NOW);
				State = 5689; Match(LR_BRACKET);
				State = 5691;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 979)) & ~0x3f) == 0 && ((1L << (_la - 979)) & ((1L << (ZERO_DECIMAL - 979)) | (1L << (ONE_DECIMAL - 979)) | (1L << (TWO_DECIMAL - 979)) | (1L << (DECIMAL_LITERAL - 979)))) != 0)) {
					{
					State = 5690; decimalLiteral();
					}
				}

				State = 5693; Match(RR_BRACKET);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionOrDefaultContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(MySqlParser.DEFAULT, 0); }
		public ExpressionOrDefaultContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionOrDefault; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExpressionOrDefault(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExpressionOrDefault(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionOrDefault(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionOrDefaultContext expressionOrDefault() {
		ExpressionOrDefaultContext _localctx = new ExpressionOrDefaultContext(Context, State);
		EnterRule(_localctx, 568, RULE_expressionOrDefault);
		try {
			State = 5698;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CASE:
			case CAST:
			case CONVERT:
			case CURRENT_USER:
			case DATABASE:
			case EXISTS:
			case FALSE:
			case IF:
			case INSERT:
			case INTERVAL:
			case LEFT:
			case NOT:
			case NULL_LITERAL:
			case REPLACE:
			case RIGHT:
			case TRUE:
			case VALUES:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case DATETIME:
			case YEAR:
			case CHAR:
			case BINARY:
			case TEXT:
			case ENUM:
			case SERIAL:
			case AVG:
			case BIT_AND:
			case BIT_OR:
			case BIT_XOR:
			case COUNT:
			case GROUP_CONCAT:
			case MAX:
			case MIN:
			case STD:
			case STDDEV:
			case STDDEV_POP:
			case STDDEV_SAMP:
			case SUM:
			case VAR_POP:
			case VAR_SAMP:
			case VARIANCE:
			case CURRENT_DATE:
			case CURRENT_TIME:
			case CURRENT_TIMESTAMP:
			case LOCALTIME:
			case CURDATE:
			case CURTIME:
			case DATE_ADD:
			case DATE_SUB:
			case EXTRACT:
			case LOCALTIMESTAMP:
			case NOW:
			case POSITION:
			case SUBSTR:
			case SUBSTRING:
			case SYSDATE:
			case TRIM:
			case UTC_DATE:
			case UTC_TIME:
			case UTC_TIMESTAMP:
			case ACCOUNT:
			case ACTION:
			case AFTER:
			case AGGREGATE:
			case ALGORITHM:
			case ANY:
			case AT:
			case AUTHORS:
			case AUTOCOMMIT:
			case AUTOEXTEND_SIZE:
			case AUTO_INCREMENT:
			case AVG_ROW_LENGTH:
			case BEGIN:
			case BINLOG:
			case BIT:
			case BLOCK:
			case BOOL:
			case BOOLEAN:
			case BTREE:
			case CACHE:
			case CASCADED:
			case CHAIN:
			case CHANGED:
			case CHANNEL:
			case CHECKSUM:
			case PAGE_CHECKSUM:
			case CIPHER:
			case CLASS_ORIGIN:
			case CLIENT:
			case CLOSE:
			case COALESCE:
			case CODE:
			case COLUMNS:
			case COLUMN_FORMAT:
			case COLUMN_NAME:
			case COMMENT:
			case COMMIT:
			case COMPACT:
			case COMPLETION:
			case COMPRESSED:
			case COMPRESSION:
			case CONCURRENT:
			case CONNECTION:
			case CONSISTENT:
			case CONSTRAINT_CATALOG:
			case CONSTRAINT_SCHEMA:
			case CONSTRAINT_NAME:
			case CONTAINS:
			case CONTEXT:
			case CONTRIBUTORS:
			case COPY:
			case CPU:
			case DATA:
			case DATAFILE:
			case DEALLOCATE:
			case DEFAULT_AUTH:
			case DEFINER:
			case DELAY_KEY_WRITE:
			case DES_KEY_FILE:
			case DIRECTORY:
			case DISABLE:
			case DISCARD:
			case DISK:
			case DO:
			case DUMPFILE:
			case DUPLICATE:
			case DYNAMIC:
			case ENABLE:
			case ENCRYPTION:
			case END:
			case ENDS:
			case ENGINE:
			case ENGINES:
			case ERROR:
			case ERRORS:
			case ESCAPE:
			case EVEN:
			case EVENT:
			case EVENTS:
			case EVERY:
			case EXCHANGE:
			case EXCLUSIVE:
			case EXPIRE:
			case EXPORT:
			case EXTENDED:
			case EXTENT_SIZE:
			case FAST:
			case FAULTS:
			case FIELDS:
			case FILE_BLOCK_SIZE:
			case FILTER:
			case FIRST:
			case FIXED:
			case FLUSH:
			case FOLLOWS:
			case FOUND:
			case FULL:
			case FUNCTION:
			case GENERAL:
			case GLOBAL:
			case GRANTS:
			case GROUP_REPLICATION:
			case HANDLER:
			case HASH:
			case HELP:
			case HOST:
			case HOSTS:
			case IDENTIFIED:
			case IGNORE_SERVER_IDS:
			case IMPORT:
			case INDEXES:
			case INITIAL_SIZE:
			case INPLACE:
			case INSERT_METHOD:
			case INSTALL:
			case INSTANCE:
			case INVISIBLE:
			case INVOKER:
			case IO:
			case IO_THREAD:
			case IPC:
			case ISOLATION:
			case ISSUER:
			case JSON:
			case KEY_BLOCK_SIZE:
			case LANGUAGE:
			case LAST:
			case LEAVES:
			case LESS:
			case LEVEL:
			case LIST:
			case LOCAL:
			case LOGFILE:
			case LOGS:
			case MASTER:
			case MASTER_AUTO_POSITION:
			case MASTER_CONNECT_RETRY:
			case MASTER_DELAY:
			case MASTER_HEARTBEAT_PERIOD:
			case MASTER_HOST:
			case MASTER_LOG_FILE:
			case MASTER_LOG_POS:
			case MASTER_PASSWORD:
			case MASTER_PORT:
			case MASTER_RETRY_COUNT:
			case MASTER_SSL:
			case MASTER_SSL_CA:
			case MASTER_SSL_CAPATH:
			case MASTER_SSL_CERT:
			case MASTER_SSL_CIPHER:
			case MASTER_SSL_CRL:
			case MASTER_SSL_CRLPATH:
			case MASTER_SSL_KEY:
			case MASTER_TLS_VERSION:
			case MASTER_USER:
			case MAX_CONNECTIONS_PER_HOUR:
			case MAX_QUERIES_PER_HOUR:
			case MAX_ROWS:
			case MAX_SIZE:
			case MAX_UPDATES_PER_HOUR:
			case MAX_USER_CONNECTIONS:
			case MEDIUM:
			case MERGE:
			case MESSAGE_TEXT:
			case MID:
			case MIGRATE:
			case MIN_ROWS:
			case MODE:
			case MODIFY:
			case MUTEX:
			case MYSQL:
			case MYSQL_ERRNO:
			case NAME:
			case NAMES:
			case NCHAR:
			case NEVER:
			case NEXT:
			case NO:
			case NODEGROUP:
			case NONE:
			case OFFLINE:
			case OFFSET:
			case OJ:
			case OLD_PASSWORD:
			case ONE:
			case ONLINE:
			case ONLY:
			case OPEN:
			case OPTIMIZER_COSTS:
			case OPTIONS:
			case OWNER:
			case PACK_KEYS:
			case PAGE:
			case PARSER:
			case PARTIAL:
			case PARTITIONING:
			case PARTITIONS:
			case PASSWORD:
			case PHASE:
			case PLUGIN:
			case PLUGIN_DIR:
			case PLUGINS:
			case PORT:
			case PRECEDES:
			case PREPARE:
			case PRESERVE:
			case PREV:
			case PROCESSLIST:
			case PROFILE:
			case PROFILES:
			case PROXY:
			case QUERY:
			case QUICK:
			case REBUILD:
			case RECOVER:
			case REDO_BUFFER_SIZE:
			case REDUNDANT:
			case RELAY:
			case RELAY_LOG_FILE:
			case RELAY_LOG_POS:
			case RELAYLOG:
			case REMOVE:
			case REORGANIZE:
			case REPAIR:
			case REPLICATE_DO_DB:
			case REPLICATE_DO_TABLE:
			case REPLICATE_IGNORE_DB:
			case REPLICATE_IGNORE_TABLE:
			case REPLICATE_REWRITE_DB:
			case REPLICATE_WILD_DO_TABLE:
			case REPLICATE_WILD_IGNORE_TABLE:
			case REPLICATION:
			case RESET:
			case RESUME:
			case RETURNS:
			case ROLLBACK:
			case ROLLUP:
			case ROTATE:
			case ROW:
			case ROWS:
			case ROW_FORMAT:
			case SAVEPOINT:
			case SCHEDULE:
			case SECURITY:
			case SERVER:
			case SESSION:
			case SHARE:
			case SHARED:
			case SIGNED:
			case SIMPLE:
			case SLAVE:
			case SLOW:
			case SNAPSHOT:
			case SOCKET:
			case SOME:
			case SONAME:
			case SOUNDS:
			case SOURCE:
			case SQL_AFTER_GTIDS:
			case SQL_AFTER_MTS_GAPS:
			case SQL_BEFORE_GTIDS:
			case SQL_BUFFER_RESULT:
			case SQL_CACHE:
			case SQL_NO_CACHE:
			case SQL_THREAD:
			case START:
			case STARTS:
			case STATS_AUTO_RECALC:
			case STATS_PERSISTENT:
			case STATS_SAMPLE_PAGES:
			case STATUS:
			case STOP:
			case STORAGE:
			case STRING:
			case SUBCLASS_ORIGIN:
			case SUBJECT:
			case SUBPARTITION:
			case SUBPARTITIONS:
			case SUSPEND:
			case SWAPS:
			case SWITCHES:
			case TABLE_NAME:
			case TABLESPACE:
			case TEMPORARY:
			case TEMPTABLE:
			case THAN:
			case TRADITIONAL:
			case TRANSACTION:
			case TRIGGERS:
			case TRUNCATE:
			case UNDEFINED:
			case UNDOFILE:
			case UNDO_BUFFER_SIZE:
			case UNINSTALL:
			case UNKNOWN:
			case UNTIL:
			case UPGRADE:
			case USER:
			case USE_FRM:
			case USER_RESOURCES:
			case VALIDATION:
			case VALUE:
			case VARIABLES:
			case VIEW:
			case VISIBLE:
			case WAIT:
			case WARNINGS:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case X509:
			case XA:
			case XML:
			case INTERNAL:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case TABLES:
			case ROUTINE:
			case EXECUTE:
			case FILE:
			case PROCESS:
			case RELOAD:
			case SHUTDOWN:
			case SUPER:
			case PRIVILEGES:
			case SESSION_VARIABLES_ADMIN:
			case ARMSCII8:
			case ASCII:
			case BIG5:
			case CP1250:
			case CP1251:
			case CP1256:
			case CP1257:
			case CP850:
			case CP852:
			case CP866:
			case CP932:
			case DEC8:
			case EUCJPMS:
			case EUCKR:
			case GB2312:
			case GBK:
			case GEOSTD8:
			case GREEK:
			case HEBREW:
			case HP8:
			case KEYBCS2:
			case KOI8R:
			case KOI8U:
			case LATIN1:
			case LATIN2:
			case LATIN5:
			case LATIN7:
			case MACCE:
			case MACROMAN:
			case SJIS:
			case SWE7:
			case TIS620:
			case UCS2:
			case UJIS:
			case UTF16:
			case UTF16LE:
			case UTF32:
			case UTF8:
			case UTF8MB3:
			case UTF8MB4:
			case ARCHIVE:
			case BLACKHOLE:
			case CSV:
			case FEDERATED:
			case INNODB:
			case MEMORY:
			case MRG_MYISAM:
			case MYISAM:
			case NDB:
			case NDBCLUSTER:
			case PERFORMANCE_SCHEMA:
			case TOKUDB:
			case REPEATABLE:
			case COMMITTED:
			case UNCOMMITTED:
			case SERIALIZABLE:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CATALOG_NAME:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SCHEMA_NAME:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
			case PLUS:
			case MINUS:
			case EXCLAMATION_SYMBOL:
			case BIT_NOT_OP:
			case LR_BRACKET:
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case CHARSET_REVERSE_QOUTE_STRING:
			case START_NATIONAL_STRING_LITERAL:
			case STRING_LITERAL:
			case DECIMAL_LITERAL:
			case HEXADECIMAL_LITERAL:
			case REAL_LITERAL:
			case NULL_SPEC_LITERAL:
			case BIT_STRING:
			case STRING_CHARSET_NAME:
			case ID:
			case REVERSE_QUOTE_ID:
			case LOCAL_ID:
			case GLOBAL_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5696; expression(0);
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5697; Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfExistsContext : ParserRuleContext {
		public ITerminalNode IF() { return GetToken(MySqlParser.IF, 0); }
		public ITerminalNode EXISTS() { return GetToken(MySqlParser.EXISTS, 0); }
		public IfExistsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifExists; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIfExists(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIfExists(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfExists(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfExistsContext ifExists() {
		IfExistsContext _localctx = new IfExistsContext(Context, State);
		EnterRule(_localctx, 570, RULE_ifExists);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5700; Match(IF);
			State = 5701; Match(EXISTS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfNotExistsContext : ParserRuleContext {
		public ITerminalNode IF() { return GetToken(MySqlParser.IF, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public ITerminalNode EXISTS() { return GetToken(MySqlParser.EXISTS, 0); }
		public IfNotExistsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifNotExists; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIfNotExists(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIfNotExists(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfNotExists(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfNotExistsContext ifNotExists() {
		IfNotExistsContext _localctx = new IfNotExistsContext(Context, State);
		EnterRule(_localctx, 572, RULE_ifNotExists);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5703; Match(IF);
			State = 5704; Match(NOT);
			State = 5705; Match(EXISTS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
	 
		public FunctionCallContext() { }
		public virtual void CopyFrom(FunctionCallContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SpecificFunctionCallContext : FunctionCallContext {
		public SpecificFunctionContext specificFunction() {
			return GetRuleContext<SpecificFunctionContext>(0);
		}
		public SpecificFunctionCallContext(FunctionCallContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSpecificFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSpecificFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecificFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PasswordFunctionCallContext : FunctionCallContext {
		public PasswordFunctionClauseContext passwordFunctionClause() {
			return GetRuleContext<PasswordFunctionClauseContext>(0);
		}
		public PasswordFunctionCallContext(FunctionCallContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPasswordFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPasswordFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPasswordFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UdfFunctionCallContext : FunctionCallContext {
		public FullIdContext fullId() {
			return GetRuleContext<FullIdContext>(0);
		}
		public FunctionArgsContext functionArgs() {
			return GetRuleContext<FunctionArgsContext>(0);
		}
		public UdfFunctionCallContext(FunctionCallContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUdfFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUdfFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUdfFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AggregateFunctionCallContext : FunctionCallContext {
		public AggregateWindowedFunctionContext aggregateWindowedFunction() {
			return GetRuleContext<AggregateWindowedFunctionContext>(0);
		}
		public AggregateFunctionCallContext(FunctionCallContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAggregateFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAggregateFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAggregateFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ScalarFunctionCallContext : FunctionCallContext {
		public ScalarFunctionNameContext scalarFunctionName() {
			return GetRuleContext<ScalarFunctionNameContext>(0);
		}
		public FunctionArgsContext functionArgs() {
			return GetRuleContext<FunctionArgsContext>(0);
		}
		public ScalarFunctionCallContext(FunctionCallContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterScalarFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitScalarFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScalarFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 574, RULE_functionCall);
		int _la;
		try {
			State = 5724;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,848,Context) ) {
			case 1:
				_localctx = new SpecificFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 5707; specificFunction();
				}
				break;
			case 2:
				_localctx = new AggregateFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 5708; aggregateWindowedFunction();
				}
				break;
			case 3:
				_localctx = new ScalarFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 5709; scalarFunctionName();
				State = 5710; Match(LR_BRACKET);
				State = 5712;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << CASE) | (1L << CAST) | (1L << CONVERT) | (1L << CURRENT_USER) | (1L << DATABASE) | (1L << EXISTS) | (1L << FALSE))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (IF - 66)) | (1L << (INSERT - 66)) | (1L << (INTERVAL - 66)) | (1L << (LEFT - 66)) | (1L << (NOT - 66)) | (1L << (NULL_LITERAL - 66)) | (1L << (REPLACE - 66)) | (1L << (RIGHT - 66)))) != 0) || ((((_la - 154)) & ~0x3f) == 0 && ((1L << (_la - 154)) & ((1L << (TRUE - 154)) | (1L << (VALUES - 154)) | (1L << (DATE - 154)) | (1L << (TIME - 154)) | (1L << (TIMESTAMP - 154)) | (1L << (DATETIME - 154)) | (1L << (YEAR - 154)) | (1L << (CHAR - 154)) | (1L << (BINARY - 154)) | (1L << (TEXT - 154)) | (1L << (ENUM - 154)) | (1L << (SERIAL - 154)))) != 0) || ((((_la - 218)) & ~0x3f) == 0 && ((1L << (_la - 218)) & ((1L << (AVG - 218)) | (1L << (BIT_AND - 218)) | (1L << (BIT_OR - 218)) | (1L << (BIT_XOR - 218)) | (1L << (COUNT - 218)) | (1L << (GROUP_CONCAT - 218)) | (1L << (MAX - 218)) | (1L << (MIN - 218)) | (1L << (STD - 218)) | (1L << (STDDEV - 218)) | (1L << (STDDEV_POP - 218)) | (1L << (STDDEV_SAMP - 218)) | (1L << (SUM - 218)) | (1L << (VAR_POP - 218)) | (1L << (VAR_SAMP - 218)) | (1L << (VARIANCE - 218)) | (1L << (CURRENT_DATE - 218)) | (1L << (CURRENT_TIME - 218)) | (1L << (CURRENT_TIMESTAMP - 218)) | (1L << (LOCALTIME - 218)) | (1L << (CURDATE - 218)) | (1L << (CURTIME - 218)) | (1L << (DATE_ADD - 218)) | (1L << (DATE_SUB - 218)) | (1L << (EXTRACT - 218)) | (1L << (LOCALTIMESTAMP - 218)) | (1L << (NOW - 218)) | (1L << (POSITION - 218)) | (1L << (SUBSTR - 218)) | (1L << (SUBSTRING - 218)) | (1L << (SYSDATE - 218)) | (1L << (TRIM - 218)) | (1L << (UTC_DATE - 218)) | (1L << (UTC_TIME - 218)) | (1L << (UTC_TIMESTAMP - 218)) | (1L << (ACCOUNT - 218)) | (1L << (ACTION - 218)) | (1L << (AFTER - 218)) | (1L << (AGGREGATE - 218)) | (1L << (ALGORITHM - 218)) | (1L << (ANY - 218)) | (1L << (AT - 218)) | (1L << (AUTHORS - 218)) | (1L << (AUTOCOMMIT - 218)) | (1L << (AUTOEXTEND_SIZE - 218)) | (1L << (AUTO_INCREMENT - 218)) | (1L << (AVG_ROW_LENGTH - 218)) | (1L << (BEGIN - 218)) | (1L << (BINLOG - 218)) | (1L << (BIT - 218)) | (1L << (BLOCK - 218)) | (1L << (BOOL - 218)) | (1L << (BOOLEAN - 218)) | (1L << (BTREE - 218)) | (1L << (CACHE - 218)) | (1L << (CASCADED - 218)) | (1L << (CHAIN - 218)) | (1L << (CHANGED - 218)) | (1L << (CHANNEL - 218)) | (1L << (CHECKSUM - 218)) | (1L << (PAGE_CHECKSUM - 218)) | (1L << (CIPHER - 218)) | (1L << (CLASS_ORIGIN - 218)) | (1L << (CLIENT - 218)))) != 0) || ((((_la - 282)) & ~0x3f) == 0 && ((1L << (_la - 282)) & ((1L << (CLOSE - 282)) | (1L << (COALESCE - 282)) | (1L << (CODE - 282)) | (1L << (COLUMNS - 282)) | (1L << (COLUMN_FORMAT - 282)) | (1L << (COLUMN_NAME - 282)) | (1L << (COMMENT - 282)) | (1L << (COMMIT - 282)) | (1L << (COMPACT - 282)) | (1L << (COMPLETION - 282)) | (1L << (COMPRESSED - 282)) | (1L << (COMPRESSION - 282)) | (1L << (CONCURRENT - 282)) | (1L << (CONNECTION - 282)) | (1L << (CONSISTENT - 282)) | (1L << (CONSTRAINT_CATALOG - 282)) | (1L << (CONSTRAINT_SCHEMA - 282)) | (1L << (CONSTRAINT_NAME - 282)) | (1L << (CONTAINS - 282)) | (1L << (CONTEXT - 282)) | (1L << (CONTRIBUTORS - 282)) | (1L << (COPY - 282)) | (1L << (CPU - 282)) | (1L << (DATA - 282)) | (1L << (DATAFILE - 282)) | (1L << (DEALLOCATE - 282)) | (1L << (DEFAULT_AUTH - 282)) | (1L << (DEFINER - 282)) | (1L << (DELAY_KEY_WRITE - 282)) | (1L << (DES_KEY_FILE - 282)) | (1L << (DIRECTORY - 282)) | (1L << (DISABLE - 282)) | (1L << (DISCARD - 282)) | (1L << (DISK - 282)) | (1L << (DO - 282)) | (1L << (DUMPFILE - 282)) | (1L << (DUPLICATE - 282)) | (1L << (DYNAMIC - 282)) | (1L << (ENABLE - 282)) | (1L << (ENCRYPTION - 282)) | (1L << (END - 282)) | (1L << (ENDS - 282)) | (1L << (ENGINE - 282)) | (1L << (ENGINES - 282)) | (1L << (ERROR - 282)) | (1L << (ERRORS - 282)) | (1L << (ESCAPE - 282)) | (1L << (EVEN - 282)) | (1L << (EVENT - 282)) | (1L << (EVENTS - 282)) | (1L << (EVERY - 282)) | (1L << (EXCHANGE - 282)) | (1L << (EXCLUSIVE - 282)) | (1L << (EXPIRE - 282)) | (1L << (EXPORT - 282)) | (1L << (EXTENDED - 282)) | (1L << (EXTENT_SIZE - 282)) | (1L << (FAST - 282)) | (1L << (FAULTS - 282)) | (1L << (FIELDS - 282)) | (1L << (FILE_BLOCK_SIZE - 282)) | (1L << (FILTER - 282)) | (1L << (FIRST - 282)) | (1L << (FIXED - 282)))) != 0) || ((((_la - 346)) & ~0x3f) == 0 && ((1L << (_la - 346)) & ((1L << (FLUSH - 346)) | (1L << (FOLLOWS - 346)) | (1L << (FOUND - 346)) | (1L << (FULL - 346)) | (1L << (FUNCTION - 346)) | (1L << (GENERAL - 346)) | (1L << (GLOBAL - 346)) | (1L << (GRANTS - 346)) | (1L << (GROUP_REPLICATION - 346)) | (1L << (HANDLER - 346)) | (1L << (HASH - 346)) | (1L << (HELP - 346)) | (1L << (HOST - 346)) | (1L << (HOSTS - 346)) | (1L << (IDENTIFIED - 346)) | (1L << (IGNORE_SERVER_IDS - 346)) | (1L << (IMPORT - 346)) | (1L << (INDEXES - 346)) | (1L << (INITIAL_SIZE - 346)) | (1L << (INPLACE - 346)) | (1L << (INSERT_METHOD - 346)) | (1L << (INSTALL - 346)) | (1L << (INSTANCE - 346)) | (1L << (INVISIBLE - 346)) | (1L << (INVOKER - 346)) | (1L << (IO - 346)) | (1L << (IO_THREAD - 346)) | (1L << (IPC - 346)) | (1L << (ISOLATION - 346)) | (1L << (ISSUER - 346)) | (1L << (JSON - 346)) | (1L << (KEY_BLOCK_SIZE - 346)) | (1L << (LANGUAGE - 346)) | (1L << (LAST - 346)) | (1L << (LEAVES - 346)) | (1L << (LESS - 346)) | (1L << (LEVEL - 346)) | (1L << (LIST - 346)) | (1L << (LOCAL - 346)) | (1L << (LOGFILE - 346)) | (1L << (LOGS - 346)) | (1L << (MASTER - 346)) | (1L << (MASTER_AUTO_POSITION - 346)) | (1L << (MASTER_CONNECT_RETRY - 346)) | (1L << (MASTER_DELAY - 346)) | (1L << (MASTER_HEARTBEAT_PERIOD - 346)) | (1L << (MASTER_HOST - 346)) | (1L << (MASTER_LOG_FILE - 346)) | (1L << (MASTER_LOG_POS - 346)) | (1L << (MASTER_PASSWORD - 346)) | (1L << (MASTER_PORT - 346)) | (1L << (MASTER_RETRY_COUNT - 346)) | (1L << (MASTER_SSL - 346)) | (1L << (MASTER_SSL_CA - 346)) | (1L << (MASTER_SSL_CAPATH - 346)) | (1L << (MASTER_SSL_CERT - 346)) | (1L << (MASTER_SSL_CIPHER - 346)) | (1L << (MASTER_SSL_CRL - 346)) | (1L << (MASTER_SSL_CRLPATH - 346)) | (1L << (MASTER_SSL_KEY - 346)) | (1L << (MASTER_TLS_VERSION - 346)) | (1L << (MASTER_USER - 346)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 346)) | (1L << (MAX_QUERIES_PER_HOUR - 346)))) != 0) || ((((_la - 410)) & ~0x3f) == 0 && ((1L << (_la - 410)) & ((1L << (MAX_ROWS - 410)) | (1L << (MAX_SIZE - 410)) | (1L << (MAX_UPDATES_PER_HOUR - 410)) | (1L << (MAX_USER_CONNECTIONS - 410)) | (1L << (MEDIUM - 410)) | (1L << (MERGE - 410)) | (1L << (MESSAGE_TEXT - 410)) | (1L << (MID - 410)) | (1L << (MIGRATE - 410)) | (1L << (MIN_ROWS - 410)) | (1L << (MODE - 410)) | (1L << (MODIFY - 410)) | (1L << (MUTEX - 410)) | (1L << (MYSQL - 410)) | (1L << (MYSQL_ERRNO - 410)) | (1L << (NAME - 410)) | (1L << (NAMES - 410)) | (1L << (NCHAR - 410)) | (1L << (NEVER - 410)) | (1L << (NEXT - 410)) | (1L << (NO - 410)) | (1L << (NODEGROUP - 410)) | (1L << (NONE - 410)) | (1L << (OFFLINE - 410)) | (1L << (OFFSET - 410)) | (1L << (OJ - 410)) | (1L << (OLD_PASSWORD - 410)) | (1L << (ONE - 410)) | (1L << (ONLINE - 410)) | (1L << (ONLY - 410)) | (1L << (OPEN - 410)) | (1L << (OPTIMIZER_COSTS - 410)) | (1L << (OPTIONS - 410)) | (1L << (OWNER - 410)) | (1L << (PACK_KEYS - 410)) | (1L << (PAGE - 410)) | (1L << (PARSER - 410)) | (1L << (PARTIAL - 410)) | (1L << (PARTITIONING - 410)) | (1L << (PARTITIONS - 410)) | (1L << (PASSWORD - 410)) | (1L << (PHASE - 410)) | (1L << (PLUGIN - 410)) | (1L << (PLUGIN_DIR - 410)) | (1L << (PLUGINS - 410)) | (1L << (PORT - 410)) | (1L << (PRECEDES - 410)) | (1L << (PREPARE - 410)) | (1L << (PRESERVE - 410)) | (1L << (PREV - 410)) | (1L << (PROCESSLIST - 410)) | (1L << (PROFILE - 410)) | (1L << (PROFILES - 410)) | (1L << (PROXY - 410)) | (1L << (QUERY - 410)) | (1L << (QUICK - 410)) | (1L << (REBUILD - 410)) | (1L << (RECOVER - 410)) | (1L << (REDO_BUFFER_SIZE - 410)) | (1L << (REDUNDANT - 410)) | (1L << (RELAY - 410)) | (1L << (RELAY_LOG_FILE - 410)) | (1L << (RELAY_LOG_POS - 410)) | (1L << (RELAYLOG - 410)))) != 0) || ((((_la - 474)) & ~0x3f) == 0 && ((1L << (_la - 474)) & ((1L << (REMOVE - 474)) | (1L << (REORGANIZE - 474)) | (1L << (REPAIR - 474)) | (1L << (REPLICATE_DO_DB - 474)) | (1L << (REPLICATE_DO_TABLE - 474)) | (1L << (REPLICATE_IGNORE_DB - 474)) | (1L << (REPLICATE_IGNORE_TABLE - 474)) | (1L << (REPLICATE_REWRITE_DB - 474)) | (1L << (REPLICATE_WILD_DO_TABLE - 474)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 474)) | (1L << (REPLICATION - 474)) | (1L << (RESET - 474)) | (1L << (RESUME - 474)) | (1L << (RETURNS - 474)) | (1L << (ROLLBACK - 474)) | (1L << (ROLLUP - 474)) | (1L << (ROTATE - 474)) | (1L << (ROW - 474)) | (1L << (ROWS - 474)) | (1L << (ROW_FORMAT - 474)) | (1L << (SAVEPOINT - 474)) | (1L << (SCHEDULE - 474)) | (1L << (SECURITY - 474)) | (1L << (SERVER - 474)) | (1L << (SESSION - 474)) | (1L << (SHARE - 474)) | (1L << (SHARED - 474)) | (1L << (SIGNED - 474)) | (1L << (SIMPLE - 474)) | (1L << (SLAVE - 474)) | (1L << (SLOW - 474)) | (1L << (SNAPSHOT - 474)) | (1L << (SOCKET - 474)) | (1L << (SOME - 474)) | (1L << (SONAME - 474)) | (1L << (SOUNDS - 474)) | (1L << (SOURCE - 474)) | (1L << (SQL_AFTER_GTIDS - 474)) | (1L << (SQL_AFTER_MTS_GAPS - 474)) | (1L << (SQL_BEFORE_GTIDS - 474)) | (1L << (SQL_BUFFER_RESULT - 474)) | (1L << (SQL_CACHE - 474)) | (1L << (SQL_NO_CACHE - 474)) | (1L << (SQL_THREAD - 474)) | (1L << (START - 474)) | (1L << (STARTS - 474)) | (1L << (STATS_AUTO_RECALC - 474)) | (1L << (STATS_PERSISTENT - 474)) | (1L << (STATS_SAMPLE_PAGES - 474)) | (1L << (STATUS - 474)) | (1L << (STOP - 474)) | (1L << (STORAGE - 474)) | (1L << (STRING - 474)) | (1L << (SUBCLASS_ORIGIN - 474)) | (1L << (SUBJECT - 474)) | (1L << (SUBPARTITION - 474)) | (1L << (SUBPARTITIONS - 474)) | (1L << (SUSPEND - 474)) | (1L << (SWAPS - 474)) | (1L << (SWITCHES - 474)) | (1L << (TABLE_NAME - 474)) | (1L << (TABLESPACE - 474)) | (1L << (TEMPORARY - 474)))) != 0) || ((((_la - 538)) & ~0x3f) == 0 && ((1L << (_la - 538)) & ((1L << (TEMPTABLE - 538)) | (1L << (THAN - 538)) | (1L << (TRADITIONAL - 538)) | (1L << (TRANSACTION - 538)) | (1L << (TRIGGERS - 538)) | (1L << (TRUNCATE - 538)) | (1L << (UNDEFINED - 538)) | (1L << (UNDOFILE - 538)) | (1L << (UNDO_BUFFER_SIZE - 538)) | (1L << (UNINSTALL - 538)) | (1L << (UNKNOWN - 538)) | (1L << (UNTIL - 538)) | (1L << (UPGRADE - 538)) | (1L << (USER - 538)) | (1L << (USE_FRM - 538)) | (1L << (USER_RESOURCES - 538)) | (1L << (VALIDATION - 538)) | (1L << (VALUE - 538)) | (1L << (VARIABLES - 538)) | (1L << (VIEW - 538)) | (1L << (VISIBLE - 538)) | (1L << (WAIT - 538)) | (1L << (WARNINGS - 538)) | (1L << (WITHOUT - 538)) | (1L << (WORK - 538)) | (1L << (WRAPPER - 538)) | (1L << (X509 - 538)) | (1L << (XA - 538)) | (1L << (XML - 538)) | (1L << (INTERNAL - 538)) | (1L << (QUARTER - 538)) | (1L << (MONTH - 538)) | (1L << (DAY - 538)) | (1L << (HOUR - 538)) | (1L << (MINUTE - 538)) | (1L << (WEEK - 538)) | (1L << (SECOND - 538)) | (1L << (MICROSECOND - 538)) | (1L << (TABLES - 538)) | (1L << (ROUTINE - 538)) | (1L << (EXECUTE - 538)) | (1L << (FILE - 538)) | (1L << (PROCESS - 538)) | (1L << (RELOAD - 538)) | (1L << (SHUTDOWN - 538)) | (1L << (SUPER - 538)) | (1L << (PRIVILEGES - 538)) | (1L << (SESSION_VARIABLES_ADMIN - 538)) | (1L << (ARMSCII8 - 538)) | (1L << (ASCII - 538)) | (1L << (BIG5 - 538)) | (1L << (CP1250 - 538)) | (1L << (CP1251 - 538)) | (1L << (CP1256 - 538)) | (1L << (CP1257 - 538)) | (1L << (CP850 - 538)) | (1L << (CP852 - 538)) | (1L << (CP866 - 538)) | (1L << (CP932 - 538)))) != 0) || ((((_la - 602)) & ~0x3f) == 0 && ((1L << (_la - 602)) & ((1L << (DEC8 - 602)) | (1L << (EUCJPMS - 602)) | (1L << (EUCKR - 602)) | (1L << (GB2312 - 602)) | (1L << (GBK - 602)) | (1L << (GEOSTD8 - 602)) | (1L << (GREEK - 602)) | (1L << (HEBREW - 602)) | (1L << (HP8 - 602)) | (1L << (KEYBCS2 - 602)) | (1L << (KOI8R - 602)) | (1L << (KOI8U - 602)) | (1L << (LATIN1 - 602)) | (1L << (LATIN2 - 602)) | (1L << (LATIN5 - 602)) | (1L << (LATIN7 - 602)) | (1L << (MACCE - 602)) | (1L << (MACROMAN - 602)) | (1L << (SJIS - 602)) | (1L << (SWE7 - 602)) | (1L << (TIS620 - 602)) | (1L << (UCS2 - 602)) | (1L << (UJIS - 602)) | (1L << (UTF16 - 602)) | (1L << (UTF16LE - 602)) | (1L << (UTF32 - 602)) | (1L << (UTF8 - 602)) | (1L << (UTF8MB3 - 602)) | (1L << (UTF8MB4 - 602)) | (1L << (ARCHIVE - 602)) | (1L << (BLACKHOLE - 602)) | (1L << (CSV - 602)) | (1L << (FEDERATED - 602)) | (1L << (INNODB - 602)) | (1L << (MEMORY - 602)) | (1L << (MRG_MYISAM - 602)) | (1L << (MYISAM - 602)) | (1L << (NDB - 602)) | (1L << (NDBCLUSTER - 602)) | (1L << (PERFORMANCE_SCHEMA - 602)) | (1L << (TOKUDB - 602)) | (1L << (REPEATABLE - 602)) | (1L << (COMMITTED - 602)) | (1L << (UNCOMMITTED - 602)) | (1L << (SERIALIZABLE - 602)) | (1L << (GEOMETRYCOLLECTION - 602)) | (1L << (LINESTRING - 602)) | (1L << (MULTILINESTRING - 602)) | (1L << (MULTIPOINT - 602)) | (1L << (MULTIPOLYGON - 602)) | (1L << (POINT - 602)) | (1L << (POLYGON - 602)) | (1L << (ABS - 602)) | (1L << (ACOS - 602)) | (1L << (ADDDATE - 602)) | (1L << (ADDTIME - 602)) | (1L << (AES_DECRYPT - 602)) | (1L << (AES_ENCRYPT - 602)) | (1L << (AREA - 602)) | (1L << (ASBINARY - 602)) | (1L << (ASIN - 602)) | (1L << (ASTEXT - 602)))) != 0) || ((((_la - 666)) & ~0x3f) == 0 && ((1L << (_la - 666)) & ((1L << (ASWKB - 666)) | (1L << (ASWKT - 666)) | (1L << (ASYMMETRIC_DECRYPT - 666)) | (1L << (ASYMMETRIC_DERIVE - 666)) | (1L << (ASYMMETRIC_ENCRYPT - 666)) | (1L << (ASYMMETRIC_SIGN - 666)) | (1L << (ASYMMETRIC_VERIFY - 666)) | (1L << (ATAN - 666)) | (1L << (ATAN2 - 666)) | (1L << (BENCHMARK - 666)) | (1L << (BIN - 666)) | (1L << (BIT_COUNT - 666)) | (1L << (BIT_LENGTH - 666)) | (1L << (BUFFER - 666)) | (1L << (CATALOG_NAME - 666)) | (1L << (CEIL - 666)) | (1L << (CEILING - 666)) | (1L << (CENTROID - 666)) | (1L << (CHARACTER_LENGTH - 666)) | (1L << (CHARSET - 666)) | (1L << (CHAR_LENGTH - 666)) | (1L << (COERCIBILITY - 666)) | (1L << (COLLATION - 666)) | (1L << (COMPRESS - 666)) | (1L << (CONCAT - 666)) | (1L << (CONCAT_WS - 666)) | (1L << (CONNECTION_ID - 666)) | (1L << (CONV - 666)) | (1L << (CONVERT_TZ - 666)) | (1L << (COS - 666)) | (1L << (COT - 666)) | (1L << (CRC32 - 666)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 666)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 666)) | (1L << (CREATE_DH_PARAMETERS - 666)) | (1L << (CREATE_DIGEST - 666)) | (1L << (CROSSES - 666)) | (1L << (DATEDIFF - 666)) | (1L << (DATE_FORMAT - 666)) | (1L << (DAYNAME - 666)) | (1L << (DAYOFMONTH - 666)) | (1L << (DAYOFWEEK - 666)) | (1L << (DAYOFYEAR - 666)) | (1L << (DECODE - 666)) | (1L << (DEGREES - 666)) | (1L << (DES_DECRYPT - 666)) | (1L << (DES_ENCRYPT - 666)) | (1L << (DIMENSION - 666)) | (1L << (DISJOINT - 666)) | (1L << (ELT - 666)) | (1L << (ENCODE - 666)) | (1L << (ENCRYPT - 666)) | (1L << (ENDPOINT - 666)) | (1L << (ENVELOPE - 666)) | (1L << (EQUALS - 666)) | (1L << (EXP - 666)) | (1L << (EXPORT_SET - 666)) | (1L << (EXTERIORRING - 666)) | (1L << (EXTRACTVALUE - 666)) | (1L << (FIELD - 666)) | (1L << (FIND_IN_SET - 666)) | (1L << (FLOOR - 666)) | (1L << (FORMAT - 666)) | (1L << (FOUND_ROWS - 666)))) != 0) || ((((_la - 730)) & ~0x3f) == 0 && ((1L << (_la - 730)) & ((1L << (FROM_BASE64 - 730)) | (1L << (FROM_DAYS - 730)) | (1L << (FROM_UNIXTIME - 730)) | (1L << (GEOMCOLLFROMTEXT - 730)) | (1L << (GEOMCOLLFROMWKB - 730)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 730)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 730)) | (1L << (GEOMETRYFROMTEXT - 730)) | (1L << (GEOMETRYFROMWKB - 730)) | (1L << (GEOMETRYN - 730)) | (1L << (GEOMETRYTYPE - 730)) | (1L << (GEOMFROMTEXT - 730)) | (1L << (GEOMFROMWKB - 730)) | (1L << (GET_FORMAT - 730)) | (1L << (GET_LOCK - 730)) | (1L << (GLENGTH - 730)) | (1L << (GREATEST - 730)) | (1L << (GTID_SUBSET - 730)) | (1L << (GTID_SUBTRACT - 730)) | (1L << (HEX - 730)) | (1L << (IFNULL - 730)) | (1L << (INET6_ATON - 730)) | (1L << (INET6_NTOA - 730)) | (1L << (INET_ATON - 730)) | (1L << (INET_NTOA - 730)) | (1L << (INSTR - 730)) | (1L << (INTERIORRINGN - 730)) | (1L << (INTERSECTS - 730)) | (1L << (ISCLOSED - 730)) | (1L << (ISEMPTY - 730)) | (1L << (ISNULL - 730)) | (1L << (ISSIMPLE - 730)) | (1L << (IS_FREE_LOCK - 730)) | (1L << (IS_IPV4 - 730)) | (1L << (IS_IPV4_COMPAT - 730)) | (1L << (IS_IPV4_MAPPED - 730)) | (1L << (IS_IPV6 - 730)) | (1L << (IS_USED_LOCK - 730)) | (1L << (LAST_INSERT_ID - 730)) | (1L << (LCASE - 730)) | (1L << (LEAST - 730)) | (1L << (LENGTH - 730)) | (1L << (LINEFROMTEXT - 730)) | (1L << (LINEFROMWKB - 730)) | (1L << (LINESTRINGFROMTEXT - 730)) | (1L << (LINESTRINGFROMWKB - 730)) | (1L << (LN - 730)) | (1L << (LOAD_FILE - 730)) | (1L << (LOCATE - 730)) | (1L << (LOG - 730)) | (1L << (LOG10 - 730)) | (1L << (LOG2 - 730)) | (1L << (LOWER - 730)) | (1L << (LPAD - 730)) | (1L << (LTRIM - 730)) | (1L << (MAKEDATE - 730)) | (1L << (MAKETIME - 730)) | (1L << (MAKE_SET - 730)) | (1L << (MASTER_POS_WAIT - 730)) | (1L << (MBRCONTAINS - 730)) | (1L << (MBRDISJOINT - 730)) | (1L << (MBREQUAL - 730)) | (1L << (MBRINTERSECTS - 730)) | (1L << (MBROVERLAPS - 730)))) != 0) || ((((_la - 794)) & ~0x3f) == 0 && ((1L << (_la - 794)) & ((1L << (MBRTOUCHES - 794)) | (1L << (MBRWITHIN - 794)) | (1L << (MD5 - 794)) | (1L << (MLINEFROMTEXT - 794)) | (1L << (MLINEFROMWKB - 794)) | (1L << (MONTHNAME - 794)) | (1L << (MPOINTFROMTEXT - 794)) | (1L << (MPOINTFROMWKB - 794)) | (1L << (MPOLYFROMTEXT - 794)) | (1L << (MPOLYFROMWKB - 794)) | (1L << (MULTILINESTRINGFROMTEXT - 794)) | (1L << (MULTILINESTRINGFROMWKB - 794)) | (1L << (MULTIPOINTFROMTEXT - 794)) | (1L << (MULTIPOINTFROMWKB - 794)) | (1L << (MULTIPOLYGONFROMTEXT - 794)) | (1L << (MULTIPOLYGONFROMWKB - 794)) | (1L << (NAME_CONST - 794)) | (1L << (NULLIF - 794)) | (1L << (NUMGEOMETRIES - 794)) | (1L << (NUMINTERIORRINGS - 794)) | (1L << (NUMPOINTS - 794)) | (1L << (OCT - 794)) | (1L << (OCTET_LENGTH - 794)) | (1L << (ORD - 794)) | (1L << (OVERLAPS - 794)) | (1L << (PERIOD_ADD - 794)) | (1L << (PERIOD_DIFF - 794)) | (1L << (PI - 794)) | (1L << (POINTFROMTEXT - 794)) | (1L << (POINTFROMWKB - 794)) | (1L << (POINTN - 794)) | (1L << (POLYFROMTEXT - 794)) | (1L << (POLYFROMWKB - 794)) | (1L << (POLYGONFROMTEXT - 794)) | (1L << (POLYGONFROMWKB - 794)) | (1L << (POW - 794)) | (1L << (POWER - 794)) | (1L << (QUOTE - 794)) | (1L << (RADIANS - 794)) | (1L << (RAND - 794)) | (1L << (RANDOM_BYTES - 794)) | (1L << (RELEASE_LOCK - 794)) | (1L << (REVERSE - 794)) | (1L << (ROUND - 794)) | (1L << (ROW_COUNT - 794)) | (1L << (RPAD - 794)) | (1L << (RTRIM - 794)) | (1L << (SEC_TO_TIME - 794)) | (1L << (SESSION_USER - 794)) | (1L << (SHA - 794)) | (1L << (SHA1 - 794)) | (1L << (SHA2 - 794)) | (1L << (SCHEMA_NAME - 794)) | (1L << (SIGN - 794)) | (1L << (SIN - 794)) | (1L << (SLEEP - 794)) | (1L << (SOUNDEX - 794)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 794)) | (1L << (SQRT - 794)) | (1L << (SRID - 794)) | (1L << (STARTPOINT - 794)) | (1L << (STRCMP - 794)) | (1L << (STR_TO_DATE - 794)) | (1L << (ST_AREA - 794)))) != 0) || ((((_la - 858)) & ~0x3f) == 0 && ((1L << (_la - 858)) & ((1L << (ST_ASBINARY - 858)) | (1L << (ST_ASTEXT - 858)) | (1L << (ST_ASWKB - 858)) | (1L << (ST_ASWKT - 858)) | (1L << (ST_BUFFER - 858)) | (1L << (ST_CENTROID - 858)) | (1L << (ST_CONTAINS - 858)) | (1L << (ST_CROSSES - 858)) | (1L << (ST_DIFFERENCE - 858)) | (1L << (ST_DIMENSION - 858)) | (1L << (ST_DISJOINT - 858)) | (1L << (ST_DISTANCE - 858)) | (1L << (ST_ENDPOINT - 858)) | (1L << (ST_ENVELOPE - 858)) | (1L << (ST_EQUALS - 858)) | (1L << (ST_EXTERIORRING - 858)) | (1L << (ST_GEOMCOLLFROMTEXT - 858)) | (1L << (ST_GEOMCOLLFROMTXT - 858)) | (1L << (ST_GEOMCOLLFROMWKB - 858)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 858)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 858)) | (1L << (ST_GEOMETRYFROMTEXT - 858)) | (1L << (ST_GEOMETRYFROMWKB - 858)) | (1L << (ST_GEOMETRYN - 858)) | (1L << (ST_GEOMETRYTYPE - 858)) | (1L << (ST_GEOMFROMTEXT - 858)) | (1L << (ST_GEOMFROMWKB - 858)) | (1L << (ST_INTERIORRINGN - 858)) | (1L << (ST_INTERSECTION - 858)) | (1L << (ST_INTERSECTS - 858)) | (1L << (ST_ISCLOSED - 858)) | (1L << (ST_ISEMPTY - 858)) | (1L << (ST_ISSIMPLE - 858)) | (1L << (ST_LINEFROMTEXT - 858)) | (1L << (ST_LINEFROMWKB - 858)) | (1L << (ST_LINESTRINGFROMTEXT - 858)) | (1L << (ST_LINESTRINGFROMWKB - 858)) | (1L << (ST_NUMGEOMETRIES - 858)) | (1L << (ST_NUMINTERIORRING - 858)) | (1L << (ST_NUMINTERIORRINGS - 858)) | (1L << (ST_NUMPOINTS - 858)) | (1L << (ST_OVERLAPS - 858)) | (1L << (ST_POINTFROMTEXT - 858)) | (1L << (ST_POINTFROMWKB - 858)) | (1L << (ST_POINTN - 858)) | (1L << (ST_POLYFROMTEXT - 858)) | (1L << (ST_POLYFROMWKB - 858)) | (1L << (ST_POLYGONFROMTEXT - 858)) | (1L << (ST_POLYGONFROMWKB - 858)) | (1L << (ST_SRID - 858)) | (1L << (ST_STARTPOINT - 858)) | (1L << (ST_SYMDIFFERENCE - 858)) | (1L << (ST_TOUCHES - 858)) | (1L << (ST_UNION - 858)) | (1L << (ST_WITHIN - 858)) | (1L << (ST_X - 858)) | (1L << (ST_Y - 858)) | (1L << (SUBDATE - 858)) | (1L << (SUBSTRING_INDEX - 858)) | (1L << (SUBTIME - 858)) | (1L << (SYSTEM_USER - 858)) | (1L << (TAN - 858)) | (1L << (TIMEDIFF - 858)) | (1L << (TIMESTAMPADD - 858)))) != 0) || ((((_la - 922)) & ~0x3f) == 0 && ((1L << (_la - 922)) & ((1L << (TIMESTAMPDIFF - 922)) | (1L << (TIME_FORMAT - 922)) | (1L << (TIME_TO_SEC - 922)) | (1L << (TOUCHES - 922)) | (1L << (TO_BASE64 - 922)) | (1L << (TO_DAYS - 922)) | (1L << (TO_SECONDS - 922)) | (1L << (UCASE - 922)) | (1L << (UNCOMPRESS - 922)) | (1L << (UNCOMPRESSED_LENGTH - 922)) | (1L << (UNHEX - 922)) | (1L << (UNIX_TIMESTAMP - 922)) | (1L << (UPDATEXML - 922)) | (1L << (UPPER - 922)) | (1L << (UUID - 922)) | (1L << (UUID_SHORT - 922)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 922)) | (1L << (VERSION - 922)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 922)) | (1L << (WEEKDAY - 922)) | (1L << (WEEKOFYEAR - 922)) | (1L << (WEIGHT_STRING - 922)) | (1L << (WITHIN - 922)) | (1L << (YEARWEEK - 922)) | (1L << (Y_FUNCTION - 922)) | (1L << (X_FUNCTION - 922)) | (1L << (PLUS - 922)) | (1L << (MINUS - 922)) | (1L << (EXCLAMATION_SYMBOL - 922)) | (1L << (BIT_NOT_OP - 922)) | (1L << (LR_BRACKET - 922)) | (1L << (ZERO_DECIMAL - 922)) | (1L << (ONE_DECIMAL - 922)) | (1L << (TWO_DECIMAL - 922)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (START_NATIONAL_STRING_LITERAL - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (DECIMAL_LITERAL - 986)) | (1L << (HEXADECIMAL_LITERAL - 986)) | (1L << (REAL_LITERAL - 986)) | (1L << (NULL_SPEC_LITERAL - 986)) | (1L << (BIT_STRING - 986)) | (1L << (STRING_CHARSET_NAME - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)) | (1L << (LOCAL_ID - 986)) | (1L << (GLOBAL_ID - 986)))) != 0)) {
					{
					State = 5711; functionArgs();
					}
				}

				State = 5714; Match(RR_BRACKET);
				}
				break;
			case 4:
				_localctx = new UdfFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 5716; fullId();
				State = 5717; Match(LR_BRACKET);
				State = 5719;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << CASE) | (1L << CAST) | (1L << CONVERT) | (1L << CURRENT_USER) | (1L << DATABASE) | (1L << EXISTS) | (1L << FALSE))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (IF - 66)) | (1L << (INSERT - 66)) | (1L << (INTERVAL - 66)) | (1L << (LEFT - 66)) | (1L << (NOT - 66)) | (1L << (NULL_LITERAL - 66)) | (1L << (REPLACE - 66)) | (1L << (RIGHT - 66)))) != 0) || ((((_la - 154)) & ~0x3f) == 0 && ((1L << (_la - 154)) & ((1L << (TRUE - 154)) | (1L << (VALUES - 154)) | (1L << (DATE - 154)) | (1L << (TIME - 154)) | (1L << (TIMESTAMP - 154)) | (1L << (DATETIME - 154)) | (1L << (YEAR - 154)) | (1L << (CHAR - 154)) | (1L << (BINARY - 154)) | (1L << (TEXT - 154)) | (1L << (ENUM - 154)) | (1L << (SERIAL - 154)))) != 0) || ((((_la - 218)) & ~0x3f) == 0 && ((1L << (_la - 218)) & ((1L << (AVG - 218)) | (1L << (BIT_AND - 218)) | (1L << (BIT_OR - 218)) | (1L << (BIT_XOR - 218)) | (1L << (COUNT - 218)) | (1L << (GROUP_CONCAT - 218)) | (1L << (MAX - 218)) | (1L << (MIN - 218)) | (1L << (STD - 218)) | (1L << (STDDEV - 218)) | (1L << (STDDEV_POP - 218)) | (1L << (STDDEV_SAMP - 218)) | (1L << (SUM - 218)) | (1L << (VAR_POP - 218)) | (1L << (VAR_SAMP - 218)) | (1L << (VARIANCE - 218)) | (1L << (CURRENT_DATE - 218)) | (1L << (CURRENT_TIME - 218)) | (1L << (CURRENT_TIMESTAMP - 218)) | (1L << (LOCALTIME - 218)) | (1L << (CURDATE - 218)) | (1L << (CURTIME - 218)) | (1L << (DATE_ADD - 218)) | (1L << (DATE_SUB - 218)) | (1L << (EXTRACT - 218)) | (1L << (LOCALTIMESTAMP - 218)) | (1L << (NOW - 218)) | (1L << (POSITION - 218)) | (1L << (SUBSTR - 218)) | (1L << (SUBSTRING - 218)) | (1L << (SYSDATE - 218)) | (1L << (TRIM - 218)) | (1L << (UTC_DATE - 218)) | (1L << (UTC_TIME - 218)) | (1L << (UTC_TIMESTAMP - 218)) | (1L << (ACCOUNT - 218)) | (1L << (ACTION - 218)) | (1L << (AFTER - 218)) | (1L << (AGGREGATE - 218)) | (1L << (ALGORITHM - 218)) | (1L << (ANY - 218)) | (1L << (AT - 218)) | (1L << (AUTHORS - 218)) | (1L << (AUTOCOMMIT - 218)) | (1L << (AUTOEXTEND_SIZE - 218)) | (1L << (AUTO_INCREMENT - 218)) | (1L << (AVG_ROW_LENGTH - 218)) | (1L << (BEGIN - 218)) | (1L << (BINLOG - 218)) | (1L << (BIT - 218)) | (1L << (BLOCK - 218)) | (1L << (BOOL - 218)) | (1L << (BOOLEAN - 218)) | (1L << (BTREE - 218)) | (1L << (CACHE - 218)) | (1L << (CASCADED - 218)) | (1L << (CHAIN - 218)) | (1L << (CHANGED - 218)) | (1L << (CHANNEL - 218)) | (1L << (CHECKSUM - 218)) | (1L << (PAGE_CHECKSUM - 218)) | (1L << (CIPHER - 218)) | (1L << (CLASS_ORIGIN - 218)) | (1L << (CLIENT - 218)))) != 0) || ((((_la - 282)) & ~0x3f) == 0 && ((1L << (_la - 282)) & ((1L << (CLOSE - 282)) | (1L << (COALESCE - 282)) | (1L << (CODE - 282)) | (1L << (COLUMNS - 282)) | (1L << (COLUMN_FORMAT - 282)) | (1L << (COLUMN_NAME - 282)) | (1L << (COMMENT - 282)) | (1L << (COMMIT - 282)) | (1L << (COMPACT - 282)) | (1L << (COMPLETION - 282)) | (1L << (COMPRESSED - 282)) | (1L << (COMPRESSION - 282)) | (1L << (CONCURRENT - 282)) | (1L << (CONNECTION - 282)) | (1L << (CONSISTENT - 282)) | (1L << (CONSTRAINT_CATALOG - 282)) | (1L << (CONSTRAINT_SCHEMA - 282)) | (1L << (CONSTRAINT_NAME - 282)) | (1L << (CONTAINS - 282)) | (1L << (CONTEXT - 282)) | (1L << (CONTRIBUTORS - 282)) | (1L << (COPY - 282)) | (1L << (CPU - 282)) | (1L << (DATA - 282)) | (1L << (DATAFILE - 282)) | (1L << (DEALLOCATE - 282)) | (1L << (DEFAULT_AUTH - 282)) | (1L << (DEFINER - 282)) | (1L << (DELAY_KEY_WRITE - 282)) | (1L << (DES_KEY_FILE - 282)) | (1L << (DIRECTORY - 282)) | (1L << (DISABLE - 282)) | (1L << (DISCARD - 282)) | (1L << (DISK - 282)) | (1L << (DO - 282)) | (1L << (DUMPFILE - 282)) | (1L << (DUPLICATE - 282)) | (1L << (DYNAMIC - 282)) | (1L << (ENABLE - 282)) | (1L << (ENCRYPTION - 282)) | (1L << (END - 282)) | (1L << (ENDS - 282)) | (1L << (ENGINE - 282)) | (1L << (ENGINES - 282)) | (1L << (ERROR - 282)) | (1L << (ERRORS - 282)) | (1L << (ESCAPE - 282)) | (1L << (EVEN - 282)) | (1L << (EVENT - 282)) | (1L << (EVENTS - 282)) | (1L << (EVERY - 282)) | (1L << (EXCHANGE - 282)) | (1L << (EXCLUSIVE - 282)) | (1L << (EXPIRE - 282)) | (1L << (EXPORT - 282)) | (1L << (EXTENDED - 282)) | (1L << (EXTENT_SIZE - 282)) | (1L << (FAST - 282)) | (1L << (FAULTS - 282)) | (1L << (FIELDS - 282)) | (1L << (FILE_BLOCK_SIZE - 282)) | (1L << (FILTER - 282)) | (1L << (FIRST - 282)) | (1L << (FIXED - 282)))) != 0) || ((((_la - 346)) & ~0x3f) == 0 && ((1L << (_la - 346)) & ((1L << (FLUSH - 346)) | (1L << (FOLLOWS - 346)) | (1L << (FOUND - 346)) | (1L << (FULL - 346)) | (1L << (FUNCTION - 346)) | (1L << (GENERAL - 346)) | (1L << (GLOBAL - 346)) | (1L << (GRANTS - 346)) | (1L << (GROUP_REPLICATION - 346)) | (1L << (HANDLER - 346)) | (1L << (HASH - 346)) | (1L << (HELP - 346)) | (1L << (HOST - 346)) | (1L << (HOSTS - 346)) | (1L << (IDENTIFIED - 346)) | (1L << (IGNORE_SERVER_IDS - 346)) | (1L << (IMPORT - 346)) | (1L << (INDEXES - 346)) | (1L << (INITIAL_SIZE - 346)) | (1L << (INPLACE - 346)) | (1L << (INSERT_METHOD - 346)) | (1L << (INSTALL - 346)) | (1L << (INSTANCE - 346)) | (1L << (INVISIBLE - 346)) | (1L << (INVOKER - 346)) | (1L << (IO - 346)) | (1L << (IO_THREAD - 346)) | (1L << (IPC - 346)) | (1L << (ISOLATION - 346)) | (1L << (ISSUER - 346)) | (1L << (JSON - 346)) | (1L << (KEY_BLOCK_SIZE - 346)) | (1L << (LANGUAGE - 346)) | (1L << (LAST - 346)) | (1L << (LEAVES - 346)) | (1L << (LESS - 346)) | (1L << (LEVEL - 346)) | (1L << (LIST - 346)) | (1L << (LOCAL - 346)) | (1L << (LOGFILE - 346)) | (1L << (LOGS - 346)) | (1L << (MASTER - 346)) | (1L << (MASTER_AUTO_POSITION - 346)) | (1L << (MASTER_CONNECT_RETRY - 346)) | (1L << (MASTER_DELAY - 346)) | (1L << (MASTER_HEARTBEAT_PERIOD - 346)) | (1L << (MASTER_HOST - 346)) | (1L << (MASTER_LOG_FILE - 346)) | (1L << (MASTER_LOG_POS - 346)) | (1L << (MASTER_PASSWORD - 346)) | (1L << (MASTER_PORT - 346)) | (1L << (MASTER_RETRY_COUNT - 346)) | (1L << (MASTER_SSL - 346)) | (1L << (MASTER_SSL_CA - 346)) | (1L << (MASTER_SSL_CAPATH - 346)) | (1L << (MASTER_SSL_CERT - 346)) | (1L << (MASTER_SSL_CIPHER - 346)) | (1L << (MASTER_SSL_CRL - 346)) | (1L << (MASTER_SSL_CRLPATH - 346)) | (1L << (MASTER_SSL_KEY - 346)) | (1L << (MASTER_TLS_VERSION - 346)) | (1L << (MASTER_USER - 346)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 346)) | (1L << (MAX_QUERIES_PER_HOUR - 346)))) != 0) || ((((_la - 410)) & ~0x3f) == 0 && ((1L << (_la - 410)) & ((1L << (MAX_ROWS - 410)) | (1L << (MAX_SIZE - 410)) | (1L << (MAX_UPDATES_PER_HOUR - 410)) | (1L << (MAX_USER_CONNECTIONS - 410)) | (1L << (MEDIUM - 410)) | (1L << (MERGE - 410)) | (1L << (MESSAGE_TEXT - 410)) | (1L << (MID - 410)) | (1L << (MIGRATE - 410)) | (1L << (MIN_ROWS - 410)) | (1L << (MODE - 410)) | (1L << (MODIFY - 410)) | (1L << (MUTEX - 410)) | (1L << (MYSQL - 410)) | (1L << (MYSQL_ERRNO - 410)) | (1L << (NAME - 410)) | (1L << (NAMES - 410)) | (1L << (NCHAR - 410)) | (1L << (NEVER - 410)) | (1L << (NEXT - 410)) | (1L << (NO - 410)) | (1L << (NODEGROUP - 410)) | (1L << (NONE - 410)) | (1L << (OFFLINE - 410)) | (1L << (OFFSET - 410)) | (1L << (OJ - 410)) | (1L << (OLD_PASSWORD - 410)) | (1L << (ONE - 410)) | (1L << (ONLINE - 410)) | (1L << (ONLY - 410)) | (1L << (OPEN - 410)) | (1L << (OPTIMIZER_COSTS - 410)) | (1L << (OPTIONS - 410)) | (1L << (OWNER - 410)) | (1L << (PACK_KEYS - 410)) | (1L << (PAGE - 410)) | (1L << (PARSER - 410)) | (1L << (PARTIAL - 410)) | (1L << (PARTITIONING - 410)) | (1L << (PARTITIONS - 410)) | (1L << (PASSWORD - 410)) | (1L << (PHASE - 410)) | (1L << (PLUGIN - 410)) | (1L << (PLUGIN_DIR - 410)) | (1L << (PLUGINS - 410)) | (1L << (PORT - 410)) | (1L << (PRECEDES - 410)) | (1L << (PREPARE - 410)) | (1L << (PRESERVE - 410)) | (1L << (PREV - 410)) | (1L << (PROCESSLIST - 410)) | (1L << (PROFILE - 410)) | (1L << (PROFILES - 410)) | (1L << (PROXY - 410)) | (1L << (QUERY - 410)) | (1L << (QUICK - 410)) | (1L << (REBUILD - 410)) | (1L << (RECOVER - 410)) | (1L << (REDO_BUFFER_SIZE - 410)) | (1L << (REDUNDANT - 410)) | (1L << (RELAY - 410)) | (1L << (RELAY_LOG_FILE - 410)) | (1L << (RELAY_LOG_POS - 410)) | (1L << (RELAYLOG - 410)))) != 0) || ((((_la - 474)) & ~0x3f) == 0 && ((1L << (_la - 474)) & ((1L << (REMOVE - 474)) | (1L << (REORGANIZE - 474)) | (1L << (REPAIR - 474)) | (1L << (REPLICATE_DO_DB - 474)) | (1L << (REPLICATE_DO_TABLE - 474)) | (1L << (REPLICATE_IGNORE_DB - 474)) | (1L << (REPLICATE_IGNORE_TABLE - 474)) | (1L << (REPLICATE_REWRITE_DB - 474)) | (1L << (REPLICATE_WILD_DO_TABLE - 474)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 474)) | (1L << (REPLICATION - 474)) | (1L << (RESET - 474)) | (1L << (RESUME - 474)) | (1L << (RETURNS - 474)) | (1L << (ROLLBACK - 474)) | (1L << (ROLLUP - 474)) | (1L << (ROTATE - 474)) | (1L << (ROW - 474)) | (1L << (ROWS - 474)) | (1L << (ROW_FORMAT - 474)) | (1L << (SAVEPOINT - 474)) | (1L << (SCHEDULE - 474)) | (1L << (SECURITY - 474)) | (1L << (SERVER - 474)) | (1L << (SESSION - 474)) | (1L << (SHARE - 474)) | (1L << (SHARED - 474)) | (1L << (SIGNED - 474)) | (1L << (SIMPLE - 474)) | (1L << (SLAVE - 474)) | (1L << (SLOW - 474)) | (1L << (SNAPSHOT - 474)) | (1L << (SOCKET - 474)) | (1L << (SOME - 474)) | (1L << (SONAME - 474)) | (1L << (SOUNDS - 474)) | (1L << (SOURCE - 474)) | (1L << (SQL_AFTER_GTIDS - 474)) | (1L << (SQL_AFTER_MTS_GAPS - 474)) | (1L << (SQL_BEFORE_GTIDS - 474)) | (1L << (SQL_BUFFER_RESULT - 474)) | (1L << (SQL_CACHE - 474)) | (1L << (SQL_NO_CACHE - 474)) | (1L << (SQL_THREAD - 474)) | (1L << (START - 474)) | (1L << (STARTS - 474)) | (1L << (STATS_AUTO_RECALC - 474)) | (1L << (STATS_PERSISTENT - 474)) | (1L << (STATS_SAMPLE_PAGES - 474)) | (1L << (STATUS - 474)) | (1L << (STOP - 474)) | (1L << (STORAGE - 474)) | (1L << (STRING - 474)) | (1L << (SUBCLASS_ORIGIN - 474)) | (1L << (SUBJECT - 474)) | (1L << (SUBPARTITION - 474)) | (1L << (SUBPARTITIONS - 474)) | (1L << (SUSPEND - 474)) | (1L << (SWAPS - 474)) | (1L << (SWITCHES - 474)) | (1L << (TABLE_NAME - 474)) | (1L << (TABLESPACE - 474)) | (1L << (TEMPORARY - 474)))) != 0) || ((((_la - 538)) & ~0x3f) == 0 && ((1L << (_la - 538)) & ((1L << (TEMPTABLE - 538)) | (1L << (THAN - 538)) | (1L << (TRADITIONAL - 538)) | (1L << (TRANSACTION - 538)) | (1L << (TRIGGERS - 538)) | (1L << (TRUNCATE - 538)) | (1L << (UNDEFINED - 538)) | (1L << (UNDOFILE - 538)) | (1L << (UNDO_BUFFER_SIZE - 538)) | (1L << (UNINSTALL - 538)) | (1L << (UNKNOWN - 538)) | (1L << (UNTIL - 538)) | (1L << (UPGRADE - 538)) | (1L << (USER - 538)) | (1L << (USE_FRM - 538)) | (1L << (USER_RESOURCES - 538)) | (1L << (VALIDATION - 538)) | (1L << (VALUE - 538)) | (1L << (VARIABLES - 538)) | (1L << (VIEW - 538)) | (1L << (VISIBLE - 538)) | (1L << (WAIT - 538)) | (1L << (WARNINGS - 538)) | (1L << (WITHOUT - 538)) | (1L << (WORK - 538)) | (1L << (WRAPPER - 538)) | (1L << (X509 - 538)) | (1L << (XA - 538)) | (1L << (XML - 538)) | (1L << (INTERNAL - 538)) | (1L << (QUARTER - 538)) | (1L << (MONTH - 538)) | (1L << (DAY - 538)) | (1L << (HOUR - 538)) | (1L << (MINUTE - 538)) | (1L << (WEEK - 538)) | (1L << (SECOND - 538)) | (1L << (MICROSECOND - 538)) | (1L << (TABLES - 538)) | (1L << (ROUTINE - 538)) | (1L << (EXECUTE - 538)) | (1L << (FILE - 538)) | (1L << (PROCESS - 538)) | (1L << (RELOAD - 538)) | (1L << (SHUTDOWN - 538)) | (1L << (SUPER - 538)) | (1L << (PRIVILEGES - 538)) | (1L << (SESSION_VARIABLES_ADMIN - 538)) | (1L << (ARMSCII8 - 538)) | (1L << (ASCII - 538)) | (1L << (BIG5 - 538)) | (1L << (CP1250 - 538)) | (1L << (CP1251 - 538)) | (1L << (CP1256 - 538)) | (1L << (CP1257 - 538)) | (1L << (CP850 - 538)) | (1L << (CP852 - 538)) | (1L << (CP866 - 538)) | (1L << (CP932 - 538)))) != 0) || ((((_la - 602)) & ~0x3f) == 0 && ((1L << (_la - 602)) & ((1L << (DEC8 - 602)) | (1L << (EUCJPMS - 602)) | (1L << (EUCKR - 602)) | (1L << (GB2312 - 602)) | (1L << (GBK - 602)) | (1L << (GEOSTD8 - 602)) | (1L << (GREEK - 602)) | (1L << (HEBREW - 602)) | (1L << (HP8 - 602)) | (1L << (KEYBCS2 - 602)) | (1L << (KOI8R - 602)) | (1L << (KOI8U - 602)) | (1L << (LATIN1 - 602)) | (1L << (LATIN2 - 602)) | (1L << (LATIN5 - 602)) | (1L << (LATIN7 - 602)) | (1L << (MACCE - 602)) | (1L << (MACROMAN - 602)) | (1L << (SJIS - 602)) | (1L << (SWE7 - 602)) | (1L << (TIS620 - 602)) | (1L << (UCS2 - 602)) | (1L << (UJIS - 602)) | (1L << (UTF16 - 602)) | (1L << (UTF16LE - 602)) | (1L << (UTF32 - 602)) | (1L << (UTF8 - 602)) | (1L << (UTF8MB3 - 602)) | (1L << (UTF8MB4 - 602)) | (1L << (ARCHIVE - 602)) | (1L << (BLACKHOLE - 602)) | (1L << (CSV - 602)) | (1L << (FEDERATED - 602)) | (1L << (INNODB - 602)) | (1L << (MEMORY - 602)) | (1L << (MRG_MYISAM - 602)) | (1L << (MYISAM - 602)) | (1L << (NDB - 602)) | (1L << (NDBCLUSTER - 602)) | (1L << (PERFORMANCE_SCHEMA - 602)) | (1L << (TOKUDB - 602)) | (1L << (REPEATABLE - 602)) | (1L << (COMMITTED - 602)) | (1L << (UNCOMMITTED - 602)) | (1L << (SERIALIZABLE - 602)) | (1L << (GEOMETRYCOLLECTION - 602)) | (1L << (LINESTRING - 602)) | (1L << (MULTILINESTRING - 602)) | (1L << (MULTIPOINT - 602)) | (1L << (MULTIPOLYGON - 602)) | (1L << (POINT - 602)) | (1L << (POLYGON - 602)) | (1L << (ABS - 602)) | (1L << (ACOS - 602)) | (1L << (ADDDATE - 602)) | (1L << (ADDTIME - 602)) | (1L << (AES_DECRYPT - 602)) | (1L << (AES_ENCRYPT - 602)) | (1L << (AREA - 602)) | (1L << (ASBINARY - 602)) | (1L << (ASIN - 602)) | (1L << (ASTEXT - 602)))) != 0) || ((((_la - 666)) & ~0x3f) == 0 && ((1L << (_la - 666)) & ((1L << (ASWKB - 666)) | (1L << (ASWKT - 666)) | (1L << (ASYMMETRIC_DECRYPT - 666)) | (1L << (ASYMMETRIC_DERIVE - 666)) | (1L << (ASYMMETRIC_ENCRYPT - 666)) | (1L << (ASYMMETRIC_SIGN - 666)) | (1L << (ASYMMETRIC_VERIFY - 666)) | (1L << (ATAN - 666)) | (1L << (ATAN2 - 666)) | (1L << (BENCHMARK - 666)) | (1L << (BIN - 666)) | (1L << (BIT_COUNT - 666)) | (1L << (BIT_LENGTH - 666)) | (1L << (BUFFER - 666)) | (1L << (CATALOG_NAME - 666)) | (1L << (CEIL - 666)) | (1L << (CEILING - 666)) | (1L << (CENTROID - 666)) | (1L << (CHARACTER_LENGTH - 666)) | (1L << (CHARSET - 666)) | (1L << (CHAR_LENGTH - 666)) | (1L << (COERCIBILITY - 666)) | (1L << (COLLATION - 666)) | (1L << (COMPRESS - 666)) | (1L << (CONCAT - 666)) | (1L << (CONCAT_WS - 666)) | (1L << (CONNECTION_ID - 666)) | (1L << (CONV - 666)) | (1L << (CONVERT_TZ - 666)) | (1L << (COS - 666)) | (1L << (COT - 666)) | (1L << (CRC32 - 666)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 666)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 666)) | (1L << (CREATE_DH_PARAMETERS - 666)) | (1L << (CREATE_DIGEST - 666)) | (1L << (CROSSES - 666)) | (1L << (DATEDIFF - 666)) | (1L << (DATE_FORMAT - 666)) | (1L << (DAYNAME - 666)) | (1L << (DAYOFMONTH - 666)) | (1L << (DAYOFWEEK - 666)) | (1L << (DAYOFYEAR - 666)) | (1L << (DECODE - 666)) | (1L << (DEGREES - 666)) | (1L << (DES_DECRYPT - 666)) | (1L << (DES_ENCRYPT - 666)) | (1L << (DIMENSION - 666)) | (1L << (DISJOINT - 666)) | (1L << (ELT - 666)) | (1L << (ENCODE - 666)) | (1L << (ENCRYPT - 666)) | (1L << (ENDPOINT - 666)) | (1L << (ENVELOPE - 666)) | (1L << (EQUALS - 666)) | (1L << (EXP - 666)) | (1L << (EXPORT_SET - 666)) | (1L << (EXTERIORRING - 666)) | (1L << (EXTRACTVALUE - 666)) | (1L << (FIELD - 666)) | (1L << (FIND_IN_SET - 666)) | (1L << (FLOOR - 666)) | (1L << (FORMAT - 666)) | (1L << (FOUND_ROWS - 666)))) != 0) || ((((_la - 730)) & ~0x3f) == 0 && ((1L << (_la - 730)) & ((1L << (FROM_BASE64 - 730)) | (1L << (FROM_DAYS - 730)) | (1L << (FROM_UNIXTIME - 730)) | (1L << (GEOMCOLLFROMTEXT - 730)) | (1L << (GEOMCOLLFROMWKB - 730)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 730)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 730)) | (1L << (GEOMETRYFROMTEXT - 730)) | (1L << (GEOMETRYFROMWKB - 730)) | (1L << (GEOMETRYN - 730)) | (1L << (GEOMETRYTYPE - 730)) | (1L << (GEOMFROMTEXT - 730)) | (1L << (GEOMFROMWKB - 730)) | (1L << (GET_FORMAT - 730)) | (1L << (GET_LOCK - 730)) | (1L << (GLENGTH - 730)) | (1L << (GREATEST - 730)) | (1L << (GTID_SUBSET - 730)) | (1L << (GTID_SUBTRACT - 730)) | (1L << (HEX - 730)) | (1L << (IFNULL - 730)) | (1L << (INET6_ATON - 730)) | (1L << (INET6_NTOA - 730)) | (1L << (INET_ATON - 730)) | (1L << (INET_NTOA - 730)) | (1L << (INSTR - 730)) | (1L << (INTERIORRINGN - 730)) | (1L << (INTERSECTS - 730)) | (1L << (ISCLOSED - 730)) | (1L << (ISEMPTY - 730)) | (1L << (ISNULL - 730)) | (1L << (ISSIMPLE - 730)) | (1L << (IS_FREE_LOCK - 730)) | (1L << (IS_IPV4 - 730)) | (1L << (IS_IPV4_COMPAT - 730)) | (1L << (IS_IPV4_MAPPED - 730)) | (1L << (IS_IPV6 - 730)) | (1L << (IS_USED_LOCK - 730)) | (1L << (LAST_INSERT_ID - 730)) | (1L << (LCASE - 730)) | (1L << (LEAST - 730)) | (1L << (LENGTH - 730)) | (1L << (LINEFROMTEXT - 730)) | (1L << (LINEFROMWKB - 730)) | (1L << (LINESTRINGFROMTEXT - 730)) | (1L << (LINESTRINGFROMWKB - 730)) | (1L << (LN - 730)) | (1L << (LOAD_FILE - 730)) | (1L << (LOCATE - 730)) | (1L << (LOG - 730)) | (1L << (LOG10 - 730)) | (1L << (LOG2 - 730)) | (1L << (LOWER - 730)) | (1L << (LPAD - 730)) | (1L << (LTRIM - 730)) | (1L << (MAKEDATE - 730)) | (1L << (MAKETIME - 730)) | (1L << (MAKE_SET - 730)) | (1L << (MASTER_POS_WAIT - 730)) | (1L << (MBRCONTAINS - 730)) | (1L << (MBRDISJOINT - 730)) | (1L << (MBREQUAL - 730)) | (1L << (MBRINTERSECTS - 730)) | (1L << (MBROVERLAPS - 730)))) != 0) || ((((_la - 794)) & ~0x3f) == 0 && ((1L << (_la - 794)) & ((1L << (MBRTOUCHES - 794)) | (1L << (MBRWITHIN - 794)) | (1L << (MD5 - 794)) | (1L << (MLINEFROMTEXT - 794)) | (1L << (MLINEFROMWKB - 794)) | (1L << (MONTHNAME - 794)) | (1L << (MPOINTFROMTEXT - 794)) | (1L << (MPOINTFROMWKB - 794)) | (1L << (MPOLYFROMTEXT - 794)) | (1L << (MPOLYFROMWKB - 794)) | (1L << (MULTILINESTRINGFROMTEXT - 794)) | (1L << (MULTILINESTRINGFROMWKB - 794)) | (1L << (MULTIPOINTFROMTEXT - 794)) | (1L << (MULTIPOINTFROMWKB - 794)) | (1L << (MULTIPOLYGONFROMTEXT - 794)) | (1L << (MULTIPOLYGONFROMWKB - 794)) | (1L << (NAME_CONST - 794)) | (1L << (NULLIF - 794)) | (1L << (NUMGEOMETRIES - 794)) | (1L << (NUMINTERIORRINGS - 794)) | (1L << (NUMPOINTS - 794)) | (1L << (OCT - 794)) | (1L << (OCTET_LENGTH - 794)) | (1L << (ORD - 794)) | (1L << (OVERLAPS - 794)) | (1L << (PERIOD_ADD - 794)) | (1L << (PERIOD_DIFF - 794)) | (1L << (PI - 794)) | (1L << (POINTFROMTEXT - 794)) | (1L << (POINTFROMWKB - 794)) | (1L << (POINTN - 794)) | (1L << (POLYFROMTEXT - 794)) | (1L << (POLYFROMWKB - 794)) | (1L << (POLYGONFROMTEXT - 794)) | (1L << (POLYGONFROMWKB - 794)) | (1L << (POW - 794)) | (1L << (POWER - 794)) | (1L << (QUOTE - 794)) | (1L << (RADIANS - 794)) | (1L << (RAND - 794)) | (1L << (RANDOM_BYTES - 794)) | (1L << (RELEASE_LOCK - 794)) | (1L << (REVERSE - 794)) | (1L << (ROUND - 794)) | (1L << (ROW_COUNT - 794)) | (1L << (RPAD - 794)) | (1L << (RTRIM - 794)) | (1L << (SEC_TO_TIME - 794)) | (1L << (SESSION_USER - 794)) | (1L << (SHA - 794)) | (1L << (SHA1 - 794)) | (1L << (SHA2 - 794)) | (1L << (SCHEMA_NAME - 794)) | (1L << (SIGN - 794)) | (1L << (SIN - 794)) | (1L << (SLEEP - 794)) | (1L << (SOUNDEX - 794)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 794)) | (1L << (SQRT - 794)) | (1L << (SRID - 794)) | (1L << (STARTPOINT - 794)) | (1L << (STRCMP - 794)) | (1L << (STR_TO_DATE - 794)) | (1L << (ST_AREA - 794)))) != 0) || ((((_la - 858)) & ~0x3f) == 0 && ((1L << (_la - 858)) & ((1L << (ST_ASBINARY - 858)) | (1L << (ST_ASTEXT - 858)) | (1L << (ST_ASWKB - 858)) | (1L << (ST_ASWKT - 858)) | (1L << (ST_BUFFER - 858)) | (1L << (ST_CENTROID - 858)) | (1L << (ST_CONTAINS - 858)) | (1L << (ST_CROSSES - 858)) | (1L << (ST_DIFFERENCE - 858)) | (1L << (ST_DIMENSION - 858)) | (1L << (ST_DISJOINT - 858)) | (1L << (ST_DISTANCE - 858)) | (1L << (ST_ENDPOINT - 858)) | (1L << (ST_ENVELOPE - 858)) | (1L << (ST_EQUALS - 858)) | (1L << (ST_EXTERIORRING - 858)) | (1L << (ST_GEOMCOLLFROMTEXT - 858)) | (1L << (ST_GEOMCOLLFROMTXT - 858)) | (1L << (ST_GEOMCOLLFROMWKB - 858)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 858)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 858)) | (1L << (ST_GEOMETRYFROMTEXT - 858)) | (1L << (ST_GEOMETRYFROMWKB - 858)) | (1L << (ST_GEOMETRYN - 858)) | (1L << (ST_GEOMETRYTYPE - 858)) | (1L << (ST_GEOMFROMTEXT - 858)) | (1L << (ST_GEOMFROMWKB - 858)) | (1L << (ST_INTERIORRINGN - 858)) | (1L << (ST_INTERSECTION - 858)) | (1L << (ST_INTERSECTS - 858)) | (1L << (ST_ISCLOSED - 858)) | (1L << (ST_ISEMPTY - 858)) | (1L << (ST_ISSIMPLE - 858)) | (1L << (ST_LINEFROMTEXT - 858)) | (1L << (ST_LINEFROMWKB - 858)) | (1L << (ST_LINESTRINGFROMTEXT - 858)) | (1L << (ST_LINESTRINGFROMWKB - 858)) | (1L << (ST_NUMGEOMETRIES - 858)) | (1L << (ST_NUMINTERIORRING - 858)) | (1L << (ST_NUMINTERIORRINGS - 858)) | (1L << (ST_NUMPOINTS - 858)) | (1L << (ST_OVERLAPS - 858)) | (1L << (ST_POINTFROMTEXT - 858)) | (1L << (ST_POINTFROMWKB - 858)) | (1L << (ST_POINTN - 858)) | (1L << (ST_POLYFROMTEXT - 858)) | (1L << (ST_POLYFROMWKB - 858)) | (1L << (ST_POLYGONFROMTEXT - 858)) | (1L << (ST_POLYGONFROMWKB - 858)) | (1L << (ST_SRID - 858)) | (1L << (ST_STARTPOINT - 858)) | (1L << (ST_SYMDIFFERENCE - 858)) | (1L << (ST_TOUCHES - 858)) | (1L << (ST_UNION - 858)) | (1L << (ST_WITHIN - 858)) | (1L << (ST_X - 858)) | (1L << (ST_Y - 858)) | (1L << (SUBDATE - 858)) | (1L << (SUBSTRING_INDEX - 858)) | (1L << (SUBTIME - 858)) | (1L << (SYSTEM_USER - 858)) | (1L << (TAN - 858)) | (1L << (TIMEDIFF - 858)) | (1L << (TIMESTAMPADD - 858)))) != 0) || ((((_la - 922)) & ~0x3f) == 0 && ((1L << (_la - 922)) & ((1L << (TIMESTAMPDIFF - 922)) | (1L << (TIME_FORMAT - 922)) | (1L << (TIME_TO_SEC - 922)) | (1L << (TOUCHES - 922)) | (1L << (TO_BASE64 - 922)) | (1L << (TO_DAYS - 922)) | (1L << (TO_SECONDS - 922)) | (1L << (UCASE - 922)) | (1L << (UNCOMPRESS - 922)) | (1L << (UNCOMPRESSED_LENGTH - 922)) | (1L << (UNHEX - 922)) | (1L << (UNIX_TIMESTAMP - 922)) | (1L << (UPDATEXML - 922)) | (1L << (UPPER - 922)) | (1L << (UUID - 922)) | (1L << (UUID_SHORT - 922)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 922)) | (1L << (VERSION - 922)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 922)) | (1L << (WEEKDAY - 922)) | (1L << (WEEKOFYEAR - 922)) | (1L << (WEIGHT_STRING - 922)) | (1L << (WITHIN - 922)) | (1L << (YEARWEEK - 922)) | (1L << (Y_FUNCTION - 922)) | (1L << (X_FUNCTION - 922)) | (1L << (PLUS - 922)) | (1L << (MINUS - 922)) | (1L << (EXCLAMATION_SYMBOL - 922)) | (1L << (BIT_NOT_OP - 922)) | (1L << (LR_BRACKET - 922)) | (1L << (ZERO_DECIMAL - 922)) | (1L << (ONE_DECIMAL - 922)) | (1L << (TWO_DECIMAL - 922)))) != 0) || ((((_la - 986)) & ~0x3f) == 0 && ((1L << (_la - 986)) & ((1L << (CHARSET_REVERSE_QOUTE_STRING - 986)) | (1L << (START_NATIONAL_STRING_LITERAL - 986)) | (1L << (STRING_LITERAL - 986)) | (1L << (DECIMAL_LITERAL - 986)) | (1L << (HEXADECIMAL_LITERAL - 986)) | (1L << (REAL_LITERAL - 986)) | (1L << (NULL_SPEC_LITERAL - 986)) | (1L << (BIT_STRING - 986)) | (1L << (STRING_CHARSET_NAME - 986)) | (1L << (ID - 986)) | (1L << (REVERSE_QUOTE_ID - 986)) | (1L << (LOCAL_ID - 986)) | (1L << (GLOBAL_ID - 986)))) != 0)) {
					{
					State = 5718; functionArgs();
					}
				}

				State = 5721; Match(RR_BRACKET);
				}
				break;
			case 5:
				_localctx = new PasswordFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 5723; passwordFunctionClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SpecificFunctionContext : ParserRuleContext {
		public SpecificFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_specificFunction; } }
	 
		public SpecificFunctionContext() { }
		public virtual void CopyFrom(SpecificFunctionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PositionFunctionCallContext : SpecificFunctionContext {
		public StringLiteralContext positionString;
		public ExpressionContext positionExpression;
		public StringLiteralContext inString;
		public ExpressionContext inExpression;
		public ITerminalNode POSITION() { return GetToken(MySqlParser.POSITION, 0); }
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public StringLiteralContext[] stringLiteral() {
			return GetRuleContexts<StringLiteralContext>();
		}
		public StringLiteralContext stringLiteral(int i) {
			return GetRuleContext<StringLiteralContext>(i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public PositionFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPositionFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPositionFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPositionFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TrimFunctionCallContext : SpecificFunctionContext {
		public IToken positioinForm;
		public StringLiteralContext sourceString;
		public ExpressionContext sourceExpression;
		public StringLiteralContext fromString;
		public ExpressionContext fromExpression;
		public ITerminalNode TRIM() { return GetToken(MySqlParser.TRIM, 0); }
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode BOTH() { return GetToken(MySqlParser.BOTH, 0); }
		public ITerminalNode LEADING() { return GetToken(MySqlParser.LEADING, 0); }
		public ITerminalNode TRAILING() { return GetToken(MySqlParser.TRAILING, 0); }
		public StringLiteralContext[] stringLiteral() {
			return GetRuleContexts<StringLiteralContext>();
		}
		public StringLiteralContext stringLiteral(int i) {
			return GetRuleContext<StringLiteralContext>(i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public TrimFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTrimFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTrimFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrimFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SimpleFunctionCallContext : SpecificFunctionContext {
		public ITerminalNode CURRENT_DATE() { return GetToken(MySqlParser.CURRENT_DATE, 0); }
		public ITerminalNode CURRENT_TIME() { return GetToken(MySqlParser.CURRENT_TIME, 0); }
		public ITerminalNode CURRENT_TIMESTAMP() { return GetToken(MySqlParser.CURRENT_TIMESTAMP, 0); }
		public ITerminalNode CURRENT_USER() { return GetToken(MySqlParser.CURRENT_USER, 0); }
		public ITerminalNode LOCALTIME() { return GetToken(MySqlParser.LOCALTIME, 0); }
		public SimpleFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSimpleFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSimpleFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CharFunctionCallContext : SpecificFunctionContext {
		public ITerminalNode CHAR() { return GetToken(MySqlParser.CHAR, 0); }
		public FunctionArgsContext functionArgs() {
			return GetRuleContext<FunctionArgsContext>(0);
		}
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public CharFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCharFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCharFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCharFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WeightFunctionCallContext : SpecificFunctionContext {
		public IToken stringFormat;
		public ITerminalNode WEIGHT_STRING() { return GetToken(MySqlParser.WEIGHT_STRING, 0); }
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public LevelsInWeightStringContext levelsInWeightString() {
			return GetRuleContext<LevelsInWeightStringContext>(0);
		}
		public ITerminalNode CHAR() { return GetToken(MySqlParser.CHAR, 0); }
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public WeightFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterWeightFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitWeightFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWeightFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class GetFormatFunctionCallContext : SpecificFunctionContext {
		public IToken datetimeFormat;
		public ITerminalNode GET_FORMAT() { return GetToken(MySqlParser.GET_FORMAT, 0); }
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public ITerminalNode DATE() { return GetToken(MySqlParser.DATE, 0); }
		public ITerminalNode TIME() { return GetToken(MySqlParser.TIME, 0); }
		public ITerminalNode DATETIME() { return GetToken(MySqlParser.DATETIME, 0); }
		public GetFormatFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterGetFormatFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitGetFormatFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGetFormatFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CaseFunctionCallContext : SpecificFunctionContext {
		public FunctionArgContext elseArg;
		public ITerminalNode CASE() { return GetToken(MySqlParser.CASE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public CaseFuncAlternativeContext[] caseFuncAlternative() {
			return GetRuleContexts<CaseFuncAlternativeContext>();
		}
		public CaseFuncAlternativeContext caseFuncAlternative(int i) {
			return GetRuleContext<CaseFuncAlternativeContext>(i);
		}
		public ITerminalNode ELSE() { return GetToken(MySqlParser.ELSE, 0); }
		public FunctionArgContext functionArg() {
			return GetRuleContext<FunctionArgContext>(0);
		}
		public CaseFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCaseFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCaseFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExtractFunctionCallContext : SpecificFunctionContext {
		public StringLiteralContext sourceString;
		public ExpressionContext sourceExpression;
		public ITerminalNode EXTRACT() { return GetToken(MySqlParser.EXTRACT, 0); }
		public IntervalTypeContext intervalType() {
			return GetRuleContext<IntervalTypeContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ExtractFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExtractFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExtractFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExtractFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DataTypeFunctionCallContext : SpecificFunctionContext {
		public IToken separator;
		public ITerminalNode CONVERT() { return GetToken(MySqlParser.CONVERT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ConvertedDataTypeContext convertedDataType() {
			return GetRuleContext<ConvertedDataTypeContext>(0);
		}
		public ITerminalNode USING() { return GetToken(MySqlParser.USING, 0); }
		public CharsetNameContext charsetName() {
			return GetRuleContext<CharsetNameContext>(0);
		}
		public ITerminalNode CAST() { return GetToken(MySqlParser.CAST, 0); }
		public ITerminalNode AS() { return GetToken(MySqlParser.AS, 0); }
		public DataTypeFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDataTypeFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDataTypeFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDataTypeFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ValuesFunctionCallContext : SpecificFunctionContext {
		public ITerminalNode VALUES() { return GetToken(MySqlParser.VALUES, 0); }
		public FullColumnNameContext fullColumnName() {
			return GetRuleContext<FullColumnNameContext>(0);
		}
		public ValuesFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterValuesFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitValuesFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitValuesFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SubstrFunctionCallContext : SpecificFunctionContext {
		public StringLiteralContext sourceString;
		public ExpressionContext sourceExpression;
		public DecimalLiteralContext fromDecimal;
		public ExpressionContext fromExpression;
		public DecimalLiteralContext forDecimal;
		public ExpressionContext forExpression;
		public ITerminalNode FROM() { return GetToken(MySqlParser.FROM, 0); }
		public ITerminalNode SUBSTR() { return GetToken(MySqlParser.SUBSTR, 0); }
		public ITerminalNode SUBSTRING() { return GetToken(MySqlParser.SUBSTRING, 0); }
		public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public ITerminalNode FOR() { return GetToken(MySqlParser.FOR, 0); }
		public SubstrFunctionCallContext(SpecificFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubstrFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubstrFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubstrFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SpecificFunctionContext specificFunction() {
		SpecificFunctionContext _localctx = new SpecificFunctionContext(Context, State);
		EnterRule(_localctx, 576, RULE_specificFunction);
		int _la;
		try {
			State = 5883;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,868,Context) ) {
			case 1:
				_localctx = new SimpleFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 5726;
				_la = TokenStream.LA(1);
				if ( !(_la==CURRENT_USER || ((((_la - 234)) & ~0x3f) == 0 && ((1L << (_la - 234)) & ((1L << (CURRENT_DATE - 234)) | (1L << (CURRENT_TIME - 234)) | (1L << (CURRENT_TIMESTAMP - 234)) | (1L << (LOCALTIME - 234)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 2:
				_localctx = new DataTypeFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 5727; Match(CONVERT);
				State = 5728; Match(LR_BRACKET);
				State = 5729; expression(0);
				State = 5730; ((DataTypeFunctionCallContext)_localctx).separator = Match(COMMA);
				State = 5731; convertedDataType();
				State = 5732; Match(RR_BRACKET);
				}
				break;
			case 3:
				_localctx = new DataTypeFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 5734; Match(CONVERT);
				State = 5735; Match(LR_BRACKET);
				State = 5736; expression(0);
				State = 5737; Match(USING);
				State = 5738; charsetName();
				State = 5739; Match(RR_BRACKET);
				}
				break;
			case 4:
				_localctx = new DataTypeFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 5741; Match(CAST);
				State = 5742; Match(LR_BRACKET);
				State = 5743; expression(0);
				State = 5744; Match(AS);
				State = 5745; convertedDataType();
				State = 5746; Match(RR_BRACKET);
				}
				break;
			case 5:
				_localctx = new ValuesFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 5748; Match(VALUES);
				State = 5749; Match(LR_BRACKET);
				State = 5750; fullColumnName();
				State = 5751; Match(RR_BRACKET);
				}
				break;
			case 6:
				_localctx = new CaseFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 5753; Match(CASE);
				State = 5754; expression(0);
				State = 5756;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 5755; caseFuncAlternative();
					}
					}
					State = 5758;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==WHEN );
				State = 5762;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ELSE) {
					{
					State = 5760; Match(ELSE);
					State = 5761; ((CaseFunctionCallContext)_localctx).elseArg = functionArg();
					}
				}

				State = 5764; Match(END);
				}
				break;
			case 7:
				_localctx = new CaseFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 5766; Match(CASE);
				State = 5768;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 5767; caseFuncAlternative();
					}
					}
					State = 5770;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==WHEN );
				State = 5774;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ELSE) {
					{
					State = 5772; Match(ELSE);
					State = 5773; ((CaseFunctionCallContext)_localctx).elseArg = functionArg();
					}
				}

				State = 5776; Match(END);
				}
				break;
			case 8:
				_localctx = new CharFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 5778; Match(CHAR);
				State = 5779; Match(LR_BRACKET);
				State = 5780; functionArgs();
				State = 5783;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 5781; Match(USING);
					State = 5782; charsetName();
					}
				}

				State = 5785; Match(RR_BRACKET);
				}
				break;
			case 9:
				_localctx = new PositionFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 5787; Match(POSITION);
				State = 5788; Match(LR_BRACKET);
				State = 5791;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,854,Context) ) {
				case 1:
					{
					State = 5789; ((PositionFunctionCallContext)_localctx).positionString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5790; ((PositionFunctionCallContext)_localctx).positionExpression = expression(0);
					}
					break;
				}
				State = 5793; Match(IN);
				State = 5796;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,855,Context) ) {
				case 1:
					{
					State = 5794; ((PositionFunctionCallContext)_localctx).inString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5795; ((PositionFunctionCallContext)_localctx).inExpression = expression(0);
					}
					break;
				}
				State = 5798; Match(RR_BRACKET);
				}
				break;
			case 10:
				_localctx = new SubstrFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 5800;
				_la = TokenStream.LA(1);
				if ( !(_la==SUBSTR || _la==SUBSTRING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5801; Match(LR_BRACKET);
				State = 5804;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,856,Context) ) {
				case 1:
					{
					State = 5802; ((SubstrFunctionCallContext)_localctx).sourceString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5803; ((SubstrFunctionCallContext)_localctx).sourceExpression = expression(0);
					}
					break;
				}
				State = 5806; Match(FROM);
				State = 5809;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,857,Context) ) {
				case 1:
					{
					State = 5807; ((SubstrFunctionCallContext)_localctx).fromDecimal = decimalLiteral();
					}
					break;
				case 2:
					{
					State = 5808; ((SubstrFunctionCallContext)_localctx).fromExpression = expression(0);
					}
					break;
				}
				State = 5816;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 5811; Match(FOR);
					State = 5814;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,858,Context) ) {
					case 1:
						{
						State = 5812; ((SubstrFunctionCallContext)_localctx).forDecimal = decimalLiteral();
						}
						break;
					case 2:
						{
						State = 5813; ((SubstrFunctionCallContext)_localctx).forExpression = expression(0);
						}
						break;
					}
					}
				}

				State = 5818; Match(RR_BRACKET);
				}
				break;
			case 11:
				_localctx = new TrimFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 5820; Match(TRIM);
				State = 5821; Match(LR_BRACKET);
				State = 5822;
				((TrimFunctionCallContext)_localctx).positioinForm = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==BOTH || _la==LEADING || _la==TRAILING) ) {
					((TrimFunctionCallContext)_localctx).positioinForm = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5825;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,860,Context) ) {
				case 1:
					{
					State = 5823; ((TrimFunctionCallContext)_localctx).sourceString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5824; ((TrimFunctionCallContext)_localctx).sourceExpression = expression(0);
					}
					break;
				}
				State = 5827; Match(FROM);
				State = 5830;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,861,Context) ) {
				case 1:
					{
					State = 5828; ((TrimFunctionCallContext)_localctx).fromString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5829; ((TrimFunctionCallContext)_localctx).fromExpression = expression(0);
					}
					break;
				}
				State = 5832; Match(RR_BRACKET);
				}
				break;
			case 12:
				_localctx = new TrimFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 5834; Match(TRIM);
				State = 5835; Match(LR_BRACKET);
				State = 5838;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,862,Context) ) {
				case 1:
					{
					State = 5836; ((TrimFunctionCallContext)_localctx).sourceString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5837; ((TrimFunctionCallContext)_localctx).sourceExpression = expression(0);
					}
					break;
				}
				State = 5840; Match(FROM);
				State = 5843;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,863,Context) ) {
				case 1:
					{
					State = 5841; ((TrimFunctionCallContext)_localctx).fromString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5842; ((TrimFunctionCallContext)_localctx).fromExpression = expression(0);
					}
					break;
				}
				State = 5845; Match(RR_BRACKET);
				}
				break;
			case 13:
				_localctx = new WeightFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 5847; Match(WEIGHT_STRING);
				State = 5848; Match(LR_BRACKET);
				State = 5851;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,864,Context) ) {
				case 1:
					{
					State = 5849; stringLiteral();
					}
					break;
				case 2:
					{
					State = 5850; expression(0);
					}
					break;
				}
				State = 5859;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 5853; Match(AS);
					State = 5854;
					((WeightFunctionCallContext)_localctx).stringFormat = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==CHAR || _la==BINARY) ) {
						((WeightFunctionCallContext)_localctx).stringFormat = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 5855; Match(LR_BRACKET);
					State = 5856; decimalLiteral();
					State = 5857; Match(RR_BRACKET);
					}
				}

				State = 5862;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LEVEL) {
					{
					State = 5861; levelsInWeightString();
					}
				}

				State = 5864; Match(RR_BRACKET);
				}
				break;
			case 14:
				_localctx = new ExtractFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 5866; Match(EXTRACT);
				State = 5867; Match(LR_BRACKET);
				State = 5868; intervalType();
				State = 5869; Match(FROM);
				State = 5872;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,867,Context) ) {
				case 1:
					{
					State = 5870; ((ExtractFunctionCallContext)_localctx).sourceString = stringLiteral();
					}
					break;
				case 2:
					{
					State = 5871; ((ExtractFunctionCallContext)_localctx).sourceExpression = expression(0);
					}
					break;
				}
				State = 5874; Match(RR_BRACKET);
				}
				break;
			case 15:
				_localctx = new GetFormatFunctionCallContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 5876; Match(GET_FORMAT);
				State = 5877; Match(LR_BRACKET);
				State = 5878;
				((GetFormatFunctionCallContext)_localctx).datetimeFormat = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (DATETIME - 185)))) != 0)) ) {
					((GetFormatFunctionCallContext)_localctx).datetimeFormat = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5879; Match(COMMA);
				State = 5880; stringLiteral();
				State = 5881; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseFuncAlternativeContext : ParserRuleContext {
		public FunctionArgContext condition;
		public FunctionArgContext consequent;
		public ITerminalNode WHEN() { return GetToken(MySqlParser.WHEN, 0); }
		public ITerminalNode THEN() { return GetToken(MySqlParser.THEN, 0); }
		public FunctionArgContext[] functionArg() {
			return GetRuleContexts<FunctionArgContext>();
		}
		public FunctionArgContext functionArg(int i) {
			return GetRuleContext<FunctionArgContext>(i);
		}
		public CaseFuncAlternativeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseFuncAlternative; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCaseFuncAlternative(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCaseFuncAlternative(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseFuncAlternative(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaseFuncAlternativeContext caseFuncAlternative() {
		CaseFuncAlternativeContext _localctx = new CaseFuncAlternativeContext(Context, State);
		EnterRule(_localctx, 578, RULE_caseFuncAlternative);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5885; Match(WHEN);
			State = 5886; _localctx.condition = functionArg();
			State = 5887; Match(THEN);
			State = 5888; _localctx.consequent = functionArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LevelsInWeightStringContext : ParserRuleContext {
		public LevelsInWeightStringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_levelsInWeightString; } }
	 
		public LevelsInWeightStringContext() { }
		public virtual void CopyFrom(LevelsInWeightStringContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class LevelWeightRangeContext : LevelsInWeightStringContext {
		public DecimalLiteralContext firstLevel;
		public DecimalLiteralContext lastLevel;
		public ITerminalNode LEVEL() { return GetToken(MySqlParser.LEVEL, 0); }
		public DecimalLiteralContext[] decimalLiteral() {
			return GetRuleContexts<DecimalLiteralContext>();
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return GetRuleContext<DecimalLiteralContext>(i);
		}
		public LevelWeightRangeContext(LevelsInWeightStringContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLevelWeightRange(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLevelWeightRange(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLevelWeightRange(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LevelWeightListContext : LevelsInWeightStringContext {
		public ITerminalNode LEVEL() { return GetToken(MySqlParser.LEVEL, 0); }
		public LevelInWeightListElementContext[] levelInWeightListElement() {
			return GetRuleContexts<LevelInWeightListElementContext>();
		}
		public LevelInWeightListElementContext levelInWeightListElement(int i) {
			return GetRuleContext<LevelInWeightListElementContext>(i);
		}
		public LevelWeightListContext(LevelsInWeightStringContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLevelWeightList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLevelWeightList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLevelWeightList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LevelsInWeightStringContext levelsInWeightString() {
		LevelsInWeightStringContext _localctx = new LevelsInWeightStringContext(Context, State);
		EnterRule(_localctx, 580, RULE_levelsInWeightString);
		int _la;
		try {
			State = 5904;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,870,Context) ) {
			case 1:
				_localctx = new LevelWeightListContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 5890; Match(LEVEL);
				State = 5891; levelInWeightListElement();
				State = 5896;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 5892; Match(COMMA);
					State = 5893; levelInWeightListElement();
					}
					}
					State = 5898;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 2:
				_localctx = new LevelWeightRangeContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 5899; Match(LEVEL);
				State = 5900; ((LevelWeightRangeContext)_localctx).firstLevel = decimalLiteral();
				State = 5901; Match(MINUS);
				State = 5902; ((LevelWeightRangeContext)_localctx).lastLevel = decimalLiteral();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LevelInWeightListElementContext : ParserRuleContext {
		public IToken orderType;
		public DecimalLiteralContext decimalLiteral() {
			return GetRuleContext<DecimalLiteralContext>(0);
		}
		public ITerminalNode ASC() { return GetToken(MySqlParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(MySqlParser.DESC, 0); }
		public ITerminalNode REVERSE() { return GetToken(MySqlParser.REVERSE, 0); }
		public LevelInWeightListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_levelInWeightListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLevelInWeightListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLevelInWeightListElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLevelInWeightListElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LevelInWeightListElementContext levelInWeightListElement() {
		LevelInWeightListElementContext _localctx = new LevelInWeightListElementContext(Context, State);
		EnterRule(_localctx, 582, RULE_levelInWeightListElement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5906; decimalLiteral();
			State = 5908;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASC || _la==DESC || _la==REVERSE) {
				{
				State = 5907;
				_localctx.orderType = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==ASC || _la==DESC || _la==REVERSE) ) {
					_localctx.orderType = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AggregateWindowedFunctionContext : ParserRuleContext {
		public IToken aggregator;
		public IToken starArg;
		public IToken separator;
		public FunctionArgContext functionArg() {
			return GetRuleContext<FunctionArgContext>(0);
		}
		public ITerminalNode AVG() { return GetToken(MySqlParser.AVG, 0); }
		public ITerminalNode MAX() { return GetToken(MySqlParser.MAX, 0); }
		public ITerminalNode MIN() { return GetToken(MySqlParser.MIN, 0); }
		public ITerminalNode SUM() { return GetToken(MySqlParser.SUM, 0); }
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(MySqlParser.DISTINCT, 0); }
		public ITerminalNode COUNT() { return GetToken(MySqlParser.COUNT, 0); }
		public FunctionArgsContext functionArgs() {
			return GetRuleContext<FunctionArgsContext>(0);
		}
		public ITerminalNode BIT_AND() { return GetToken(MySqlParser.BIT_AND, 0); }
		public ITerminalNode BIT_OR() { return GetToken(MySqlParser.BIT_OR, 0); }
		public ITerminalNode BIT_XOR() { return GetToken(MySqlParser.BIT_XOR, 0); }
		public ITerminalNode STD() { return GetToken(MySqlParser.STD, 0); }
		public ITerminalNode STDDEV() { return GetToken(MySqlParser.STDDEV, 0); }
		public ITerminalNode STDDEV_POP() { return GetToken(MySqlParser.STDDEV_POP, 0); }
		public ITerminalNode STDDEV_SAMP() { return GetToken(MySqlParser.STDDEV_SAMP, 0); }
		public ITerminalNode VAR_POP() { return GetToken(MySqlParser.VAR_POP, 0); }
		public ITerminalNode VAR_SAMP() { return GetToken(MySqlParser.VAR_SAMP, 0); }
		public ITerminalNode VARIANCE() { return GetToken(MySqlParser.VARIANCE, 0); }
		public ITerminalNode GROUP_CONCAT() { return GetToken(MySqlParser.GROUP_CONCAT, 0); }
		public ITerminalNode ORDER() { return GetToken(MySqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(MySqlParser.BY, 0); }
		public OrderByExpressionContext[] orderByExpression() {
			return GetRuleContexts<OrderByExpressionContext>();
		}
		public OrderByExpressionContext orderByExpression(int i) {
			return GetRuleContext<OrderByExpressionContext>(i);
		}
		public ITerminalNode SEPARATOR() { return GetToken(MySqlParser.SEPARATOR, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public AggregateWindowedFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aggregateWindowedFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterAggregateWindowedFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitAggregateWindowedFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAggregateWindowedFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AggregateWindowedFunctionContext aggregateWindowedFunction() {
		AggregateWindowedFunctionContext _localctx = new AggregateWindowedFunctionContext(Context, State);
		EnterRule(_localctx, 584, RULE_aggregateWindowedFunction);
		int _la;
		try {
			State = 5966;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,880,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5910;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 218)) & ~0x3f) == 0 && ((1L << (_la - 218)) & ((1L << (AVG - 218)) | (1L << (MAX - 218)) | (1L << (MIN - 218)) | (1L << (SUM - 218)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5911; Match(LR_BRACKET);
				State = 5913;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALL || _la==DISTINCT) {
					{
					State = 5912;
					_localctx.aggregator = TokenStream.LT(1);
					_la = TokenStream.LA(1);
					if ( !(_la==ALL || _la==DISTINCT) ) {
						_localctx.aggregator = ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 5915; functionArg();
				State = 5916; Match(RR_BRACKET);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5918; Match(COUNT);
				State = 5919; Match(LR_BRACKET);
				State = 5925;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case STAR:
					{
					State = 5920; _localctx.starArg = Match(STAR);
					}
					break;
				case ALL:
				case CASE:
				case CAST:
				case CONVERT:
				case CURRENT_USER:
				case DATABASE:
				case EXISTS:
				case FALSE:
				case IF:
				case INSERT:
				case INTERVAL:
				case LEFT:
				case NOT:
				case NULL_LITERAL:
				case REPLACE:
				case RIGHT:
				case TRUE:
				case VALUES:
				case DATE:
				case TIME:
				case TIMESTAMP:
				case DATETIME:
				case YEAR:
				case CHAR:
				case BINARY:
				case TEXT:
				case ENUM:
				case SERIAL:
				case AVG:
				case BIT_AND:
				case BIT_OR:
				case BIT_XOR:
				case COUNT:
				case GROUP_CONCAT:
				case MAX:
				case MIN:
				case STD:
				case STDDEV:
				case STDDEV_POP:
				case STDDEV_SAMP:
				case SUM:
				case VAR_POP:
				case VAR_SAMP:
				case VARIANCE:
				case CURRENT_DATE:
				case CURRENT_TIME:
				case CURRENT_TIMESTAMP:
				case LOCALTIME:
				case CURDATE:
				case CURTIME:
				case DATE_ADD:
				case DATE_SUB:
				case EXTRACT:
				case LOCALTIMESTAMP:
				case NOW:
				case POSITION:
				case SUBSTR:
				case SUBSTRING:
				case SYSDATE:
				case TRIM:
				case UTC_DATE:
				case UTC_TIME:
				case UTC_TIMESTAMP:
				case ACCOUNT:
				case ACTION:
				case AFTER:
				case AGGREGATE:
				case ALGORITHM:
				case ANY:
				case AT:
				case AUTHORS:
				case AUTOCOMMIT:
				case AUTOEXTEND_SIZE:
				case AUTO_INCREMENT:
				case AVG_ROW_LENGTH:
				case BEGIN:
				case BINLOG:
				case BIT:
				case BLOCK:
				case BOOL:
				case BOOLEAN:
				case BTREE:
				case CACHE:
				case CASCADED:
				case CHAIN:
				case CHANGED:
				case CHANNEL:
				case CHECKSUM:
				case PAGE_CHECKSUM:
				case CIPHER:
				case CLASS_ORIGIN:
				case CLIENT:
				case CLOSE:
				case COALESCE:
				case CODE:
				case COLUMNS:
				case COLUMN_FORMAT:
				case COLUMN_NAME:
				case COMMENT:
				case COMMIT:
				case COMPACT:
				case COMPLETION:
				case COMPRESSED:
				case COMPRESSION:
				case CONCURRENT:
				case CONNECTION:
				case CONSISTENT:
				case CONSTRAINT_CATALOG:
				case CONSTRAINT_SCHEMA:
				case CONSTRAINT_NAME:
				case CONTAINS:
				case CONTEXT:
				case CONTRIBUTORS:
				case COPY:
				case CPU:
				case DATA:
				case DATAFILE:
				case DEALLOCATE:
				case DEFAULT_AUTH:
				case DEFINER:
				case DELAY_KEY_WRITE:
				case DES_KEY_FILE:
				case DIRECTORY:
				case DISABLE:
				case DISCARD:
				case DISK:
				case DO:
				case DUMPFILE:
				case DUPLICATE:
				case DYNAMIC:
				case ENABLE:
				case ENCRYPTION:
				case END:
				case ENDS:
				case ENGINE:
				case ENGINES:
				case ERROR:
				case ERRORS:
				case ESCAPE:
				case EVEN:
				case EVENT:
				case EVENTS:
				case EVERY:
				case EXCHANGE:
				case EXCLUSIVE:
				case EXPIRE:
				case EXPORT:
				case EXTENDED:
				case EXTENT_SIZE:
				case FAST:
				case FAULTS:
				case FIELDS:
				case FILE_BLOCK_SIZE:
				case FILTER:
				case FIRST:
				case FIXED:
				case FLUSH:
				case FOLLOWS:
				case FOUND:
				case FULL:
				case FUNCTION:
				case GENERAL:
				case GLOBAL:
				case GRANTS:
				case GROUP_REPLICATION:
				case HANDLER:
				case HASH:
				case HELP:
				case HOST:
				case HOSTS:
				case IDENTIFIED:
				case IGNORE_SERVER_IDS:
				case IMPORT:
				case INDEXES:
				case INITIAL_SIZE:
				case INPLACE:
				case INSERT_METHOD:
				case INSTALL:
				case INSTANCE:
				case INVISIBLE:
				case INVOKER:
				case IO:
				case IO_THREAD:
				case IPC:
				case ISOLATION:
				case ISSUER:
				case JSON:
				case KEY_BLOCK_SIZE:
				case LANGUAGE:
				case LAST:
				case LEAVES:
				case LESS:
				case LEVEL:
				case LIST:
				case LOCAL:
				case LOGFILE:
				case LOGS:
				case MASTER:
				case MASTER_AUTO_POSITION:
				case MASTER_CONNECT_RETRY:
				case MASTER_DELAY:
				case MASTER_HEARTBEAT_PERIOD:
				case MASTER_HOST:
				case MASTER_LOG_FILE:
				case MASTER_LOG_POS:
				case MASTER_PASSWORD:
				case MASTER_PORT:
				case MASTER_RETRY_COUNT:
				case MASTER_SSL:
				case MASTER_SSL_CA:
				case MASTER_SSL_CAPATH:
				case MASTER_SSL_CERT:
				case MASTER_SSL_CIPHER:
				case MASTER_SSL_CRL:
				case MASTER_SSL_CRLPATH:
				case MASTER_SSL_KEY:
				case MASTER_TLS_VERSION:
				case MASTER_USER:
				case MAX_CONNECTIONS_PER_HOUR:
				case MAX_QUERIES_PER_HOUR:
				case MAX_ROWS:
				case MAX_SIZE:
				case MAX_UPDATES_PER_HOUR:
				case MAX_USER_CONNECTIONS:
				case MEDIUM:
				case MERGE:
				case MESSAGE_TEXT:
				case MID:
				case MIGRATE:
				case MIN_ROWS:
				case MODE:
				case MODIFY:
				case MUTEX:
				case MYSQL:
				case MYSQL_ERRNO:
				case NAME:
				case NAMES:
				case NCHAR:
				case NEVER:
				case NEXT:
				case NO:
				case NODEGROUP:
				case NONE:
				case OFFLINE:
				case OFFSET:
				case OJ:
				case OLD_PASSWORD:
				case ONE:
				case ONLINE:
				case ONLY:
				case OPEN:
				case OPTIMIZER_COSTS:
				case OPTIONS:
				case OWNER:
				case PACK_KEYS:
				case PAGE:
				case PARSER:
				case PARTIAL:
				case PARTITIONING:
				case PARTITIONS:
				case PASSWORD:
				case PHASE:
				case PLUGIN:
				case PLUGIN_DIR:
				case PLUGINS:
				case PORT:
				case PRECEDES:
				case PREPARE:
				case PRESERVE:
				case PREV:
				case PROCESSLIST:
				case PROFILE:
				case PROFILES:
				case PROXY:
				case QUERY:
				case QUICK:
				case REBUILD:
				case RECOVER:
				case REDO_BUFFER_SIZE:
				case REDUNDANT:
				case RELAY:
				case RELAY_LOG_FILE:
				case RELAY_LOG_POS:
				case RELAYLOG:
				case REMOVE:
				case REORGANIZE:
				case REPAIR:
				case REPLICATE_DO_DB:
				case REPLICATE_DO_TABLE:
				case REPLICATE_IGNORE_DB:
				case REPLICATE_IGNORE_TABLE:
				case REPLICATE_REWRITE_DB:
				case REPLICATE_WILD_DO_TABLE:
				case REPLICATE_WILD_IGNORE_TABLE:
				case REPLICATION:
				case RESET:
				case RESUME:
				case RETURNS:
				case ROLLBACK:
				case ROLLUP:
				case ROTATE:
				case ROW:
				case ROWS:
				case ROW_FORMAT:
				case SAVEPOINT:
				case SCHEDULE:
				case SECURITY:
				case SERVER:
				case SESSION:
				case SHARE:
				case SHARED:
				case SIGNED:
				case SIMPLE:
				case SLAVE:
				case SLOW:
				case SNAPSHOT:
				case SOCKET:
				case SOME:
				case SONAME:
				case SOUNDS:
				case SOURCE:
				case SQL_AFTER_GTIDS:
				case SQL_AFTER_MTS_GAPS:
				case SQL_BEFORE_GTIDS:
				case SQL_BUFFER_RESULT:
				case SQL_CACHE:
				case SQL_NO_CACHE:
				case SQL_THREAD:
				case START:
				case STARTS:
				case STATS_AUTO_RECALC:
				case STATS_PERSISTENT:
				case STATS_SAMPLE_PAGES:
				case STATUS:
				case STOP:
				case STORAGE:
				case STRING:
				case SUBCLASS_ORIGIN:
				case SUBJECT:
				case SUBPARTITION:
				case SUBPARTITIONS:
				case SUSPEND:
				case SWAPS:
				case SWITCHES:
				case TABLE_NAME:
				case TABLESPACE:
				case TEMPORARY:
				case TEMPTABLE:
				case THAN:
				case TRADITIONAL:
				case TRANSACTION:
				case TRIGGERS:
				case TRUNCATE:
				case UNDEFINED:
				case UNDOFILE:
				case UNDO_BUFFER_SIZE:
				case UNINSTALL:
				case UNKNOWN:
				case UNTIL:
				case UPGRADE:
				case USER:
				case USE_FRM:
				case USER_RESOURCES:
				case VALIDATION:
				case VALUE:
				case VARIABLES:
				case VIEW:
				case VISIBLE:
				case WAIT:
				case WARNINGS:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case X509:
				case XA:
				case XML:
				case INTERNAL:
				case QUARTER:
				case MONTH:
				case DAY:
				case HOUR:
				case MINUTE:
				case WEEK:
				case SECOND:
				case MICROSECOND:
				case TABLES:
				case ROUTINE:
				case EXECUTE:
				case FILE:
				case PROCESS:
				case RELOAD:
				case SHUTDOWN:
				case SUPER:
				case PRIVILEGES:
				case SESSION_VARIABLES_ADMIN:
				case ARMSCII8:
				case ASCII:
				case BIG5:
				case CP1250:
				case CP1251:
				case CP1256:
				case CP1257:
				case CP850:
				case CP852:
				case CP866:
				case CP932:
				case DEC8:
				case EUCJPMS:
				case EUCKR:
				case GB2312:
				case GBK:
				case GEOSTD8:
				case GREEK:
				case HEBREW:
				case HP8:
				case KEYBCS2:
				case KOI8R:
				case KOI8U:
				case LATIN1:
				case LATIN2:
				case LATIN5:
				case LATIN7:
				case MACCE:
				case MACROMAN:
				case SJIS:
				case SWE7:
				case TIS620:
				case UCS2:
				case UJIS:
				case UTF16:
				case UTF16LE:
				case UTF32:
				case UTF8:
				case UTF8MB3:
				case UTF8MB4:
				case ARCHIVE:
				case BLACKHOLE:
				case CSV:
				case FEDERATED:
				case INNODB:
				case MEMORY:
				case MRG_MYISAM:
				case MYISAM:
				case NDB:
				case NDBCLUSTER:
				case PERFORMANCE_SCHEMA:
				case TOKUDB:
				case REPEATABLE:
				case COMMITTED:
				case UNCOMMITTED:
				case SERIALIZABLE:
				case GEOMETRYCOLLECTION:
				case LINESTRING:
				case MULTILINESTRING:
				case MULTIPOINT:
				case MULTIPOLYGON:
				case POINT:
				case POLYGON:
				case ABS:
				case ACOS:
				case ADDDATE:
				case ADDTIME:
				case AES_DECRYPT:
				case AES_ENCRYPT:
				case AREA:
				case ASBINARY:
				case ASIN:
				case ASTEXT:
				case ASWKB:
				case ASWKT:
				case ASYMMETRIC_DECRYPT:
				case ASYMMETRIC_DERIVE:
				case ASYMMETRIC_ENCRYPT:
				case ASYMMETRIC_SIGN:
				case ASYMMETRIC_VERIFY:
				case ATAN:
				case ATAN2:
				case BENCHMARK:
				case BIN:
				case BIT_COUNT:
				case BIT_LENGTH:
				case BUFFER:
				case CATALOG_NAME:
				case CEIL:
				case CEILING:
				case CENTROID:
				case CHARACTER_LENGTH:
				case CHARSET:
				case CHAR_LENGTH:
				case COERCIBILITY:
				case COLLATION:
				case COMPRESS:
				case CONCAT:
				case CONCAT_WS:
				case CONNECTION_ID:
				case CONV:
				case CONVERT_TZ:
				case COS:
				case COT:
				case CRC32:
				case CREATE_ASYMMETRIC_PRIV_KEY:
				case CREATE_ASYMMETRIC_PUB_KEY:
				case CREATE_DH_PARAMETERS:
				case CREATE_DIGEST:
				case CROSSES:
				case DATEDIFF:
				case DATE_FORMAT:
				case DAYNAME:
				case DAYOFMONTH:
				case DAYOFWEEK:
				case DAYOFYEAR:
				case DECODE:
				case DEGREES:
				case DES_DECRYPT:
				case DES_ENCRYPT:
				case DIMENSION:
				case DISJOINT:
				case ELT:
				case ENCODE:
				case ENCRYPT:
				case ENDPOINT:
				case ENVELOPE:
				case EQUALS:
				case EXP:
				case EXPORT_SET:
				case EXTERIORRING:
				case EXTRACTVALUE:
				case FIELD:
				case FIND_IN_SET:
				case FLOOR:
				case FORMAT:
				case FOUND_ROWS:
				case FROM_BASE64:
				case FROM_DAYS:
				case FROM_UNIXTIME:
				case GEOMCOLLFROMTEXT:
				case GEOMCOLLFROMWKB:
				case GEOMETRYCOLLECTIONFROMTEXT:
				case GEOMETRYCOLLECTIONFROMWKB:
				case GEOMETRYFROMTEXT:
				case GEOMETRYFROMWKB:
				case GEOMETRYN:
				case GEOMETRYTYPE:
				case GEOMFROMTEXT:
				case GEOMFROMWKB:
				case GET_FORMAT:
				case GET_LOCK:
				case GLENGTH:
				case GREATEST:
				case GTID_SUBSET:
				case GTID_SUBTRACT:
				case HEX:
				case IFNULL:
				case INET6_ATON:
				case INET6_NTOA:
				case INET_ATON:
				case INET_NTOA:
				case INSTR:
				case INTERIORRINGN:
				case INTERSECTS:
				case ISCLOSED:
				case ISEMPTY:
				case ISNULL:
				case ISSIMPLE:
				case IS_FREE_LOCK:
				case IS_IPV4:
				case IS_IPV4_COMPAT:
				case IS_IPV4_MAPPED:
				case IS_IPV6:
				case IS_USED_LOCK:
				case LAST_INSERT_ID:
				case LCASE:
				case LEAST:
				case LENGTH:
				case LINEFROMTEXT:
				case LINEFROMWKB:
				case LINESTRINGFROMTEXT:
				case LINESTRINGFROMWKB:
				case LN:
				case LOAD_FILE:
				case LOCATE:
				case LOG:
				case LOG10:
				case LOG2:
				case LOWER:
				case LPAD:
				case LTRIM:
				case MAKEDATE:
				case MAKETIME:
				case MAKE_SET:
				case MASTER_POS_WAIT:
				case MBRCONTAINS:
				case MBRDISJOINT:
				case MBREQUAL:
				case MBRINTERSECTS:
				case MBROVERLAPS:
				case MBRTOUCHES:
				case MBRWITHIN:
				case MD5:
				case MLINEFROMTEXT:
				case MLINEFROMWKB:
				case MONTHNAME:
				case MPOINTFROMTEXT:
				case MPOINTFROMWKB:
				case MPOLYFROMTEXT:
				case MPOLYFROMWKB:
				case MULTILINESTRINGFROMTEXT:
				case MULTILINESTRINGFROMWKB:
				case MULTIPOINTFROMTEXT:
				case MULTIPOINTFROMWKB:
				case MULTIPOLYGONFROMTEXT:
				case MULTIPOLYGONFROMWKB:
				case NAME_CONST:
				case NULLIF:
				case NUMGEOMETRIES:
				case NUMINTERIORRINGS:
				case NUMPOINTS:
				case OCT:
				case OCTET_LENGTH:
				case ORD:
				case OVERLAPS:
				case PERIOD_ADD:
				case PERIOD_DIFF:
				case PI:
				case POINTFROMTEXT:
				case POINTFROMWKB:
				case POINTN:
				case POLYFROMTEXT:
				case POLYFROMWKB:
				case POLYGONFROMTEXT:
				case POLYGONFROMWKB:
				case POW:
				case POWER:
				case QUOTE:
				case RADIANS:
				case RAND:
				case RANDOM_BYTES:
				case RELEASE_LOCK:
				case REVERSE:
				case ROUND:
				case ROW_COUNT:
				case RPAD:
				case RTRIM:
				case SEC_TO_TIME:
				case SESSION_USER:
				case SHA:
				case SHA1:
				case SHA2:
				case SCHEMA_NAME:
				case SIGN:
				case SIN:
				case SLEEP:
				case SOUNDEX:
				case SQL_THREAD_WAIT_AFTER_GTIDS:
				case SQRT:
				case SRID:
				case STARTPOINT:
				case STRCMP:
				case STR_TO_DATE:
				case ST_AREA:
				case ST_ASBINARY:
				case ST_ASTEXT:
				case ST_ASWKB:
				case ST_ASWKT:
				case ST_BUFFER:
				case ST_CENTROID:
				case ST_CONTAINS:
				case ST_CROSSES:
				case ST_DIFFERENCE:
				case ST_DIMENSION:
				case ST_DISJOINT:
				case ST_DISTANCE:
				case ST_ENDPOINT:
				case ST_ENVELOPE:
				case ST_EQUALS:
				case ST_EXTERIORRING:
				case ST_GEOMCOLLFROMTEXT:
				case ST_GEOMCOLLFROMTXT:
				case ST_GEOMCOLLFROMWKB:
				case ST_GEOMETRYCOLLECTIONFROMTEXT:
				case ST_GEOMETRYCOLLECTIONFROMWKB:
				case ST_GEOMETRYFROMTEXT:
				case ST_GEOMETRYFROMWKB:
				case ST_GEOMETRYN:
				case ST_GEOMETRYTYPE:
				case ST_GEOMFROMTEXT:
				case ST_GEOMFROMWKB:
				case ST_INTERIORRINGN:
				case ST_INTERSECTION:
				case ST_INTERSECTS:
				case ST_ISCLOSED:
				case ST_ISEMPTY:
				case ST_ISSIMPLE:
				case ST_LINEFROMTEXT:
				case ST_LINEFROMWKB:
				case ST_LINESTRINGFROMTEXT:
				case ST_LINESTRINGFROMWKB:
				case ST_NUMGEOMETRIES:
				case ST_NUMINTERIORRING:
				case ST_NUMINTERIORRINGS:
				case ST_NUMPOINTS:
				case ST_OVERLAPS:
				case ST_POINTFROMTEXT:
				case ST_POINTFROMWKB:
				case ST_POINTN:
				case ST_POLYFROMTEXT:
				case ST_POLYFROMWKB:
				case ST_POLYGONFROMTEXT:
				case ST_POLYGONFROMWKB:
				case ST_SRID:
				case ST_STARTPOINT:
				case ST_SYMDIFFERENCE:
				case ST_TOUCHES:
				case ST_UNION:
				case ST_WITHIN:
				case ST_X:
				case ST_Y:
				case SUBDATE:
				case SUBSTRING_INDEX:
				case SUBTIME:
				case SYSTEM_USER:
				case TAN:
				case TIMEDIFF:
				case TIMESTAMPADD:
				case TIMESTAMPDIFF:
				case TIME_FORMAT:
				case TIME_TO_SEC:
				case TOUCHES:
				case TO_BASE64:
				case TO_DAYS:
				case TO_SECONDS:
				case UCASE:
				case UNCOMPRESS:
				case UNCOMPRESSED_LENGTH:
				case UNHEX:
				case UNIX_TIMESTAMP:
				case UPDATEXML:
				case UPPER:
				case UUID:
				case UUID_SHORT:
				case VALIDATE_PASSWORD_STRENGTH:
				case VERSION:
				case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
				case WEEKDAY:
				case WEEKOFYEAR:
				case WEIGHT_STRING:
				case WITHIN:
				case YEARWEEK:
				case Y_FUNCTION:
				case X_FUNCTION:
				case PLUS:
				case MINUS:
				case EXCLAMATION_SYMBOL:
				case BIT_NOT_OP:
				case LR_BRACKET:
				case ZERO_DECIMAL:
				case ONE_DECIMAL:
				case TWO_DECIMAL:
				case CHARSET_REVERSE_QOUTE_STRING:
				case START_NATIONAL_STRING_LITERAL:
				case STRING_LITERAL:
				case DECIMAL_LITERAL:
				case HEXADECIMAL_LITERAL:
				case REAL_LITERAL:
				case NULL_SPEC_LITERAL:
				case BIT_STRING:
				case STRING_CHARSET_NAME:
				case ID:
				case REVERSE_QUOTE_ID:
				case LOCAL_ID:
				case GLOBAL_ID:
					{
					State = 5922;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==ALL) {
						{
						State = 5921; _localctx.aggregator = Match(ALL);
						}
					}

					State = 5924; functionArg();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5927; Match(RR_BRACKET);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5928; Match(COUNT);
				State = 5929; Match(LR_BRACKET);
				State = 5930; _localctx.aggregator = Match(DISTINCT);
				State = 5931; functionArgs();
				State = 5932; Match(RR_BRACKET);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5934;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 219)) & ~0x3f) == 0 && ((1L << (_la - 219)) & ((1L << (BIT_AND - 219)) | (1L << (BIT_OR - 219)) | (1L << (BIT_XOR - 219)) | (1L << (STD - 219)) | (1L << (STDDEV - 219)) | (1L << (STDDEV_POP - 219)) | (1L << (STDDEV_SAMP - 219)) | (1L << (VAR_POP - 219)) | (1L << (VAR_SAMP - 219)) | (1L << (VARIANCE - 219)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 5935; Match(LR_BRACKET);
				State = 5937;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALL) {
					{
					State = 5936; _localctx.aggregator = Match(ALL);
					}
				}

				State = 5939; functionArg();
				State = 5940; Match(RR_BRACKET);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5942; Match(GROUP_CONCAT);
				State = 5943; Match(LR_BRACKET);
				State = 5945;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DISTINCT) {
					{
					State = 5944; _localctx.aggregator = Match(DISTINCT);
					}
				}

				State = 5947; functionArgs();
				State = 5958;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ORDER) {
					{
					State = 5948; Match(ORDER);
					State = 5949; Match(BY);
					State = 5950; orderByExpression();
					State = 5955;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 5951; Match(COMMA);
						State = 5952; orderByExpression();
						}
						}
						State = 5957;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 5962;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SEPARATOR) {
					{
					State = 5960; Match(SEPARATOR);
					State = 5961; _localctx.separator = Match(STRING_LITERAL);
					}
				}

				State = 5964; Match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScalarFunctionNameContext : ParserRuleContext {
		public FunctionNameBaseContext functionNameBase() {
			return GetRuleContext<FunctionNameBaseContext>(0);
		}
		public ITerminalNode ASCII() { return GetToken(MySqlParser.ASCII, 0); }
		public ITerminalNode CURDATE() { return GetToken(MySqlParser.CURDATE, 0); }
		public ITerminalNode CURRENT_DATE() { return GetToken(MySqlParser.CURRENT_DATE, 0); }
		public ITerminalNode CURRENT_TIME() { return GetToken(MySqlParser.CURRENT_TIME, 0); }
		public ITerminalNode CURRENT_TIMESTAMP() { return GetToken(MySqlParser.CURRENT_TIMESTAMP, 0); }
		public ITerminalNode CURTIME() { return GetToken(MySqlParser.CURTIME, 0); }
		public ITerminalNode DATE_ADD() { return GetToken(MySqlParser.DATE_ADD, 0); }
		public ITerminalNode DATE_SUB() { return GetToken(MySqlParser.DATE_SUB, 0); }
		public ITerminalNode IF() { return GetToken(MySqlParser.IF, 0); }
		public ITerminalNode INSERT() { return GetToken(MySqlParser.INSERT, 0); }
		public ITerminalNode LOCALTIME() { return GetToken(MySqlParser.LOCALTIME, 0); }
		public ITerminalNode LOCALTIMESTAMP() { return GetToken(MySqlParser.LOCALTIMESTAMP, 0); }
		public ITerminalNode MID() { return GetToken(MySqlParser.MID, 0); }
		public ITerminalNode NOW() { return GetToken(MySqlParser.NOW, 0); }
		public ITerminalNode REPLACE() { return GetToken(MySqlParser.REPLACE, 0); }
		public ITerminalNode SUBSTR() { return GetToken(MySqlParser.SUBSTR, 0); }
		public ITerminalNode SUBSTRING() { return GetToken(MySqlParser.SUBSTRING, 0); }
		public ITerminalNode SYSDATE() { return GetToken(MySqlParser.SYSDATE, 0); }
		public ITerminalNode TRIM() { return GetToken(MySqlParser.TRIM, 0); }
		public ITerminalNode UTC_DATE() { return GetToken(MySqlParser.UTC_DATE, 0); }
		public ITerminalNode UTC_TIME() { return GetToken(MySqlParser.UTC_TIME, 0); }
		public ITerminalNode UTC_TIMESTAMP() { return GetToken(MySqlParser.UTC_TIMESTAMP, 0); }
		public ScalarFunctionNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scalarFunctionName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterScalarFunctionName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitScalarFunctionName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScalarFunctionName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScalarFunctionNameContext scalarFunctionName() {
		ScalarFunctionNameContext _localctx = new ScalarFunctionNameContext(Context, State);
		EnterRule(_localctx, 586, RULE_scalarFunctionName);
		try {
			State = 5991;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DATABASE:
			case LEFT:
			case RIGHT:
			case DATE:
			case TIME:
			case TIMESTAMP:
			case YEAR:
			case COUNT:
			case POSITION:
			case INVISIBLE:
			case VISIBLE:
			case QUARTER:
			case MONTH:
			case DAY:
			case HOUR:
			case MINUTE:
			case WEEK:
			case SECOND:
			case MICROSECOND:
			case SESSION_VARIABLES_ADMIN:
			case GEOMETRYCOLLECTION:
			case LINESTRING:
			case MULTILINESTRING:
			case MULTIPOINT:
			case MULTIPOLYGON:
			case POINT:
			case POLYGON:
			case ABS:
			case ACOS:
			case ADDDATE:
			case ADDTIME:
			case AES_DECRYPT:
			case AES_ENCRYPT:
			case AREA:
			case ASBINARY:
			case ASIN:
			case ASTEXT:
			case ASWKB:
			case ASWKT:
			case ASYMMETRIC_DECRYPT:
			case ASYMMETRIC_DERIVE:
			case ASYMMETRIC_ENCRYPT:
			case ASYMMETRIC_SIGN:
			case ASYMMETRIC_VERIFY:
			case ATAN:
			case ATAN2:
			case BENCHMARK:
			case BIN:
			case BIT_COUNT:
			case BIT_LENGTH:
			case BUFFER:
			case CEIL:
			case CEILING:
			case CENTROID:
			case CHARACTER_LENGTH:
			case CHARSET:
			case CHAR_LENGTH:
			case COERCIBILITY:
			case COLLATION:
			case COMPRESS:
			case CONCAT:
			case CONCAT_WS:
			case CONNECTION_ID:
			case CONV:
			case CONVERT_TZ:
			case COS:
			case COT:
			case CRC32:
			case CREATE_ASYMMETRIC_PRIV_KEY:
			case CREATE_ASYMMETRIC_PUB_KEY:
			case CREATE_DH_PARAMETERS:
			case CREATE_DIGEST:
			case CROSSES:
			case DATEDIFF:
			case DATE_FORMAT:
			case DAYNAME:
			case DAYOFMONTH:
			case DAYOFWEEK:
			case DAYOFYEAR:
			case DECODE:
			case DEGREES:
			case DES_DECRYPT:
			case DES_ENCRYPT:
			case DIMENSION:
			case DISJOINT:
			case ELT:
			case ENCODE:
			case ENCRYPT:
			case ENDPOINT:
			case ENVELOPE:
			case EQUALS:
			case EXP:
			case EXPORT_SET:
			case EXTERIORRING:
			case EXTRACTVALUE:
			case FIELD:
			case FIND_IN_SET:
			case FLOOR:
			case FORMAT:
			case FOUND_ROWS:
			case FROM_BASE64:
			case FROM_DAYS:
			case FROM_UNIXTIME:
			case GEOMCOLLFROMTEXT:
			case GEOMCOLLFROMWKB:
			case GEOMETRYCOLLECTIONFROMTEXT:
			case GEOMETRYCOLLECTIONFROMWKB:
			case GEOMETRYFROMTEXT:
			case GEOMETRYFROMWKB:
			case GEOMETRYN:
			case GEOMETRYTYPE:
			case GEOMFROMTEXT:
			case GEOMFROMWKB:
			case GET_FORMAT:
			case GET_LOCK:
			case GLENGTH:
			case GREATEST:
			case GTID_SUBSET:
			case GTID_SUBTRACT:
			case HEX:
			case IFNULL:
			case INET6_ATON:
			case INET6_NTOA:
			case INET_ATON:
			case INET_NTOA:
			case INSTR:
			case INTERIORRINGN:
			case INTERSECTS:
			case ISCLOSED:
			case ISEMPTY:
			case ISNULL:
			case ISSIMPLE:
			case IS_FREE_LOCK:
			case IS_IPV4:
			case IS_IPV4_COMPAT:
			case IS_IPV4_MAPPED:
			case IS_IPV6:
			case IS_USED_LOCK:
			case LAST_INSERT_ID:
			case LCASE:
			case LEAST:
			case LENGTH:
			case LINEFROMTEXT:
			case LINEFROMWKB:
			case LINESTRINGFROMTEXT:
			case LINESTRINGFROMWKB:
			case LN:
			case LOAD_FILE:
			case LOCATE:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case LPAD:
			case LTRIM:
			case MAKEDATE:
			case MAKETIME:
			case MAKE_SET:
			case MASTER_POS_WAIT:
			case MBRCONTAINS:
			case MBRDISJOINT:
			case MBREQUAL:
			case MBRINTERSECTS:
			case MBROVERLAPS:
			case MBRTOUCHES:
			case MBRWITHIN:
			case MD5:
			case MLINEFROMTEXT:
			case MLINEFROMWKB:
			case MONTHNAME:
			case MPOINTFROMTEXT:
			case MPOINTFROMWKB:
			case MPOLYFROMTEXT:
			case MPOLYFROMWKB:
			case MULTILINESTRINGFROMTEXT:
			case MULTILINESTRINGFROMWKB:
			case MULTIPOINTFROMTEXT:
			case MULTIPOINTFROMWKB:
			case MULTIPOLYGONFROMTEXT:
			case MULTIPOLYGONFROMWKB:
			case NAME_CONST:
			case NULLIF:
			case NUMGEOMETRIES:
			case NUMINTERIORRINGS:
			case NUMPOINTS:
			case OCT:
			case OCTET_LENGTH:
			case ORD:
			case OVERLAPS:
			case PERIOD_ADD:
			case PERIOD_DIFF:
			case PI:
			case POINTFROMTEXT:
			case POINTFROMWKB:
			case POINTN:
			case POLYFROMTEXT:
			case POLYFROMWKB:
			case POLYGONFROMTEXT:
			case POLYGONFROMWKB:
			case POW:
			case POWER:
			case QUOTE:
			case RADIANS:
			case RAND:
			case RANDOM_BYTES:
			case RELEASE_LOCK:
			case REVERSE:
			case ROUND:
			case ROW_COUNT:
			case RPAD:
			case RTRIM:
			case SEC_TO_TIME:
			case SESSION_USER:
			case SHA:
			case SHA1:
			case SHA2:
			case SIGN:
			case SIN:
			case SLEEP:
			case SOUNDEX:
			case SQL_THREAD_WAIT_AFTER_GTIDS:
			case SQRT:
			case SRID:
			case STARTPOINT:
			case STRCMP:
			case STR_TO_DATE:
			case ST_AREA:
			case ST_ASBINARY:
			case ST_ASTEXT:
			case ST_ASWKB:
			case ST_ASWKT:
			case ST_BUFFER:
			case ST_CENTROID:
			case ST_CONTAINS:
			case ST_CROSSES:
			case ST_DIFFERENCE:
			case ST_DIMENSION:
			case ST_DISJOINT:
			case ST_DISTANCE:
			case ST_ENDPOINT:
			case ST_ENVELOPE:
			case ST_EQUALS:
			case ST_EXTERIORRING:
			case ST_GEOMCOLLFROMTEXT:
			case ST_GEOMCOLLFROMTXT:
			case ST_GEOMCOLLFROMWKB:
			case ST_GEOMETRYCOLLECTIONFROMTEXT:
			case ST_GEOMETRYCOLLECTIONFROMWKB:
			case ST_GEOMETRYFROMTEXT:
			case ST_GEOMETRYFROMWKB:
			case ST_GEOMETRYN:
			case ST_GEOMETRYTYPE:
			case ST_GEOMFROMTEXT:
			case ST_GEOMFROMWKB:
			case ST_INTERIORRINGN:
			case ST_INTERSECTION:
			case ST_INTERSECTS:
			case ST_ISCLOSED:
			case ST_ISEMPTY:
			case ST_ISSIMPLE:
			case ST_LINEFROMTEXT:
			case ST_LINEFROMWKB:
			case ST_LINESTRINGFROMTEXT:
			case ST_LINESTRINGFROMWKB:
			case ST_NUMGEOMETRIES:
			case ST_NUMINTERIORRING:
			case ST_NUMINTERIORRINGS:
			case ST_NUMPOINTS:
			case ST_OVERLAPS:
			case ST_POINTFROMTEXT:
			case ST_POINTFROMWKB:
			case ST_POINTN:
			case ST_POLYFROMTEXT:
			case ST_POLYFROMWKB:
			case ST_POLYGONFROMTEXT:
			case ST_POLYGONFROMWKB:
			case ST_SRID:
			case ST_STARTPOINT:
			case ST_SYMDIFFERENCE:
			case ST_TOUCHES:
			case ST_UNION:
			case ST_WITHIN:
			case ST_X:
			case ST_Y:
			case SUBDATE:
			case SUBSTRING_INDEX:
			case SUBTIME:
			case SYSTEM_USER:
			case TAN:
			case TIMEDIFF:
			case TIMESTAMPADD:
			case TIMESTAMPDIFF:
			case TIME_FORMAT:
			case TIME_TO_SEC:
			case TOUCHES:
			case TO_BASE64:
			case TO_DAYS:
			case TO_SECONDS:
			case UCASE:
			case UNCOMPRESS:
			case UNCOMPRESSED_LENGTH:
			case UNHEX:
			case UNIX_TIMESTAMP:
			case UPDATEXML:
			case UPPER:
			case UUID:
			case UUID_SHORT:
			case VALIDATE_PASSWORD_STRENGTH:
			case VERSION:
			case WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
			case WEEKDAY:
			case WEEKOFYEAR:
			case WEIGHT_STRING:
			case WITHIN:
			case YEARWEEK:
			case Y_FUNCTION:
			case X_FUNCTION:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5968; functionNameBase();
				}
				break;
			case ASCII:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5969; Match(ASCII);
				}
				break;
			case CURDATE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5970; Match(CURDATE);
				}
				break;
			case CURRENT_DATE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5971; Match(CURRENT_DATE);
				}
				break;
			case CURRENT_TIME:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5972; Match(CURRENT_TIME);
				}
				break;
			case CURRENT_TIMESTAMP:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5973; Match(CURRENT_TIMESTAMP);
				}
				break;
			case CURTIME:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5974; Match(CURTIME);
				}
				break;
			case DATE_ADD:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5975; Match(DATE_ADD);
				}
				break;
			case DATE_SUB:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5976; Match(DATE_SUB);
				}
				break;
			case IF:
				EnterOuterAlt(_localctx, 10);
				{
				State = 5977; Match(IF);
				}
				break;
			case INSERT:
				EnterOuterAlt(_localctx, 11);
				{
				State = 5978; Match(INSERT);
				}
				break;
			case LOCALTIME:
				EnterOuterAlt(_localctx, 12);
				{
				State = 5979; Match(LOCALTIME);
				}
				break;
			case LOCALTIMESTAMP:
				EnterOuterAlt(_localctx, 13);
				{
				State = 5980; Match(LOCALTIMESTAMP);
				}
				break;
			case MID:
				EnterOuterAlt(_localctx, 14);
				{
				State = 5981; Match(MID);
				}
				break;
			case NOW:
				EnterOuterAlt(_localctx, 15);
				{
				State = 5982; Match(NOW);
				}
				break;
			case REPLACE:
				EnterOuterAlt(_localctx, 16);
				{
				State = 5983; Match(REPLACE);
				}
				break;
			case SUBSTR:
				EnterOuterAlt(_localctx, 17);
				{
				State = 5984; Match(SUBSTR);
				}
				break;
			case SUBSTRING:
				EnterOuterAlt(_localctx, 18);
				{
				State = 5985; Match(SUBSTRING);
				}
				break;
			case SYSDATE:
				EnterOuterAlt(_localctx, 19);
				{
				State = 5986; Match(SYSDATE);
				}
				break;
			case TRIM:
				EnterOuterAlt(_localctx, 20);
				{
				State = 5987; Match(TRIM);
				}
				break;
			case UTC_DATE:
				EnterOuterAlt(_localctx, 21);
				{
				State = 5988; Match(UTC_DATE);
				}
				break;
			case UTC_TIME:
				EnterOuterAlt(_localctx, 22);
				{
				State = 5989; Match(UTC_TIME);
				}
				break;
			case UTC_TIMESTAMP:
				EnterOuterAlt(_localctx, 23);
				{
				State = 5990; Match(UTC_TIMESTAMP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PasswordFunctionClauseContext : ParserRuleContext {
		public IToken functionName;
		public FunctionArgContext functionArg() {
			return GetRuleContext<FunctionArgContext>(0);
		}
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode OLD_PASSWORD() { return GetToken(MySqlParser.OLD_PASSWORD, 0); }
		public PasswordFunctionClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_passwordFunctionClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPasswordFunctionClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPasswordFunctionClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPasswordFunctionClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PasswordFunctionClauseContext passwordFunctionClause() {
		PasswordFunctionClauseContext _localctx = new PasswordFunctionClauseContext(Context, State);
		EnterRule(_localctx, 588, RULE_passwordFunctionClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5993;
			_localctx.functionName = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==OLD_PASSWORD || _la==PASSWORD) ) {
				_localctx.functionName = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 5994; Match(LR_BRACKET);
			State = 5995; functionArg();
			State = 5996; Match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionArgsContext : ParserRuleContext {
		public ConstantContext[] constant() {
			return GetRuleContexts<ConstantContext>();
		}
		public ConstantContext constant(int i) {
			return GetRuleContext<ConstantContext>(i);
		}
		public FullColumnNameContext[] fullColumnName() {
			return GetRuleContexts<FullColumnNameContext>();
		}
		public FullColumnNameContext fullColumnName(int i) {
			return GetRuleContext<FullColumnNameContext>(i);
		}
		public FunctionCallContext[] functionCall() {
			return GetRuleContexts<FunctionCallContext>();
		}
		public FunctionCallContext functionCall(int i) {
			return GetRuleContext<FunctionCallContext>(i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public FunctionArgsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionArgs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFunctionArgs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFunctionArgs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionArgs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionArgsContext functionArgs() {
		FunctionArgsContext _localctx = new FunctionArgsContext(Context, State);
		EnterRule(_localctx, 590, RULE_functionArgs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6002;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,882,Context) ) {
			case 1:
				{
				State = 5998; constant();
				}
				break;
			case 2:
				{
				State = 5999; fullColumnName();
				}
				break;
			case 3:
				{
				State = 6000; functionCall();
				}
				break;
			case 4:
				{
				State = 6001; expression(0);
				}
				break;
			}
			State = 6013;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 6004; Match(COMMA);
				State = 6009;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,883,Context) ) {
				case 1:
					{
					State = 6005; constant();
					}
					break;
				case 2:
					{
					State = 6006; fullColumnName();
					}
					break;
				case 3:
					{
					State = 6007; functionCall();
					}
					break;
				case 4:
					{
					State = 6008; expression(0);
					}
					break;
				}
				}
				}
				State = 6015;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionArgContext : ParserRuleContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public FullColumnNameContext fullColumnName() {
			return GetRuleContext<FullColumnNameContext>(0);
		}
		public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public FunctionArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionArg; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFunctionArg(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFunctionArg(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionArgContext functionArg() {
		FunctionArgContext _localctx = new FunctionArgContext(Context, State);
		EnterRule(_localctx, 592, RULE_functionArg);
		try {
			State = 6020;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,885,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6016; constant();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6017; fullColumnName();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6018; functionCall();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 6019; expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IsExpressionContext : ExpressionContext {
		public IToken testValue;
		public PredicateContext predicate() {
			return GetRuleContext<PredicateContext>(0);
		}
		public ITerminalNode IS() { return GetToken(MySqlParser.IS, 0); }
		public ITerminalNode TRUE() { return GetToken(MySqlParser.TRUE, 0); }
		public ITerminalNode FALSE() { return GetToken(MySqlParser.FALSE, 0); }
		public ITerminalNode UNKNOWN() { return GetToken(MySqlParser.UNKNOWN, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public IsExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIsExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIsExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIsExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NotExpressionContext : ExpressionContext {
		public IToken notOperator;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public NotExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNotExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNotExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNotExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalExpressionContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public LogicalOperatorContext logicalOperator() {
			return GetRuleContext<LogicalOperatorContext>(0);
		}
		public LogicalExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLogicalExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLogicalExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PredicateExpressionContext : ExpressionContext {
		public PredicateContext predicate() {
			return GetRuleContext<PredicateContext>(0);
		}
		public PredicateExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPredicateExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPredicateExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPredicateExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(Context, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 594;
		EnterRecursionRule(_localctx, 594, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 6033;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,887,Context) ) {
			case 1:
				{
				_localctx = new NotExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 6023;
				((NotExpressionContext)_localctx).notOperator = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==NOT || _la==EXCLAMATION_SYMBOL) ) {
					((NotExpressionContext)_localctx).notOperator = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 6024; expression(4);
				}
				break;
			case 2:
				{
				_localctx = new IsExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6025; predicate(0);
				State = 6026; Match(IS);
				State = 6028;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 6027; Match(NOT);
					}
				}

				State = 6030;
				((IsExpressionContext)_localctx).testValue = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==FALSE || _la==TRUE || _la==UNKNOWN) ) {
					((IsExpressionContext)_localctx).testValue = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 3:
				{
				_localctx = new PredicateExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6032; predicate(0);
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 6041;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,888,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new LogicalExpressionContext(new ExpressionContext(_parentctx, _parentState));
					PushNewRecursionContext(_localctx, _startState, RULE_expression);
					State = 6035;
					if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
					State = 6036; logicalOperator();
					State = 6037; expression(4);
					}
					} 
				}
				State = 6043;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,888,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class PredicateContext : ParserRuleContext {
		public PredicateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predicate; } }
	 
		public PredicateContext() { }
		public virtual void CopyFrom(PredicateContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SoundsLikePredicateContext : PredicateContext {
		public PredicateContext[] predicate() {
			return GetRuleContexts<PredicateContext>();
		}
		public PredicateContext predicate(int i) {
			return GetRuleContext<PredicateContext>(i);
		}
		public ITerminalNode SOUNDS() { return GetToken(MySqlParser.SOUNDS, 0); }
		public ITerminalNode LIKE() { return GetToken(MySqlParser.LIKE, 0); }
		public SoundsLikePredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSoundsLikePredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSoundsLikePredicate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSoundsLikePredicate(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionAtomPredicateContext : PredicateContext {
		public ExpressionAtomContext expressionAtom() {
			return GetRuleContext<ExpressionAtomContext>(0);
		}
		public ITerminalNode LOCAL_ID() { return GetToken(MySqlParser.LOCAL_ID, 0); }
		public ITerminalNode VAR_ASSIGN() { return GetToken(MySqlParser.VAR_ASSIGN, 0); }
		public ExpressionAtomPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExpressionAtomPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExpressionAtomPredicate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionAtomPredicate(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class InPredicateContext : PredicateContext {
		public PredicateContext predicate() {
			return GetRuleContext<PredicateContext>(0);
		}
		public ITerminalNode IN() { return GetToken(MySqlParser.IN, 0); }
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ExpressionsContext expressions() {
			return GetRuleContext<ExpressionsContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public InPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterInPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitInPredicate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInPredicate(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SubqueryComparasionPredicateContext : PredicateContext {
		public IToken quantifier;
		public PredicateContext predicate() {
			return GetRuleContext<PredicateContext>(0);
		}
		public ComparisonOperatorContext comparisonOperator() {
			return GetRuleContext<ComparisonOperatorContext>(0);
		}
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(MySqlParser.ALL, 0); }
		public ITerminalNode ANY() { return GetToken(MySqlParser.ANY, 0); }
		public ITerminalNode SOME() { return GetToken(MySqlParser.SOME, 0); }
		public SubqueryComparasionPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubqueryComparasionPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubqueryComparasionPredicate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubqueryComparasionPredicate(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BetweenPredicateContext : PredicateContext {
		public PredicateContext[] predicate() {
			return GetRuleContexts<PredicateContext>();
		}
		public PredicateContext predicate(int i) {
			return GetRuleContext<PredicateContext>(i);
		}
		public ITerminalNode BETWEEN() { return GetToken(MySqlParser.BETWEEN, 0); }
		public ITerminalNode AND() { return GetToken(MySqlParser.AND, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public BetweenPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBetweenPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBetweenPredicate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBetweenPredicate(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BinaryComparasionPredicateContext : PredicateContext {
		public PredicateContext left;
		public PredicateContext right;
		public ComparisonOperatorContext comparisonOperator() {
			return GetRuleContext<ComparisonOperatorContext>(0);
		}
		public PredicateContext[] predicate() {
			return GetRuleContexts<PredicateContext>();
		}
		public PredicateContext predicate(int i) {
			return GetRuleContext<PredicateContext>(i);
		}
		public BinaryComparasionPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBinaryComparasionPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBinaryComparasionPredicate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBinaryComparasionPredicate(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IsNullPredicateContext : PredicateContext {
		public PredicateContext predicate() {
			return GetRuleContext<PredicateContext>(0);
		}
		public ITerminalNode IS() { return GetToken(MySqlParser.IS, 0); }
		public NullNotnullContext nullNotnull() {
			return GetRuleContext<NullNotnullContext>(0);
		}
		public IsNullPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIsNullPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIsNullPredicate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIsNullPredicate(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LikePredicateContext : PredicateContext {
		public PredicateContext[] predicate() {
			return GetRuleContexts<PredicateContext>();
		}
		public PredicateContext predicate(int i) {
			return GetRuleContext<PredicateContext>(i);
		}
		public ITerminalNode LIKE() { return GetToken(MySqlParser.LIKE, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public ITerminalNode ESCAPE() { return GetToken(MySqlParser.ESCAPE, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(MySqlParser.STRING_LITERAL, 0); }
		public LikePredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLikePredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLikePredicate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLikePredicate(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RegexpPredicateContext : PredicateContext {
		public IToken regex;
		public PredicateContext[] predicate() {
			return GetRuleContexts<PredicateContext>();
		}
		public PredicateContext predicate(int i) {
			return GetRuleContext<PredicateContext>(i);
		}
		public ITerminalNode REGEXP() { return GetToken(MySqlParser.REGEXP, 0); }
		public ITerminalNode RLIKE() { return GetToken(MySqlParser.RLIKE, 0); }
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public RegexpPredicateContext(PredicateContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterRegexpPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitRegexpPredicate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRegexpPredicate(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PredicateContext predicate() {
		return predicate(0);
	}

	private PredicateContext predicate(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		PredicateContext _localctx = new PredicateContext(Context, _parentState);
		PredicateContext _prevctx = _localctx;
		int _startState = 596;
		EnterRecursionRule(_localctx, 596, RULE_predicate, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			_localctx = new ExpressionAtomPredicateContext(_localctx);
			Context = _localctx;
			_prevctx = _localctx;

			State = 6047;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,889,Context) ) {
			case 1:
				{
				State = 6045; Match(LOCAL_ID);
				State = 6046; Match(VAR_ASSIGN);
				}
				break;
			}
			State = 6049; expressionAtom(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 6108;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,897,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 6106;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,896,Context) ) {
					case 1:
						{
						_localctx = new BinaryComparasionPredicateContext(new PredicateContext(_parentctx, _parentState));
						((BinaryComparasionPredicateContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6051;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 6052; comparisonOperator();
						State = 6053; ((BinaryComparasionPredicateContext)_localctx).right = predicate(8);
						}
						break;
					case 2:
						{
						_localctx = new BetweenPredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6055;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 6057;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 6056; Match(NOT);
							}
						}

						State = 6059; Match(BETWEEN);
						State = 6060; predicate(0);
						State = 6061; Match(AND);
						State = 6062; predicate(6);
						}
						break;
					case 3:
						{
						_localctx = new SoundsLikePredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6064;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 6065; Match(SOUNDS);
						State = 6066; Match(LIKE);
						State = 6067; predicate(5);
						}
						break;
					case 4:
						{
						_localctx = new RegexpPredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6068;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 6070;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 6069; Match(NOT);
							}
						}

						State = 6072;
						((RegexpPredicateContext)_localctx).regex = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==REGEXP || _la==RLIKE) ) {
							((RegexpPredicateContext)_localctx).regex = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 6073; predicate(3);
						}
						break;
					case 5:
						{
						_localctx = new InPredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6074;
						if (!(Precpred(Context, 9))) throw new FailedPredicateException(this, "Precpred(Context, 9)");
						State = 6076;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 6075; Match(NOT);
							}
						}

						State = 6078; Match(IN);
						State = 6079; Match(LR_BRACKET);
						State = 6082;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,893,Context) ) {
						case 1:
							{
							State = 6080; selectStatement();
							}
							break;
						case 2:
							{
							State = 6081; expressions();
							}
							break;
						}
						State = 6084; Match(RR_BRACKET);
						}
						break;
					case 6:
						{
						_localctx = new IsNullPredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6086;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 6087; Match(IS);
						State = 6088; nullNotnull();
						}
						break;
					case 7:
						{
						_localctx = new SubqueryComparasionPredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6089;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 6090; comparisonOperator();
						State = 6091;
						((SubqueryComparasionPredicateContext)_localctx).quantifier = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==ALL || _la==ANY || _la==SOME) ) {
							((SubqueryComparasionPredicateContext)_localctx).quantifier = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 6092; Match(LR_BRACKET);
						State = 6093; selectStatement();
						State = 6094; Match(RR_BRACKET);
						}
						break;
					case 8:
						{
						_localctx = new LikePredicateContext(new PredicateContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_predicate);
						State = 6096;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 6098;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 6097; Match(NOT);
							}
						}

						State = 6100; Match(LIKE);
						State = 6101; predicate(0);
						State = 6104;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,895,Context) ) {
						case 1:
							{
							State = 6102; Match(ESCAPE);
							State = 6103; Match(STRING_LITERAL);
							}
							break;
						}
						}
						break;
					}
					} 
				}
				State = 6110;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,897,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ExpressionAtomContext : ParserRuleContext {
		public ExpressionAtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionAtom; } }
	 
		public ExpressionAtomContext() { }
		public virtual void CopyFrom(ExpressionAtomContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class UnaryExpressionAtomContext : ExpressionAtomContext {
		public UnaryOperatorContext unaryOperator() {
			return GetRuleContext<UnaryOperatorContext>(0);
		}
		public ExpressionAtomContext expressionAtom() {
			return GetRuleContext<ExpressionAtomContext>(0);
		}
		public UnaryExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnaryExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnaryExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CollateExpressionAtomContext : ExpressionAtomContext {
		public ExpressionAtomContext expressionAtom() {
			return GetRuleContext<ExpressionAtomContext>(0);
		}
		public ITerminalNode COLLATE() { return GetToken(MySqlParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return GetRuleContext<CollationNameContext>(0);
		}
		public CollateExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCollateExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCollateExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollateExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SubqueryExpessionAtomContext : ExpressionAtomContext {
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public SubqueryExpessionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterSubqueryExpessionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitSubqueryExpessionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubqueryExpessionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MysqlVariableExpressionAtomContext : ExpressionAtomContext {
		public MysqlVariableContext mysqlVariable() {
			return GetRuleContext<MysqlVariableContext>(0);
		}
		public MysqlVariableExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMysqlVariableExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMysqlVariableExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMysqlVariableExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NestedExpressionAtomContext : ExpressionAtomContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public NestedExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNestedExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNestedExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNestedExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NestedRowExpressionAtomContext : ExpressionAtomContext {
		public ITerminalNode ROW() { return GetToken(MySqlParser.ROW, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public NestedRowExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterNestedRowExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitNestedRowExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNestedRowExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MathExpressionAtomContext : ExpressionAtomContext {
		public ExpressionAtomContext left;
		public ExpressionAtomContext right;
		public MathOperatorContext mathOperator() {
			return GetRuleContext<MathOperatorContext>(0);
		}
		public ExpressionAtomContext[] expressionAtom() {
			return GetRuleContexts<ExpressionAtomContext>();
		}
		public ExpressionAtomContext expressionAtom(int i) {
			return GetRuleContext<ExpressionAtomContext>(i);
		}
		public MathExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMathExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMathExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMathExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IntervalExpressionAtomContext : ExpressionAtomContext {
		public ITerminalNode INTERVAL() { return GetToken(MySqlParser.INTERVAL, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public IntervalTypeContext intervalType() {
			return GetRuleContext<IntervalTypeContext>(0);
		}
		public IntervalExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIntervalExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIntervalExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntervalExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExistsExpessionAtomContext : ExpressionAtomContext {
		public ITerminalNode EXISTS() { return GetToken(MySqlParser.EXISTS, 0); }
		public SelectStatementContext selectStatement() {
			return GetRuleContext<SelectStatementContext>(0);
		}
		public ExistsExpessionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterExistsExpessionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitExistsExpessionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExistsExpessionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConstantExpressionAtomContext : ExpressionAtomContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ConstantExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterConstantExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitConstantExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstantExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FunctionCallExpressionAtomContext : ExpressionAtomContext {
		public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public FunctionCallExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFunctionCallExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFunctionCallExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCallExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BinaryExpressionAtomContext : ExpressionAtomContext {
		public ITerminalNode BINARY() { return GetToken(MySqlParser.BINARY, 0); }
		public ExpressionAtomContext expressionAtom() {
			return GetRuleContext<ExpressionAtomContext>(0);
		}
		public BinaryExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBinaryExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBinaryExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBinaryExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FullColumnNameExpressionAtomContext : ExpressionAtomContext {
		public FullColumnNameContext fullColumnName() {
			return GetRuleContext<FullColumnNameContext>(0);
		}
		public FullColumnNameExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFullColumnNameExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFullColumnNameExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFullColumnNameExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BitExpressionAtomContext : ExpressionAtomContext {
		public ExpressionAtomContext left;
		public ExpressionAtomContext right;
		public BitOperatorContext bitOperator() {
			return GetRuleContext<BitOperatorContext>(0);
		}
		public ExpressionAtomContext[] expressionAtom() {
			return GetRuleContexts<ExpressionAtomContext>();
		}
		public ExpressionAtomContext expressionAtom(int i) {
			return GetRuleContext<ExpressionAtomContext>(i);
		}
		public BitExpressionAtomContext(ExpressionAtomContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBitExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBitExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionAtomContext expressionAtom() {
		return expressionAtom(0);
	}

	private ExpressionAtomContext expressionAtom(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionAtomContext _localctx = new ExpressionAtomContext(Context, _parentState);
		ExpressionAtomContext _prevctx = _localctx;
		int _startState = 598;
		EnterRecursionRule(_localctx, 598, RULE_expressionAtom, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 6156;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,900,Context) ) {
			case 1:
				{
				_localctx = new ConstantExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 6112; constant();
				}
				break;
			case 2:
				{
				_localctx = new FullColumnNameExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6113; fullColumnName();
				}
				break;
			case 3:
				{
				_localctx = new FunctionCallExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6114; functionCall();
				}
				break;
			case 4:
				{
				_localctx = new MysqlVariableExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6115; mysqlVariable();
				}
				break;
			case 5:
				{
				_localctx = new UnaryExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6116; unaryOperator();
				State = 6117; expressionAtom(9);
				}
				break;
			case 6:
				{
				_localctx = new BinaryExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6119; Match(BINARY);
				State = 6120; expressionAtom(8);
				}
				break;
			case 7:
				{
				_localctx = new NestedExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6121; Match(LR_BRACKET);
				State = 6122; expression(0);
				State = 6127;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 6123; Match(COMMA);
					State = 6124; expression(0);
					}
					}
					State = 6129;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 6130; Match(RR_BRACKET);
				}
				break;
			case 8:
				{
				_localctx = new NestedRowExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6132; Match(ROW);
				State = 6133; Match(LR_BRACKET);
				State = 6134; expression(0);
				State = 6137;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 6135; Match(COMMA);
					State = 6136; expression(0);
					}
					}
					State = 6139;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==COMMA );
				State = 6141; Match(RR_BRACKET);
				}
				break;
			case 9:
				{
				_localctx = new ExistsExpessionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6143; Match(EXISTS);
				State = 6144; Match(LR_BRACKET);
				State = 6145; selectStatement();
				State = 6146; Match(RR_BRACKET);
				}
				break;
			case 10:
				{
				_localctx = new SubqueryExpessionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6148; Match(LR_BRACKET);
				State = 6149; selectStatement();
				State = 6150; Match(RR_BRACKET);
				}
				break;
			case 11:
				{
				_localctx = new IntervalExpressionAtomContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 6152; Match(INTERVAL);
				State = 6153; expression(0);
				State = 6154; intervalType();
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 6171;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,902,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 6169;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,901,Context) ) {
					case 1:
						{
						_localctx = new BitExpressionAtomContext(new ExpressionAtomContext(_parentctx, _parentState));
						((BitExpressionAtomContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expressionAtom);
						State = 6158;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 6159; bitOperator();
						State = 6160; ((BitExpressionAtomContext)_localctx).right = expressionAtom(3);
						}
						break;
					case 2:
						{
						_localctx = new MathExpressionAtomContext(new ExpressionAtomContext(_parentctx, _parentState));
						((MathExpressionAtomContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expressionAtom);
						State = 6162;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 6163; mathOperator();
						State = 6164; ((MathExpressionAtomContext)_localctx).right = expressionAtom(2);
						}
						break;
					case 3:
						{
						_localctx = new CollateExpressionAtomContext(new ExpressionAtomContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expressionAtom);
						State = 6166;
						if (!(Precpred(Context, 11))) throw new FailedPredicateException(this, "Precpred(Context, 11)");
						State = 6167; Match(COLLATE);
						State = 6168; collationName();
						}
						break;
					}
					} 
				}
				State = 6173;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,902,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class UnaryOperatorContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(MySqlParser.NOT, 0); }
		public UnaryOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterUnaryOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitUnaryOperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryOperatorContext unaryOperator() {
		UnaryOperatorContext _localctx = new UnaryOperatorContext(Context, State);
		EnterRule(_localctx, 600, RULE_unaryOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6174;
			_la = TokenStream.LA(1);
			if ( !(_la==NOT || ((((_la - 960)) & ~0x3f) == 0 && ((1L << (_la - 960)) & ((1L << (PLUS - 960)) | (1L << (MINUS - 960)) | (1L << (EXCLAMATION_SYMBOL - 960)) | (1L << (BIT_NOT_OP - 960)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComparisonOperatorContext : ParserRuleContext {
		public ComparisonOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comparisonOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterComparisonOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitComparisonOperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComparisonOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ComparisonOperatorContext comparisonOperator() {
		ComparisonOperatorContext _localctx = new ComparisonOperatorContext(Context, State);
		EnterRule(_localctx, 602, RULE_comparisonOperator);
		try {
			State = 6190;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,903,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6176; Match(EQUAL_SYMBOL);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6177; Match(GREATER_SYMBOL);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6178; Match(LESS_SYMBOL);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 6179; Match(LESS_SYMBOL);
				State = 6180; Match(EQUAL_SYMBOL);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 6181; Match(GREATER_SYMBOL);
				State = 6182; Match(EQUAL_SYMBOL);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 6183; Match(LESS_SYMBOL);
				State = 6184; Match(GREATER_SYMBOL);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 6185; Match(EXCLAMATION_SYMBOL);
				State = 6186; Match(EQUAL_SYMBOL);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 6187; Match(LESS_SYMBOL);
				State = 6188; Match(EQUAL_SYMBOL);
				State = 6189; Match(GREATER_SYMBOL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicalOperatorContext : ParserRuleContext {
		public ITerminalNode AND() { return GetToken(MySqlParser.AND, 0); }
		public ITerminalNode XOR() { return GetToken(MySqlParser.XOR, 0); }
		public ITerminalNode OR() { return GetToken(MySqlParser.OR, 0); }
		public LogicalOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicalOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterLogicalOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitLogicalOperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicalOperatorContext logicalOperator() {
		LogicalOperatorContext _localctx = new LogicalOperatorContext(Context, State);
		EnterRule(_localctx, 604, RULE_logicalOperator);
		try {
			State = 6199;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AND:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6192; Match(AND);
				}
				break;
			case BIT_AND_OP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6193; Match(BIT_AND_OP);
				State = 6194; Match(BIT_AND_OP);
				}
				break;
			case XOR:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6195; Match(XOR);
				}
				break;
			case OR:
				EnterOuterAlt(_localctx, 4);
				{
				State = 6196; Match(OR);
				}
				break;
			case BIT_OR_OP:
				EnterOuterAlt(_localctx, 5);
				{
				State = 6197; Match(BIT_OR_OP);
				State = 6198; Match(BIT_OR_OP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitOperatorContext : ParserRuleContext {
		public BitOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterBitOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitBitOperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BitOperatorContext bitOperator() {
		BitOperatorContext _localctx = new BitOperatorContext(Context, State);
		EnterRule(_localctx, 606, RULE_bitOperator);
		try {
			State = 6208;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LESS_SYMBOL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 6201; Match(LESS_SYMBOL);
				State = 6202; Match(LESS_SYMBOL);
				}
				break;
			case GREATER_SYMBOL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 6203; Match(GREATER_SYMBOL);
				State = 6204; Match(GREATER_SYMBOL);
				}
				break;
			case BIT_AND_OP:
				EnterOuterAlt(_localctx, 3);
				{
				State = 6205; Match(BIT_AND_OP);
				}
				break;
			case BIT_XOR_OP:
				EnterOuterAlt(_localctx, 4);
				{
				State = 6206; Match(BIT_XOR_OP);
				}
				break;
			case BIT_OR_OP:
				EnterOuterAlt(_localctx, 5);
				{
				State = 6207; Match(BIT_OR_OP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MathOperatorContext : ParserRuleContext {
		public ITerminalNode DIV() { return GetToken(MySqlParser.DIV, 0); }
		public ITerminalNode MOD() { return GetToken(MySqlParser.MOD, 0); }
		public MathOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mathOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterMathOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitMathOperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMathOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MathOperatorContext mathOperator() {
		MathOperatorContext _localctx = new MathOperatorContext(Context, State);
		EnterRule(_localctx, 608, RULE_mathOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6210;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 957)) & ~0x3f) == 0 && ((1L << (_la - 957)) & ((1L << (STAR - 957)) | (1L << (DIVIDE - 957)) | (1L << (MODULE - 957)) | (1L << (PLUS - 957)) | (1L << (MINUSMINUS - 957)) | (1L << (MINUS - 957)) | (1L << (DIV - 957)) | (1L << (MOD - 957)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CharsetNameBaseContext : ParserRuleContext {
		public ITerminalNode ARMSCII8() { return GetToken(MySqlParser.ARMSCII8, 0); }
		public ITerminalNode ASCII() { return GetToken(MySqlParser.ASCII, 0); }
		public ITerminalNode BIG5() { return GetToken(MySqlParser.BIG5, 0); }
		public ITerminalNode CP1250() { return GetToken(MySqlParser.CP1250, 0); }
		public ITerminalNode CP1251() { return GetToken(MySqlParser.CP1251, 0); }
		public ITerminalNode CP1256() { return GetToken(MySqlParser.CP1256, 0); }
		public ITerminalNode CP1257() { return GetToken(MySqlParser.CP1257, 0); }
		public ITerminalNode CP850() { return GetToken(MySqlParser.CP850, 0); }
		public ITerminalNode CP852() { return GetToken(MySqlParser.CP852, 0); }
		public ITerminalNode CP866() { return GetToken(MySqlParser.CP866, 0); }
		public ITerminalNode CP932() { return GetToken(MySqlParser.CP932, 0); }
		public ITerminalNode DEC8() { return GetToken(MySqlParser.DEC8, 0); }
		public ITerminalNode EUCJPMS() { return GetToken(MySqlParser.EUCJPMS, 0); }
		public ITerminalNode EUCKR() { return GetToken(MySqlParser.EUCKR, 0); }
		public ITerminalNode GB2312() { return GetToken(MySqlParser.GB2312, 0); }
		public ITerminalNode GBK() { return GetToken(MySqlParser.GBK, 0); }
		public ITerminalNode GEOSTD8() { return GetToken(MySqlParser.GEOSTD8, 0); }
		public ITerminalNode GREEK() { return GetToken(MySqlParser.GREEK, 0); }
		public ITerminalNode HEBREW() { return GetToken(MySqlParser.HEBREW, 0); }
		public ITerminalNode HP8() { return GetToken(MySqlParser.HP8, 0); }
		public ITerminalNode KEYBCS2() { return GetToken(MySqlParser.KEYBCS2, 0); }
		public ITerminalNode KOI8R() { return GetToken(MySqlParser.KOI8R, 0); }
		public ITerminalNode KOI8U() { return GetToken(MySqlParser.KOI8U, 0); }
		public ITerminalNode LATIN1() { return GetToken(MySqlParser.LATIN1, 0); }
		public ITerminalNode LATIN2() { return GetToken(MySqlParser.LATIN2, 0); }
		public ITerminalNode LATIN5() { return GetToken(MySqlParser.LATIN5, 0); }
		public ITerminalNode LATIN7() { return GetToken(MySqlParser.LATIN7, 0); }
		public ITerminalNode MACCE() { return GetToken(MySqlParser.MACCE, 0); }
		public ITerminalNode MACROMAN() { return GetToken(MySqlParser.MACROMAN, 0); }
		public ITerminalNode SJIS() { return GetToken(MySqlParser.SJIS, 0); }
		public ITerminalNode SWE7() { return GetToken(MySqlParser.SWE7, 0); }
		public ITerminalNode TIS620() { return GetToken(MySqlParser.TIS620, 0); }
		public ITerminalNode UCS2() { return GetToken(MySqlParser.UCS2, 0); }
		public ITerminalNode UJIS() { return GetToken(MySqlParser.UJIS, 0); }
		public ITerminalNode UTF16() { return GetToken(MySqlParser.UTF16, 0); }
		public ITerminalNode UTF16LE() { return GetToken(MySqlParser.UTF16LE, 0); }
		public ITerminalNode UTF32() { return GetToken(MySqlParser.UTF32, 0); }
		public ITerminalNode UTF8() { return GetToken(MySqlParser.UTF8, 0); }
		public ITerminalNode UTF8MB3() { return GetToken(MySqlParser.UTF8MB3, 0); }
		public ITerminalNode UTF8MB4() { return GetToken(MySqlParser.UTF8MB4, 0); }
		public CharsetNameBaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_charsetNameBase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterCharsetNameBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitCharsetNameBase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCharsetNameBase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CharsetNameBaseContext charsetNameBase() {
		CharsetNameBaseContext _localctx = new CharsetNameBaseContext(Context, State);
		EnterRule(_localctx, 610, RULE_charsetNameBase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6212;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 591)) & ~0x3f) == 0 && ((1L << (_la - 591)) & ((1L << (ARMSCII8 - 591)) | (1L << (ASCII - 591)) | (1L << (BIG5 - 591)) | (1L << (CP1250 - 591)) | (1L << (CP1251 - 591)) | (1L << (CP1256 - 591)) | (1L << (CP1257 - 591)) | (1L << (CP850 - 591)) | (1L << (CP852 - 591)) | (1L << (CP866 - 591)) | (1L << (CP932 - 591)) | (1L << (DEC8 - 591)) | (1L << (EUCJPMS - 591)) | (1L << (EUCKR - 591)) | (1L << (GB2312 - 591)) | (1L << (GBK - 591)) | (1L << (GEOSTD8 - 591)) | (1L << (GREEK - 591)) | (1L << (HEBREW - 591)) | (1L << (HP8 - 591)) | (1L << (KEYBCS2 - 591)) | (1L << (KOI8R - 591)) | (1L << (KOI8U - 591)) | (1L << (LATIN1 - 591)) | (1L << (LATIN2 - 591)) | (1L << (LATIN5 - 591)) | (1L << (LATIN7 - 591)) | (1L << (MACCE - 591)) | (1L << (MACROMAN - 591)) | (1L << (SJIS - 591)) | (1L << (SWE7 - 591)) | (1L << (TIS620 - 591)) | (1L << (UCS2 - 591)) | (1L << (UJIS - 591)) | (1L << (UTF16 - 591)) | (1L << (UTF16LE - 591)) | (1L << (UTF32 - 591)) | (1L << (UTF8 - 591)) | (1L << (UTF8MB3 - 591)) | (1L << (UTF8MB4 - 591)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TransactionLevelBaseContext : ParserRuleContext {
		public ITerminalNode REPEATABLE() { return GetToken(MySqlParser.REPEATABLE, 0); }
		public ITerminalNode COMMITTED() { return GetToken(MySqlParser.COMMITTED, 0); }
		public ITerminalNode UNCOMMITTED() { return GetToken(MySqlParser.UNCOMMITTED, 0); }
		public ITerminalNode SERIALIZABLE() { return GetToken(MySqlParser.SERIALIZABLE, 0); }
		public TransactionLevelBaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transactionLevelBase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterTransactionLevelBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitTransactionLevelBase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTransactionLevelBase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TransactionLevelBaseContext transactionLevelBase() {
		TransactionLevelBaseContext _localctx = new TransactionLevelBaseContext(Context, State);
		EnterRule(_localctx, 612, RULE_transactionLevelBase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6214;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 643)) & ~0x3f) == 0 && ((1L << (_la - 643)) & ((1L << (REPEATABLE - 643)) | (1L << (COMMITTED - 643)) | (1L << (UNCOMMITTED - 643)) | (1L << (SERIALIZABLE - 643)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrivilegesBaseContext : ParserRuleContext {
		public ITerminalNode TABLES() { return GetToken(MySqlParser.TABLES, 0); }
		public ITerminalNode ROUTINE() { return GetToken(MySqlParser.ROUTINE, 0); }
		public ITerminalNode EXECUTE() { return GetToken(MySqlParser.EXECUTE, 0); }
		public ITerminalNode FILE() { return GetToken(MySqlParser.FILE, 0); }
		public ITerminalNode PROCESS() { return GetToken(MySqlParser.PROCESS, 0); }
		public ITerminalNode RELOAD() { return GetToken(MySqlParser.RELOAD, 0); }
		public ITerminalNode SHUTDOWN() { return GetToken(MySqlParser.SHUTDOWN, 0); }
		public ITerminalNode SUPER() { return GetToken(MySqlParser.SUPER, 0); }
		public ITerminalNode PRIVILEGES() { return GetToken(MySqlParser.PRIVILEGES, 0); }
		public PrivilegesBaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_privilegesBase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterPrivilegesBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitPrivilegesBase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrivilegesBase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrivilegesBaseContext privilegesBase() {
		PrivilegesBaseContext _localctx = new PrivilegesBaseContext(Context, State);
		EnterRule(_localctx, 614, RULE_privilegesBase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6216;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 581)) & ~0x3f) == 0 && ((1L << (_la - 581)) & ((1L << (TABLES - 581)) | (1L << (ROUTINE - 581)) | (1L << (EXECUTE - 581)) | (1L << (FILE - 581)) | (1L << (PROCESS - 581)) | (1L << (RELOAD - 581)) | (1L << (SHUTDOWN - 581)) | (1L << (SUPER - 581)) | (1L << (PRIVILEGES - 581)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalTypeBaseContext : ParserRuleContext {
		public ITerminalNode QUARTER() { return GetToken(MySqlParser.QUARTER, 0); }
		public ITerminalNode MONTH() { return GetToken(MySqlParser.MONTH, 0); }
		public ITerminalNode DAY() { return GetToken(MySqlParser.DAY, 0); }
		public ITerminalNode HOUR() { return GetToken(MySqlParser.HOUR, 0); }
		public ITerminalNode MINUTE() { return GetToken(MySqlParser.MINUTE, 0); }
		public ITerminalNode WEEK() { return GetToken(MySqlParser.WEEK, 0); }
		public ITerminalNode SECOND() { return GetToken(MySqlParser.SECOND, 0); }
		public ITerminalNode MICROSECOND() { return GetToken(MySqlParser.MICROSECOND, 0); }
		public IntervalTypeBaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalTypeBase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterIntervalTypeBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitIntervalTypeBase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntervalTypeBase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntervalTypeBaseContext intervalTypeBase() {
		IntervalTypeBaseContext _localctx = new IntervalTypeBaseContext(Context, State);
		EnterRule(_localctx, 616, RULE_intervalTypeBase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6218;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 573)) & ~0x3f) == 0 && ((1L << (_la - 573)) & ((1L << (QUARTER - 573)) | (1L << (MONTH - 573)) | (1L << (DAY - 573)) | (1L << (HOUR - 573)) | (1L << (MINUTE - 573)) | (1L << (WEEK - 573)) | (1L << (SECOND - 573)) | (1L << (MICROSECOND - 573)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DataTypeBaseContext : ParserRuleContext {
		public ITerminalNode DATE() { return GetToken(MySqlParser.DATE, 0); }
		public ITerminalNode TIME() { return GetToken(MySqlParser.TIME, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(MySqlParser.TIMESTAMP, 0); }
		public ITerminalNode DATETIME() { return GetToken(MySqlParser.DATETIME, 0); }
		public ITerminalNode YEAR() { return GetToken(MySqlParser.YEAR, 0); }
		public ITerminalNode ENUM() { return GetToken(MySqlParser.ENUM, 0); }
		public ITerminalNode TEXT() { return GetToken(MySqlParser.TEXT, 0); }
		public DataTypeBaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dataTypeBase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterDataTypeBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitDataTypeBase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDataTypeBase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DataTypeBaseContext dataTypeBase() {
		DataTypeBaseContext _localctx = new DataTypeBaseContext(Context, State);
		EnterRule(_localctx, 618, RULE_dataTypeBase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6220;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (DATETIME - 185)) | (1L << (YEAR - 185)) | (1L << (TEXT - 185)) | (1L << (ENUM - 185)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordsCanBeIdContext : ParserRuleContext {
		public ITerminalNode ACCOUNT() { return GetToken(MySqlParser.ACCOUNT, 0); }
		public ITerminalNode ACTION() { return GetToken(MySqlParser.ACTION, 0); }
		public ITerminalNode AFTER() { return GetToken(MySqlParser.AFTER, 0); }
		public ITerminalNode AGGREGATE() { return GetToken(MySqlParser.AGGREGATE, 0); }
		public ITerminalNode ALGORITHM() { return GetToken(MySqlParser.ALGORITHM, 0); }
		public ITerminalNode ANY() { return GetToken(MySqlParser.ANY, 0); }
		public ITerminalNode AT() { return GetToken(MySqlParser.AT, 0); }
		public ITerminalNode AUTHORS() { return GetToken(MySqlParser.AUTHORS, 0); }
		public ITerminalNode AUTOCOMMIT() { return GetToken(MySqlParser.AUTOCOMMIT, 0); }
		public ITerminalNode AUTOEXTEND_SIZE() { return GetToken(MySqlParser.AUTOEXTEND_SIZE, 0); }
		public ITerminalNode AUTO_INCREMENT() { return GetToken(MySqlParser.AUTO_INCREMENT, 0); }
		public ITerminalNode AVG_ROW_LENGTH() { return GetToken(MySqlParser.AVG_ROW_LENGTH, 0); }
		public ITerminalNode BEGIN() { return GetToken(MySqlParser.BEGIN, 0); }
		public ITerminalNode BINLOG() { return GetToken(MySqlParser.BINLOG, 0); }
		public ITerminalNode BIT() { return GetToken(MySqlParser.BIT, 0); }
		public ITerminalNode BLOCK() { return GetToken(MySqlParser.BLOCK, 0); }
		public ITerminalNode BOOL() { return GetToken(MySqlParser.BOOL, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(MySqlParser.BOOLEAN, 0); }
		public ITerminalNode BTREE() { return GetToken(MySqlParser.BTREE, 0); }
		public ITerminalNode CACHE() { return GetToken(MySqlParser.CACHE, 0); }
		public ITerminalNode CASCADED() { return GetToken(MySqlParser.CASCADED, 0); }
		public ITerminalNode CHAIN() { return GetToken(MySqlParser.CHAIN, 0); }
		public ITerminalNode CHANGED() { return GetToken(MySqlParser.CHANGED, 0); }
		public ITerminalNode CHANNEL() { return GetToken(MySqlParser.CHANNEL, 0); }
		public ITerminalNode CHECKSUM() { return GetToken(MySqlParser.CHECKSUM, 0); }
		public ITerminalNode PAGE_CHECKSUM() { return GetToken(MySqlParser.PAGE_CHECKSUM, 0); }
		public ITerminalNode CATALOG_NAME() { return GetToken(MySqlParser.CATALOG_NAME, 0); }
		public ITerminalNode CIPHER() { return GetToken(MySqlParser.CIPHER, 0); }
		public ITerminalNode CLASS_ORIGIN() { return GetToken(MySqlParser.CLASS_ORIGIN, 0); }
		public ITerminalNode CLIENT() { return GetToken(MySqlParser.CLIENT, 0); }
		public ITerminalNode CLOSE() { return GetToken(MySqlParser.CLOSE, 0); }
		public ITerminalNode COALESCE() { return GetToken(MySqlParser.COALESCE, 0); }
		public ITerminalNode CODE() { return GetToken(MySqlParser.CODE, 0); }
		public ITerminalNode COLUMNS() { return GetToken(MySqlParser.COLUMNS, 0); }
		public ITerminalNode COLUMN_FORMAT() { return GetToken(MySqlParser.COLUMN_FORMAT, 0); }
		public ITerminalNode COLUMN_NAME() { return GetToken(MySqlParser.COLUMN_NAME, 0); }
		public ITerminalNode COMMENT() { return GetToken(MySqlParser.COMMENT, 0); }
		public ITerminalNode COMMIT() { return GetToken(MySqlParser.COMMIT, 0); }
		public ITerminalNode COMPACT() { return GetToken(MySqlParser.COMPACT, 0); }
		public ITerminalNode COMPLETION() { return GetToken(MySqlParser.COMPLETION, 0); }
		public ITerminalNode COMPRESSED() { return GetToken(MySqlParser.COMPRESSED, 0); }
		public ITerminalNode COMPRESSION() { return GetToken(MySqlParser.COMPRESSION, 0); }
		public ITerminalNode CONCURRENT() { return GetToken(MySqlParser.CONCURRENT, 0); }
		public ITerminalNode CONNECTION() { return GetToken(MySqlParser.CONNECTION, 0); }
		public ITerminalNode CONSISTENT() { return GetToken(MySqlParser.CONSISTENT, 0); }
		public ITerminalNode CONSTRAINT_CATALOG() { return GetToken(MySqlParser.CONSTRAINT_CATALOG, 0); }
		public ITerminalNode CONSTRAINT_NAME() { return GetToken(MySqlParser.CONSTRAINT_NAME, 0); }
		public ITerminalNode CONSTRAINT_SCHEMA() { return GetToken(MySqlParser.CONSTRAINT_SCHEMA, 0); }
		public ITerminalNode CONTAINS() { return GetToken(MySqlParser.CONTAINS, 0); }
		public ITerminalNode CONTEXT() { return GetToken(MySqlParser.CONTEXT, 0); }
		public ITerminalNode CONTRIBUTORS() { return GetToken(MySqlParser.CONTRIBUTORS, 0); }
		public ITerminalNode COPY() { return GetToken(MySqlParser.COPY, 0); }
		public ITerminalNode CPU() { return GetToken(MySqlParser.CPU, 0); }
		public ITerminalNode DATA() { return GetToken(MySqlParser.DATA, 0); }
		public ITerminalNode DATAFILE() { return GetToken(MySqlParser.DATAFILE, 0); }
		public ITerminalNode DEALLOCATE() { return GetToken(MySqlParser.DEALLOCATE, 0); }
		public ITerminalNode DEFAULT_AUTH() { return GetToken(MySqlParser.DEFAULT_AUTH, 0); }
		public ITerminalNode DEFINER() { return GetToken(MySqlParser.DEFINER, 0); }
		public ITerminalNode DELAY_KEY_WRITE() { return GetToken(MySqlParser.DELAY_KEY_WRITE, 0); }
		public ITerminalNode DES_KEY_FILE() { return GetToken(MySqlParser.DES_KEY_FILE, 0); }
		public ITerminalNode DIRECTORY() { return GetToken(MySqlParser.DIRECTORY, 0); }
		public ITerminalNode DISABLE() { return GetToken(MySqlParser.DISABLE, 0); }
		public ITerminalNode DISCARD() { return GetToken(MySqlParser.DISCARD, 0); }
		public ITerminalNode DISK() { return GetToken(MySqlParser.DISK, 0); }
		public ITerminalNode DO() { return GetToken(MySqlParser.DO, 0); }
		public ITerminalNode DUMPFILE() { return GetToken(MySqlParser.DUMPFILE, 0); }
		public ITerminalNode DUPLICATE() { return GetToken(MySqlParser.DUPLICATE, 0); }
		public ITerminalNode DYNAMIC() { return GetToken(MySqlParser.DYNAMIC, 0); }
		public ITerminalNode ENABLE() { return GetToken(MySqlParser.ENABLE, 0); }
		public ITerminalNode ENCRYPTION() { return GetToken(MySqlParser.ENCRYPTION, 0); }
		public ITerminalNode END() { return GetToken(MySqlParser.END, 0); }
		public ITerminalNode ENDS() { return GetToken(MySqlParser.ENDS, 0); }
		public ITerminalNode ENGINE() { return GetToken(MySqlParser.ENGINE, 0); }
		public ITerminalNode ENGINES() { return GetToken(MySqlParser.ENGINES, 0); }
		public ITerminalNode ERROR() { return GetToken(MySqlParser.ERROR, 0); }
		public ITerminalNode ERRORS() { return GetToken(MySqlParser.ERRORS, 0); }
		public ITerminalNode ESCAPE() { return GetToken(MySqlParser.ESCAPE, 0); }
		public ITerminalNode EVEN() { return GetToken(MySqlParser.EVEN, 0); }
		public ITerminalNode EVENT() { return GetToken(MySqlParser.EVENT, 0); }
		public ITerminalNode EVENTS() { return GetToken(MySqlParser.EVENTS, 0); }
		public ITerminalNode EVERY() { return GetToken(MySqlParser.EVERY, 0); }
		public ITerminalNode EXCHANGE() { return GetToken(MySqlParser.EXCHANGE, 0); }
		public ITerminalNode EXCLUSIVE() { return GetToken(MySqlParser.EXCLUSIVE, 0); }
		public ITerminalNode EXPIRE() { return GetToken(MySqlParser.EXPIRE, 0); }
		public ITerminalNode EXPORT() { return GetToken(MySqlParser.EXPORT, 0); }
		public ITerminalNode EXTENDED() { return GetToken(MySqlParser.EXTENDED, 0); }
		public ITerminalNode EXTENT_SIZE() { return GetToken(MySqlParser.EXTENT_SIZE, 0); }
		public ITerminalNode FAST() { return GetToken(MySqlParser.FAST, 0); }
		public ITerminalNode FAULTS() { return GetToken(MySqlParser.FAULTS, 0); }
		public ITerminalNode FIELDS() { return GetToken(MySqlParser.FIELDS, 0); }
		public ITerminalNode FILE_BLOCK_SIZE() { return GetToken(MySqlParser.FILE_BLOCK_SIZE, 0); }
		public ITerminalNode FILTER() { return GetToken(MySqlParser.FILTER, 0); }
		public ITerminalNode FIRST() { return GetToken(MySqlParser.FIRST, 0); }
		public ITerminalNode FIXED() { return GetToken(MySqlParser.FIXED, 0); }
		public ITerminalNode FLUSH() { return GetToken(MySqlParser.FLUSH, 0); }
		public ITerminalNode FOLLOWS() { return GetToken(MySqlParser.FOLLOWS, 0); }
		public ITerminalNode FOUND() { return GetToken(MySqlParser.FOUND, 0); }
		public ITerminalNode FULL() { return GetToken(MySqlParser.FULL, 0); }
		public ITerminalNode FUNCTION() { return GetToken(MySqlParser.FUNCTION, 0); }
		public ITerminalNode GENERAL() { return GetToken(MySqlParser.GENERAL, 0); }
		public ITerminalNode GLOBAL() { return GetToken(MySqlParser.GLOBAL, 0); }
		public ITerminalNode GRANTS() { return GetToken(MySqlParser.GRANTS, 0); }
		public ITerminalNode GROUP_REPLICATION() { return GetToken(MySqlParser.GROUP_REPLICATION, 0); }
		public ITerminalNode HANDLER() { return GetToken(MySqlParser.HANDLER, 0); }
		public ITerminalNode HASH() { return GetToken(MySqlParser.HASH, 0); }
		public ITerminalNode HELP() { return GetToken(MySqlParser.HELP, 0); }
		public ITerminalNode HOST() { return GetToken(MySqlParser.HOST, 0); }
		public ITerminalNode HOSTS() { return GetToken(MySqlParser.HOSTS, 0); }
		public ITerminalNode IDENTIFIED() { return GetToken(MySqlParser.IDENTIFIED, 0); }
		public ITerminalNode IGNORE_SERVER_IDS() { return GetToken(MySqlParser.IGNORE_SERVER_IDS, 0); }
		public ITerminalNode IMPORT() { return GetToken(MySqlParser.IMPORT, 0); }
		public ITerminalNode INDEXES() { return GetToken(MySqlParser.INDEXES, 0); }
		public ITerminalNode INITIAL_SIZE() { return GetToken(MySqlParser.INITIAL_SIZE, 0); }
		public ITerminalNode INPLACE() { return GetToken(MySqlParser.INPLACE, 0); }
		public ITerminalNode INSERT_METHOD() { return GetToken(MySqlParser.INSERT_METHOD, 0); }
		public ITerminalNode INSTALL() { return GetToken(MySqlParser.INSTALL, 0); }
		public ITerminalNode INSTANCE() { return GetToken(MySqlParser.INSTANCE, 0); }
		public ITerminalNode INTERNAL() { return GetToken(MySqlParser.INTERNAL, 0); }
		public ITerminalNode INVOKER() { return GetToken(MySqlParser.INVOKER, 0); }
		public ITerminalNode IO() { return GetToken(MySqlParser.IO, 0); }
		public ITerminalNode IO_THREAD() { return GetToken(MySqlParser.IO_THREAD, 0); }
		public ITerminalNode IPC() { return GetToken(MySqlParser.IPC, 0); }
		public ITerminalNode ISOLATION() { return GetToken(MySqlParser.ISOLATION, 0); }
		public ITerminalNode ISSUER() { return GetToken(MySqlParser.ISSUER, 0); }
		public ITerminalNode JSON() { return GetToken(MySqlParser.JSON, 0); }
		public ITerminalNode KEY_BLOCK_SIZE() { return GetToken(MySqlParser.KEY_BLOCK_SIZE, 0); }
		public ITerminalNode LANGUAGE() { return GetToken(MySqlParser.LANGUAGE, 0); }
		public ITerminalNode LAST() { return GetToken(MySqlParser.LAST, 0); }
		public ITerminalNode LEAVES() { return GetToken(MySqlParser.LEAVES, 0); }
		public ITerminalNode LESS() { return GetToken(MySqlParser.LESS, 0); }
		public ITerminalNode LEVEL() { return GetToken(MySqlParser.LEVEL, 0); }
		public ITerminalNode LIST() { return GetToken(MySqlParser.LIST, 0); }
		public ITerminalNode LOCAL() { return GetToken(MySqlParser.LOCAL, 0); }
		public ITerminalNode LOGFILE() { return GetToken(MySqlParser.LOGFILE, 0); }
		public ITerminalNode LOGS() { return GetToken(MySqlParser.LOGS, 0); }
		public ITerminalNode MASTER() { return GetToken(MySqlParser.MASTER, 0); }
		public ITerminalNode MASTER_AUTO_POSITION() { return GetToken(MySqlParser.MASTER_AUTO_POSITION, 0); }
		public ITerminalNode MASTER_CONNECT_RETRY() { return GetToken(MySqlParser.MASTER_CONNECT_RETRY, 0); }
		public ITerminalNode MASTER_DELAY() { return GetToken(MySqlParser.MASTER_DELAY, 0); }
		public ITerminalNode MASTER_HEARTBEAT_PERIOD() { return GetToken(MySqlParser.MASTER_HEARTBEAT_PERIOD, 0); }
		public ITerminalNode MASTER_HOST() { return GetToken(MySqlParser.MASTER_HOST, 0); }
		public ITerminalNode MASTER_LOG_FILE() { return GetToken(MySqlParser.MASTER_LOG_FILE, 0); }
		public ITerminalNode MASTER_LOG_POS() { return GetToken(MySqlParser.MASTER_LOG_POS, 0); }
		public ITerminalNode MASTER_PASSWORD() { return GetToken(MySqlParser.MASTER_PASSWORD, 0); }
		public ITerminalNode MASTER_PORT() { return GetToken(MySqlParser.MASTER_PORT, 0); }
		public ITerminalNode MASTER_RETRY_COUNT() { return GetToken(MySqlParser.MASTER_RETRY_COUNT, 0); }
		public ITerminalNode MASTER_SSL() { return GetToken(MySqlParser.MASTER_SSL, 0); }
		public ITerminalNode MASTER_SSL_CA() { return GetToken(MySqlParser.MASTER_SSL_CA, 0); }
		public ITerminalNode MASTER_SSL_CAPATH() { return GetToken(MySqlParser.MASTER_SSL_CAPATH, 0); }
		public ITerminalNode MASTER_SSL_CERT() { return GetToken(MySqlParser.MASTER_SSL_CERT, 0); }
		public ITerminalNode MASTER_SSL_CIPHER() { return GetToken(MySqlParser.MASTER_SSL_CIPHER, 0); }
		public ITerminalNode MASTER_SSL_CRL() { return GetToken(MySqlParser.MASTER_SSL_CRL, 0); }
		public ITerminalNode MASTER_SSL_CRLPATH() { return GetToken(MySqlParser.MASTER_SSL_CRLPATH, 0); }
		public ITerminalNode MASTER_SSL_KEY() { return GetToken(MySqlParser.MASTER_SSL_KEY, 0); }
		public ITerminalNode MASTER_TLS_VERSION() { return GetToken(MySqlParser.MASTER_TLS_VERSION, 0); }
		public ITerminalNode MASTER_USER() { return GetToken(MySqlParser.MASTER_USER, 0); }
		public ITerminalNode MAX_CONNECTIONS_PER_HOUR() { return GetToken(MySqlParser.MAX_CONNECTIONS_PER_HOUR, 0); }
		public ITerminalNode MAX_QUERIES_PER_HOUR() { return GetToken(MySqlParser.MAX_QUERIES_PER_HOUR, 0); }
		public ITerminalNode MAX_ROWS() { return GetToken(MySqlParser.MAX_ROWS, 0); }
		public ITerminalNode MAX_SIZE() { return GetToken(MySqlParser.MAX_SIZE, 0); }
		public ITerminalNode MAX_UPDATES_PER_HOUR() { return GetToken(MySqlParser.MAX_UPDATES_PER_HOUR, 0); }
		public ITerminalNode MAX_USER_CONNECTIONS() { return GetToken(MySqlParser.MAX_USER_CONNECTIONS, 0); }
		public ITerminalNode MEDIUM() { return GetToken(MySqlParser.MEDIUM, 0); }
		public ITerminalNode MEMORY() { return GetToken(MySqlParser.MEMORY, 0); }
		public ITerminalNode MERGE() { return GetToken(MySqlParser.MERGE, 0); }
		public ITerminalNode MESSAGE_TEXT() { return GetToken(MySqlParser.MESSAGE_TEXT, 0); }
		public ITerminalNode MID() { return GetToken(MySqlParser.MID, 0); }
		public ITerminalNode MIGRATE() { return GetToken(MySqlParser.MIGRATE, 0); }
		public ITerminalNode MIN_ROWS() { return GetToken(MySqlParser.MIN_ROWS, 0); }
		public ITerminalNode MODE() { return GetToken(MySqlParser.MODE, 0); }
		public ITerminalNode MODIFY() { return GetToken(MySqlParser.MODIFY, 0); }
		public ITerminalNode MUTEX() { return GetToken(MySqlParser.MUTEX, 0); }
		public ITerminalNode MYSQL() { return GetToken(MySqlParser.MYSQL, 0); }
		public ITerminalNode MYSQL_ERRNO() { return GetToken(MySqlParser.MYSQL_ERRNO, 0); }
		public ITerminalNode NAME() { return GetToken(MySqlParser.NAME, 0); }
		public ITerminalNode NAMES() { return GetToken(MySqlParser.NAMES, 0); }
		public ITerminalNode NCHAR() { return GetToken(MySqlParser.NCHAR, 0); }
		public ITerminalNode NEVER() { return GetToken(MySqlParser.NEVER, 0); }
		public ITerminalNode NEXT() { return GetToken(MySqlParser.NEXT, 0); }
		public ITerminalNode NO() { return GetToken(MySqlParser.NO, 0); }
		public ITerminalNode NODEGROUP() { return GetToken(MySqlParser.NODEGROUP, 0); }
		public ITerminalNode NONE() { return GetToken(MySqlParser.NONE, 0); }
		public ITerminalNode OFFLINE() { return GetToken(MySqlParser.OFFLINE, 0); }
		public ITerminalNode OFFSET() { return GetToken(MySqlParser.OFFSET, 0); }
		public ITerminalNode OJ() { return GetToken(MySqlParser.OJ, 0); }
		public ITerminalNode OLD_PASSWORD() { return GetToken(MySqlParser.OLD_PASSWORD, 0); }
		public ITerminalNode ONE() { return GetToken(MySqlParser.ONE, 0); }
		public ITerminalNode ONLINE() { return GetToken(MySqlParser.ONLINE, 0); }
		public ITerminalNode ONLY() { return GetToken(MySqlParser.ONLY, 0); }
		public ITerminalNode OPEN() { return GetToken(MySqlParser.OPEN, 0); }
		public ITerminalNode OPTIMIZER_COSTS() { return GetToken(MySqlParser.OPTIMIZER_COSTS, 0); }
		public ITerminalNode OPTIONS() { return GetToken(MySqlParser.OPTIONS, 0); }
		public ITerminalNode OWNER() { return GetToken(MySqlParser.OWNER, 0); }
		public ITerminalNode PACK_KEYS() { return GetToken(MySqlParser.PACK_KEYS, 0); }
		public ITerminalNode PAGE() { return GetToken(MySqlParser.PAGE, 0); }
		public ITerminalNode PARSER() { return GetToken(MySqlParser.PARSER, 0); }
		public ITerminalNode PARTIAL() { return GetToken(MySqlParser.PARTIAL, 0); }
		public ITerminalNode PARTITIONING() { return GetToken(MySqlParser.PARTITIONING, 0); }
		public ITerminalNode PARTITIONS() { return GetToken(MySqlParser.PARTITIONS, 0); }
		public ITerminalNode PASSWORD() { return GetToken(MySqlParser.PASSWORD, 0); }
		public ITerminalNode PHASE() { return GetToken(MySqlParser.PHASE, 0); }
		public ITerminalNode PLUGINS() { return GetToken(MySqlParser.PLUGINS, 0); }
		public ITerminalNode PLUGIN_DIR() { return GetToken(MySqlParser.PLUGIN_DIR, 0); }
		public ITerminalNode PLUGIN() { return GetToken(MySqlParser.PLUGIN, 0); }
		public ITerminalNode PORT() { return GetToken(MySqlParser.PORT, 0); }
		public ITerminalNode PRECEDES() { return GetToken(MySqlParser.PRECEDES, 0); }
		public ITerminalNode PREPARE() { return GetToken(MySqlParser.PREPARE, 0); }
		public ITerminalNode PRESERVE() { return GetToken(MySqlParser.PRESERVE, 0); }
		public ITerminalNode PREV() { return GetToken(MySqlParser.PREV, 0); }
		public ITerminalNode PROCESSLIST() { return GetToken(MySqlParser.PROCESSLIST, 0); }
		public ITerminalNode PROFILE() { return GetToken(MySqlParser.PROFILE, 0); }
		public ITerminalNode PROFILES() { return GetToken(MySqlParser.PROFILES, 0); }
		public ITerminalNode PROXY() { return GetToken(MySqlParser.PROXY, 0); }
		public ITerminalNode QUERY() { return GetToken(MySqlParser.QUERY, 0); }
		public ITerminalNode QUICK() { return GetToken(MySqlParser.QUICK, 0); }
		public ITerminalNode REBUILD() { return GetToken(MySqlParser.REBUILD, 0); }
		public ITerminalNode RECOVER() { return GetToken(MySqlParser.RECOVER, 0); }
		public ITerminalNode REDO_BUFFER_SIZE() { return GetToken(MySqlParser.REDO_BUFFER_SIZE, 0); }
		public ITerminalNode REDUNDANT() { return GetToken(MySqlParser.REDUNDANT, 0); }
		public ITerminalNode RELAY() { return GetToken(MySqlParser.RELAY, 0); }
		public ITerminalNode RELAYLOG() { return GetToken(MySqlParser.RELAYLOG, 0); }
		public ITerminalNode RELAY_LOG_FILE() { return GetToken(MySqlParser.RELAY_LOG_FILE, 0); }
		public ITerminalNode RELAY_LOG_POS() { return GetToken(MySqlParser.RELAY_LOG_POS, 0); }
		public ITerminalNode REMOVE() { return GetToken(MySqlParser.REMOVE, 0); }
		public ITerminalNode REORGANIZE() { return GetToken(MySqlParser.REORGANIZE, 0); }
		public ITerminalNode REPAIR() { return GetToken(MySqlParser.REPAIR, 0); }
		public ITerminalNode REPLICATE_DO_DB() { return GetToken(MySqlParser.REPLICATE_DO_DB, 0); }
		public ITerminalNode REPLICATE_DO_TABLE() { return GetToken(MySqlParser.REPLICATE_DO_TABLE, 0); }
		public ITerminalNode REPLICATE_IGNORE_DB() { return GetToken(MySqlParser.REPLICATE_IGNORE_DB, 0); }
		public ITerminalNode REPLICATE_IGNORE_TABLE() { return GetToken(MySqlParser.REPLICATE_IGNORE_TABLE, 0); }
		public ITerminalNode REPLICATE_REWRITE_DB() { return GetToken(MySqlParser.REPLICATE_REWRITE_DB, 0); }
		public ITerminalNode REPLICATE_WILD_DO_TABLE() { return GetToken(MySqlParser.REPLICATE_WILD_DO_TABLE, 0); }
		public ITerminalNode REPLICATE_WILD_IGNORE_TABLE() { return GetToken(MySqlParser.REPLICATE_WILD_IGNORE_TABLE, 0); }
		public ITerminalNode REPLICATION() { return GetToken(MySqlParser.REPLICATION, 0); }
		public ITerminalNode RESET() { return GetToken(MySqlParser.RESET, 0); }
		public ITerminalNode RESUME() { return GetToken(MySqlParser.RESUME, 0); }
		public ITerminalNode RETURNS() { return GetToken(MySqlParser.RETURNS, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(MySqlParser.ROLLBACK, 0); }
		public ITerminalNode ROLLUP() { return GetToken(MySqlParser.ROLLUP, 0); }
		public ITerminalNode ROTATE() { return GetToken(MySqlParser.ROTATE, 0); }
		public ITerminalNode ROW() { return GetToken(MySqlParser.ROW, 0); }
		public ITerminalNode ROWS() { return GetToken(MySqlParser.ROWS, 0); }
		public ITerminalNode ROW_FORMAT() { return GetToken(MySqlParser.ROW_FORMAT, 0); }
		public ITerminalNode SAVEPOINT() { return GetToken(MySqlParser.SAVEPOINT, 0); }
		public ITerminalNode SCHEDULE() { return GetToken(MySqlParser.SCHEDULE, 0); }
		public ITerminalNode SCHEMA_NAME() { return GetToken(MySqlParser.SCHEMA_NAME, 0); }
		public ITerminalNode SECURITY() { return GetToken(MySqlParser.SECURITY, 0); }
		public ITerminalNode SERIAL() { return GetToken(MySqlParser.SERIAL, 0); }
		public ITerminalNode SERVER() { return GetToken(MySqlParser.SERVER, 0); }
		public ITerminalNode SESSION() { return GetToken(MySqlParser.SESSION, 0); }
		public ITerminalNode SHARE() { return GetToken(MySqlParser.SHARE, 0); }
		public ITerminalNode SHARED() { return GetToken(MySqlParser.SHARED, 0); }
		public ITerminalNode SIGNED() { return GetToken(MySqlParser.SIGNED, 0); }
		public ITerminalNode SIMPLE() { return GetToken(MySqlParser.SIMPLE, 0); }
		public ITerminalNode SLAVE() { return GetToken(MySqlParser.SLAVE, 0); }
		public ITerminalNode SLOW() { return GetToken(MySqlParser.SLOW, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(MySqlParser.SNAPSHOT, 0); }
		public ITerminalNode SOCKET() { return GetToken(MySqlParser.SOCKET, 0); }
		public ITerminalNode SOME() { return GetToken(MySqlParser.SOME, 0); }
		public ITerminalNode SONAME() { return GetToken(MySqlParser.SONAME, 0); }
		public ITerminalNode SOUNDS() { return GetToken(MySqlParser.SOUNDS, 0); }
		public ITerminalNode SOURCE() { return GetToken(MySqlParser.SOURCE, 0); }
		public ITerminalNode SQL_AFTER_GTIDS() { return GetToken(MySqlParser.SQL_AFTER_GTIDS, 0); }
		public ITerminalNode SQL_AFTER_MTS_GAPS() { return GetToken(MySqlParser.SQL_AFTER_MTS_GAPS, 0); }
		public ITerminalNode SQL_BEFORE_GTIDS() { return GetToken(MySqlParser.SQL_BEFORE_GTIDS, 0); }
		public ITerminalNode SQL_BUFFER_RESULT() { return GetToken(MySqlParser.SQL_BUFFER_RESULT, 0); }
		public ITerminalNode SQL_CACHE() { return GetToken(MySqlParser.SQL_CACHE, 0); }
		public ITerminalNode SQL_NO_CACHE() { return GetToken(MySqlParser.SQL_NO_CACHE, 0); }
		public ITerminalNode SQL_THREAD() { return GetToken(MySqlParser.SQL_THREAD, 0); }
		public ITerminalNode START() { return GetToken(MySqlParser.START, 0); }
		public ITerminalNode STARTS() { return GetToken(MySqlParser.STARTS, 0); }
		public ITerminalNode STATS_AUTO_RECALC() { return GetToken(MySqlParser.STATS_AUTO_RECALC, 0); }
		public ITerminalNode STATS_PERSISTENT() { return GetToken(MySqlParser.STATS_PERSISTENT, 0); }
		public ITerminalNode STATS_SAMPLE_PAGES() { return GetToken(MySqlParser.STATS_SAMPLE_PAGES, 0); }
		public ITerminalNode STATUS() { return GetToken(MySqlParser.STATUS, 0); }
		public ITerminalNode STOP() { return GetToken(MySqlParser.STOP, 0); }
		public ITerminalNode STORAGE() { return GetToken(MySqlParser.STORAGE, 0); }
		public ITerminalNode STRING() { return GetToken(MySqlParser.STRING, 0); }
		public ITerminalNode SUBCLASS_ORIGIN() { return GetToken(MySqlParser.SUBCLASS_ORIGIN, 0); }
		public ITerminalNode SUBJECT() { return GetToken(MySqlParser.SUBJECT, 0); }
		public ITerminalNode SUBPARTITION() { return GetToken(MySqlParser.SUBPARTITION, 0); }
		public ITerminalNode SUBPARTITIONS() { return GetToken(MySqlParser.SUBPARTITIONS, 0); }
		public ITerminalNode SUSPEND() { return GetToken(MySqlParser.SUSPEND, 0); }
		public ITerminalNode SWAPS() { return GetToken(MySqlParser.SWAPS, 0); }
		public ITerminalNode SWITCHES() { return GetToken(MySqlParser.SWITCHES, 0); }
		public ITerminalNode TABLE_NAME() { return GetToken(MySqlParser.TABLE_NAME, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(MySqlParser.TABLESPACE, 0); }
		public ITerminalNode TEMPORARY() { return GetToken(MySqlParser.TEMPORARY, 0); }
		public ITerminalNode TEMPTABLE() { return GetToken(MySqlParser.TEMPTABLE, 0); }
		public ITerminalNode THAN() { return GetToken(MySqlParser.THAN, 0); }
		public ITerminalNode TRADITIONAL() { return GetToken(MySqlParser.TRADITIONAL, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(MySqlParser.TRANSACTION, 0); }
		public ITerminalNode TRIGGERS() { return GetToken(MySqlParser.TRIGGERS, 0); }
		public ITerminalNode TRUNCATE() { return GetToken(MySqlParser.TRUNCATE, 0); }
		public ITerminalNode UNDEFINED() { return GetToken(MySqlParser.UNDEFINED, 0); }
		public ITerminalNode UNDOFILE() { return GetToken(MySqlParser.UNDOFILE, 0); }
		public ITerminalNode UNDO_BUFFER_SIZE() { return GetToken(MySqlParser.UNDO_BUFFER_SIZE, 0); }
		public ITerminalNode UNINSTALL() { return GetToken(MySqlParser.UNINSTALL, 0); }
		public ITerminalNode UNKNOWN() { return GetToken(MySqlParser.UNKNOWN, 0); }
		public ITerminalNode UNTIL() { return GetToken(MySqlParser.UNTIL, 0); }
		public ITerminalNode UPGRADE() { return GetToken(MySqlParser.UPGRADE, 0); }
		public ITerminalNode USER() { return GetToken(MySqlParser.USER, 0); }
		public ITerminalNode USE_FRM() { return GetToken(MySqlParser.USE_FRM, 0); }
		public ITerminalNode USER_RESOURCES() { return GetToken(MySqlParser.USER_RESOURCES, 0); }
		public ITerminalNode VALIDATION() { return GetToken(MySqlParser.VALIDATION, 0); }
		public ITerminalNode VALUE() { return GetToken(MySqlParser.VALUE, 0); }
		public ITerminalNode VARIABLES() { return GetToken(MySqlParser.VARIABLES, 0); }
		public ITerminalNode VIEW() { return GetToken(MySqlParser.VIEW, 0); }
		public ITerminalNode WAIT() { return GetToken(MySqlParser.WAIT, 0); }
		public ITerminalNode WARNINGS() { return GetToken(MySqlParser.WARNINGS, 0); }
		public ITerminalNode WITHOUT() { return GetToken(MySqlParser.WITHOUT, 0); }
		public ITerminalNode WORK() { return GetToken(MySqlParser.WORK, 0); }
		public ITerminalNode WRAPPER() { return GetToken(MySqlParser.WRAPPER, 0); }
		public ITerminalNode X509() { return GetToken(MySqlParser.X509, 0); }
		public ITerminalNode XA() { return GetToken(MySqlParser.XA, 0); }
		public ITerminalNode XML() { return GetToken(MySqlParser.XML, 0); }
		public KeywordsCanBeIdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keywordsCanBeId; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterKeywordsCanBeId(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitKeywordsCanBeId(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeywordsCanBeId(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeywordsCanBeIdContext keywordsCanBeId() {
		KeywordsCanBeIdContext _localctx = new KeywordsCanBeIdContext(Context, State);
		EnterRule(_localctx, 620, RULE_keywordsCanBeId);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6222;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 206)) & ~0x3f) == 0 && ((1L << (_la - 206)) & ((1L << (SERIAL - 206)) | (1L << (ACCOUNT - 206)) | (1L << (ACTION - 206)) | (1L << (AFTER - 206)) | (1L << (AGGREGATE - 206)) | (1L << (ALGORITHM - 206)) | (1L << (ANY - 206)) | (1L << (AT - 206)) | (1L << (AUTHORS - 206)) | (1L << (AUTOCOMMIT - 206)) | (1L << (AUTOEXTEND_SIZE - 206)) | (1L << (AUTO_INCREMENT - 206)) | (1L << (AVG_ROW_LENGTH - 206)) | (1L << (BEGIN - 206)) | (1L << (BINLOG - 206)) | (1L << (BIT - 206)) | (1L << (BLOCK - 206)) | (1L << (BOOL - 206)))) != 0) || ((((_la - 270)) & ~0x3f) == 0 && ((1L << (_la - 270)) & ((1L << (BOOLEAN - 270)) | (1L << (BTREE - 270)) | (1L << (CACHE - 270)) | (1L << (CASCADED - 270)) | (1L << (CHAIN - 270)) | (1L << (CHANGED - 270)) | (1L << (CHANNEL - 270)) | (1L << (CHECKSUM - 270)) | (1L << (PAGE_CHECKSUM - 270)) | (1L << (CIPHER - 270)) | (1L << (CLASS_ORIGIN - 270)) | (1L << (CLIENT - 270)) | (1L << (CLOSE - 270)) | (1L << (COALESCE - 270)) | (1L << (CODE - 270)) | (1L << (COLUMNS - 270)) | (1L << (COLUMN_FORMAT - 270)) | (1L << (COLUMN_NAME - 270)) | (1L << (COMMENT - 270)) | (1L << (COMMIT - 270)) | (1L << (COMPACT - 270)) | (1L << (COMPLETION - 270)) | (1L << (COMPRESSED - 270)) | (1L << (COMPRESSION - 270)) | (1L << (CONCURRENT - 270)) | (1L << (CONNECTION - 270)) | (1L << (CONSISTENT - 270)) | (1L << (CONSTRAINT_CATALOG - 270)) | (1L << (CONSTRAINT_SCHEMA - 270)) | (1L << (CONSTRAINT_NAME - 270)) | (1L << (CONTAINS - 270)) | (1L << (CONTEXT - 270)) | (1L << (CONTRIBUTORS - 270)) | (1L << (COPY - 270)) | (1L << (CPU - 270)) | (1L << (DATA - 270)) | (1L << (DATAFILE - 270)) | (1L << (DEALLOCATE - 270)) | (1L << (DEFAULT_AUTH - 270)) | (1L << (DEFINER - 270)) | (1L << (DELAY_KEY_WRITE - 270)) | (1L << (DES_KEY_FILE - 270)) | (1L << (DIRECTORY - 270)) | (1L << (DISABLE - 270)) | (1L << (DISCARD - 270)) | (1L << (DISK - 270)) | (1L << (DO - 270)) | (1L << (DUMPFILE - 270)) | (1L << (DUPLICATE - 270)) | (1L << (DYNAMIC - 270)) | (1L << (ENABLE - 270)) | (1L << (ENCRYPTION - 270)) | (1L << (END - 270)) | (1L << (ENDS - 270)) | (1L << (ENGINE - 270)) | (1L << (ENGINES - 270)) | (1L << (ERROR - 270)) | (1L << (ERRORS - 270)) | (1L << (ESCAPE - 270)) | (1L << (EVEN - 270)) | (1L << (EVENT - 270)) | (1L << (EVENTS - 270)) | (1L << (EVERY - 270)) | (1L << (EXCHANGE - 270)))) != 0) || ((((_la - 334)) & ~0x3f) == 0 && ((1L << (_la - 334)) & ((1L << (EXCLUSIVE - 334)) | (1L << (EXPIRE - 334)) | (1L << (EXPORT - 334)) | (1L << (EXTENDED - 334)) | (1L << (EXTENT_SIZE - 334)) | (1L << (FAST - 334)) | (1L << (FAULTS - 334)) | (1L << (FIELDS - 334)) | (1L << (FILE_BLOCK_SIZE - 334)) | (1L << (FILTER - 334)) | (1L << (FIRST - 334)) | (1L << (FIXED - 334)) | (1L << (FLUSH - 334)) | (1L << (FOLLOWS - 334)) | (1L << (FOUND - 334)) | (1L << (FULL - 334)) | (1L << (FUNCTION - 334)) | (1L << (GENERAL - 334)) | (1L << (GLOBAL - 334)) | (1L << (GRANTS - 334)) | (1L << (GROUP_REPLICATION - 334)) | (1L << (HANDLER - 334)) | (1L << (HASH - 334)) | (1L << (HELP - 334)) | (1L << (HOST - 334)) | (1L << (HOSTS - 334)) | (1L << (IDENTIFIED - 334)) | (1L << (IGNORE_SERVER_IDS - 334)) | (1L << (IMPORT - 334)) | (1L << (INDEXES - 334)) | (1L << (INITIAL_SIZE - 334)) | (1L << (INPLACE - 334)) | (1L << (INSERT_METHOD - 334)) | (1L << (INSTALL - 334)) | (1L << (INSTANCE - 334)) | (1L << (INVOKER - 334)) | (1L << (IO - 334)) | (1L << (IO_THREAD - 334)) | (1L << (IPC - 334)) | (1L << (ISOLATION - 334)) | (1L << (ISSUER - 334)) | (1L << (JSON - 334)) | (1L << (KEY_BLOCK_SIZE - 334)) | (1L << (LANGUAGE - 334)) | (1L << (LAST - 334)) | (1L << (LEAVES - 334)) | (1L << (LESS - 334)) | (1L << (LEVEL - 334)) | (1L << (LIST - 334)) | (1L << (LOCAL - 334)) | (1L << (LOGFILE - 334)) | (1L << (LOGS - 334)) | (1L << (MASTER - 334)) | (1L << (MASTER_AUTO_POSITION - 334)) | (1L << (MASTER_CONNECT_RETRY - 334)) | (1L << (MASTER_DELAY - 334)) | (1L << (MASTER_HEARTBEAT_PERIOD - 334)) | (1L << (MASTER_HOST - 334)) | (1L << (MASTER_LOG_FILE - 334)) | (1L << (MASTER_LOG_POS - 334)) | (1L << (MASTER_PASSWORD - 334)) | (1L << (MASTER_PORT - 334)) | (1L << (MASTER_RETRY_COUNT - 334)))) != 0) || ((((_la - 398)) & ~0x3f) == 0 && ((1L << (_la - 398)) & ((1L << (MASTER_SSL - 398)) | (1L << (MASTER_SSL_CA - 398)) | (1L << (MASTER_SSL_CAPATH - 398)) | (1L << (MASTER_SSL_CERT - 398)) | (1L << (MASTER_SSL_CIPHER - 398)) | (1L << (MASTER_SSL_CRL - 398)) | (1L << (MASTER_SSL_CRLPATH - 398)) | (1L << (MASTER_SSL_KEY - 398)) | (1L << (MASTER_TLS_VERSION - 398)) | (1L << (MASTER_USER - 398)) | (1L << (MAX_CONNECTIONS_PER_HOUR - 398)) | (1L << (MAX_QUERIES_PER_HOUR - 398)) | (1L << (MAX_ROWS - 398)) | (1L << (MAX_SIZE - 398)) | (1L << (MAX_UPDATES_PER_HOUR - 398)) | (1L << (MAX_USER_CONNECTIONS - 398)) | (1L << (MEDIUM - 398)) | (1L << (MERGE - 398)) | (1L << (MESSAGE_TEXT - 398)) | (1L << (MID - 398)) | (1L << (MIGRATE - 398)) | (1L << (MIN_ROWS - 398)) | (1L << (MODE - 398)) | (1L << (MODIFY - 398)) | (1L << (MUTEX - 398)) | (1L << (MYSQL - 398)) | (1L << (MYSQL_ERRNO - 398)) | (1L << (NAME - 398)) | (1L << (NAMES - 398)) | (1L << (NCHAR - 398)) | (1L << (NEVER - 398)) | (1L << (NEXT - 398)) | (1L << (NO - 398)) | (1L << (NODEGROUP - 398)) | (1L << (NONE - 398)) | (1L << (OFFLINE - 398)) | (1L << (OFFSET - 398)) | (1L << (OJ - 398)) | (1L << (OLD_PASSWORD - 398)) | (1L << (ONE - 398)) | (1L << (ONLINE - 398)) | (1L << (ONLY - 398)) | (1L << (OPEN - 398)) | (1L << (OPTIMIZER_COSTS - 398)) | (1L << (OPTIONS - 398)) | (1L << (OWNER - 398)) | (1L << (PACK_KEYS - 398)) | (1L << (PAGE - 398)) | (1L << (PARSER - 398)) | (1L << (PARTIAL - 398)) | (1L << (PARTITIONING - 398)) | (1L << (PARTITIONS - 398)) | (1L << (PASSWORD - 398)) | (1L << (PHASE - 398)) | (1L << (PLUGIN - 398)) | (1L << (PLUGIN_DIR - 398)) | (1L << (PLUGINS - 398)) | (1L << (PORT - 398)) | (1L << (PRECEDES - 398)) | (1L << (PREPARE - 398)) | (1L << (PRESERVE - 398)) | (1L << (PREV - 398)) | (1L << (PROCESSLIST - 398)) | (1L << (PROFILE - 398)))) != 0) || ((((_la - 462)) & ~0x3f) == 0 && ((1L << (_la - 462)) & ((1L << (PROFILES - 462)) | (1L << (PROXY - 462)) | (1L << (QUERY - 462)) | (1L << (QUICK - 462)) | (1L << (REBUILD - 462)) | (1L << (RECOVER - 462)) | (1L << (REDO_BUFFER_SIZE - 462)) | (1L << (REDUNDANT - 462)) | (1L << (RELAY - 462)) | (1L << (RELAY_LOG_FILE - 462)) | (1L << (RELAY_LOG_POS - 462)) | (1L << (RELAYLOG - 462)) | (1L << (REMOVE - 462)) | (1L << (REORGANIZE - 462)) | (1L << (REPAIR - 462)) | (1L << (REPLICATE_DO_DB - 462)) | (1L << (REPLICATE_DO_TABLE - 462)) | (1L << (REPLICATE_IGNORE_DB - 462)) | (1L << (REPLICATE_IGNORE_TABLE - 462)) | (1L << (REPLICATE_REWRITE_DB - 462)) | (1L << (REPLICATE_WILD_DO_TABLE - 462)) | (1L << (REPLICATE_WILD_IGNORE_TABLE - 462)) | (1L << (REPLICATION - 462)) | (1L << (RESET - 462)) | (1L << (RESUME - 462)) | (1L << (RETURNS - 462)) | (1L << (ROLLBACK - 462)) | (1L << (ROLLUP - 462)) | (1L << (ROTATE - 462)) | (1L << (ROW - 462)) | (1L << (ROWS - 462)) | (1L << (ROW_FORMAT - 462)) | (1L << (SAVEPOINT - 462)) | (1L << (SCHEDULE - 462)) | (1L << (SECURITY - 462)) | (1L << (SERVER - 462)) | (1L << (SESSION - 462)) | (1L << (SHARE - 462)) | (1L << (SHARED - 462)) | (1L << (SIGNED - 462)) | (1L << (SIMPLE - 462)) | (1L << (SLAVE - 462)) | (1L << (SLOW - 462)) | (1L << (SNAPSHOT - 462)) | (1L << (SOCKET - 462)) | (1L << (SOME - 462)) | (1L << (SONAME - 462)) | (1L << (SOUNDS - 462)) | (1L << (SOURCE - 462)) | (1L << (SQL_AFTER_GTIDS - 462)) | (1L << (SQL_AFTER_MTS_GAPS - 462)) | (1L << (SQL_BEFORE_GTIDS - 462)) | (1L << (SQL_BUFFER_RESULT - 462)) | (1L << (SQL_CACHE - 462)) | (1L << (SQL_NO_CACHE - 462)) | (1L << (SQL_THREAD - 462)) | (1L << (START - 462)) | (1L << (STARTS - 462)) | (1L << (STATS_AUTO_RECALC - 462)) | (1L << (STATS_PERSISTENT - 462)) | (1L << (STATS_SAMPLE_PAGES - 462)) | (1L << (STATUS - 462)) | (1L << (STOP - 462)) | (1L << (STORAGE - 462)))) != 0) || ((((_la - 527)) & ~0x3f) == 0 && ((1L << (_la - 527)) & ((1L << (STRING - 527)) | (1L << (SUBCLASS_ORIGIN - 527)) | (1L << (SUBJECT - 527)) | (1L << (SUBPARTITION - 527)) | (1L << (SUBPARTITIONS - 527)) | (1L << (SUSPEND - 527)) | (1L << (SWAPS - 527)) | (1L << (SWITCHES - 527)) | (1L << (TABLE_NAME - 527)) | (1L << (TABLESPACE - 527)) | (1L << (TEMPORARY - 527)) | (1L << (TEMPTABLE - 527)) | (1L << (THAN - 527)) | (1L << (TRADITIONAL - 527)) | (1L << (TRANSACTION - 527)) | (1L << (TRIGGERS - 527)) | (1L << (TRUNCATE - 527)) | (1L << (UNDEFINED - 527)) | (1L << (UNDOFILE - 527)) | (1L << (UNDO_BUFFER_SIZE - 527)) | (1L << (UNINSTALL - 527)) | (1L << (UNKNOWN - 527)) | (1L << (UNTIL - 527)) | (1L << (UPGRADE - 527)) | (1L << (USER - 527)) | (1L << (USE_FRM - 527)) | (1L << (USER_RESOURCES - 527)) | (1L << (VALIDATION - 527)) | (1L << (VALUE - 527)) | (1L << (VARIABLES - 527)) | (1L << (VIEW - 527)) | (1L << (WAIT - 527)) | (1L << (WARNINGS - 527)) | (1L << (WITHOUT - 527)) | (1L << (WORK - 527)) | (1L << (WRAPPER - 527)) | (1L << (X509 - 527)) | (1L << (XA - 527)) | (1L << (XML - 527)) | (1L << (INTERNAL - 527)))) != 0) || _la==MEMORY || _la==CATALOG_NAME || _la==SCHEMA_NAME) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionNameBaseContext : ParserRuleContext {
		public ITerminalNode ABS() { return GetToken(MySqlParser.ABS, 0); }
		public ITerminalNode ACOS() { return GetToken(MySqlParser.ACOS, 0); }
		public ITerminalNode ADDDATE() { return GetToken(MySqlParser.ADDDATE, 0); }
		public ITerminalNode ADDTIME() { return GetToken(MySqlParser.ADDTIME, 0); }
		public ITerminalNode AES_DECRYPT() { return GetToken(MySqlParser.AES_DECRYPT, 0); }
		public ITerminalNode AES_ENCRYPT() { return GetToken(MySqlParser.AES_ENCRYPT, 0); }
		public ITerminalNode AREA() { return GetToken(MySqlParser.AREA, 0); }
		public ITerminalNode ASBINARY() { return GetToken(MySqlParser.ASBINARY, 0); }
		public ITerminalNode ASIN() { return GetToken(MySqlParser.ASIN, 0); }
		public ITerminalNode ASTEXT() { return GetToken(MySqlParser.ASTEXT, 0); }
		public ITerminalNode ASWKB() { return GetToken(MySqlParser.ASWKB, 0); }
		public ITerminalNode ASWKT() { return GetToken(MySqlParser.ASWKT, 0); }
		public ITerminalNode ASYMMETRIC_DECRYPT() { return GetToken(MySqlParser.ASYMMETRIC_DECRYPT, 0); }
		public ITerminalNode ASYMMETRIC_DERIVE() { return GetToken(MySqlParser.ASYMMETRIC_DERIVE, 0); }
		public ITerminalNode ASYMMETRIC_ENCRYPT() { return GetToken(MySqlParser.ASYMMETRIC_ENCRYPT, 0); }
		public ITerminalNode ASYMMETRIC_SIGN() { return GetToken(MySqlParser.ASYMMETRIC_SIGN, 0); }
		public ITerminalNode ASYMMETRIC_VERIFY() { return GetToken(MySqlParser.ASYMMETRIC_VERIFY, 0); }
		public ITerminalNode ATAN() { return GetToken(MySqlParser.ATAN, 0); }
		public ITerminalNode ATAN2() { return GetToken(MySqlParser.ATAN2, 0); }
		public ITerminalNode BENCHMARK() { return GetToken(MySqlParser.BENCHMARK, 0); }
		public ITerminalNode BIN() { return GetToken(MySqlParser.BIN, 0); }
		public ITerminalNode BIT_COUNT() { return GetToken(MySqlParser.BIT_COUNT, 0); }
		public ITerminalNode BIT_LENGTH() { return GetToken(MySqlParser.BIT_LENGTH, 0); }
		public ITerminalNode BUFFER() { return GetToken(MySqlParser.BUFFER, 0); }
		public ITerminalNode CEIL() { return GetToken(MySqlParser.CEIL, 0); }
		public ITerminalNode CEILING() { return GetToken(MySqlParser.CEILING, 0); }
		public ITerminalNode CENTROID() { return GetToken(MySqlParser.CENTROID, 0); }
		public ITerminalNode CHARACTER_LENGTH() { return GetToken(MySqlParser.CHARACTER_LENGTH, 0); }
		public ITerminalNode CHARSET() { return GetToken(MySqlParser.CHARSET, 0); }
		public ITerminalNode CHAR_LENGTH() { return GetToken(MySqlParser.CHAR_LENGTH, 0); }
		public ITerminalNode COERCIBILITY() { return GetToken(MySqlParser.COERCIBILITY, 0); }
		public ITerminalNode COLLATION() { return GetToken(MySqlParser.COLLATION, 0); }
		public ITerminalNode COMPRESS() { return GetToken(MySqlParser.COMPRESS, 0); }
		public ITerminalNode CONCAT() { return GetToken(MySqlParser.CONCAT, 0); }
		public ITerminalNode CONCAT_WS() { return GetToken(MySqlParser.CONCAT_WS, 0); }
		public ITerminalNode CONNECTION_ID() { return GetToken(MySqlParser.CONNECTION_ID, 0); }
		public ITerminalNode CONV() { return GetToken(MySqlParser.CONV, 0); }
		public ITerminalNode CONVERT_TZ() { return GetToken(MySqlParser.CONVERT_TZ, 0); }
		public ITerminalNode COS() { return GetToken(MySqlParser.COS, 0); }
		public ITerminalNode COT() { return GetToken(MySqlParser.COT, 0); }
		public ITerminalNode COUNT() { return GetToken(MySqlParser.COUNT, 0); }
		public ITerminalNode CRC32() { return GetToken(MySqlParser.CRC32, 0); }
		public ITerminalNode CREATE_ASYMMETRIC_PRIV_KEY() { return GetToken(MySqlParser.CREATE_ASYMMETRIC_PRIV_KEY, 0); }
		public ITerminalNode CREATE_ASYMMETRIC_PUB_KEY() { return GetToken(MySqlParser.CREATE_ASYMMETRIC_PUB_KEY, 0); }
		public ITerminalNode CREATE_DH_PARAMETERS() { return GetToken(MySqlParser.CREATE_DH_PARAMETERS, 0); }
		public ITerminalNode CREATE_DIGEST() { return GetToken(MySqlParser.CREATE_DIGEST, 0); }
		public ITerminalNode CROSSES() { return GetToken(MySqlParser.CROSSES, 0); }
		public ITerminalNode DATABASE() { return GetToken(MySqlParser.DATABASE, 0); }
		public ITerminalNode DATE() { return GetToken(MySqlParser.DATE, 0); }
		public ITerminalNode DATEDIFF() { return GetToken(MySqlParser.DATEDIFF, 0); }
		public ITerminalNode DATE_FORMAT() { return GetToken(MySqlParser.DATE_FORMAT, 0); }
		public ITerminalNode DAY() { return GetToken(MySqlParser.DAY, 0); }
		public ITerminalNode DAYNAME() { return GetToken(MySqlParser.DAYNAME, 0); }
		public ITerminalNode DAYOFMONTH() { return GetToken(MySqlParser.DAYOFMONTH, 0); }
		public ITerminalNode DAYOFWEEK() { return GetToken(MySqlParser.DAYOFWEEK, 0); }
		public ITerminalNode DAYOFYEAR() { return GetToken(MySqlParser.DAYOFYEAR, 0); }
		public ITerminalNode DECODE() { return GetToken(MySqlParser.DECODE, 0); }
		public ITerminalNode DEGREES() { return GetToken(MySqlParser.DEGREES, 0); }
		public ITerminalNode DES_DECRYPT() { return GetToken(MySqlParser.DES_DECRYPT, 0); }
		public ITerminalNode DES_ENCRYPT() { return GetToken(MySqlParser.DES_ENCRYPT, 0); }
		public ITerminalNode DIMENSION() { return GetToken(MySqlParser.DIMENSION, 0); }
		public ITerminalNode DISJOINT() { return GetToken(MySqlParser.DISJOINT, 0); }
		public ITerminalNode ELT() { return GetToken(MySqlParser.ELT, 0); }
		public ITerminalNode ENCODE() { return GetToken(MySqlParser.ENCODE, 0); }
		public ITerminalNode ENCRYPT() { return GetToken(MySqlParser.ENCRYPT, 0); }
		public ITerminalNode ENDPOINT() { return GetToken(MySqlParser.ENDPOINT, 0); }
		public ITerminalNode ENVELOPE() { return GetToken(MySqlParser.ENVELOPE, 0); }
		public ITerminalNode EQUALS() { return GetToken(MySqlParser.EQUALS, 0); }
		public ITerminalNode EXP() { return GetToken(MySqlParser.EXP, 0); }
		public ITerminalNode EXPORT_SET() { return GetToken(MySqlParser.EXPORT_SET, 0); }
		public ITerminalNode EXTERIORRING() { return GetToken(MySqlParser.EXTERIORRING, 0); }
		public ITerminalNode EXTRACTVALUE() { return GetToken(MySqlParser.EXTRACTVALUE, 0); }
		public ITerminalNode FIELD() { return GetToken(MySqlParser.FIELD, 0); }
		public ITerminalNode FIND_IN_SET() { return GetToken(MySqlParser.FIND_IN_SET, 0); }
		public ITerminalNode FLOOR() { return GetToken(MySqlParser.FLOOR, 0); }
		public ITerminalNode FORMAT() { return GetToken(MySqlParser.FORMAT, 0); }
		public ITerminalNode FOUND_ROWS() { return GetToken(MySqlParser.FOUND_ROWS, 0); }
		public ITerminalNode FROM_BASE64() { return GetToken(MySqlParser.FROM_BASE64, 0); }
		public ITerminalNode FROM_DAYS() { return GetToken(MySqlParser.FROM_DAYS, 0); }
		public ITerminalNode FROM_UNIXTIME() { return GetToken(MySqlParser.FROM_UNIXTIME, 0); }
		public ITerminalNode GEOMCOLLFROMTEXT() { return GetToken(MySqlParser.GEOMCOLLFROMTEXT, 0); }
		public ITerminalNode GEOMCOLLFROMWKB() { return GetToken(MySqlParser.GEOMCOLLFROMWKB, 0); }
		public ITerminalNode GEOMETRYCOLLECTION() { return GetToken(MySqlParser.GEOMETRYCOLLECTION, 0); }
		public ITerminalNode GEOMETRYCOLLECTIONFROMTEXT() { return GetToken(MySqlParser.GEOMETRYCOLLECTIONFROMTEXT, 0); }
		public ITerminalNode GEOMETRYCOLLECTIONFROMWKB() { return GetToken(MySqlParser.GEOMETRYCOLLECTIONFROMWKB, 0); }
		public ITerminalNode GEOMETRYFROMTEXT() { return GetToken(MySqlParser.GEOMETRYFROMTEXT, 0); }
		public ITerminalNode GEOMETRYFROMWKB() { return GetToken(MySqlParser.GEOMETRYFROMWKB, 0); }
		public ITerminalNode GEOMETRYN() { return GetToken(MySqlParser.GEOMETRYN, 0); }
		public ITerminalNode GEOMETRYTYPE() { return GetToken(MySqlParser.GEOMETRYTYPE, 0); }
		public ITerminalNode GEOMFROMTEXT() { return GetToken(MySqlParser.GEOMFROMTEXT, 0); }
		public ITerminalNode GEOMFROMWKB() { return GetToken(MySqlParser.GEOMFROMWKB, 0); }
		public ITerminalNode GET_FORMAT() { return GetToken(MySqlParser.GET_FORMAT, 0); }
		public ITerminalNode GET_LOCK() { return GetToken(MySqlParser.GET_LOCK, 0); }
		public ITerminalNode GLENGTH() { return GetToken(MySqlParser.GLENGTH, 0); }
		public ITerminalNode GREATEST() { return GetToken(MySqlParser.GREATEST, 0); }
		public ITerminalNode GTID_SUBSET() { return GetToken(MySqlParser.GTID_SUBSET, 0); }
		public ITerminalNode GTID_SUBTRACT() { return GetToken(MySqlParser.GTID_SUBTRACT, 0); }
		public ITerminalNode HEX() { return GetToken(MySqlParser.HEX, 0); }
		public ITerminalNode HOUR() { return GetToken(MySqlParser.HOUR, 0); }
		public ITerminalNode IFNULL() { return GetToken(MySqlParser.IFNULL, 0); }
		public ITerminalNode INET6_ATON() { return GetToken(MySqlParser.INET6_ATON, 0); }
		public ITerminalNode INET6_NTOA() { return GetToken(MySqlParser.INET6_NTOA, 0); }
		public ITerminalNode INET_ATON() { return GetToken(MySqlParser.INET_ATON, 0); }
		public ITerminalNode INET_NTOA() { return GetToken(MySqlParser.INET_NTOA, 0); }
		public ITerminalNode INSTR() { return GetToken(MySqlParser.INSTR, 0); }
		public ITerminalNode INTERIORRINGN() { return GetToken(MySqlParser.INTERIORRINGN, 0); }
		public ITerminalNode INTERSECTS() { return GetToken(MySqlParser.INTERSECTS, 0); }
		public ITerminalNode INVISIBLE() { return GetToken(MySqlParser.INVISIBLE, 0); }
		public ITerminalNode ISCLOSED() { return GetToken(MySqlParser.ISCLOSED, 0); }
		public ITerminalNode ISEMPTY() { return GetToken(MySqlParser.ISEMPTY, 0); }
		public ITerminalNode ISNULL() { return GetToken(MySqlParser.ISNULL, 0); }
		public ITerminalNode ISSIMPLE() { return GetToken(MySqlParser.ISSIMPLE, 0); }
		public ITerminalNode IS_FREE_LOCK() { return GetToken(MySqlParser.IS_FREE_LOCK, 0); }
		public ITerminalNode IS_IPV4() { return GetToken(MySqlParser.IS_IPV4, 0); }
		public ITerminalNode IS_IPV4_COMPAT() { return GetToken(MySqlParser.IS_IPV4_COMPAT, 0); }
		public ITerminalNode IS_IPV4_MAPPED() { return GetToken(MySqlParser.IS_IPV4_MAPPED, 0); }
		public ITerminalNode IS_IPV6() { return GetToken(MySqlParser.IS_IPV6, 0); }
		public ITerminalNode IS_USED_LOCK() { return GetToken(MySqlParser.IS_USED_LOCK, 0); }
		public ITerminalNode LAST_INSERT_ID() { return GetToken(MySqlParser.LAST_INSERT_ID, 0); }
		public ITerminalNode LCASE() { return GetToken(MySqlParser.LCASE, 0); }
		public ITerminalNode LEAST() { return GetToken(MySqlParser.LEAST, 0); }
		public ITerminalNode LEFT() { return GetToken(MySqlParser.LEFT, 0); }
		public ITerminalNode LENGTH() { return GetToken(MySqlParser.LENGTH, 0); }
		public ITerminalNode LINEFROMTEXT() { return GetToken(MySqlParser.LINEFROMTEXT, 0); }
		public ITerminalNode LINEFROMWKB() { return GetToken(MySqlParser.LINEFROMWKB, 0); }
		public ITerminalNode LINESTRING() { return GetToken(MySqlParser.LINESTRING, 0); }
		public ITerminalNode LINESTRINGFROMTEXT() { return GetToken(MySqlParser.LINESTRINGFROMTEXT, 0); }
		public ITerminalNode LINESTRINGFROMWKB() { return GetToken(MySqlParser.LINESTRINGFROMWKB, 0); }
		public ITerminalNode LN() { return GetToken(MySqlParser.LN, 0); }
		public ITerminalNode LOAD_FILE() { return GetToken(MySqlParser.LOAD_FILE, 0); }
		public ITerminalNode LOCATE() { return GetToken(MySqlParser.LOCATE, 0); }
		public ITerminalNode LOG() { return GetToken(MySqlParser.LOG, 0); }
		public ITerminalNode LOG10() { return GetToken(MySqlParser.LOG10, 0); }
		public ITerminalNode LOG2() { return GetToken(MySqlParser.LOG2, 0); }
		public ITerminalNode LOWER() { return GetToken(MySqlParser.LOWER, 0); }
		public ITerminalNode LPAD() { return GetToken(MySqlParser.LPAD, 0); }
		public ITerminalNode LTRIM() { return GetToken(MySqlParser.LTRIM, 0); }
		public ITerminalNode MAKEDATE() { return GetToken(MySqlParser.MAKEDATE, 0); }
		public ITerminalNode MAKETIME() { return GetToken(MySqlParser.MAKETIME, 0); }
		public ITerminalNode MAKE_SET() { return GetToken(MySqlParser.MAKE_SET, 0); }
		public ITerminalNode MASTER_POS_WAIT() { return GetToken(MySqlParser.MASTER_POS_WAIT, 0); }
		public ITerminalNode MBRCONTAINS() { return GetToken(MySqlParser.MBRCONTAINS, 0); }
		public ITerminalNode MBRDISJOINT() { return GetToken(MySqlParser.MBRDISJOINT, 0); }
		public ITerminalNode MBREQUAL() { return GetToken(MySqlParser.MBREQUAL, 0); }
		public ITerminalNode MBRINTERSECTS() { return GetToken(MySqlParser.MBRINTERSECTS, 0); }
		public ITerminalNode MBROVERLAPS() { return GetToken(MySqlParser.MBROVERLAPS, 0); }
		public ITerminalNode MBRTOUCHES() { return GetToken(MySqlParser.MBRTOUCHES, 0); }
		public ITerminalNode MBRWITHIN() { return GetToken(MySqlParser.MBRWITHIN, 0); }
		public ITerminalNode MD5() { return GetToken(MySqlParser.MD5, 0); }
		public ITerminalNode MICROSECOND() { return GetToken(MySqlParser.MICROSECOND, 0); }
		public ITerminalNode MINUTE() { return GetToken(MySqlParser.MINUTE, 0); }
		public ITerminalNode MLINEFROMTEXT() { return GetToken(MySqlParser.MLINEFROMTEXT, 0); }
		public ITerminalNode MLINEFROMWKB() { return GetToken(MySqlParser.MLINEFROMWKB, 0); }
		public ITerminalNode MONTH() { return GetToken(MySqlParser.MONTH, 0); }
		public ITerminalNode MONTHNAME() { return GetToken(MySqlParser.MONTHNAME, 0); }
		public ITerminalNode MPOINTFROMTEXT() { return GetToken(MySqlParser.MPOINTFROMTEXT, 0); }
		public ITerminalNode MPOINTFROMWKB() { return GetToken(MySqlParser.MPOINTFROMWKB, 0); }
		public ITerminalNode MPOLYFROMTEXT() { return GetToken(MySqlParser.MPOLYFROMTEXT, 0); }
		public ITerminalNode MPOLYFROMWKB() { return GetToken(MySqlParser.MPOLYFROMWKB, 0); }
		public ITerminalNode MULTILINESTRING() { return GetToken(MySqlParser.MULTILINESTRING, 0); }
		public ITerminalNode MULTILINESTRINGFROMTEXT() { return GetToken(MySqlParser.MULTILINESTRINGFROMTEXT, 0); }
		public ITerminalNode MULTILINESTRINGFROMWKB() { return GetToken(MySqlParser.MULTILINESTRINGFROMWKB, 0); }
		public ITerminalNode MULTIPOINT() { return GetToken(MySqlParser.MULTIPOINT, 0); }
		public ITerminalNode MULTIPOINTFROMTEXT() { return GetToken(MySqlParser.MULTIPOINTFROMTEXT, 0); }
		public ITerminalNode MULTIPOINTFROMWKB() { return GetToken(MySqlParser.MULTIPOINTFROMWKB, 0); }
		public ITerminalNode MULTIPOLYGON() { return GetToken(MySqlParser.MULTIPOLYGON, 0); }
		public ITerminalNode MULTIPOLYGONFROMTEXT() { return GetToken(MySqlParser.MULTIPOLYGONFROMTEXT, 0); }
		public ITerminalNode MULTIPOLYGONFROMWKB() { return GetToken(MySqlParser.MULTIPOLYGONFROMWKB, 0); }
		public ITerminalNode NAME_CONST() { return GetToken(MySqlParser.NAME_CONST, 0); }
		public ITerminalNode NULLIF() { return GetToken(MySqlParser.NULLIF, 0); }
		public ITerminalNode NUMGEOMETRIES() { return GetToken(MySqlParser.NUMGEOMETRIES, 0); }
		public ITerminalNode NUMINTERIORRINGS() { return GetToken(MySqlParser.NUMINTERIORRINGS, 0); }
		public ITerminalNode NUMPOINTS() { return GetToken(MySqlParser.NUMPOINTS, 0); }
		public ITerminalNode OCT() { return GetToken(MySqlParser.OCT, 0); }
		public ITerminalNode OCTET_LENGTH() { return GetToken(MySqlParser.OCTET_LENGTH, 0); }
		public ITerminalNode ORD() { return GetToken(MySqlParser.ORD, 0); }
		public ITerminalNode OVERLAPS() { return GetToken(MySqlParser.OVERLAPS, 0); }
		public ITerminalNode PERIOD_ADD() { return GetToken(MySqlParser.PERIOD_ADD, 0); }
		public ITerminalNode PERIOD_DIFF() { return GetToken(MySqlParser.PERIOD_DIFF, 0); }
		public ITerminalNode PI() { return GetToken(MySqlParser.PI, 0); }
		public ITerminalNode POINT() { return GetToken(MySqlParser.POINT, 0); }
		public ITerminalNode POINTFROMTEXT() { return GetToken(MySqlParser.POINTFROMTEXT, 0); }
		public ITerminalNode POINTFROMWKB() { return GetToken(MySqlParser.POINTFROMWKB, 0); }
		public ITerminalNode POINTN() { return GetToken(MySqlParser.POINTN, 0); }
		public ITerminalNode POLYFROMTEXT() { return GetToken(MySqlParser.POLYFROMTEXT, 0); }
		public ITerminalNode POLYFROMWKB() { return GetToken(MySqlParser.POLYFROMWKB, 0); }
		public ITerminalNode POLYGON() { return GetToken(MySqlParser.POLYGON, 0); }
		public ITerminalNode POLYGONFROMTEXT() { return GetToken(MySqlParser.POLYGONFROMTEXT, 0); }
		public ITerminalNode POLYGONFROMWKB() { return GetToken(MySqlParser.POLYGONFROMWKB, 0); }
		public ITerminalNode POSITION() { return GetToken(MySqlParser.POSITION, 0); }
		public ITerminalNode POW() { return GetToken(MySqlParser.POW, 0); }
		public ITerminalNode POWER() { return GetToken(MySqlParser.POWER, 0); }
		public ITerminalNode QUARTER() { return GetToken(MySqlParser.QUARTER, 0); }
		public ITerminalNode QUOTE() { return GetToken(MySqlParser.QUOTE, 0); }
		public ITerminalNode RADIANS() { return GetToken(MySqlParser.RADIANS, 0); }
		public ITerminalNode RAND() { return GetToken(MySqlParser.RAND, 0); }
		public ITerminalNode RANDOM_BYTES() { return GetToken(MySqlParser.RANDOM_BYTES, 0); }
		public ITerminalNode RELEASE_LOCK() { return GetToken(MySqlParser.RELEASE_LOCK, 0); }
		public ITerminalNode REVERSE() { return GetToken(MySqlParser.REVERSE, 0); }
		public ITerminalNode RIGHT() { return GetToken(MySqlParser.RIGHT, 0); }
		public ITerminalNode ROUND() { return GetToken(MySqlParser.ROUND, 0); }
		public ITerminalNode ROW_COUNT() { return GetToken(MySqlParser.ROW_COUNT, 0); }
		public ITerminalNode RPAD() { return GetToken(MySqlParser.RPAD, 0); }
		public ITerminalNode RTRIM() { return GetToken(MySqlParser.RTRIM, 0); }
		public ITerminalNode SECOND() { return GetToken(MySqlParser.SECOND, 0); }
		public ITerminalNode SEC_TO_TIME() { return GetToken(MySqlParser.SEC_TO_TIME, 0); }
		public ITerminalNode SESSION_USER() { return GetToken(MySqlParser.SESSION_USER, 0); }
		public ITerminalNode SESSION_VARIABLES_ADMIN() { return GetToken(MySqlParser.SESSION_VARIABLES_ADMIN, 0); }
		public ITerminalNode SHA() { return GetToken(MySqlParser.SHA, 0); }
		public ITerminalNode SHA1() { return GetToken(MySqlParser.SHA1, 0); }
		public ITerminalNode SHA2() { return GetToken(MySqlParser.SHA2, 0); }
		public ITerminalNode SIGN() { return GetToken(MySqlParser.SIGN, 0); }
		public ITerminalNode SIN() { return GetToken(MySqlParser.SIN, 0); }
		public ITerminalNode SLEEP() { return GetToken(MySqlParser.SLEEP, 0); }
		public ITerminalNode SOUNDEX() { return GetToken(MySqlParser.SOUNDEX, 0); }
		public ITerminalNode SQL_THREAD_WAIT_AFTER_GTIDS() { return GetToken(MySqlParser.SQL_THREAD_WAIT_AFTER_GTIDS, 0); }
		public ITerminalNode SQRT() { return GetToken(MySqlParser.SQRT, 0); }
		public ITerminalNode SRID() { return GetToken(MySqlParser.SRID, 0); }
		public ITerminalNode STARTPOINT() { return GetToken(MySqlParser.STARTPOINT, 0); }
		public ITerminalNode STRCMP() { return GetToken(MySqlParser.STRCMP, 0); }
		public ITerminalNode STR_TO_DATE() { return GetToken(MySqlParser.STR_TO_DATE, 0); }
		public ITerminalNode ST_AREA() { return GetToken(MySqlParser.ST_AREA, 0); }
		public ITerminalNode ST_ASBINARY() { return GetToken(MySqlParser.ST_ASBINARY, 0); }
		public ITerminalNode ST_ASTEXT() { return GetToken(MySqlParser.ST_ASTEXT, 0); }
		public ITerminalNode ST_ASWKB() { return GetToken(MySqlParser.ST_ASWKB, 0); }
		public ITerminalNode ST_ASWKT() { return GetToken(MySqlParser.ST_ASWKT, 0); }
		public ITerminalNode ST_BUFFER() { return GetToken(MySqlParser.ST_BUFFER, 0); }
		public ITerminalNode ST_CENTROID() { return GetToken(MySqlParser.ST_CENTROID, 0); }
		public ITerminalNode ST_CONTAINS() { return GetToken(MySqlParser.ST_CONTAINS, 0); }
		public ITerminalNode ST_CROSSES() { return GetToken(MySqlParser.ST_CROSSES, 0); }
		public ITerminalNode ST_DIFFERENCE() { return GetToken(MySqlParser.ST_DIFFERENCE, 0); }
		public ITerminalNode ST_DIMENSION() { return GetToken(MySqlParser.ST_DIMENSION, 0); }
		public ITerminalNode ST_DISJOINT() { return GetToken(MySqlParser.ST_DISJOINT, 0); }
		public ITerminalNode ST_DISTANCE() { return GetToken(MySqlParser.ST_DISTANCE, 0); }
		public ITerminalNode ST_ENDPOINT() { return GetToken(MySqlParser.ST_ENDPOINT, 0); }
		public ITerminalNode ST_ENVELOPE() { return GetToken(MySqlParser.ST_ENVELOPE, 0); }
		public ITerminalNode ST_EQUALS() { return GetToken(MySqlParser.ST_EQUALS, 0); }
		public ITerminalNode ST_EXTERIORRING() { return GetToken(MySqlParser.ST_EXTERIORRING, 0); }
		public ITerminalNode ST_GEOMCOLLFROMTEXT() { return GetToken(MySqlParser.ST_GEOMCOLLFROMTEXT, 0); }
		public ITerminalNode ST_GEOMCOLLFROMTXT() { return GetToken(MySqlParser.ST_GEOMCOLLFROMTXT, 0); }
		public ITerminalNode ST_GEOMCOLLFROMWKB() { return GetToken(MySqlParser.ST_GEOMCOLLFROMWKB, 0); }
		public ITerminalNode ST_GEOMETRYCOLLECTIONFROMTEXT() { return GetToken(MySqlParser.ST_GEOMETRYCOLLECTIONFROMTEXT, 0); }
		public ITerminalNode ST_GEOMETRYCOLLECTIONFROMWKB() { return GetToken(MySqlParser.ST_GEOMETRYCOLLECTIONFROMWKB, 0); }
		public ITerminalNode ST_GEOMETRYFROMTEXT() { return GetToken(MySqlParser.ST_GEOMETRYFROMTEXT, 0); }
		public ITerminalNode ST_GEOMETRYFROMWKB() { return GetToken(MySqlParser.ST_GEOMETRYFROMWKB, 0); }
		public ITerminalNode ST_GEOMETRYN() { return GetToken(MySqlParser.ST_GEOMETRYN, 0); }
		public ITerminalNode ST_GEOMETRYTYPE() { return GetToken(MySqlParser.ST_GEOMETRYTYPE, 0); }
		public ITerminalNode ST_GEOMFROMTEXT() { return GetToken(MySqlParser.ST_GEOMFROMTEXT, 0); }
		public ITerminalNode ST_GEOMFROMWKB() { return GetToken(MySqlParser.ST_GEOMFROMWKB, 0); }
		public ITerminalNode ST_INTERIORRINGN() { return GetToken(MySqlParser.ST_INTERIORRINGN, 0); }
		public ITerminalNode ST_INTERSECTION() { return GetToken(MySqlParser.ST_INTERSECTION, 0); }
		public ITerminalNode ST_INTERSECTS() { return GetToken(MySqlParser.ST_INTERSECTS, 0); }
		public ITerminalNode ST_ISCLOSED() { return GetToken(MySqlParser.ST_ISCLOSED, 0); }
		public ITerminalNode ST_ISEMPTY() { return GetToken(MySqlParser.ST_ISEMPTY, 0); }
		public ITerminalNode ST_ISSIMPLE() { return GetToken(MySqlParser.ST_ISSIMPLE, 0); }
		public ITerminalNode ST_LINEFROMTEXT() { return GetToken(MySqlParser.ST_LINEFROMTEXT, 0); }
		public ITerminalNode ST_LINEFROMWKB() { return GetToken(MySqlParser.ST_LINEFROMWKB, 0); }
		public ITerminalNode ST_LINESTRINGFROMTEXT() { return GetToken(MySqlParser.ST_LINESTRINGFROMTEXT, 0); }
		public ITerminalNode ST_LINESTRINGFROMWKB() { return GetToken(MySqlParser.ST_LINESTRINGFROMWKB, 0); }
		public ITerminalNode ST_NUMGEOMETRIES() { return GetToken(MySqlParser.ST_NUMGEOMETRIES, 0); }
		public ITerminalNode ST_NUMINTERIORRING() { return GetToken(MySqlParser.ST_NUMINTERIORRING, 0); }
		public ITerminalNode ST_NUMINTERIORRINGS() { return GetToken(MySqlParser.ST_NUMINTERIORRINGS, 0); }
		public ITerminalNode ST_NUMPOINTS() { return GetToken(MySqlParser.ST_NUMPOINTS, 0); }
		public ITerminalNode ST_OVERLAPS() { return GetToken(MySqlParser.ST_OVERLAPS, 0); }
		public ITerminalNode ST_POINTFROMTEXT() { return GetToken(MySqlParser.ST_POINTFROMTEXT, 0); }
		public ITerminalNode ST_POINTFROMWKB() { return GetToken(MySqlParser.ST_POINTFROMWKB, 0); }
		public ITerminalNode ST_POINTN() { return GetToken(MySqlParser.ST_POINTN, 0); }
		public ITerminalNode ST_POLYFROMTEXT() { return GetToken(MySqlParser.ST_POLYFROMTEXT, 0); }
		public ITerminalNode ST_POLYFROMWKB() { return GetToken(MySqlParser.ST_POLYFROMWKB, 0); }
		public ITerminalNode ST_POLYGONFROMTEXT() { return GetToken(MySqlParser.ST_POLYGONFROMTEXT, 0); }
		public ITerminalNode ST_POLYGONFROMWKB() { return GetToken(MySqlParser.ST_POLYGONFROMWKB, 0); }
		public ITerminalNode ST_SRID() { return GetToken(MySqlParser.ST_SRID, 0); }
		public ITerminalNode ST_STARTPOINT() { return GetToken(MySqlParser.ST_STARTPOINT, 0); }
		public ITerminalNode ST_SYMDIFFERENCE() { return GetToken(MySqlParser.ST_SYMDIFFERENCE, 0); }
		public ITerminalNode ST_TOUCHES() { return GetToken(MySqlParser.ST_TOUCHES, 0); }
		public ITerminalNode ST_UNION() { return GetToken(MySqlParser.ST_UNION, 0); }
		public ITerminalNode ST_WITHIN() { return GetToken(MySqlParser.ST_WITHIN, 0); }
		public ITerminalNode ST_X() { return GetToken(MySqlParser.ST_X, 0); }
		public ITerminalNode ST_Y() { return GetToken(MySqlParser.ST_Y, 0); }
		public ITerminalNode SUBDATE() { return GetToken(MySqlParser.SUBDATE, 0); }
		public ITerminalNode SUBSTRING_INDEX() { return GetToken(MySqlParser.SUBSTRING_INDEX, 0); }
		public ITerminalNode SUBTIME() { return GetToken(MySqlParser.SUBTIME, 0); }
		public ITerminalNode SYSTEM_USER() { return GetToken(MySqlParser.SYSTEM_USER, 0); }
		public ITerminalNode TAN() { return GetToken(MySqlParser.TAN, 0); }
		public ITerminalNode TIME() { return GetToken(MySqlParser.TIME, 0); }
		public ITerminalNode TIMEDIFF() { return GetToken(MySqlParser.TIMEDIFF, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(MySqlParser.TIMESTAMP, 0); }
		public ITerminalNode TIMESTAMPADD() { return GetToken(MySqlParser.TIMESTAMPADD, 0); }
		public ITerminalNode TIMESTAMPDIFF() { return GetToken(MySqlParser.TIMESTAMPDIFF, 0); }
		public ITerminalNode TIME_FORMAT() { return GetToken(MySqlParser.TIME_FORMAT, 0); }
		public ITerminalNode TIME_TO_SEC() { return GetToken(MySqlParser.TIME_TO_SEC, 0); }
		public ITerminalNode TOUCHES() { return GetToken(MySqlParser.TOUCHES, 0); }
		public ITerminalNode TO_BASE64() { return GetToken(MySqlParser.TO_BASE64, 0); }
		public ITerminalNode TO_DAYS() { return GetToken(MySqlParser.TO_DAYS, 0); }
		public ITerminalNode TO_SECONDS() { return GetToken(MySqlParser.TO_SECONDS, 0); }
		public ITerminalNode UCASE() { return GetToken(MySqlParser.UCASE, 0); }
		public ITerminalNode UNCOMPRESS() { return GetToken(MySqlParser.UNCOMPRESS, 0); }
		public ITerminalNode UNCOMPRESSED_LENGTH() { return GetToken(MySqlParser.UNCOMPRESSED_LENGTH, 0); }
		public ITerminalNode UNHEX() { return GetToken(MySqlParser.UNHEX, 0); }
		public ITerminalNode UNIX_TIMESTAMP() { return GetToken(MySqlParser.UNIX_TIMESTAMP, 0); }
		public ITerminalNode UPDATEXML() { return GetToken(MySqlParser.UPDATEXML, 0); }
		public ITerminalNode UPPER() { return GetToken(MySqlParser.UPPER, 0); }
		public ITerminalNode UUID() { return GetToken(MySqlParser.UUID, 0); }
		public ITerminalNode UUID_SHORT() { return GetToken(MySqlParser.UUID_SHORT, 0); }
		public ITerminalNode VALIDATE_PASSWORD_STRENGTH() { return GetToken(MySqlParser.VALIDATE_PASSWORD_STRENGTH, 0); }
		public ITerminalNode VERSION() { return GetToken(MySqlParser.VERSION, 0); }
		public ITerminalNode VISIBLE() { return GetToken(MySqlParser.VISIBLE, 0); }
		public ITerminalNode WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() { return GetToken(MySqlParser.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, 0); }
		public ITerminalNode WEEK() { return GetToken(MySqlParser.WEEK, 0); }
		public ITerminalNode WEEKDAY() { return GetToken(MySqlParser.WEEKDAY, 0); }
		public ITerminalNode WEEKOFYEAR() { return GetToken(MySqlParser.WEEKOFYEAR, 0); }
		public ITerminalNode WEIGHT_STRING() { return GetToken(MySqlParser.WEIGHT_STRING, 0); }
		public ITerminalNode WITHIN() { return GetToken(MySqlParser.WITHIN, 0); }
		public ITerminalNode YEAR() { return GetToken(MySqlParser.YEAR, 0); }
		public ITerminalNode YEARWEEK() { return GetToken(MySqlParser.YEARWEEK, 0); }
		public ITerminalNode Y_FUNCTION() { return GetToken(MySqlParser.Y_FUNCTION, 0); }
		public ITerminalNode X_FUNCTION() { return GetToken(MySqlParser.X_FUNCTION, 0); }
		public FunctionNameBaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionNameBase; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.EnterFunctionNameBase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMySqlParserListener typedListener = listener as IMySqlParserListener;
			if (typedListener != null) typedListener.ExitFunctionNameBase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMySqlParserVisitor<TResult> typedVisitor = visitor as IMySqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionNameBase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionNameBaseContext functionNameBase() {
		FunctionNameBaseContext _localctx = new FunctionNameBaseContext(Context, State);
		EnterRule(_localctx, 622, RULE_functionNameBase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 6224;
			_la = TokenStream.LA(1);
			if ( !(_la==DATABASE || _la==LEFT || _la==RIGHT || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (DATE - 185)) | (1L << (TIME - 185)) | (1L << (TIMESTAMP - 185)) | (1L << (YEAR - 185)) | (1L << (COUNT - 185)) | (1L << (POSITION - 185)))) != 0) || _la==INVISIBLE || ((((_la - 559)) & ~0x3f) == 0 && ((1L << (_la - 559)) & ((1L << (VISIBLE - 559)) | (1L << (QUARTER - 559)) | (1L << (MONTH - 559)) | (1L << (DAY - 559)) | (1L << (HOUR - 559)) | (1L << (MINUTE - 559)) | (1L << (WEEK - 559)) | (1L << (SECOND - 559)) | (1L << (MICROSECOND - 559)) | (1L << (SESSION_VARIABLES_ADMIN - 559)))) != 0) || ((((_la - 647)) & ~0x3f) == 0 && ((1L << (_la - 647)) & ((1L << (GEOMETRYCOLLECTION - 647)) | (1L << (LINESTRING - 647)) | (1L << (MULTILINESTRING - 647)) | (1L << (MULTIPOINT - 647)) | (1L << (MULTIPOLYGON - 647)) | (1L << (POINT - 647)) | (1L << (POLYGON - 647)) | (1L << (ABS - 647)) | (1L << (ACOS - 647)) | (1L << (ADDDATE - 647)) | (1L << (ADDTIME - 647)) | (1L << (AES_DECRYPT - 647)) | (1L << (AES_ENCRYPT - 647)) | (1L << (AREA - 647)) | (1L << (ASBINARY - 647)) | (1L << (ASIN - 647)) | (1L << (ASTEXT - 647)) | (1L << (ASWKB - 647)) | (1L << (ASWKT - 647)) | (1L << (ASYMMETRIC_DECRYPT - 647)) | (1L << (ASYMMETRIC_DERIVE - 647)) | (1L << (ASYMMETRIC_ENCRYPT - 647)) | (1L << (ASYMMETRIC_SIGN - 647)) | (1L << (ASYMMETRIC_VERIFY - 647)) | (1L << (ATAN - 647)) | (1L << (ATAN2 - 647)) | (1L << (BENCHMARK - 647)) | (1L << (BIN - 647)) | (1L << (BIT_COUNT - 647)) | (1L << (BIT_LENGTH - 647)) | (1L << (BUFFER - 647)) | (1L << (CEIL - 647)) | (1L << (CEILING - 647)) | (1L << (CENTROID - 647)) | (1L << (CHARACTER_LENGTH - 647)) | (1L << (CHARSET - 647)) | (1L << (CHAR_LENGTH - 647)) | (1L << (COERCIBILITY - 647)) | (1L << (COLLATION - 647)) | (1L << (COMPRESS - 647)) | (1L << (CONCAT - 647)) | (1L << (CONCAT_WS - 647)) | (1L << (CONNECTION_ID - 647)) | (1L << (CONV - 647)) | (1L << (CONVERT_TZ - 647)) | (1L << (COS - 647)) | (1L << (COT - 647)) | (1L << (CRC32 - 647)) | (1L << (CREATE_ASYMMETRIC_PRIV_KEY - 647)) | (1L << (CREATE_ASYMMETRIC_PUB_KEY - 647)) | (1L << (CREATE_DH_PARAMETERS - 647)) | (1L << (CREATE_DIGEST - 647)) | (1L << (CROSSES - 647)) | (1L << (DATEDIFF - 647)) | (1L << (DATE_FORMAT - 647)) | (1L << (DAYNAME - 647)) | (1L << (DAYOFMONTH - 647)) | (1L << (DAYOFWEEK - 647)) | (1L << (DAYOFYEAR - 647)) | (1L << (DECODE - 647)) | (1L << (DEGREES - 647)))) != 0) || ((((_la - 711)) & ~0x3f) == 0 && ((1L << (_la - 711)) & ((1L << (DES_DECRYPT - 711)) | (1L << (DES_ENCRYPT - 711)) | (1L << (DIMENSION - 711)) | (1L << (DISJOINT - 711)) | (1L << (ELT - 711)) | (1L << (ENCODE - 711)) | (1L << (ENCRYPT - 711)) | (1L << (ENDPOINT - 711)) | (1L << (ENVELOPE - 711)) | (1L << (EQUALS - 711)) | (1L << (EXP - 711)) | (1L << (EXPORT_SET - 711)) | (1L << (EXTERIORRING - 711)) | (1L << (EXTRACTVALUE - 711)) | (1L << (FIELD - 711)) | (1L << (FIND_IN_SET - 711)) | (1L << (FLOOR - 711)) | (1L << (FORMAT - 711)) | (1L << (FOUND_ROWS - 711)) | (1L << (FROM_BASE64 - 711)) | (1L << (FROM_DAYS - 711)) | (1L << (FROM_UNIXTIME - 711)) | (1L << (GEOMCOLLFROMTEXT - 711)) | (1L << (GEOMCOLLFROMWKB - 711)) | (1L << (GEOMETRYCOLLECTIONFROMTEXT - 711)) | (1L << (GEOMETRYCOLLECTIONFROMWKB - 711)) | (1L << (GEOMETRYFROMTEXT - 711)) | (1L << (GEOMETRYFROMWKB - 711)) | (1L << (GEOMETRYN - 711)) | (1L << (GEOMETRYTYPE - 711)) | (1L << (GEOMFROMTEXT - 711)) | (1L << (GEOMFROMWKB - 711)) | (1L << (GET_FORMAT - 711)) | (1L << (GET_LOCK - 711)) | (1L << (GLENGTH - 711)) | (1L << (GREATEST - 711)) | (1L << (GTID_SUBSET - 711)) | (1L << (GTID_SUBTRACT - 711)) | (1L << (HEX - 711)) | (1L << (IFNULL - 711)) | (1L << (INET6_ATON - 711)) | (1L << (INET6_NTOA - 711)) | (1L << (INET_ATON - 711)) | (1L << (INET_NTOA - 711)) | (1L << (INSTR - 711)) | (1L << (INTERIORRINGN - 711)) | (1L << (INTERSECTS - 711)) | (1L << (ISCLOSED - 711)) | (1L << (ISEMPTY - 711)) | (1L << (ISNULL - 711)) | (1L << (ISSIMPLE - 711)) | (1L << (IS_FREE_LOCK - 711)) | (1L << (IS_IPV4 - 711)) | (1L << (IS_IPV4_COMPAT - 711)) | (1L << (IS_IPV4_MAPPED - 711)) | (1L << (IS_IPV6 - 711)) | (1L << (IS_USED_LOCK - 711)) | (1L << (LAST_INSERT_ID - 711)) | (1L << (LCASE - 711)) | (1L << (LEAST - 711)) | (1L << (LENGTH - 711)) | (1L << (LINEFROMTEXT - 711)) | (1L << (LINEFROMWKB - 711)) | (1L << (LINESTRINGFROMTEXT - 711)))) != 0) || ((((_la - 775)) & ~0x3f) == 0 && ((1L << (_la - 775)) & ((1L << (LINESTRINGFROMWKB - 775)) | (1L << (LN - 775)) | (1L << (LOAD_FILE - 775)) | (1L << (LOCATE - 775)) | (1L << (LOG - 775)) | (1L << (LOG10 - 775)) | (1L << (LOG2 - 775)) | (1L << (LOWER - 775)) | (1L << (LPAD - 775)) | (1L << (LTRIM - 775)) | (1L << (MAKEDATE - 775)) | (1L << (MAKETIME - 775)) | (1L << (MAKE_SET - 775)) | (1L << (MASTER_POS_WAIT - 775)) | (1L << (MBRCONTAINS - 775)) | (1L << (MBRDISJOINT - 775)) | (1L << (MBREQUAL - 775)) | (1L << (MBRINTERSECTS - 775)) | (1L << (MBROVERLAPS - 775)) | (1L << (MBRTOUCHES - 775)) | (1L << (MBRWITHIN - 775)) | (1L << (MD5 - 775)) | (1L << (MLINEFROMTEXT - 775)) | (1L << (MLINEFROMWKB - 775)) | (1L << (MONTHNAME - 775)) | (1L << (MPOINTFROMTEXT - 775)) | (1L << (MPOINTFROMWKB - 775)) | (1L << (MPOLYFROMTEXT - 775)) | (1L << (MPOLYFROMWKB - 775)) | (1L << (MULTILINESTRINGFROMTEXT - 775)) | (1L << (MULTILINESTRINGFROMWKB - 775)) | (1L << (MULTIPOINTFROMTEXT - 775)) | (1L << (MULTIPOINTFROMWKB - 775)) | (1L << (MULTIPOLYGONFROMTEXT - 775)) | (1L << (MULTIPOLYGONFROMWKB - 775)) | (1L << (NAME_CONST - 775)) | (1L << (NULLIF - 775)) | (1L << (NUMGEOMETRIES - 775)) | (1L << (NUMINTERIORRINGS - 775)) | (1L << (NUMPOINTS - 775)) | (1L << (OCT - 775)) | (1L << (OCTET_LENGTH - 775)) | (1L << (ORD - 775)) | (1L << (OVERLAPS - 775)) | (1L << (PERIOD_ADD - 775)) | (1L << (PERIOD_DIFF - 775)) | (1L << (PI - 775)) | (1L << (POINTFROMTEXT - 775)) | (1L << (POINTFROMWKB - 775)) | (1L << (POINTN - 775)) | (1L << (POLYFROMTEXT - 775)) | (1L << (POLYFROMWKB - 775)) | (1L << (POLYGONFROMTEXT - 775)) | (1L << (POLYGONFROMWKB - 775)) | (1L << (POW - 775)) | (1L << (POWER - 775)) | (1L << (QUOTE - 775)) | (1L << (RADIANS - 775)) | (1L << (RAND - 775)) | (1L << (RANDOM_BYTES - 775)) | (1L << (RELEASE_LOCK - 775)) | (1L << (REVERSE - 775)) | (1L << (ROUND - 775)) | (1L << (ROW_COUNT - 775)))) != 0) || ((((_la - 839)) & ~0x3f) == 0 && ((1L << (_la - 839)) & ((1L << (RPAD - 839)) | (1L << (RTRIM - 839)) | (1L << (SEC_TO_TIME - 839)) | (1L << (SESSION_USER - 839)) | (1L << (SHA - 839)) | (1L << (SHA1 - 839)) | (1L << (SHA2 - 839)) | (1L << (SIGN - 839)) | (1L << (SIN - 839)) | (1L << (SLEEP - 839)) | (1L << (SOUNDEX - 839)) | (1L << (SQL_THREAD_WAIT_AFTER_GTIDS - 839)) | (1L << (SQRT - 839)) | (1L << (SRID - 839)) | (1L << (STARTPOINT - 839)) | (1L << (STRCMP - 839)) | (1L << (STR_TO_DATE - 839)) | (1L << (ST_AREA - 839)) | (1L << (ST_ASBINARY - 839)) | (1L << (ST_ASTEXT - 839)) | (1L << (ST_ASWKB - 839)) | (1L << (ST_ASWKT - 839)) | (1L << (ST_BUFFER - 839)) | (1L << (ST_CENTROID - 839)) | (1L << (ST_CONTAINS - 839)) | (1L << (ST_CROSSES - 839)) | (1L << (ST_DIFFERENCE - 839)) | (1L << (ST_DIMENSION - 839)) | (1L << (ST_DISJOINT - 839)) | (1L << (ST_DISTANCE - 839)) | (1L << (ST_ENDPOINT - 839)) | (1L << (ST_ENVELOPE - 839)) | (1L << (ST_EQUALS - 839)) | (1L << (ST_EXTERIORRING - 839)) | (1L << (ST_GEOMCOLLFROMTEXT - 839)) | (1L << (ST_GEOMCOLLFROMTXT - 839)) | (1L << (ST_GEOMCOLLFROMWKB - 839)) | (1L << (ST_GEOMETRYCOLLECTIONFROMTEXT - 839)) | (1L << (ST_GEOMETRYCOLLECTIONFROMWKB - 839)) | (1L << (ST_GEOMETRYFROMTEXT - 839)) | (1L << (ST_GEOMETRYFROMWKB - 839)) | (1L << (ST_GEOMETRYN - 839)) | (1L << (ST_GEOMETRYTYPE - 839)) | (1L << (ST_GEOMFROMTEXT - 839)) | (1L << (ST_GEOMFROMWKB - 839)) | (1L << (ST_INTERIORRINGN - 839)) | (1L << (ST_INTERSECTION - 839)) | (1L << (ST_INTERSECTS - 839)) | (1L << (ST_ISCLOSED - 839)) | (1L << (ST_ISEMPTY - 839)) | (1L << (ST_ISSIMPLE - 839)) | (1L << (ST_LINEFROMTEXT - 839)) | (1L << (ST_LINEFROMWKB - 839)) | (1L << (ST_LINESTRINGFROMTEXT - 839)) | (1L << (ST_LINESTRINGFROMWKB - 839)) | (1L << (ST_NUMGEOMETRIES - 839)) | (1L << (ST_NUMINTERIORRING - 839)) | (1L << (ST_NUMINTERIORRINGS - 839)) | (1L << (ST_NUMPOINTS - 839)) | (1L << (ST_OVERLAPS - 839)) | (1L << (ST_POINTFROMTEXT - 839)) | (1L << (ST_POINTFROMWKB - 839)) | (1L << (ST_POINTN - 839)))) != 0) || ((((_la - 903)) & ~0x3f) == 0 && ((1L << (_la - 903)) & ((1L << (ST_POLYFROMTEXT - 903)) | (1L << (ST_POLYFROMWKB - 903)) | (1L << (ST_POLYGONFROMTEXT - 903)) | (1L << (ST_POLYGONFROMWKB - 903)) | (1L << (ST_SRID - 903)) | (1L << (ST_STARTPOINT - 903)) | (1L << (ST_SYMDIFFERENCE - 903)) | (1L << (ST_TOUCHES - 903)) | (1L << (ST_UNION - 903)) | (1L << (ST_WITHIN - 903)) | (1L << (ST_X - 903)) | (1L << (ST_Y - 903)) | (1L << (SUBDATE - 903)) | (1L << (SUBSTRING_INDEX - 903)) | (1L << (SUBTIME - 903)) | (1L << (SYSTEM_USER - 903)) | (1L << (TAN - 903)) | (1L << (TIMEDIFF - 903)) | (1L << (TIMESTAMPADD - 903)) | (1L << (TIMESTAMPDIFF - 903)) | (1L << (TIME_FORMAT - 903)) | (1L << (TIME_TO_SEC - 903)) | (1L << (TOUCHES - 903)) | (1L << (TO_BASE64 - 903)) | (1L << (TO_DAYS - 903)) | (1L << (TO_SECONDS - 903)) | (1L << (UCASE - 903)) | (1L << (UNCOMPRESS - 903)) | (1L << (UNCOMPRESSED_LENGTH - 903)) | (1L << (UNHEX - 903)) | (1L << (UNIX_TIMESTAMP - 903)) | (1L << (UPDATEXML - 903)) | (1L << (UPPER - 903)) | (1L << (UUID - 903)) | (1L << (UUID_SHORT - 903)) | (1L << (VALIDATE_PASSWORD_STRENGTH - 903)) | (1L << (VERSION - 903)) | (1L << (WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 903)) | (1L << (WEEKDAY - 903)) | (1L << (WEEKOFYEAR - 903)) | (1L << (WEIGHT_STRING - 903)) | (1L << (WITHIN - 903)) | (1L << (YEARWEEK - 903)) | (1L << (Y_FUNCTION - 903)) | (1L << (X_FUNCTION - 903)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 297: return expression_sempred((ExpressionContext)_localctx, predIndex);
		case 298: return predicate_sempred((PredicateContext)_localctx, predIndex);
		case 299: return expressionAtom_sempred((ExpressionAtomContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 3);
		}
		return true;
	}
	private bool predicate_sempred(PredicateContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return Precpred(Context, 7);
		case 2: return Precpred(Context, 5);
		case 3: return Precpred(Context, 4);
		case 4: return Precpred(Context, 2);
		case 5: return Precpred(Context, 9);
		case 6: return Precpred(Context, 8);
		case 7: return Precpred(Context, 6);
		case 8: return Precpred(Context, 3);
		}
		return true;
	}
	private bool expressionAtom_sempred(ExpressionAtomContext _localctx, int predIndex) {
		switch (predIndex) {
		case 9: return Precpred(Context, 2);
		case 10: return Precpred(Context, 1);
		case 11: return Precpred(Context, 11);
		}
		return true;
	}

	private static string _serializedATN = _serializeATN();
	private static string _serializeATN()
	{
	    StringBuilder sb = new StringBuilder();
	    sb.Append("\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\x3EC");
		sb.Append("\x1855\x4\x2\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6");
		sb.Append("\x4\a\t\a\x4\b\t\b\x4\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r");
		sb.Append("\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t\x10\x4\x11\t\x11\x4\x12");
		sb.Append("\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15\x4\x16\t\x16\x4");
		sb.Append("\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B\t\x1B");
		sb.Append("\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t ");
		sb.Append("\x4!\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t");
		sb.Append("(\x4)\t)\x4*\t*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t");
		sb.Append("\x30\x4\x31\t\x31\x4\x32\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4");
		sb.Append("\x35\t\x35\x4\x36\t\x36\x4\x37\t\x37\x4\x38\t\x38\x4\x39\t\x39");
		sb.Append("\x4:\t:\x4;\t;\x4<\t<\x4=\t=\x4>\t>\x4?\t?\x4@\t@\x4\x41\t\x41");
		sb.Append("\x4\x42\t\x42\x4\x43\t\x43\x4\x44\t\x44\x4\x45\t\x45\x4\x46");
		sb.Append("\t\x46\x4G\tG\x4H\tH\x4I\tI\x4J\tJ\x4K\tK\x4L\tL\x4M\tM\x4N");
		sb.Append("\tN\x4O\tO\x4P\tP\x4Q\tQ\x4R\tR\x4S\tS\x4T\tT\x4U\tU\x4V\tV");
		sb.Append("\x4W\tW\x4X\tX\x4Y\tY\x4Z\tZ\x4[\t[\x4\\\t\\\x4]\t]\x4^\t^\x4");
		sb.Append("_\t_\x4`\t`\x4\x61\t\x61\x4\x62\t\x62\x4\x63\t\x63\x4\x64\t");
		sb.Append("\x64\x4\x65\t\x65\x4\x66\t\x66\x4g\tg\x4h\th\x4i\ti\x4j\tj\x4");
		sb.Append("k\tk\x4l\tl\x4m\tm\x4n\tn\x4o\to\x4p\tp\x4q\tq\x4r\tr\x4s\t");
		sb.Append("s\x4t\tt\x4u\tu\x4v\tv\x4w\tw\x4x\tx\x4y\ty\x4z\tz\x4{\t{\x4");
		sb.Append("|\t|\x4}\t}\x4~\t~\x4\x7F\t\x7F\x4\x80\t\x80\x4\x81\t\x81\x4");
		sb.Append("\x82\t\x82\x4\x83\t\x83\x4\x84\t\x84\x4\x85\t\x85\x4\x86\t\x86");
		sb.Append("\x4\x87\t\x87\x4\x88\t\x88\x4\x89\t\x89\x4\x8A\t\x8A\x4\x8B");
		sb.Append("\t\x8B\x4\x8C\t\x8C\x4\x8D\t\x8D\x4\x8E\t\x8E\x4\x8F\t\x8F\x4");
		sb.Append("\x90\t\x90\x4\x91\t\x91\x4\x92\t\x92\x4\x93\t\x93\x4\x94\t\x94");
		sb.Append("\x4\x95\t\x95\x4\x96\t\x96\x4\x97\t\x97\x4\x98\t\x98\x4\x99");
		sb.Append("\t\x99\x4\x9A\t\x9A\x4\x9B\t\x9B\x4\x9C\t\x9C\x4\x9D\t\x9D\x4");
		sb.Append("\x9E\t\x9E\x4\x9F\t\x9F\x4\xA0\t\xA0\x4\xA1\t\xA1\x4\xA2\t\xA2");
		sb.Append("\x4\xA3\t\xA3\x4\xA4\t\xA4\x4\xA5\t\xA5\x4\xA6\t\xA6\x4\xA7");
		sb.Append("\t\xA7\x4\xA8\t\xA8\x4\xA9\t\xA9\x4\xAA\t\xAA\x4\xAB\t\xAB\x4");
		sb.Append("\xAC\t\xAC\x4\xAD\t\xAD\x4\xAE\t\xAE\x4\xAF\t\xAF\x4\xB0\t\xB0");
		sb.Append("\x4\xB1\t\xB1\x4\xB2\t\xB2\x4\xB3\t\xB3\x4\xB4\t\xB4\x4\xB5");
		sb.Append("\t\xB5\x4\xB6\t\xB6\x4\xB7\t\xB7\x4\xB8\t\xB8\x4\xB9\t\xB9\x4");
		sb.Append("\xBA\t\xBA\x4\xBB\t\xBB\x4\xBC\t\xBC\x4\xBD\t\xBD\x4\xBE\t\xBE");
		sb.Append("\x4\xBF\t\xBF\x4\xC0\t\xC0\x4\xC1\t\xC1\x4\xC2\t\xC2\x4\xC3");
		sb.Append("\t\xC3\x4\xC4\t\xC4\x4\xC5\t\xC5\x4\xC6\t\xC6\x4\xC7\t\xC7\x4");
		sb.Append("\xC8\t\xC8\x4\xC9\t\xC9\x4\xCA\t\xCA\x4\xCB\t\xCB\x4\xCC\t\xCC");
		sb.Append("\x4\xCD\t\xCD\x4\xCE\t\xCE\x4\xCF\t\xCF\x4\xD0\t\xD0\x4\xD1");
		sb.Append("\t\xD1\x4\xD2\t\xD2\x4\xD3\t\xD3\x4\xD4\t\xD4\x4\xD5\t\xD5\x4");
		sb.Append("\xD6\t\xD6\x4\xD7\t\xD7\x4\xD8\t\xD8\x4\xD9\t\xD9\x4\xDA\t\xDA");
		sb.Append("\x4\xDB\t\xDB\x4\xDC\t\xDC\x4\xDD\t\xDD\x4\xDE\t\xDE\x4\xDF");
		sb.Append("\t\xDF\x4\xE0\t\xE0\x4\xE1\t\xE1\x4\xE2\t\xE2\x4\xE3\t\xE3\x4");
		sb.Append("\xE4\t\xE4\x4\xE5\t\xE5\x4\xE6\t\xE6\x4\xE7\t\xE7\x4\xE8\t\xE8");
		sb.Append("\x4\xE9\t\xE9\x4\xEA\t\xEA\x4\xEB\t\xEB\x4\xEC\t\xEC\x4\xED");
		sb.Append("\t\xED\x4\xEE\t\xEE\x4\xEF\t\xEF\x4\xF0\t\xF0\x4\xF1\t\xF1\x4");
		sb.Append("\xF2\t\xF2\x4\xF3\t\xF3\x4\xF4\t\xF4\x4\xF5\t\xF5\x4\xF6\t\xF6");
		sb.Append("\x4\xF7\t\xF7\x4\xF8\t\xF8\x4\xF9\t\xF9\x4\xFA\t\xFA\x4\xFB");
		sb.Append("\t\xFB\x4\xFC\t\xFC\x4\xFD\t\xFD\x4\xFE\t\xFE\x4\xFF\t\xFF\x4");
		sb.Append("\x100\t\x100\x4\x101\t\x101\x4\x102\t\x102\x4\x103\t\x103\x4");
		sb.Append("\x104\t\x104\x4\x105\t\x105\x4\x106\t\x106\x4\x107\t\x107\x4");
		sb.Append("\x108\t\x108\x4\x109\t\x109\x4\x10A\t\x10A\x4\x10B\t\x10B\x4");
		sb.Append("\x10C\t\x10C\x4\x10D\t\x10D\x4\x10E\t\x10E\x4\x10F\t\x10F\x4");
		sb.Append("\x110\t\x110\x4\x111\t\x111\x4\x112\t\x112\x4\x113\t\x113\x4");
		sb.Append("\x114\t\x114\x4\x115\t\x115\x4\x116\t\x116\x4\x117\t\x117\x4");
		sb.Append("\x118\t\x118\x4\x119\t\x119\x4\x11A\t\x11A\x4\x11B\t\x11B\x4");
		sb.Append("\x11C\t\x11C\x4\x11D\t\x11D\x4\x11E\t\x11E\x4\x11F\t\x11F\x4");
		sb.Append("\x120\t\x120\x4\x121\t\x121\x4\x122\t\x122\x4\x123\t\x123\x4");
		sb.Append("\x124\t\x124\x4\x125\t\x125\x4\x126\t\x126\x4\x127\t\x127\x4");
		sb.Append("\x128\t\x128\x4\x129\t\x129\x4\x12A\t\x12A\x4\x12B\t\x12B\x4");
		sb.Append("\x12C\t\x12C\x4\x12D\t\x12D\x4\x12E\t\x12E\x4\x12F\t\x12F\x4");
		sb.Append("\x130\t\x130\x4\x131\t\x131\x4\x132\t\x132\x4\x133\t\x133\x4");
		sb.Append("\x134\t\x134\x4\x135\t\x135\x4\x136\t\x136\x4\x137\t\x137\x4");
		sb.Append("\x138\t\x138\x4\x139\t\x139\x3\x2\x5\x2\x274\n\x2\x3\x2\x5\x2");
		sb.Append("\x277\n\x2\x3\x2\x3\x2\x3\x3\x3\x3\x5\x3\x27D\n\x3\x3\x3\x5");
		sb.Append("\x3\x280\n\x3\x3\x3\a\x3\x283\n\x3\f\x3\xE\x3\x286\v\x3\x3\x3");
		sb.Append("\x3\x3\x5\x3\x28A\n\x3\x3\x3\x5\x3\x28D\n\x3\x3\x3\x5\x3\x290");
		sb.Append("\n\x3\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x5\x4\x299\n");
		sb.Append("\x4\x3\x5\x3\x5\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3");
		sb.Append("\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3");
		sb.Append("\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3");
		sb.Append("\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x5\x6\x2C0\n\x6");
		sb.Append("\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x5\a\x2CC");
		sb.Append("\n\a\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\x5\b\x2D7");
		sb.Append("\n\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t");
		sb.Append("\x3\t\x3\t\x3\t\x3\t\x5\t\x2E8\n\t\x3\n\x3\n\x3\n\x5\n\x2ED");
		sb.Append("\n\n\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x5\v");
		sb.Append("\x2F9\n\v\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f");
		sb.Append("\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f");
		sb.Append("\x3\f\x3\f\x3\f\x5\f\x314\n\f\x3\r\x3\r\x3\r\x3\r\x3\r\x5\r");
		sb.Append("\x31B\n\r\x3\xE\x3\xE\x3\xE\x5\xE\x320\n\xE\x3\xE\x3\xE\a\xE");
		sb.Append("\x324\n\xE\f\xE\xE\xE\x327\v\xE\x3\xF\x3\xF\x5\xF\x32B\n\xF");
		sb.Append("\x3\xF\x3\xF\x5\xF\x32F\n\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3");
		sb.Append("\xF\x3\xF\x5\xF\x338\n\xF\x3\xF\x5\xF\x33B\n\xF\x3\xF\x5\xF");
		sb.Append("\x33E\n\xF\x3\xF\x3\xF\x5\xF\x342\n\xF\x3\xF\x3\xF\x3\xF\x3");
		sb.Append("\x10\x3\x10\x5\x10\x349\n\x10\x3\x10\x5\x10\x34C\n\x10\x3\x10");
		sb.Append("\x3\x10\x3\x10\x5\x10\x351\n\x10\x3\x10\x3\x10\x3\x10\x3\x10");
		sb.Append("\a\x10\x357\n\x10\f\x10\xE\x10\x35A\v\x10\x3\x10\x3\x10\x5\x10");
		sb.Append("\x35E\n\x10\x3\x10\x3\x10\x3\x10\x5\x10\x363\n\x10\x3\x10\a");
		sb.Append("\x10\x366\n\x10\f\x10\xE\x10\x369\v\x10\x3\x11\x3\x11\x3\x11");
		sb.Append("\x3\x11\x3\x11\x3\x11\x3\x11\x3\x11\x3\x11\x5\x11\x374\n\x11");
		sb.Append("\x3\x11\x5\x11\x377\n\x11\x3\x11\x3\x11\x5\x11\x37B\n\x11\x3");
		sb.Append("\x11\x5\x11\x37E\n\x11\x3\x11\x3\x11\x5\x11\x382\n\x11\x3\x11");
		sb.Append("\x5\x11\x385\n\x11\x3\x11\x3\x11\x5\x11\x389\n\x11\x3\x11\x5");
		sb.Append("\x11\x38C\n\x11\x3\x11\x5\x11\x38F\n\x11\x3\x11\x3\x11\x5\x11");
		sb.Append("\x393\n\x11\x3\x11\x5\x11\x396\n\x11\x3\x11\x3\x11\x5\x11\x39A");
		sb.Append("\n\x11\x3\x11\x3\x11\x3\x12\x3\x12\x5\x12\x3A0\n\x12\x3\x12");
		sb.Append("\x3\x12\x3\x12\x3\x12\x5\x12\x3A6\n\x12\x3\x12\x3\x12\a\x12");
		sb.Append("\x3AA\n\x12\f\x12\xE\x12\x3AD\v\x12\x3\x12\x3\x12\a\x12\x3B1");
		sb.Append("\n\x12\f\x12\xE\x12\x3B4\v\x12\x3\x12\x3\x12\x3\x13\x3\x13\x5");
		sb.Append("\x13\x3BA\n\x13\x3\x13\x3\x13\x3\x13\x3\x13\x5\x13\x3C0\n\x13");
		sb.Append("\x3\x13\x3\x13\a\x13\x3C4\n\x13\f\x13\xE\x13\x3C7\v\x13\x3\x13");
		sb.Append("\x3\x13\x3\x13\x3\x13\a\x13\x3CD\n\x13\f\x13\xE\x13\x3D0\v\x13");
		sb.Append("\x3\x13\x3\x13\x5\x13\x3D4\n\x13\x3\x14\x3\x14\x3\x14\x3\x14");
		sb.Append("\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\a\x14");
		sb.Append("\x3E2\n\x14\f\x14\xE\x14\x3E5\v\x14\x3\x14\x3\x14\x3\x15\x3");
		sb.Append("\x15\x5\x15\x3EB\n\x15\x3\x15\x3\x15\x5\x15\x3EF\n\x15\x3\x15");
		sb.Append("\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15\x5\x15\x3F9");
		sb.Append("\n\x15\x3\x15\x3\x15\x5\x15\x3FD\n\x15\x3\x15\x3\x15\x5\x15");
		sb.Append("\x401\n\x15\x3\x15\x3\x15\x5\x15\x405\n\x15\x3\x15\x3\x15\x5");
		sb.Append("\x15\x409\n\x15\x3\x15\a\x15\x40C\n\x15\f\x15\xE\x15\x40F\v");
		sb.Append("\x15\x5\x15\x411\n\x15\x3\x15\x5\x15\x414\n\x15\x3\x15\x5\x15");
		sb.Append("\x417\n\x15\x3\x15\x5\x15\x41A\n\x15\x3\x15\x3\x15\x3\x15\x3");
		sb.Append("\x15\x5\x15\x420\n\x15\x3\x15\x3\x15\x5\x15\x424\n\x15\x3\x15");
		sb.Append("\x3\x15\x3\x15\x3\x15\x5\x15\x42A\n\x15\x3\x15\a\x15\x42D\n");
		sb.Append("\x15\f\x15\xE\x15\x430\v\x15\x5\x15\x432\n\x15\x3\x15\x5\x15");
		sb.Append("\x435\n\x15\x5\x15\x437\n\x15\x3\x16\x3\x16\x3\x16\x3\x16\x3");
		sb.Append("\x16\x3\x16\x3\x16\x3\x16\x3\x16\x5\x16\x442\n\x16\x3\x16\x3");
		sb.Append("\x16\x5\x16\x446\n\x16\x3\x16\x5\x16\x449\n\x16\x3\x17\x3\x17");
		sb.Append("\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3");
		sb.Append("\x17\x3\x17\x5\x17\x457\n\x17\x3\x17\x5\x17\x45A\n\x17\x3\x17");
		sb.Append("\x3\x17\x5\x17\x45E\n\x17\x3\x17\x5\x17\x461\n\x17\x3\x17\x3");
		sb.Append("\x17\x5\x17\x465\n\x17\x3\x17\x5\x17\x468\n\x17\x3\x17\x3\x17");
		sb.Append("\x5\x17\x46C\n\x17\x3\x17\x5\x17\x46F\n\x17\x3\x17\x3\x17\x5");
		sb.Append("\x17\x473\n\x17\x3\x17\x5\x17\x476\n\x17\x3\x17\x5\x17\x479");
		sb.Append("\n\x17\x3\x17\x3\x17\x5\x17\x47D\n\x17\x3\x17\x5\x17\x480\n");
		sb.Append("\x17\x3\x17\x3\x17\x5\x17\x484\n\x17\x3\x17\x3\x17\x3\x18\x3");
		sb.Append("\x18\x5\x18\x48A\n\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3");
		sb.Append("\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\x497\n\x18\x3");
		sb.Append("\x18\x3\x18\x3\x19\x3\x19\x3\x19\x5\x19\x49E\n\x19\x3\x19\x3");
		sb.Append("\x19\x3\x19\x5\x19\x4A3\n\x19\x3\x19\x5\x19\x4A6\n\x19\x3\x19");
		sb.Append("\x3\x19\x3\x19\x5\x19\x4AB\n\x19\x3\x19\x3\x19\x3\x19\x3\x19");
		sb.Append("\x3\x19\x3\x19\x5\x19\x4B3\n\x19\x3\x19\x3\x19\x3\x19\x3\x19");
		sb.Append("\x5\x19\x4B9\n\x19\x3\x19\x3\x19\x5\x19\x4BD\n\x19\x3\x1A\x5");
		sb.Append("\x1A\x4C0\n\x1A\x3\x1A\x3\x1A\x3\x1A\x5\x1A\x4C5\n\x1A\x3\x1A");
		sb.Append("\x5\x1A\x4C8\n\x1A\x3\x1A\x3\x1A\x5\x1A\x4CC\n\x1A\x3\x1A\x5");
		sb.Append("\x1A\x4CF\n\x1A\x3\x1A\x3\x1A\x5\x1A\x4D3\n\x1A\x3\x1A\x5\x1A");
		sb.Append("\x4D6\n\x1A\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x5\x1B");
		sb.Append("\x4DE\n\x1B\x5\x1B\x4E0\n\x1B\x3\x1C\x3\x1C\x3\x1C\a\x1C\x4E5");
		sb.Append("\n\x1C\f\x1C\xE\x1C\x4E8\v\x1C\x3\x1C\x3\x1C\x3\x1C\x5\x1C\x4ED");
		sb.Append("\n\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\a\x1C\x4F3\n\x1C\f\x1C\xE");
		sb.Append("\x1C\x4F6\v\x1C\x5\x1C\x4F8\n\x1C\x3\x1C\x3\x1C\x3\x1C\a\x1C");
		sb.Append("\x4FD\n\x1C\f\x1C\xE\x1C\x500\v\x1C\x5\x1C\x502\n\x1C\x5\x1C");
		sb.Append("\x504\n\x1C\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x5\x1D\x50A\n\x1D\x3");
		sb.Append("\x1E\x3\x1E\x3\x1E\x3\x1E\x5\x1E\x510\n\x1E\x3\x1E\x3\x1E\x3");
		sb.Append("\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F");
		sb.Append("\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x5\x1F\x521\n\x1F\x3 \x3 \x3 \x3");
		sb.Append(" \x3 \x5 \x528\n \x3!\x3!\x3!\x3\"\x3\"\x5\"\x52F\n\"\x3\"\x3");
		sb.Append("\"\x3\"\x3\"\x3\"\x3\"\x3\"\x3\"\x3\"\x5\"\x53A\n\"\x3#\x5#");
		sb.Append("\x53D\n#\x3#\x3#\x3#\x3$\x3$\x3$\x3%\x3%\x3%\x3%\x3%\x5%\x54A");
		sb.Append("\n%\x3%\x3%\x3%\x3%\x3%\x3%\x3%\x3%\x3%\x3%\x3%\x5%\x557\n%");
		sb.Append("\x3%\x3%\x3%\x5%\x55C\n%\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3");
		sb.Append("&\x3&\x3&\x3&\x3&\x3&\x5&\x56C\n&\x3\'\x3\'\x3\'\x3\'\a\'\x572");
		sb.Append("\n\'\f\'\xE\'\x575\v\'\x3\'\x3\'\x3(\x3(\x3(\x3(\x3(\x5(\x57E");
		sb.Append("\n(\x3)\x3)\a)\x582\n)\f)\xE)\x585\v)\x3*\x3*\x3*\x3*\x3*\x3");
		sb.Append("*\x3*\x5*\x58E\n*\x3*\x5*\x591\n*\x3*\x3*\x3*\x5*\x596\n*\x3");
		sb.Append("*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x5*\x5A3\n*\x3*\x3");
		sb.Append("*\x3*\x3*\x3*\x5*\x5AA\n*\x3*\x3*\x3*\x5*\x5AF\n*\x3+\x3+\x5");
		sb.Append("+\x5B3\n+\x5+\x5B5\n+\x3+\x3+\x3+\x5+\x5BA\n+\x3+\x5+\x5BD\n");
		sb.Append("+\x3+\x3+\a+\x5C1\n+\f+\xE+\x5C4\v+\x3+\x3+\x5+\x5C8\n+\x5+");
		sb.Append("\x5CA\n+\x3+\x3+\x5+\x5CE\n+\x3+\x5+\x5D1\n+\x3+\x5+\x5D4\n");
		sb.Append("+\x3+\x3+\a+\x5D8\n+\f+\xE+\x5DB\v+\x3+\x3+\x5+\x5DF\n+\x5+");
		sb.Append("\x5E1\n+\x3+\x3+\x3+\x5+\x5E6\n+\x3+\x3+\x3+\x3+\x3+\x5+\x5ED");
		sb.Append("\n+\x5+\x5EF\n+\x3+\x3+\x3+\x3+\x3+\x5+\x5F6\n+\x3,\x3,\x3,");
		sb.Append("\x5,\x5FB\n,\x3,\x3,\x5,\x5FF\n,\x3,\x5,\x602\n,\x3-\x3-\x3");
		sb.Append("-\x3-\x3-\x3-\x5-\x60A\n-\x3-\x3-\x3-\x3-\x3-\x3-\x5-\x612\n");
		sb.Append("-\x5-\x614\n-\x3.\x3.\x3.\x3.\x3.\x3.\x5.\x61C\n.\x3/\x3/\x5");
		sb.Append("/\x620\n/\x3/\x5/\x623\n/\x3/\x3/\a/\x627\n/\f/\xE/\x62A\v/");
		sb.Append("\x3/\x3/\x5/\x62E\n/\x3/\x5/\x631\n/\x3/\x3/\a/\x635\n/\f/\xE");
		sb.Append("/\x638\v/\x5/\x63A\n/\x3\x30\x3\x30\x5\x30\x63E\n\x30\x3\x30");
		sb.Append("\x3\x30\x3\x30\x5\x30\x643\n\x30\x3\x30\x3\x30\x3\x30\x5\x30");
		sb.Append("\x648\n\x30\x3\x30\x3\x30\x5\x30\x64C\n\x30\x3\x30\x3\x30\x3");
		sb.Append("\x30\x5\x30\x651\n\x30\x3\x30\x5\x30\x654\n\x30\x3\x30\x3\x30");
		sb.Append("\x5\x30\x658\n\x30\x3\x30\x3\x30\x5\x30\x65C\n\x30\x3\x30\x3");
		sb.Append("\x30\x5\x30\x660\n\x30\x3\x30\x3\x30\x5\x30\x664\n\x30\x3\x30");
		sb.Append("\x3\x30\x3\x30\x5\x30\x669\n\x30\x3\x30\x3\x30\x3\x30\x5\x30");
		sb.Append("\x66E\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x673\n\x30\x3\x30\x3");
		sb.Append("\x30\x3\x30\x3\x30\x5\x30\x679\n\x30\x3\x30\x3\x30\x3\x30\x5");
		sb.Append("\x30\x67E\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x683\n\x30\x3\x30");
		sb.Append("\x3\x30\x3\x30\x3\x30\x5\x30\x689\n\x30\x3\x30\x3\x30\x3\x30");
		sb.Append("\x5\x30\x68E\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x693\n\x30\x3");
		sb.Append("\x30\x3\x30\x3\x30\x5\x30\x698\n\x30\x3\x30\x3\x30\x3\x30\x5");
		sb.Append("\x30\x69D\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x6A2\n\x30\x3\x30");
		sb.Append("\x3\x30\x3\x30\x5\x30\x6A7\n\x30\x3\x30\x3\x30\x3\x30\x5\x30");
		sb.Append("\x6AC\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x6B1\n\x30\x3\x30\x3");
		sb.Append("\x30\x3\x30\x5\x30\x6B6\n\x30\x3\x30\x3\x30\x3\x30\x5\x30\x6BB");
		sb.Append("\n\x30\x3\x30\x3\x30\x3\x30\x3\x30\x5\x30\x6C1\n\x30\x3\x30");
		sb.Append("\x3\x30\x3\x30\x5\x30\x6C6\n\x30\x3\x30\x3\x30\x3\x30\x3\x30");
		sb.Append("\x5\x30\x6CC\n\x30\x3\x31\x3\x31\x3\x31\x3\x32\x3\x32\x3\x32");
		sb.Append("\x3\x32\x3\x32\x5\x32\x6D6\n\x32\x3\x32\x3\x32\x3\x32\x3\x32");
		sb.Append("\x3\x32\x5\x32\x6DD\n\x32\x5\x32\x6DF\n\x32\x3\x32\x3\x32\x3");
		sb.Append("\x32\x3\x32\a\x32\x6E5\n\x32\f\x32\xE\x32\x6E8\v\x32\x3\x32");
		sb.Append("\x3\x32\x5\x32\x6EC\n\x32\x3\x33\x5\x33\x6EF\n\x33\x3\x33\x3");
		sb.Append("\x33\x3\x33\x3\x33\x3\x33\x3\x33\x5\x33\x6F7\n\x33\x3\x33\x3");
		sb.Append("\x33\x3\x33\x3\x33\x5\x33\x6FD\n\x33\x3\x33\x3\x33\x3\x33\x3");
		sb.Append("\x33\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33");
		sb.Append("\x3\x33\x3\x33\x5\x33\x70D\n\x33\x3\x33\x3\x33\x3\x33\x3\x33");
		sb.Append("\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33\x5\x33\x719\n\x33");
		sb.Append("\x5\x33\x71B\n\x33\x3\x34\x5\x34\x71E\n\x34\x3\x34\x3\x34\x3");
		sb.Append("\x34\x3\x34\x3\x34\x3\x34\x5\x34\x726\n\x34\x3\x34\x3\x34\x3");
		sb.Append("\x34\x3\x34\x5\x34\x72C\n\x34\x3\x34\x3\x34\x3\x34\x3\x34\x5");
		sb.Append("\x34\x732\n\x34\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3");
		sb.Append("\x35\x3\x35\x3\x35\a\x35\x73D\n\x35\f\x35\xE\x35\x740\v\x35");
		sb.Append("\x3\x35\x3\x35\a\x35\x744\n\x35\f\x35\xE\x35\x747\v\x35\x3\x35");
		sb.Append("\x3\x35\x3\x35\a\x35\x74C\n\x35\f\x35\xE\x35\x74F\v\x35\x5\x35");
		sb.Append("\x751\n\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35");
		sb.Append("\a\x35\x75A\n\x35\f\x35\xE\x35\x75D\v\x35\x3\x35\x3\x35\x3\x35");
		sb.Append("\a\x35\x762\n\x35\f\x35\xE\x35\x765\v\x35\x5\x35\x767\n\x35");
		sb.Append("\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\a\x35");
		sb.Append("\x771\n\x35\f\x35\xE\x35\x774\v\x35\x3\x35\x3\x35\a\x35\x778");
		sb.Append("\n\x35\f\x35\xE\x35\x77B\v\x35\x3\x35\x3\x35\x3\x35\a\x35\x780");
		sb.Append("\n\x35\f\x35\xE\x35\x783\v\x35\x5\x35\x785\n\x35\x3\x35\x3\x35");
		sb.Append("\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\a\x35\x78F\n\x35");
		sb.Append("\f\x35\xE\x35\x792\v\x35\x3\x35\x3\x35\a\x35\x796\n\x35\f\x35");
		sb.Append("\xE\x35\x799\v\x35\x3\x35\x3\x35\x3\x35\a\x35\x79E\n\x35\f\x35");
		sb.Append("\xE\x35\x7A1\v\x35\x5\x35\x7A3\n\x35\x3\x35\x3\x35\x3\x35\a");
		sb.Append("\x35\x7A8\n\x35\f\x35\xE\x35\x7AB\v\x35\x3\x35\x3\x35\x3\x35");
		sb.Append("\a\x35\x7B0\n\x35\f\x35\xE\x35\x7B3\v\x35\x5\x35\x7B5\n\x35");
		sb.Append("\x5\x35\x7B7\n\x35\x3\x36\x3\x36\x3\x36\x5\x36\x7BC\n\x36\x3");
		sb.Append("\x37\x3\x37\x3\x37\x3\x37\x6\x37\x7C2\n\x37\r\x37\xE\x37\x7C3");
		sb.Append("\x3\x37\x3\x37\x3\x38\x3\x38\x3\x38\a\x38\x7CB\n\x38\f\x38\xE");
		sb.Append("\x38\x7CE\v\x38\x3\x39\x5\x39\x7D1\n\x39\x3\x39\x3\x39\x5\x39");
		sb.Append("\x7D5\n\x39\x3\x39\x3\x39\x3\x39\x5\x39\x7DA\n\x39\x3\x39\x3");
		sb.Append("\x39\x3\x39\x3\x39\x5\x39\x7E0\n\x39\x3\x39\x3\x39\x3\x39\x3");
		sb.Append("\x39\x5\x39\x7E6\n\x39\x3\x39\x3\x39\x3\x39\x5\x39\x7EB\n\x39");
		sb.Append("\x3\x39\x3\x39\x3\x39\x5\x39\x7F0\n\x39\x3\x39\x3\x39\x3\x39");
		sb.Append("\x5\x39\x7F5\n\x39\x3\x39\x3\x39\x3\x39\x5\x39\x7FA\n\x39\x3");
		sb.Append("\x39\x5\x39\x7FD\n\x39\x3:\x3:\x3:\x5:\x802\n:\x3:\x6:\x805");
		sb.Append("\n:\r:\xE:\x806\x3:\x3:\x3:\x3:\x3:\x3:\x3:\x3:\x5:\x811\n:");
		sb.Append("\x3;\x3;\x5;\x815\n;\x3;\x3;\x3;\x3;\x3;\x5;\x81C\n;\x3;\x3");
		sb.Append(";\x3;\x5;\x821\n;\x3;\x5;\x824\n;\x3;\x3;\x3;\x5;\x829\n;\x3");
		sb.Append(";\x5;\x82C\n;\x3;\x3;\x5;\x830\n;\x3;\x3;\x5;\x834\n;\x3<\x3");
		sb.Append("<\x3<\x3<\a<\x83A\n<\f<\xE<\x83D\v<\x3=\x3=\x3=\x3=\x3=\x3=");
		sb.Append("\x3=\x3>\x3>\x3>\x3>\x3>\x3>\x3>\x3>\x3>\x5>\x84F\n>\x3>\x5");
		sb.Append(">\x852\n>\x3>\x5>\x855\n>\x3>\x3>\x5>\x859\n>\x3>\x3>\x3?\x3");
		sb.Append("?\x3?\x3?\a?\x861\n?\f?\xE?\x864\v?\x3@\x3@\x3@\x3@\x3@\x3@");
		sb.Append("\x3@\x3@\a@\x86E\n@\f@\xE@\x871\v@\x3@\x3@\x3\x41\x3\x41\x5");
		sb.Append("\x41\x877\n\x41\x3\x41\x5\x41\x87A\n\x41\x3\x41\x3\x41\x3\x41");
		sb.Append("\x3\x41\x3\x41\a\x41\x881\n\x41\f\x41\xE\x41\x884\v\x41\x5\x41");
		sb.Append("\x886\n\x41\x3\x41\x5\x41\x889\n\x41\x3\x42\x3\x42\x3\x42\x3");
		sb.Append("\x42\x3\x42\x3\x42\x3\x42\x3\x42\x3\x42\x5\x42\x894\n\x42\x3");
		sb.Append("\x42\x5\x42\x897\n\x42\x3\x42\x3\x42\x5\x42\x89B\n\x42\x3\x42");
		sb.Append("\x3\x42\x3\x43\x3\x43\x3\x43\x3\x43\x5\x43\x8A3\n\x43\x3\x43");
		sb.Append("\x5\x43\x8A6\n\x43\x3\x43\x3\x43\x3\x43\x5\x43\x8AB\n\x43\x3");
		sb.Append("\x43\x3\x43\x3\x43\x3\x43\x3\x43\x3\x43\x5\x43\x8B3\n\x43\x3");
		sb.Append("\x43\x3\x43\x3\x43\x3\x43\x5\x43\x8B9\n\x43\x3\x43\x3\x43\x5");
		sb.Append("\x43\x8BD\n\x43\x3\x44\x3\x44\x5\x44\x8C1\n\x44\x3\x44\a\x44");
		sb.Append("\x8C4\n\x44\f\x44\xE\x44\x8C7\v\x44\x3\x44\x3\x44\x5\x44\x8CB");
		sb.Append("\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x8D2\n\x44");
		sb.Append("\x3\x44\x3\x44\x5\x44\x8D6\n\x44\x3\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\a\x44\x8DF\n\x44\f\x44\xE\x44\x8E2\v\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x8E9\n\x44\x3\x44");
		sb.Append("\x5\x44\x8EC\n\x44\x3\x44\x3\x44\a\x44\x8F0\n\x44\f\x44\xE\x44");
		sb.Append("\x8F3\v\x44\x3\x44\x3\x44\x3\x44\x5\x44\x8F8\n\x44\x5\x44\x8FA");
		sb.Append("\n\x44\x3\x44\x3\x44\x3\x44\x5\x44\x8FF\n\x44\x3\x44\x3\x44");
		sb.Append("\a\x44\x903\n\x44\f\x44\xE\x44\x906\v\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x5\x44\x90B\n\x44\x5\x44\x90D\n\x44\x3\x44\x3\x44\x5\x44\x911");
		sb.Append("\n\x44\x3\x44\x5\x44\x914\n\x44\x3\x44\x5\x44\x917\n\x44\x3");
		sb.Append("\x44\x3\x44\a\x44\x91B\n\x44\f\x44\xE\x44\x91E\v\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x5\x44\x923\n\x44\x3\x44\x5\x44\x926\n\x44\x3");
		sb.Append("\x44\x3\x44\a\x44\x92A\n\x44\f\x44\xE\x44\x92D\v\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x5\x44\x932\n\x44\x5\x44\x934\n\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x5\x44\x939\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x5\x44\x941\n\x44\x5\x44\x943\n\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x94C\n\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x5\x44\x951\n\x44\x3\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x5\x44\x959\n\x44\x3\x44\x3\x44\x5\x44\x95D\n");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x965\n");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x5\x44\x96F\n\x44\x3\x44\x3\x44\x3\x44\x5\x44\x974\n\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x97B\n\x44\x3\x44\x3");
		sb.Append("\x44\x5\x44\x97F\n\x44\x3\x44\x3\x44\x5\x44\x983\n\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x99B\n\x44\x3\x44\x3\x44");
		sb.Append("\x5\x44\x99F\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x9AB\n\x44\x3\x44\x5\x44");
		sb.Append("\x9AE\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x5\x44\x9B7\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\a\x44\x9C6");
		sb.Append("\n\x44\f\x44\xE\x44\x9C9\v\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x9D4\n\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x5\x44\x9DB\n\x44\x3\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x5\x44\x9E2\n\x44\x3\x44\x3\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\a\x44");
		sb.Append("\x9EF\n\x44\f\x44\xE\x44\x9F2\v\x44\x3\x44\x3\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\x9FE\n");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\xA04\n\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x5\x44\xA0A\n\x44\x3\x44\x3\x44\x3\x44\x3");
		sb.Append("\x44\x5\x44\xA10\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\xA16");
		sb.Append("\n\x44\x3\x44\x3\x44\x3\x44\x3\x44\x5\x44\xA1C\n\x44\x3\x44");
		sb.Append("\x3\x44\x3\x44\x3\x44\x5\x44\xA22\n\x44\x3\x45\x3\x45\x3\x45");
		sb.Append("\x5\x45\xA27\n\x45\x3\x45\x3\x45\x3\x46\x3\x46\x3\x46\x5\x46");
		sb.Append("\xA2E\n\x46\x3\x46\x3\x46\x3G\x3G\x3G\x5G\xA35\nG\x3G\x3G\x3");
		sb.Append("G\x3G\x3G\x5G\xA3C\nG\x3G\x3G\x3G\x5G\xA41\nG\x3G\aG\xA44\n");
		sb.Append("G\fG\xEG\xA47\vG\x3H\x3H\x3H\x3H\x3H\x3H\x3H\x3H\x3I\x3I\x3");
		sb.Append("I\x5I\xA54\nI\x3I\x3I\x3J\x3J\x3J\x5J\xA5B\nJ\x3J\x3J\x3K\x3");
		sb.Append("K\x3K\x5K\xA62\nK\x3K\x3K\x3L\x3L\x5L\xA68\nL\x3L\x3L\x5L\xA6C");
		sb.Append("\nL\x3L\x3L\x5L\xA70\nL\x3M\x3M\x3M\x3M\x3M\x5M\xA77\nM\x3M");
		sb.Append("\x5M\xA7A\nM\x3N\x3N\x3N\x5N\xA7F\nN\x3N\x3N\x3O\x3O\x3O\x5");
		sb.Append("O\xA86\nO\x3O\x3O\x3O\aO\xA8B\nO\fO\xEO\xA8E\vO\x3O\x5O\xA91");
		sb.Append("\nO\x3P\x3P\x3P\x3P\x3P\aP\xA98\nP\fP\xEP\xA9B\vP\x3Q\x3Q\x3");
		sb.Append("Q\x3Q\x3R\x3R\x5R\xAA3\nR\x3R\x3R\x3S\x3S\x3S\x3S\x3S\x5S\xAAC");
		sb.Append("\nS\x3S\x5S\xAAF\nS\x3T\x3T\x5T\xAB3\nT\x3U\x3U\x3U\x3V\x3V");
		sb.Append("\x3V\x3V\x5V\xABC\nV\x3W\x3W\x5W\xAC0\nW\x3W\x5W\xAC3\nW\x3");
		sb.Append("W\x5W\xAC6\nW\x3W\x3W\x3W\x3W\x3W\x3W\x5W\xACE\nW\x3W\x3W\x3");
		sb.Append("W\x3W\x5W\xAD4\nW\x3W\x3W\x3W\x3W\x3W\aW\xADB\nW\fW\xEW\xADE");
		sb.Append("\vW\x5W\xAE0\nW\x3W\x3W\x3W\x3W\x3W\x3W\x3W\aW\xAE9\nW\fW\xE");
		sb.Append("W\xAEC\vW\x5W\xAEE\nW\x3X\x3X\x3X\x5X\xAF3\nX\x3X\x5X\xAF6\n");
		sb.Append("X\x3X\x3X\x3X\x5X\xAFB\nX\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x5");
		sb.Append("X\xB05\nX\x3X\x3X\x3X\x5X\xB0A\nX\x3X\x3X\x6X\xB0E\nX\rX\xE");
		sb.Append("X\xB0F\x5X\xB12\nX\x3X\x3X\x6X\xB16\nX\rX\xEX\xB17\x5X\xB1A");
		sb.Append("\nX\x3X\x3X\x3X\x3X\x5X\xB20\nX\x3X\x3X\x3X\x3X\aX\xB26\nX\f");
		sb.Append("X\xEX\xB29\vX\x3X\x3X\x5X\xB2D\nX\x3X\x3X\x3X\x3X\aX\xB33\n");
		sb.Append("X\fX\xEX\xB36\vX\x5X\xB38\nX\x3Y\x3Y\x3Y\x5Y\xB3D\nY\x3Y\x5");
		sb.Append("Y\xB40\nY\x3Y\x3Y\x3Y\x5Y\xB45\nY\x3Y\x3Y\x3Y\x3Y\x3Y\x3Y\x5");
		sb.Append("Y\xB4D\nY\x3Y\x3Y\x3Y\x3Y\x3Y\x3Y\x5Y\xB55\nY\x3Y\x3Y\x3Y\x3");
		sb.Append("Y\x5Y\xB5B\nY\x3Y\x3Y\x3Y\x3Y\aY\xB61\nY\fY\xEY\xB64\vY\x3Y");
		sb.Append("\x3Y\x5Y\xB68\nY\x3Y\x3Y\x3Y\x3Y\aY\xB6E\nY\fY\xEY\xB71\vY\x5");
		sb.Append("Y\xB73\nY\x3Z\x3Z\x5Z\xB77\nZ\x3Z\x5Z\xB7A\nZ\x3Z\x3Z\x3Z\x3");
		sb.Append("Z\x3Z\x3Z\x5Z\xB82\nZ\x3Z\x3Z\x3Z\x3Z\x5Z\xB88\nZ\x3Z\x3Z\x3");
		sb.Append("Z\x3Z\x3Z\aZ\xB8F\nZ\fZ\xEZ\xB92\vZ\x5Z\xB94\nZ\x3[\x3[\x5[");
		sb.Append("\xB98\n[\x3[\x3[\x5[\xB9C\n[\x3[\x3[\x6[\xBA0\n[\r[\xE[\xBA1");
		sb.Append("\x3[\x3[\x5[\xBA6\n[\x3[\x3[\x5[\xBAA\n[\x5[\xBAC\n[\x3[\x5");
		sb.Append("[\xBAF\n[\x3[\x5[\xBB2\n[\x3[\x5[\xBB5\n[\x3[\x3[\x6[\xBB9\n");
		sb.Append("[\r[\xE[\xBBA\x3[\x3[\x5[\xBBF\n[\x3[\x5[\xBC2\n[\x3[\x5[\xBC5");
		sb.Append("\n[\x3[\x5[\xBC8\n[\x3[\x5[\xBCB\n[\x5[\xBCD\n[\x3\\\x3\\\x5");
		sb.Append("\\\xBD1\n\\\x3]\x3]\x3]\x3]\x3]\x3]\x3]\x3]\x3]\x3]\a]\xBDD");
		sb.Append("\n]\f]\xE]\xBE0\v]\x5]\xBE2\n]\x3^\x3^\x3^\x3^\x5^\xBE8\n^\x3");
		sb.Append("_\x3_\x5_\xBEC\n_\x3`\x3`\x3`\x3`\x3`\x3`\x5`\xBF4\n`\x3\x61");
		sb.Append("\x3\x61\x5\x61\xBF8\n\x61\x3\x61\x5\x61\xBFB\n\x61\x3\x61\x5");
		sb.Append("\x61\xBFE\n\x61\x3\x61\x3\x61\x3\x61\x3\x61\x3\x61\x3\x61\x3");
		sb.Append("\x61\x5\x61\xC07\n\x61\x3\x61\x3\x61\x5\x61\xC0B\n\x61\x3\x61");
		sb.Append("\x5\x61\xC0E\n\x61\x3\x61\x3\x61\x5\x61\xC12\n\x61\x3\x62\x3");
		sb.Append("\x62\x5\x62\xC16\n\x62\x3\x62\x5\x62\xC19\n\x62\x3\x62\x5\x62");
		sb.Append("\xC1C\n\x62\x3\x62\x3\x62\x3\x62\x5\x62\xC21\n\x62\x3\x62\x3");
		sb.Append("\x62\x3\x62\x3\x62\x5\x62\xC27\n\x62\a\x62\xC29\n\x62\f\x62");
		sb.Append("\xE\x62\xC2C\v\x62\x3\x62\x3\x62\x3\x62\x3\x62\x3\x62\x3\x62");
		sb.Append("\x3\x62\x5\x62\xC35\n\x62\x3\x62\x3\x62\x3\x62\x3\x62\x5\x62");
		sb.Append("\xC3B\n\x62\a\x62\xC3D\n\x62\f\x62\xE\x62\xC40\v\x62\x3\x62");
		sb.Append("\x3\x62\x3\x62\x5\x62\xC45\n\x62\x3\x62\x3\x62\x5\x62\xC49\n");
		sb.Append("\x62\x3\x63\x3\x63\x3\x63\x3\x63\x5\x63\xC4F\n\x63\x3\x63\x5");
		sb.Append("\x63\xC52\n\x63\x3\x64\x3\x64\x3\x64\x3\x64\x3\x64\x3\x64\x3");
		sb.Append("\x64\x3\x64\x3\x64\x3\x64\x5\x64\xC5E\n\x64\x3\x64\x3\x64\x5");
		sb.Append("\x64\xC62\n\x64\x3\x64\x3\x64\x5\x64\xC66\n\x64\x3\x65\x3\x65");
		sb.Append("\x3\x65\x3\x65\x3\x65\x3\x65\x5\x65\xC6E\n\x65\x3\x65\x3\x65");
		sb.Append("\x5\x65\xC72\n\x65\x3\x66\x3\x66\x3\x66\x3\x66\x3g\x3g\x5g\xC7A");
		sb.Append("\ng\x3g\x5g\xC7D\ng\x3g\x3g\x5g\xC81\ng\x3g\x5g\xC84\ng\x3g");
		sb.Append("\x3g\x3g\x3g\ag\xC8A\ng\fg\xEg\xC8D\vg\x3g\x3g\x5g\xC91\ng\x3");
		sb.Append("g\x5g\xC94\ng\x3g\x5g\xC97\ng\x3h\x3h\x5h\xC9B\nh\x3h\x5h\xC9E");
		sb.Append("\nh\x3h\x3h\x3h\x3h\x3h\ah\xCA5\nh\fh\xEh\xCA8\vh\x3h\x3h\x5");
		sb.Append("h\xCAC\nh\x3i\x3i\x3i\x3i\x3i\ai\xCB3\ni\fi\xEi\xCB6\vi\x3j");
		sb.Append("\x3j\x5j\xCBA\nj\x3k\x3k\x3k\ak\xCBF\nk\fk\xEk\xCC2\vk\x3l\x3");
		sb.Append("l\al\xCC6\nl\fl\xEl\xCC9\vl\x3l\x3l\x3l\al\xCCE\nl\fl\xEl\xCD1");
		sb.Append("\vl\x3l\x3l\x5l\xCD5\nl\x3m\x3m\x3m\x3m\x3m\x3m\x5m\xCDD\nm");
		sb.Append("\x3m\x5m\xCE0\nm\x3m\x5m\xCE3\nm\x3m\x3m\x3m\am\xCE8\nm\fm\xE");
		sb.Append("m\xCEB\vm\x5m\xCED\nm\x3m\x3m\x3m\x3m\x3m\x5m\xCF4\nm\x3m\x5");
		sb.Append("m\xCF7\nm\x3m\x3m\x3m\x3m\x3m\x3m\x5m\xCFF\nm\x3n\x3n\x3n\x3");
		sb.Append("n\x5n\xD05\nn\x3n\x3n\x3n\x3n\x3o\x3o\x3o\x3o\x3o\x5o\xD10\n");
		sb.Append("o\x3p\x5p\xD13\np\x3p\x3p\x3p\x3p\x3p\x3p\x3p\x3p\x3p\x5p\xD1E");
		sb.Append("\np\x3p\x3p\x3p\x3p\x5p\xD24\np\x3p\x3p\x5p\xD28\np\x3p\x3p");
		sb.Append("\x3p\x3p\x3p\x3p\x3p\x3p\x3p\x5p\xD33\np\x3p\x3p\x3p\x5p\xD38");
		sb.Append("\np\x5p\xD3A\np\x3p\x3p\x5p\xD3E\np\x3q\x3q\x3q\x3q\x3q\x3q");
		sb.Append("\x3q\x3q\x5q\xD48\nq\x3r\x3r\x3r\x3r\x3r\x3r\x3r\x3r\x5r\xD52");
		sb.Append("\nr\x3s\x3s\as\xD56\ns\fs\xEs\xD59\vs\x3s\x3s\x5s\xD5D\ns\x3");
		sb.Append("s\x5s\xD60\ns\x3s\x5s\xD63\ns\x3s\x5s\xD66\ns\x3s\x3s\as\xD6A");
		sb.Append("\ns\fs\xEs\xD6D\vs\x3s\x3s\x5s\xD71\ns\x3s\x5s\xD74\ns\x3s\x5");
		sb.Append("s\xD77\ns\x3s\x5s\xD7A\ns\x5s\xD7C\ns\x3t\x3t\at\xD80\nt\ft");
		sb.Append("\xEt\xD83\vt\x3t\x3t\x5t\xD87\nt\x3t\x5t\xD8A\nt\x3t\x5t\xD8D");
		sb.Append("\nt\x3u\x3u\x5u\xD91\nu\x3u\x3u\x3v\x3v\x5v\xD97\nv\x3v\x3v");
		sb.Append("\x5v\xD9B\nv\x3w\x3w\x3w\x3w\x3w\x3w\x3w\x3w\x5w\xDA5\nw\x3");
		sb.Append("x\x3x\x5x\xDA9\nx\x3x\x3x\ax\xDAD\nx\fx\xEx\xDB0\vx\x3y\x3y");
		sb.Append("\x3y\x3y\x3y\x3y\x5y\xDB8\ny\x3y\x5y\xDBB\ny\x3y\x3y\x5y\xDBF");
		sb.Append("\ny\x3y\x5y\xDC2\ny\x3y\x3y\x5y\xDC6\ny\x3y\x3y\x5y\xDCA\ny");
		sb.Append("\x3y\x5y\xDCD\ny\x5y\xDCF\ny\x3z\x3z\x3z\x3z\az\xDD5\nz\fz\xE");
		sb.Append("z\xDD8\vz\x3z\x3z\x3z\x3z\x3z\x3z\x3z\x3z\x3z\x5z\xDE3\nz\x3");
		sb.Append("z\x3z\x6z\xDE7\nz\rz\xEz\xDE8\x5z\xDEB\nz\x3z\x3z\x6z\xDEF\n");
		sb.Append("z\rz\xEz\xDF0\x5z\xDF3\nz\x5z\xDF5\nz\x3{\x3{\x3{\x3{\x5{\xDFB");
		sb.Append("\n{\x3{\x3{\x3{\x3{\x3{\x3{\x5{\xE03\n{\x3|\x3|\x3|\x3|\x3|");
		sb.Append("\x3|\x5|\xE0B\n|\x3}\x3}\x3}\x3}\x5}\xE11\n}\x3}\x3}\x3}\x3");
		sb.Append("}\x3}\a}\xE18\n}\f}\xE}\xE1B\v}\x3}\x3}\x5}\xE1F\n}\x5}\xE21");
		sb.Append("\n}\x3}\x3}\x5}\xE25\n}\x3~\x3~\x5~\xE29\n~\x3\x7F\x3\x7F\x3");
		sb.Append("\x7F\x3\x7F\x5\x7F\xE2F\n\x7F\x3\x7F\x3\x7F\x3\x7F\x3\x7F\x3");
		sb.Append("\x7F\x5\x7F\xE36\n\x7F\x3\x80\x3\x80\x5\x80\xE3A\n\x80\x3\x81");
		sb.Append("\x3\x81\x3\x81\x3\x81\x3\x81\a\x81\xE41\n\x81\f\x81\xE\x81\xE44");
		sb.Append("\v\x81\x5\x81\xE46\n\x81\x3\x82\x3\x82\x5\x82\xE4A\n\x82\x3");
		sb.Append("\x83\x3\x83\x5\x83\xE4E\n\x83\x3\x83\x3\x83\x5\x83\xE52\n\x83");
		sb.Append("\x3\x83\x5\x83\xE55\n\x83\x3\x83\x5\x83\xE58\n\x83\x3\x83\x5");
		sb.Append("\x83\xE5B\n\x83\x3\x84\x3\x84\x5\x84\xE5F\n\x84\x3\x84\x3\x84");
		sb.Append("\x5\x84\xE63\n\x84\x3\x84\x5\x84\xE66\n\x84\x3\x84\x5\x84\xE69");
		sb.Append("\n\x84\x3\x84\x5\x84\xE6C\n\x84\x3\x85\x3\x85\x3\x85\x3\x86");
		sb.Append("\x3\x86\x5\x86\xE73\n\x86\x3\x86\x3\x86\x5\x86\xE77\n\x86\x3");
		sb.Append("\x86\x3\x86\x3\x87\x3\x87\x3\x87\x3\x87\x3\x88\x3\x88\x3\x88");
		sb.Append("\x3\x88\x3\x88\a\x88\xE84\n\x88\f\x88\xE\x88\xE87\v\x88\x3\x89");
		sb.Append("\x3\x89\x3\x89\x3\x8A\x3\x8A\x3\x8A\x3\x8A\x3\x8A\x3\x8B\x3");
		sb.Append("\x8B\x5\x8B\xE93\n\x8B\x3\x8B\x3\x8B\x3\x8B\x3\x8B\a\x8B\xE99");
		sb.Append("\n\x8B\f\x8B\xE\x8B\xE9C\v\x8B\x3\x8C\x3\x8C\x3\x8C\x3\x8C\x3");
		sb.Append("\x8C\x3\x8C\x3\x8C\x5\x8C\xEA5\n\x8C\x3\x8D\x3\x8D\x5\x8D\xEA9");
		sb.Append("\n\x8D\x3\x8D\x5\x8D\xEAC\n\x8D\x3\x8D\x3\x8D\x3\x8E\x3\x8E");
		sb.Append("\x5\x8E\xEB2\n\x8E\x3\x8E\x5\x8E\xEB5\n\x8E\x3\x8E\x5\x8E\xEB8");
		sb.Append("\n\x8E\x3\x8F\x3\x8F\x3\x8F\x3\x8F\x3\x8F\x3\x8F\x3\x8F\x5\x8F");
		sb.Append("\xEC1\n\x8F\x3\x90\x3\x90\x3\x90\x3\x90\x3\x90\x3\x90\x3\x90");
		sb.Append("\x5\x90\xECA\n\x90\x3\x91\x3\x91\x3\x91\x3\x91\x3\x91\x3\x91");
		sb.Append("\a\x91\xED2\n\x91\f\x91\xE\x91\xED5\v\x91\x3\x91\x5\x91\xED8");
		sb.Append("\n\x91\x3\x92\x3\x92\x3\x92\x3\x92\x3\x92\x3\x92\a\x92\xEE0");
		sb.Append("\n\x92\f\x92\xE\x92\xEE3\v\x92\x3\x93\x3\x93\x3\x93\x3\x93\x3");
		sb.Append("\x93\x3\x93\x3\x93\x5\x93\xEEC\n\x93\x3\x94\x3\x94\x3\x94\x3");
		sb.Append("\x95\x3\x95\x3\x95\x5\x95\xEF4\n\x95\x3\x95\x5\x95\xEF7\n\x95");
		sb.Append("\x3\x96\x3\x96\x3\x96\x3\x96\x3\x96\a\x96\xEFE\n\x96\f\x96\xE");
		sb.Append("\x96\xF01\v\x96\x5\x96\xF03\n\x96\x3\x96\x3\x96\x5\x96\xF07");
		sb.Append("\n\x96\x3\x96\a\x96\xF0A\n\x96\f\x96\xE\x96\xF0D\v\x96\x3\x96");
		sb.Append("\x5\x96\xF10\n\x96\x3\x97\x3\x97\x3\x97\x3\x97\x3\x97\a\x97");
		sb.Append("\xF17\n\x97\f\x97\xE\x97\xF1A\v\x97\x5\x97\xF1C\n\x97\x3\x98");
		sb.Append("\x3\x98\x3\x98\x3\x99\x3\x99\x3\x99\x3\x9A\x3\x9A\x3\x9A\x3");
		sb.Append("\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A");
		sb.Append("\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3");
		sb.Append("\x9A\a\x9A\xF39\n\x9A\f\x9A\xE\x9A\xF3C\v\x9A\x5\x9A\xF3E\n");
		sb.Append("\x9A\x3\x9A\x5\x9A\xF41\n\x9A\x3\x9B\x3\x9B\x3\x9C\x3\x9C\x3");
		sb.Append("\x9D\x3\x9D\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9F\x3\x9F\x3\x9F");
		sb.Append("\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3");
		sb.Append("\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F");
		sb.Append("\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3");
		sb.Append("\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F");
		sb.Append("\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\a\x9F\xF77\n\x9F\f\x9F\xE");
		sb.Append("\x9F\xF7A\v\x9F\x3\x9F\x3\x9F\x5\x9F\xF7E\n\x9F\x3\xA0\x3\xA0");
		sb.Append("\x3\xA0\x3\xA0\x3\xA0\x3\xA0\x3\xA1\x3\xA1\x3\xA2\x3\xA2\x3");
		sb.Append("\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2");
		sb.Append("\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x5\xA2\xF9A");
		sb.Append("\n\xA2\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3");
		sb.Append("\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x5\xA3\xFA8\n\xA3\x3\xA4\x3\xA4");
		sb.Append("\x3\xA4\a\xA4\xFAD\n\xA4\f\xA4\xE\xA4\xFB0\v\xA4\x3\xA4\x5\xA4");
		sb.Append("\xFB3\n\xA4\x3\xA5\x3\xA5\x3\xA5\x3\xA5\x5\xA5\xFB9\n\xA5\x3");
		sb.Append("\xA6\x3\xA6\x3\xA6\x3\xA6\x3\xA6\x3\xA6\x5\xA6\xFC1\n\xA6\x5");
		sb.Append("\xA6\xFC3\n\xA6\x3\xA7\x3\xA7\x3\xA7\x3\xA7\x3\xA8\x3\xA8\x3");
		sb.Append("\xA8\x3\xA8\x3\xA8\x5\xA8\xFCE\n\xA8\x3\xA9\x3\xA9\x3\xA9\x3");
		sb.Append("\xA9\x3\xAA\x3\xAA\x3\xAA\x3\xAA\x5\xAA\xFD8\n\xAA\x3\xAB\x3");
		sb.Append("\xAB\x3\xAB\x3\xAB\x3\xAB\x5\xAB\xFDF\n\xAB\x3\xAC\x3\xAC\x3");
		sb.Append("\xAC\x3\xAC\x5\xAC\xFE5\n\xAC\x3\xAD\x3\xAD\x3\xAD\x3\xAD\x3");
		sb.Append("\xAE\x3\xAE\x5\xAE\xFED\n\xAE\x3\xAF\x3\xAF\x3\xAF\x5\xAF\xFF2");
		sb.Append("\n\xAF\x3\xAF\x3\xAF\x3\xAF\x3\xAF\a\xAF\xFF8\n\xAF\f\xAF\xE");
		sb.Append("\xAF\xFFB\v\xAF\x3\xAF\x3\xAF\x3\xAF\a\xAF\x1000\n\xAF\f\xAF");
		sb.Append("\xE\xAF\x1003\v\xAF\x3\xAF\x3\xAF\x3\xAF\a\xAF\x1008\n\xAF\f");
		sb.Append("\xAF\xE\xAF\x100B\v\xAF\x3\xAF\x3\xAF\x3\xAF\a\xAF\x1010\n\xAF");
		sb.Append("\f\xAF\xE\xAF\x1013\v\xAF\x3\xAF\a\xAF\x1016\n\xAF\f\xAF\xE");
		sb.Append("\xAF\x1019\v\xAF\x5\xAF\x101B\n\xAF\x3\xAF\x3\xAF\x5\xAF\x101F");
		sb.Append("\n\xAF\x3\xB0\x3\xB0\x3\xB0\x5\xB0\x1024\n\xB0\x3\xB0\x6\xB0");
		sb.Append("\x1027\n\xB0\r\xB0\xE\xB0\x1028\x3\xB0\x3\xB0\x6\xB0\x102D\n");
		sb.Append("\xB0\r\xB0\xE\xB0\x102E\x5\xB0\x1031\n\xB0\x3\xB0\x3\xB0\x3");
		sb.Append("\xB0\x3\xB1\x3\xB1\x3\xB1\x3\xB1\x6\xB1\x103A\n\xB1\r\xB1\xE");
		sb.Append("\xB1\x103B\x3\xB1\a\xB1\x103F\n\xB1\f\xB1\xE\xB1\x1042\v\xB1");
		sb.Append("\x3\xB1\x3\xB1\x6\xB1\x1046\n\xB1\r\xB1\xE\xB1\x1047\x5\xB1");
		sb.Append("\x104A\n\xB1\x3\xB1\x3\xB1\x3\xB1\x3\xB2\x3\xB2\x3\xB2\x3\xB3");
		sb.Append("\x3\xB3\x3\xB3\x3\xB4\x3\xB4\x3\xB4\x5\xB4\x1058\n\xB4\x3\xB4");
		sb.Append("\x3\xB4\x6\xB4\x105C\n\xB4\r\xB4\xE\xB4\x105D\x3\xB4\x3\xB4");
		sb.Append("\x3\xB4\x5\xB4\x1063\n\xB4\x3\xB5\x3\xB5\x3\xB5\x5\xB5\x1068");
		sb.Append("\n\xB5\x3\xB5\x3\xB5\x6\xB5\x106C\n\xB5\r\xB5\xE\xB5\x106D\x3");
		sb.Append("\xB5\x3\xB5\x3\xB5\x3\xB5\x3\xB5\x5\xB5\x1075\n\xB5\x3\xB6\x3");
		sb.Append("\xB6\x3\xB6\x3\xB7\x3\xB7\x3\xB7\x5\xB7\x107D\n\xB7\x3\xB7\x3");
		sb.Append("\xB7\x3\xB7\x3\xB7\x6\xB7\x1083\n\xB7\r\xB7\xE\xB7\x1084\x3");
		sb.Append("\xB7\x3\xB7\x3\xB7\x5\xB7\x108A\n\xB7\x3\xB8\x3\xB8\x3\xB8\x3");
		sb.Append("\xB8\x5\xB8\x1090\n\xB8\x3\xB8\x5\xB8\x1093\n\xB8\x3\xB8\x3");
		sb.Append("\xB8\x3\xB8\x3\xB8\x3\xB8\x3\xB8\x5\xB8\x109B\n\xB8\x3\xB9\x3");
		sb.Append("\xB9\x3\xB9\x3\xB9\x3\xB9\x5\xB9\x10A2\n\xB9\x3\xBA\x3\xBA\x3");
		sb.Append("\xBA\x3\xBA\x3\xBA\x3\xBA\x3\xBA\x5\xBA\x10AB\n\xBA\x3\xBA\x5");
		sb.Append("\xBA\x10AE\n\xBA\x3\xBB\x3\xBB\x3\xBB\x3\xBB\x3\xBB\x3\xBB\x3");
		sb.Append("\xBC\x3\xBC\x3\xBC\x3\xBC\x3\xBC\x3\xBC\x3\xBC\a\xBC\x10BD\n");
		sb.Append("\xBC\f\xBC\xE\xBC\x10C0\v\xBC\x3\xBC\x3\xBC\x3\xBD\x3\xBD\x3");
		sb.Append("\xBD\x5\xBD\x10C7\n\xBD\x3\xBD\x3\xBD\x3\xBD\x3\xBD\x3\xBD\x3");
		sb.Append("\xBD\x5\xBD\x10CF\n\xBD\x3\xBE\x3\xBE\x5\xBE\x10D3\n\xBE\x3");
		sb.Append("\xBE\x3\xBE\x3\xBF\x3\xBF\x3\xBF\x5\xBF\x10DA\n\xBF\x3\xBF\x3");
		sb.Append("\xBF\x6\xBF\x10DE\n\xBF\r\xBF\xE\xBF\x10DF\x3\xC0\x3\xC0\x3");
		sb.Append("\xC0\x3\xC0\x6\xC0\x10E6\n\xC0\r\xC0\xE\xC0\x10E7\x3\xC1\x3");
		sb.Append("\xC1\x3\xC1\x3\xC1\x3\xC1\a\xC1\x10EF\n\xC1\f\xC1\xE\xC1\x10F2");
		sb.Append("\v\xC1\x3\xC1\x3\xC1\x3\xC1\x5\xC1\x10F7\n\xC1\x3\xC1\x3\xC1");
		sb.Append("\x3\xC1\a\xC1\x10FC\n\xC1\f\xC1\xE\xC1\x10FF\v\xC1\x3\xC1\x3");
		sb.Append("\xC1\x3\xC1\x3\xC1\x5\xC1\x1105\n\xC1\x3\xC1\a\xC1\x1108\n\xC1");
		sb.Append("\f\xC1\xE\xC1\x110B\v\xC1\x5\xC1\x110D\n\xC1\x5\xC1\x110F\n");
		sb.Append("\xC1\x3\xC1\x3\xC1\x6\xC1\x1113\n\xC1\r\xC1\xE\xC1\x1114\x5");
		sb.Append("\xC1\x1117\n\xC1\x3\xC1\x3\xC1\a\xC1\x111B\n\xC1\f\xC1\xE\xC1");
		sb.Append("\x111E\v\xC1\x5\xC1\x1120\n\xC1\x3\xC2\x3\xC2\x3\xC2\x3\xC2");
		sb.Append("\x3\xC2\a\xC2\x1127\n\xC2\f\xC2\xE\xC2\x112A\v\xC2\x3\xC2\x3");
		sb.Append("\xC2\x3\xC2\x5\xC2\x112F\n\xC2\x3\xC2\x3\xC2\x3\xC2\a\xC2\x1134");
		sb.Append("\n\xC2\f\xC2\xE\xC2\x1137\v\xC2\x3\xC2\x3\xC2\x3\xC2\x3\xC2");
		sb.Append("\x5\xC2\x113D\n\xC2\x3\xC2\a\xC2\x1140\n\xC2\f\xC2\xE\xC2\x1143");
		sb.Append("\v\xC2\x5\xC2\x1145\n\xC2\x5\xC2\x1147\n\xC2\x3\xC2\x3\xC2\x6");
		sb.Append("\xC2\x114B\n\xC2\r\xC2\xE\xC2\x114C\x5\xC2\x114F\n\xC2\x3\xC2");
		sb.Append("\x3\xC2\a\xC2\x1153\n\xC2\f\xC2\xE\xC2\x1156\v\xC2\x5\xC2\x1158");
		sb.Append("\n\xC2\x3\xC3\x3\xC3\x3\xC3\x5\xC3\x115D\n\xC3\x3\xC3\x3\xC3");
		sb.Append("\x3\xC3\a\xC3\x1162\n\xC3\f\xC3\xE\xC3\x1165\v\xC3\x3\xC4\x3");
		sb.Append("\xC4\x3\xC4\x3\xC4\a\xC4\x116B\n\xC4\f\xC4\xE\xC4\x116E\v\xC4");
		sb.Append("\x3\xC4\x3\xC4\x5\xC4\x1172\n\xC4\x3\xC4\x3\xC4\x3\xC4\x3\xC4");
		sb.Append("\x3\xC4\a\xC4\x1179\n\xC4\f\xC4\xE\xC4\x117C\v\xC4\x3\xC4\x3");
		sb.Append("\xC4\x3\xC4\x3\xC4\x5\xC4\x1182\n\xC4\x3\xC4\a\xC4\x1185\n\xC4");
		sb.Append("\f\xC4\xE\xC4\x1188\v\xC4\x5\xC4\x118A\n\xC4\x5\xC4\x118C\n");
		sb.Append("\xC4\x3\xC4\x3\xC4\x3\xC4\x3\xC4\a\xC4\x1192\n\xC4\f\xC4\xE");
		sb.Append("\xC4\x1195\v\xC4\x5\xC4\x1197\n\xC4\x3\xC5\x3\xC5\x3\xC5\x3");
		sb.Append("\xC5\x3\xC5\x3\xC5\x3\xC5\x3\xC5\a\xC5\x11A1\n\xC5\f\xC5\xE");
		sb.Append("\xC5\x11A4\v\xC5\x3\xC5\x3\xC5\x3\xC5\x5\xC5\x11A9\n\xC5\x3");
		sb.Append("\xC6\x3\xC6\x3\xC6\x3\xC6\x3\xC6\a\xC6\x11B0\n\xC6\f\xC6\xE");
		sb.Append("\xC6\x11B3\v\xC6\x3\xC7\x3\xC7\x3\xC7\x3\xC7\a\xC7\x11B9\n\xC7");
		sb.Append("\f\xC7\xE\xC7\x11BC\v\xC7\x3\xC7\x3\xC7\x5\xC7\x11C0\n\xC7\x3");
		sb.Append("\xC7\x3\xC7\x3\xC7\x3\xC7\x3\xC7\a\xC7\x11C7\n\xC7\f\xC7\xE");
		sb.Append("\xC7\x11CA\v\xC7\x3\xC7\x3\xC7\x3\xC7\x5\xC7\x11CF\n\xC7\x3");
		sb.Append("\xC7\x3\xC7\x3\xC7\x3\xC7\x3\xC7\x3\xC7\x3\xC7\a\xC7\x11D8\n");
		sb.Append("\xC7\f\xC7\xE\xC7\x11DB\v\xC7\x5\xC7\x11DD\n\xC7\x3\xC8\x3\xC8");
		sb.Append("\x3\xC8\x3\xC8\x3\xC8\x3\xC8\x3\xC8\x3\xC8\a\xC8\x11E7\n\xC8");
		sb.Append("\f\xC8\xE\xC8\x11EA\v\xC8\x3\xC9\x3\xC9\x3\xC9\x3\xC9\x5\xC9");
		sb.Append("\x11F0\n\xC9\x3\xC9\x3\xC9\x3\xC9\x5\xC9\x11F5\n\xC9\x3\xCA");
		sb.Append("\x3\xCA\x3\xCA\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x3");
		sb.Append("\xCB\x3\xCB\x3\xCB\x3\xCB\x5\xCB\x1204\n\xCB\x3\xCB\x3\xCB\x3");
		sb.Append("\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x5\xCB\x120F");
		sb.Append("\n\xCB\x3\xCB\x5\xCB\x1212\n\xCB\x3\xCC\x3\xCC\x3\xCC\x3\xCC");
		sb.Append("\x3\xCC\x3\xCC\x3\xCC\x3\xCC\x5\xCC\x121C\n\xCC\x3\xCD\x3\xCD");
		sb.Append("\x3\xCD\x3\xCD\x3\xCD\x3\xCD\x3\xCD\x3\xCD\x5\xCD\x1226\n\xCD");
		sb.Append("\x3\xCE\x3\xCE\x3\xCE\x3\xCE\x3\xCE\x3\xCE\x3\xCE\x3\xCE\x5");
		sb.Append("\xCE\x1230\n\xCE\x3\xCF\x3\xCF\x3\xCF\x3\xD0\x3\xD0\x3\xD0\x3");
		sb.Append("\xD0\x3\xD0\x5\xD0\x123A\n\xD0\x3\xD1\x3\xD1\x5\xD1\x123E\n");
		sb.Append("\xD1\x3\xD1\x3\xD1\x5\xD1\x1242\n\xD1\x3\xD1\x3\xD1\x3\xD1\x3");
		sb.Append("\xD1\x3\xD1\x3\xD1\x3\xD1\x5\xD1\x124B\n\xD1\x3\xD1\x3\xD1\x3");
		sb.Append("\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1");
		sb.Append("\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3");
		sb.Append("\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\x5\xD1\x1267");
		sb.Append("\n\xD1\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2");
		sb.Append("\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x5");
		sb.Append("\xD2\x1279\n\xD2\x3\xD3\x3\xD3\x3\xD3\x3\xD3\x3\xD4\x3\xD4\x5");
		sb.Append("\xD4\x1281\n\xD4\x3\xD4\x3\xD4\x3\xD4\x3\xD5\x3\xD5\x3\xD5\x3");
		sb.Append("\xD5\a\xD5\x128A\n\xD5\f\xD5\xE\xD5\x128D\v\xD5\x3\xD6\x3\xD6");
		sb.Append("\x3\xD6\x3\xD6\x5\xD6\x1293\n\xD6\x3\xD7\x3\xD7\x5\xD7\x1297");
		sb.Append("\n\xD7\x3\xD7\x3\xD7\x3\xD7\x3\xD8\x3\xD8\x5\xD8\x129E\n\xD8");
		sb.Append("\x3\xD8\x3\xD8\x3\xD8\x5\xD8\x12A3\n\xD8\x3\xD8\x5\xD8\x12A6");
		sb.Append("\n\xD8\x3\xD8\x5\xD8\x12A9\n\xD8\x3\xD9\x3\xD9\x3\xD9\x3\xD9");
		sb.Append("\x3\xD9\x3\xD9\x3\xD9\x5\xD9\x12B2\n\xD9\x3\xDA\x3\xDA\x5\xDA");
		sb.Append("\x12B6\n\xDA\x3\xDA\x3\xDA\x3\xDA\x3\xDA\x3\xDA\x3\xDA\x3\xDA");
		sb.Append("\x3\xDB\x3\xDB\x3\xDB\x3\xDB\x3\xDB\x3\xDB\x3\xDC\x3\xDC\x3");
		sb.Append("\xDC\x3\xDC\x3\xDD\x3\xDD\x3\xDD\x3\xDD\x3\xDD\x3\xDD\x3\xDD");
		sb.Append("\x3\xDD\x3\xDD\a\xDD\x12D2\n\xDD\f\xDD\xE\xDD\x12D5\v\xDD\x3");
		sb.Append("\xDD\x3\xDD\x3\xDD\x3\xDD\x5\xDD\x12DB\n\xDD\x3\xDD\x3\xDD\x5");
		sb.Append("\xDD\x12DF\n\xDD\x3\xDD\x3\xDD\x3\xDD\x3\xDD\x3\xDD\x5\xDD\x12E6");
		sb.Append("\n\xDD\x3\xDD\x5\xDD\x12E9\n\xDD\x3\xDD\x3\xDD\x3\xDD\x3\xDD");
		sb.Append("\x3\xDD\x3\xDD\x3\xDD\x3\xDD\x5\xDD\x12F3\n\xDD\x3\xDE\x3\xDE");
		sb.Append("\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x12FD\n\xDE");
		sb.Append("\x3\xDE\x3\xDE\x5\xDE\x1301\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE");
		sb.Append("\x5\xDE\x1307\n\xDE\x3\xDE\x5\xDE\x130A\n\xDE\x3\xDE\x3\xDE");
		sb.Append("\x3\xDE\x5\xDE\x130F\n\xDE\x3\xDE\x3\xDE\x5\xDE\x1313\n\xDE");
		sb.Append("\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x131A\n\xDE\x3\xDE");
		sb.Append("\x5\xDE\x131D\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x1323");
		sb.Append("\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE");
		sb.Append("\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3");
		sb.Append("\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x133B\n\xDE\x3");
		sb.Append("\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE");
		sb.Append("\x3\xDE\x3\xDE\x5\xDE\x1348\n\xDE\x3\xDE\x5\xDE\x134B\n\xDE");
		sb.Append("\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x5");
		sb.Append("\xDE\x1355\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x5");
		sb.Append("\xDE\x135D\n\xDE\x3\xDE\x3\xDE\x5\xDE\x1361\n\xDE\x3\xDE\x3");
		sb.Append("\xDE\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x1368\n\xDE\x3\xDE\x5\xDE\x136B");
		sb.Append("\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\a\xDE\x1372\n\xDE");
		sb.Append("\f\xDE\xE\xDE\x1375\v\xDE\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x137A");
		sb.Append("\n\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x1380\n\xDE\x3\xDE");
		sb.Append("\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x5\xDE\x138A");
		sb.Append("\n\xDE\x5\xDE\x138C\n\xDE\x3\xDF\x3\xDF\x3\xDF\x3\xDF\x5\xDF");
		sb.Append("\x1392\n\xDF\x3\xDF\x5\xDF\x1395\n\xDF\x3\xDF\x5\xDF\x1398\n");
		sb.Append("\xDF\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0");
		sb.Append("\x3\xE0\x3\xE0\x5\xE0\x13A4\n\xE0\x3\xE0\x5\xE0\x13A7\n\xE0");
		sb.Append("\x3\xE1\x3\xE1\x3\xE1\x3\xE1\x5\xE1\x13AD\n\xE1\x3\xE2\x5\xE2");
		sb.Append("\x13B0\n\xE2\x3\xE2\x3\xE2\x3\xE2\x3\xE2\x3\xE2\x3\xE2\x5\xE2");
		sb.Append("\x13B8\n\xE2\x3\xE2\x3\xE2\x3\xE2\x3\xE2\x3\xE2\x3\xE2\x5\xE2");
		sb.Append("\x13C0\n\xE2\x3\xE3\x3\xE3\x3\xE3\x3\xE3\x5\xE3\x13C6\n\xE3");
		sb.Append("\x3\xE3\x3\xE3\x5\xE3\x13CA\n\xE3\x3\xE4\x3\xE4\x3\xE4\x3\xE4");
		sb.Append("\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x5");
		sb.Append("\xE4\x13D8\n\xE4\x3\xE5\x3\xE5\x3\xE5\x3\xE6\x3\xE6\x3\xE6\x3");
		sb.Append("\xE6\x3\xE6\a\xE6\x13E2\n\xE6\f\xE6\xE\xE6\x13E5\v\xE6\x3\xE6");
		sb.Append("\x3\xE6\x3\xE6\x3\xE6\x5\xE6\x13EB\n\xE6\x3\xE6\x5\xE6\x13EE");
		sb.Append("\n\xE6\x3\xE6\x3\xE6\x3\xE6\x3\xE7\x3\xE7\x5\xE7\x13F5\n\xE7");
		sb.Append("\x3\xE7\x3\xE7\x3\xE7\a\xE7\x13FA\n\xE7\f\xE7\xE\xE7\x13FD\v");
		sb.Append("\xE7\x3\xE8\x3\xE8\x5\xE8\x1401\n\xE8\x3\xE8\x6\xE8\x1404\n");
		sb.Append("\xE8\r\xE8\xE\xE8\x1405\x3\xE9\x3\xE9\x3\xE9\x3\xE9\x3\xE9\x3");
		sb.Append("\xE9\x3\xE9\a\xE9\x140F\n\xE9\f\xE9\xE\xE9\x1412\v\xE9\x3\xEA");
		sb.Append("\x3\xEA\x3\xEA\x3\xEA\x3\xEB\x3\xEB\x3\xEC\x3\xEC\x5\xEC\x141C");
		sb.Append("\n\xEC\x3\xEC\x3\xEC\x3\xEC\x3\xEC\x5\xEC\x1422\n\xEC\x3\xED");
		sb.Append("\x3\xED\x3\xED\x5\xED\x1427\n\xED\x3\xED\x3\xED\x3\xED\x3\xED");
		sb.Append("\x3\xED\x3\xED\x3\xED\x3\xED\x3\xED\x3\xED\x3\xED\x5\xED\x1434");
		sb.Append("\n\xED\x5\xED\x1436\n\xED\x3\xED\x3\xED\x3\xED\x5\xED\x143B");
		sb.Append("\n\xED\x3\xED\x3\xED\x3\xED\x5\xED\x1440\n\xED\x5\xED\x1442");
		sb.Append("\n\xED\x3\xEE\x3\xEE\x3\xEE\x3\xEE\x3\xEE\x5\xEE\x1449\n\xEE");
		sb.Append("\x3\xEF\x3\xEF\x3\xEF\x3\xEF\x3\xEF\x5\xEF\x1450\n\xEF\x3\xEF");
		sb.Append("\x5\xEF\x1453\n\xEF\x3\xEF\x5\xEF\x1456\n\xEF\x3\xEF\x3\xEF");
		sb.Append("\x3\xEF\x3\xEF\x5\xEF\x145C\n\xEF\x3\xEF\x3\xEF\x5\xEF\x1460");
		sb.Append("\n\xEF\x3\xF0\x3\xF0\x3\xF0\x3\xF0\x5\xF0\x1466\n\xF0\x3\xF1");
		sb.Append("\x3\xF1\x3\xF1\x3\xF1\x5\xF1\x146C\n\xF1\x3\xF1\x3\xF1\x3\xF2");
		sb.Append("\x3\xF2\x3\xF2\x3\xF3\x3\xF3\x3\xF3\x3\xF4\x3\xF4\x3\xF4\x5");
		sb.Append("\xF4\x1479\n\xF4\x3\xF4\x3\xF4\x3\xF4\x5\xF4\x147E\n\xF4\x3");
		sb.Append("\xF4\x3\xF4\x3\xF4\x3\xF4\a\xF4\x1484\n\xF4\f\xF4\xE\xF4\x1487");
		sb.Append("\v\xF4\x5\xF4\x1489\n\xF4\x3\xF5\x3\xF5\x3\xF5\x3\xF5\x5\xF5");
		sb.Append("\x148F\n\xF5\x3\xF6\x3\xF6\x3\xF6\x3\xF6\x3\xF6\x5\xF6\x1496");
		sb.Append("\n\xF6\x3\xF6\x3\xF6\x3\xF6\x5\xF6\x149B\n\xF6\x3\xF7\x3\xF7");
		sb.Append("\x3\xF7\x3\xF7\x5\xF7\x14A1\n\xF7\x3\xF8\x3\xF8\x3\xF9\x3\xF9");
		sb.Append("\x3\xF9\x5\xF9\x14A8\n\xF9\x5\xF9\x14AA\n\xF9\x3\xFA\x3\xFA");
		sb.Append("\x5\xFA\x14AE\n\xFA\x3\xFA\x3\xFA\x3\xFA\x3\xFA\x5\xFA\x14B4");
		sb.Append("\n\xFA\x3\xFA\x5\xFA\x14B7\n\xFA\x3\xFB\x3\xFB\x3\xFC\x3\xFC");
		sb.Append("\x3\xFD\x3\xFD\x3\xFD\x3\xFD\x5\xFD\x14C1\n\xFD\x3\xFE\x3\xFE");
		sb.Append("\x5\xFE\x14C5\n\xFE\x3\xFF\x3\xFF\x3\x100\x3\x100\x3\x100\x3");
		sb.Append("\x100\x3\x100\x3\x100\x3\x100\x3\x100\x3\x100\x3\x100\x3\x100");
		sb.Append("\x3\x100\x3\x100\x3\x100\x6\x100\x14D7\n\x100\r\x100\xE\x100");
		sb.Append("\x14D8\x3\x101\x3\x101\x3\x101\x3\x101\x3\x101\x5\x101\x14E0");
		sb.Append("\n\x101\x5\x101\x14E2\n\x101\x3\x102\x3\x102\x3\x102\x6\x102");
		sb.Append("\x14E7\n\x102\r\x102\xE\x102\x14E8\x5\x102\x14EB\n\x102\x3\x103");
		sb.Append("\x3\x103\x5\x103\x14EF\n\x103\x3\x104\x3\x104\x3\x104\x5\x104");
		sb.Append("\x14F4\n\x104\x3\x105\x3\x105\x3\x105\x3\x105\x3\x105\x3\x105");
		sb.Append("\x3\x105\x3\x105\x3\x105\x5\x105\x14FF\n\x105\x3\x106\x3\x106");
		sb.Append("\x3\x106\x5\x106\x1504\n\x106\x3\x107\x3\x107\x3\x108\x3\x108");
		sb.Append("\x5\x108\x150A\n\x108\x3\x109\x5\x109\x150D\n\x109\x3\x109\x3");
		sb.Append("\x109\x5\x109\x1511\n\x109\x3\x109\x6\x109\x1514\n\x109\r\x109");
		sb.Append("\xE\x109\x1515\x3\x109\x5\x109\x1519\n\x109\x3\x109\x3\x109");
		sb.Append("\x5\x109\x151D\n\x109\x3\x109\x3\x109\x5\x109\x1521\n\x109\x5");
		sb.Append("\x109\x1523\n\x109\x3\x10A\x3\x10A\x3\x10B\x5\x10B\x1528\n\x10B");
		sb.Append("\x3\x10B\x3\x10B\x3\x10C\x5\x10C\x152D\n\x10C\x3\x10C\x3\x10C");
		sb.Append("\x3\x10D\x3\x10D\x3\x10D\x3\x10D\x3\x10D\x3\x10D\x3\x10D\x3");
		sb.Append("\x10D\x3\x10D\x5\x10D\x153A\n\x10D\x3\x10D\x5\x10D\x153D\n\x10D");
		sb.Append("\x3\x10E\x3\x10E\x5\x10E\x1541\n\x10E\x3\x10E\x5\x10E\x1544");
		sb.Append("\n\x10E\x3\x10E\x3\x10E\x3\x10E\x5\x10E\x1549\n\x10E\x3\x10E");
		sb.Append("\x5\x10E\x154C\n\x10E\x3\x10E\x3\x10E\x5\x10E\x1550\n\x10E\x3");
		sb.Append("\x10E\x3\x10E\x3\x10E\x5\x10E\x1555\n\x10E\x3\x10E\x5\x10E\x1558");
		sb.Append("\n\x10E\x3\x10E\x3\x10E\x3\x10E\x5\x10E\x155D\n\x10E\x3\x10E");
		sb.Append("\x5\x10E\x1560\n\x10E\x3\x10E\x3\x10E\x3\x10E\x3\x10E\x5\x10E");
		sb.Append("\x1566\n\x10E\x3\x10E\x5\x10E\x1569\n\x10E\x3\x10E\x3\x10E\x5");
		sb.Append("\x10E\x156D\n\x10E\x3\x10E\x5\x10E\x1570\n\x10E\x3\x10E\x5\x10E");
		sb.Append("\x1573\n\x10E\x3\x10E\x3\x10E\x5\x10E\x1577\n\x10E\x3\x10E\x5");
		sb.Append("\x10E\x157A\n\x10E\x3\x10E\x5\x10E\x157D\n\x10E\x3\x10E\x3\x10E");
		sb.Append("\x5\x10E\x1581\n\x10E\x3\x10E\x5\x10E\x1584\n\x10E\x3\x10E\x5");
		sb.Append("\x10E\x1587\n\x10E\x3\x10E\x5\x10E\x158A\n\x10E\x3\x10E\x3\x10E");
		sb.Append("\x5\x10E\x158E\n\x10E\x3\x10E\x5\x10E\x1591\n\x10E\x3\x10E\x5");
		sb.Append("\x10E\x1594\n\x10E\x3\x10E\x3\x10E\x3\x10E\x5\x10E\x1599\n\x10E");
		sb.Append("\x3\x10E\x3\x10E\x3\x10E\x5\x10E\x159E\n\x10E\x3\x10E\x3\x10E");
		sb.Append("\x3\x10E\x5\x10E\x15A3\n\x10E\x3\x10E\x5\x10E\x15A6\n\x10E\x3");
		sb.Append("\x10E\x5\x10E\x15A9\n\x10E\x3\x10F\x3\x10F\x3\x10F\x3\x10F\a");
		sb.Append("\x10F\x15AF\n\x10F\f\x10F\xE\x10F\x15B2\v\x10F\x3\x10F\x3\x10F");
		sb.Append("\x3\x110\x3\x110\x5\x110\x15B8\n\x110\x3\x110\x3\x110\x5\x110");
		sb.Append("\x15BC\n\x110\x3\x110\x3\x110\x3\x110\x5\x110\x15C1\n\x110\x3");
		sb.Append("\x110\x5\x110\x15C4\n\x110\x3\x110\x3\x110\x3\x110\x5\x110\x15C9");
		sb.Append("\n\x110\x3\x110\x3\x110\x5\x110\x15CD\n\x110\x5\x110\x15CF\n");
		sb.Append("\x110\x3\x111\x3\x111\x3\x111\x3\x111\x3\x112\x3\x112\x3\x112");
		sb.Append("\x3\x112\x3\x112\x3\x112\x3\x113\x3\x113\x3\x113\x3\x113\x5");
		sb.Append("\x113\x15DF\n\x113\x3\x113\x3\x113\x3\x114\x3\x114\x3\x114\a");
		sb.Append("\x114\x15E6\n\x114\f\x114\xE\x114\x15E9\v\x114\x3\x115\x3\x115");
		sb.Append("\x3\x115\a\x115\x15EE\n\x115\f\x115\xE\x115\x15F1\v\x115\x3");
		sb.Append("\x116\x3\x116\x3\x116\x3\x116\a\x116\x15F7\n\x116\f\x116\xE");
		sb.Append("\x116\x15FA\v\x116\x3\x116\x3\x116\x3\x117\x3\x117\x3\x117\a");
		sb.Append("\x117\x1601\n\x117\f\x117\xE\x117\x1604\v\x117\x3\x118\x3\x118");
		sb.Append("\x3\x118\a\x118\x1609\n\x118\f\x118\xE\x118\x160C\v\x118\x3");
		sb.Append("\x119\x3\x119\x3\x119\a\x119\x1611\n\x119\f\x119\xE\x119\x1614");
		sb.Append("\v\x119\x3\x11A\x3\x11A\x3\x11A\a\x11A\x1619\n\x11A\f\x11A\xE");
		sb.Append("\x11A\x161C\v\x11A\x3\x11B\x3\x11B\x3\x11B\a\x11B\x1621\n\x11B");
		sb.Append("\f\x11B\xE\x11B\x1624\v\x11B\x3\x11C\x3\x11C\x5\x11C\x1628\n");
		sb.Append("\x11C\x3\x11C\x3\x11C\x3\x11C\x3\x11C\x3\x11C\x5\x11C\x162F");
		sb.Append("\n\x11C\x5\x11C\x1631\n\x11C\x3\x11D\x3\x11D\x3\x11D\x5\x11D");
		sb.Append("\x1636\n\x11D\x3\x11D\x5\x11D\x1639\n\x11D\x3\x11D\x3\x11D\x3");
		sb.Append("\x11D\x5\x11D\x163E\n\x11D\x3\x11D\x5\x11D\x1641\n\x11D\x3\x11E");
		sb.Append("\x3\x11E\x5\x11E\x1645\n\x11E\x3\x11F\x3\x11F\x3\x11F\x3\x120");
		sb.Append("\x3\x120\x3\x120\x3\x120\x3\x121\x3\x121\x3\x121\x3\x121\x3");
		sb.Append("\x121\x5\x121\x1653\n\x121\x3\x121\x3\x121\x3\x121\x3\x121\x3");
		sb.Append("\x121\x5\x121\x165A\n\x121\x3\x121\x3\x121\x3\x121\x5\x121\x165F");
		sb.Append("\n\x121\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122");
		sb.Append("\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3");
		sb.Append("\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122");
		sb.Append("\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3");
		sb.Append("\x122\x6\x122\x167F\n\x122\r\x122\xE\x122\x1680\x3\x122\x3\x122");
		sb.Append("\x5\x122\x1685\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x6\x122");
		sb.Append("\x168B\n\x122\r\x122\xE\x122\x168C\x3\x122\x3\x122\x5\x122\x1691");
		sb.Append("\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122");
		sb.Append("\x5\x122\x169A\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122");
		sb.Append("\x3\x122\x5\x122\x16A2\n\x122\x3\x122\x3\x122\x3\x122\x5\x122");
		sb.Append("\x16A7\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122");
		sb.Append("\x5\x122\x16AF\n\x122\x3\x122\x3\x122\x3\x122\x5\x122\x16B4");
		sb.Append("\n\x122\x3\x122\x3\x122\x3\x122\x5\x122\x16B9\n\x122\x5\x122");
		sb.Append("\x16BB\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122");
		sb.Append("\x3\x122\x5\x122\x16C4\n\x122\x3\x122\x3\x122\x3\x122\x5\x122");
		sb.Append("\x16C9\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122");
		sb.Append("\x5\x122\x16D1\n\x122\x3\x122\x3\x122\x3\x122\x5\x122\x16D6");
		sb.Append("\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x5\x122");
		sb.Append("\x16DE\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122");
		sb.Append("\x5\x122\x16E6\n\x122\x3\x122\x5\x122\x16E9\n\x122\x3\x122\x3");
		sb.Append("\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x5\x122");
		sb.Append("\x16F3\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122");
		sb.Append("\x3\x122\x3\x122\x3\x122\x5\x122\x16FE\n\x122\x3\x123\x3\x123");
		sb.Append("\x3\x123\x3\x123\x3\x123\x3\x124\x3\x124\x3\x124\x3\x124\a\x124");
		sb.Append("\x1709\n\x124\f\x124\xE\x124\x170C\v\x124\x3\x124\x3\x124\x3");
		sb.Append("\x124\x3\x124\x3\x124\x5\x124\x1713\n\x124\x3\x125\x3\x125\x5");
		sb.Append("\x125\x1717\n\x125\x3\x126\x3\x126\x3\x126\x5\x126\x171C\n\x126");
		sb.Append("\x3\x126\x3\x126\x3\x126\x3\x126\x3\x126\x3\x126\x3\x126\x5");
		sb.Append("\x126\x1725\n\x126\x3\x126\x5\x126\x1728\n\x126\x3\x126\x3\x126");
		sb.Append("\x3\x126\x3\x126\x3\x126\x3\x126\x3\x126\x3\x126\x3\x126\x3");
		sb.Append("\x126\x5\x126\x1734\n\x126\x3\x126\x3\x126\x3\x126\x3\x126\x3");
		sb.Append("\x126\x3\x126\x5\x126\x173C\n\x126\x3\x126\x3\x126\x3\x126\x3");
		sb.Append("\x126\x3\x126\x3\x126\a\x126\x1744\n\x126\f\x126\xE\x126\x1747");
		sb.Append("\v\x126\x5\x126\x1749\n\x126\x3\x126\x3\x126\x5\x126\x174D\n");
		sb.Append("\x126\x3\x126\x3\x126\x5\x126\x1751\n\x126\x3\x127\x3\x127\x3");
		sb.Append("\x127\x3\x127\x3\x127\x3\x127\x3\x127\x3\x127\x3\x127\x3\x127");
		sb.Append("\x3\x127\x3\x127\x3\x127\x3\x127\x3\x127\x3\x127\x3\x127\x3");
		sb.Append("\x127\x3\x127\x3\x127\x3\x127\x3\x127\x3\x127\x5\x127\x176A");
		sb.Append("\n\x127\x3\x128\x3\x128\x3\x128\x3\x128\x3\x128\x3\x129\x3\x129");
		sb.Append("\x3\x129\x3\x129\x5\x129\x1775\n\x129\x3\x129\x3\x129\x3\x129");
		sb.Append("\x3\x129\x3\x129\x5\x129\x177C\n\x129\a\x129\x177E\n\x129\f");
		sb.Append("\x129\xE\x129\x1781\v\x129\x3\x12A\x3\x12A\x3\x12A\x3\x12A\x5");
		sb.Append("\x12A\x1787\n\x12A\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3");
		sb.Append("\x12B\x5\x12B\x178F\n\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x1794");
		sb.Append("\n\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\a\x12B\x179A\n\x12B");
		sb.Append("\f\x12B\xE\x12B\x179D\v\x12B\x3\x12C\x3\x12C\x3\x12C\x5\x12C");
		sb.Append("\x17A2\n\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C");
		sb.Append("\x3\x12C\x3\x12C\x5\x12C\x17AC\n\x12C\x3\x12C\x3\x12C\x3\x12C");
		sb.Append("\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x3");
		sb.Append("\x12C\x5\x12C\x17B9\n\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x5");
		sb.Append("\x12C\x17BF\n\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x5\x12C\x17C5");
		sb.Append("\n\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C");
		sb.Append("\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x5");
		sb.Append("\x12C\x17D5\n\x12C\x3\x12C\x3\x12C\x3\x12C\x3\x12C\x5\x12C\x17DB");
		sb.Append("\n\x12C\a\x12C\x17DD\n\x12C\f\x12C\xE\x12C\x17E0\v\x12C\x3\x12D");
		sb.Append("\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3");
		sb.Append("\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\a\x12D\x17F0\n");
		sb.Append("\x12D\f\x12D\xE\x12D\x17F3\v\x12D\x3\x12D\x3\x12D\x3\x12D\x3");
		sb.Append("\x12D\x3\x12D\x3\x12D\x3\x12D\x6\x12D\x17FC\n\x12D\r\x12D\xE");
		sb.Append("\x12D\x17FD\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D");
		sb.Append("\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3");
		sb.Append("\x12D\x3\x12D\x5\x12D\x180F\n\x12D\x3\x12D\x3\x12D\x3\x12D\x3");
		sb.Append("\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D");
		sb.Append("\a\x12D\x181C\n\x12D\f\x12D\xE\x12D\x181F\v\x12D\x3\x12E\x3");
		sb.Append("\x12E\x3\x12F\x3\x12F\x3\x12F\x3\x12F\x3\x12F\x3\x12F\x3\x12F");
		sb.Append("\x3\x12F\x3\x12F\x3\x12F\x3\x12F\x3\x12F\x3\x12F\x3\x12F\x5");
		sb.Append("\x12F\x1831\n\x12F\x3\x130\x3\x130\x3\x130\x3\x130\x3\x130\x3");
		sb.Append("\x130\x3\x130\x5\x130\x183A\n\x130\x3\x131\x3\x131\x3\x131\x3");
		sb.Append("\x131\x3\x131\x3\x131\x3\x131\x5\x131\x1843\n\x131\x3\x132\x3");
		sb.Append("\x132\x3\x133\x3\x133\x3\x134\x3\x134\x3\x135\x3\x135\x3\x136");
		sb.Append("\x3\x136\x3\x137\x3\x137\x3\x138\x3\x138\x3\x139\x3\x139\x3");
		sb.Append("\x139\x2\x5\x254\x256\x258\x13A\x2\x4\x6\b\n\f\xE\x10\x12\x14");
		sb.Append("\x16\x18\x1A\x1C\x1E \"$&(*,.\x30\x32\x34\x36\x38:<>@\x42\x44");
		sb.Append("\x46HJLNPRTVXZ\\^`\x62\x64\x66hjlnprtvxz|~\x80\x82\x84\x86\x88");
		sb.Append("\x8A\x8C\x8E\x90\x92\x94\x96\x98\x9A\x9C\x9E\xA0\xA2\xA4\xA6");
		sb.Append("\xA8\xAA\xAC\xAE\xB0\xB2\xB4\xB6\xB8\xBA\xBC\xBE\xC0\xC2\xC4");
		sb.Append("\xC6\xC8\xCA\xCC\xCE\xD0\xD2\xD4\xD6\xD8\xDA\xDC\xDE\xE0\xE2");
		sb.Append("\xE4\xE6\xE8\xEA\xEC\xEE\xF0\xF2\xF4\xF6\xF8\xFA\xFC\xFE\x100");
		sb.Append("\x102\x104\x106\x108\x10A\x10C\x10E\x110\x112\x114\x116\x118");
		sb.Append("\x11A\x11C\x11E\x120\x122\x124\x126\x128\x12A\x12C\x12E\x130");
		sb.Append("\x132\x134\x136\x138\x13A\x13C\x13E\x140\x142\x144\x146\x148");
		sb.Append("\x14A\x14C\x14E\x150\x152\x154\x156\x158\x15A\x15C\x15E\x160");
		sb.Append("\x162\x164\x166\x168\x16A\x16C\x16E\x170\x172\x174\x176\x178");
		sb.Append("\x17A\x17C\x17E\x180\x182\x184\x186\x188\x18A\x18C\x18E\x190");
		sb.Append("\x192\x194\x196\x198\x19A\x19C\x19E\x1A0\x1A2\x1A4\x1A6\x1A8");
		sb.Append("\x1AA\x1AC\x1AE\x1B0\x1B2\x1B4\x1B6\x1B8\x1BA\x1BC\x1BE\x1C0");
		sb.Append("\x1C2\x1C4\x1C6\x1C8\x1CA\x1CC\x1CE\x1D0\x1D2\x1D4\x1D6\x1D8");
		sb.Append("\x1DA\x1DC\x1DE\x1E0\x1E2\x1E4\x1E6\x1E8\x1EA\x1EC\x1EE\x1F0");
		sb.Append("\x1F2\x1F4\x1F6\x1F8\x1FA\x1FC\x1FE\x200\x202\x204\x206\x208");
		sb.Append("\x20A\x20C\x20E\x210\x212\x214\x216\x218\x21A\x21C\x21E\x220");
		sb.Append("\x222\x224\x226\x228\x22A\x22C\x22E\x230\x232\x234\x236\x238");
		sb.Append("\x23A\x23C\x23E\x240\x242\x244\x246\x248\x24A\x24C\x24E\x250");
		sb.Append("\x252\x254\x256\x258\x25A\x25C\x25E\x260\x262\x264\x266\x268");
		sb.Append("\x26A\x26C\x26E\x270\x2|\x4\x2$$\x84\x84\x4\x2\x1B3\x1B3\x1B8");
		sb.Append("\x1B8\x5\x2>>\x8B\x8B\x9F\x9F\x5\x2\'\'\x131\x131\x16F\x16F");
		sb.Append("\x6\x2\'\'\x150\x150\x1B2\x1B2\x1F6\x1F6\x4\x2\x1A9\x1A9\x3DF");
		sb.Append("\x3DF\x4\x2\x45\x45}}\x4\x2\xF\xF\x101\x101\x5\x2))KK\xA2\xA2");
		sb.Append("\x4\x2\x15D\x15D\x1CA\x1CA\x5\x2\x1A1\x1A1\x21C\x21C\x222\x222");
		sb.Append("\x4\x2\x137\x137\x174\x174\x4\x2\x113\x113\x182\x182\x4\x2\x111");
		sb.Append("\x111\x166\x166\x5\x2\x46\x46JJnn\x5\x2\'\'\x141\x141\x15B\x15B");
		sb.Append("\x5\x2\'\'\x13D\x13D\x27E\x27E\x4\x2\x210\x210\x230\x230\x4");
		sb.Append("\x2GGQQ\x5\x2\x15F\x15F\x1C1\x1C1\x1F8\x1F8\x4\x2>>\x8B\x8B");
		sb.Append("\x3\x2\x117\x118\x3\x2\x3D5\x3D6\x4\x2\x3DF\x3DF\x3E7\x3E7\x5");
		sb.Append("\x2\x15A\x15A\x17D\x17D\x1B0\x1B0\x4\x2\'\'\x3D5\x3D6\b\x2\'");
		sb.Append("\'\x124\x124\x126\x126\x141\x141\x15B\x15B\x1D7\x1D7\x3\x2\x3D6");
		sb.Append("\x3D7\x4\x2\a\a//\x4\x2\r\r\x99\x99\x4\x2\xAA\xAA\x234\x234");
		sb.Append("\x4\x2\x14\x14\x7F\x7F\x5\x2((\x43\x43^^\x4\x2^^\x128\x128\x4");
		sb.Append("\x2\x11F\x11F\x157\x157\x4\x2ZZ\x1EE\x1EE\x4\x2((^^\x4\x2\b");
		sb.Append("\b--\x4\x2\xA6\xA6\x22D\x22D\x6\x2\x15A\x15A\x17D\x17D\x1AF");
		sb.Append("\x1AF\x1CD\x1CD\x4\x2\x15A\x15A\x1AF\x1AF\x4\x2\xE\xE**\x5\x2");
		sb.Append(";;\x45\x45\xA4\xA4\x4\x2!!II\x4\x2VV\x82\x82\x4\x2\b\b-.\x3");
		sb.Append("\x2\x205\x206\x4\x2\x162\x162\x1F4\x1F4\x4\x2\xC4\xC4\x185\x185");
		sb.Append("\a\x2__\x18A\x18B\x18D\x18D\x191\x199\x1D9\x1D9\x6\x2\x187\x188");
		sb.Append("\x18C\x18C\x18E\x18F\x1DA\x1DA\x5\x2``\x186\x186\x190\x190\x4");
		sb.Append("\x2\x176\x176\x207\x207\x4\x2\x201\x201\x203\x203\x4\x2\x10B");
		sb.Append("\x10B\x208\x208\x4\x2PP\x1E8\x1E8\x4\x2//\x135\x135\x5\x2\x1E");
		sb.Append("\x1E\x36\x36\x9D\x9D\x5\x2ss\x96\x96\x160\x160\x4\x2\\\\\xA0");
		sb.Append("\xA0\x4\x2\x11B\x11B\x1F9\x1F9\x4\x2%%\x22F\x22F\x4\x2\x66\x66");
		sb.Append("\x182\x182\x4\x2\x153\x153\x1D3\x1D3\x6\x2\xB2\xB2\xB4\xB4\xB8");
		sb.Append("\xB8\x211\x211\x4\x2\x3B6\x3B6\x3C7\x3C7\x4\x2\x10C\x10C\x1DB");
		sb.Append("\x1DB\x4\x2==\x46\x46\b\x2ss\x96\x96\x9B\x9B\x14C\x14C\x160");
		sb.Append("\x160\x22F\x22F\x4\x2\x1A8\x1A8\x20D\x20D\x4\x2\x149\x149\x233");
		sb.Append("\x233\x4\x2ss\x160\x160\x5\x2GGRR\x16D\x16D\x5\x2\x162\x162");
		sb.Append("\x182\x182\x1F4\x1F4\x4\x2\x20D\x20D\x22E\x22E\x4\x2\x129\x129");
		sb.Append("\x1D2\x1D2\b\x2\xC4\xC4\x146\x146\x148\x148\x161\x161\x1D8\x1D8");
		sb.Append("\x1FA\x1FA\x4\x2*+\x37\x37\x5\x2\x153\x153\x1C3\x1C3\x2DA\x2DA");
		sb.Append("\x4\x2\x17A\x17A\x21E\x21E\v\x2\x11A\x11A\x121\x121\x12B\x12D");
		sb.Append("\x1A2\x1A2\x1AA\x1AA\x212\x212\x219\x219\x2AA\x2AA\x350\x350");
		sb.Append("\x5\x2\x3DF\x3DF\x3E7\x3E7\x3E9\x3E9\x3\x2\x3EA\x3EB\x5\x2\x279");
		sb.Append("\x284\x3DF\x3DF\x3E7\x3E8\x4\x2\x3D5\x3D7\x3E0\x3E0\x4\x2\x38");
		sb.Append("\x38\x9C\x9C\x4\x2gg\x3E3\x3E3\x5\x2\xC0\xC2\xCA\xCD\x1AD\x1AD");
		sb.Append("\x4\x2\x18\x18\xC1\xC1\x4\x2\x18\x18\xC0\xC0\x3\x2\xAE\xB3\x4");
		sb.Append("\x2\xA1\xA1\x1F7\x1F7\x4\x2\xB7\xBA\x15B\x15B\x6\x2\xBB\xBB");
		sb.Append("\xC6\xC9\xD0\xD0\x10F\x110\x5\x2\xBC\xBF\xC4\xC5\x10D\x10D\x4");
		sb.Append("\x2\x87\x87\xCE\xCE\x4\x2\x17A\x17A\x289\x291\x4\x2\xC4\xC4");
		sb.Append("\x1AD\x1AD\x5\x2\xBB\xBC\xBE\xBE\x17A\x17A\x4\x2\xEE\xEF\xF5");
		sb.Append("\xF5\x4\x2\"\"\xEC\xEF\x3\x2\xF8\xF9\x5\x2\x11\x11TT\x9A\x9A");
		sb.Append("\x4\x2\xC0\xC0\xC4\xC4\x4\x2\xBB\xBC\xBE\xBE\x5\x2\xE\xE**\x346");
		sb.Append("\x346\x5\x2\xDC\xDC\xE2\xE3\xE8\xE8\x5\x2\xDD\xDF\xE4\xE7\xE9");
		sb.Append("\xEB\x4\x2\x1B6\x1B6\x1C4\x1C4\x4\x2\x65\x65\x3CA\x3CA\x5\x2");
		sb.Append("\x38\x38\x9C\x9C\x226\x226\x4\x2yy\x83\x83\x5\x2\b\b\x104\x104");
		sb.Append("\x1FD\x1FD\x6\x2\x65\x65\x3C2\x3C2\x3C4\x3C4\x3CA\x3CB\x3\x2");
		sb.Append("\x3BF\x3C6\x3\x2\x251\x278\x3\x2\x285\x288\x3\x2\x247\x24F\x3");
		sb.Append("\x2\x23F\x246\x5\x2\xBB\xBF\xCB\xCB\xCE\xCE\v\x2\xD0\xD0\xFF");
		sb.Append("\x172\x174\x20F\x211\x22F\x232\x239\x23E\x23E\x27E\x27E\x2AA");
		sb.Append("\x2AA\x350\x350\x11\x2$$VV\x82\x82\xBB\xBD\xBF\xBF\xE0\xE0\xF7");
		sb.Append("\xF7\x173\x173\x231\x231\x23F\x246\x250\x250\x289\x289\x28C");
		sb.Append("\x2A9\x2AB\x34F\x351\x3B5\x1C83\x2\x273\x3\x2\x2\x2\x4\x284");
		sb.Append("\x3\x2\x2\x2\x6\x298\x3\x2\x2\x2\b\x29A\x3\x2\x2\x2\n\x2BF\x3");
		sb.Append("\x2\x2\x2\f\x2CB\x3\x2\x2\x2\xE\x2D6\x3\x2\x2\x2\x10\x2E7\x3");
		sb.Append("\x2\x2\x2\x12\x2EC\x3\x2\x2\x2\x14\x2F8\x3\x2\x2\x2\x16\x313");
		sb.Append("\x3\x2\x2\x2\x18\x31A\x3\x2\x2\x2\x1A\x31C\x3\x2\x2\x2\x1C\x328");
		sb.Append("\x3\x2\x2\x2\x1E\x346\x3\x2\x2\x2 \x36A\x3\x2\x2\x2\"\x39D\x3");
		sb.Append("\x2\x2\x2$\x3B7\x3\x2\x2\x2&\x3D5\x3\x2\x2\x2(\x436\x3\x2\x2");
		sb.Append("\x2*\x438\x3\x2\x2\x2,\x44A\x3\x2\x2\x2.\x487\x3\x2\x2\x2\x30");
		sb.Append("\x49A\x3\x2\x2\x2\x32\x4D5\x3\x2\x2\x2\x34\x4D7\x3\x2\x2\x2");
		sb.Append("\x36\x503\x3\x2\x2\x2\x38\x509\x3\x2\x2\x2:\x50B\x3\x2\x2\x2");
		sb.Append("<\x520\x3\x2\x2\x2>\x527\x3\x2\x2\x2@\x529\x3\x2\x2\x2\x42\x539");
		sb.Append("\x3\x2\x2\x2\x44\x53C\x3\x2\x2\x2\x46\x541\x3\x2\x2\x2H\x55B");
		sb.Append("\x3\x2\x2\x2J\x56B\x3\x2\x2\x2L\x56D\x3\x2\x2\x2N\x57D\x3\x2");
		sb.Append("\x2\x2P\x57F\x3\x2\x2\x2R\x5AE\x3\x2\x2\x2T\x5F5\x3\x2\x2\x2");
		sb.Append("V\x5F7\x3\x2\x2\x2X\x613\x3\x2\x2\x2Z\x61B\x3\x2\x2\x2\\\x639");
		sb.Append("\x3\x2\x2\x2^\x6CB\x3\x2\x2\x2`\x6CD\x3\x2\x2\x2\x62\x6D0\x3");
		sb.Append("\x2\x2\x2\x64\x71A\x3\x2\x2\x2\x66\x731\x3\x2\x2\x2h\x7B6\x3");
		sb.Append("\x2\x2\x2j\x7BB\x3\x2\x2\x2l\x7BD\x3\x2\x2\x2n\x7C7\x3\x2\x2");
		sb.Append("\x2p\x7FC\x3\x2\x2\x2r\x810\x3\x2\x2\x2t\x812\x3\x2\x2\x2v\x835");
		sb.Append("\x3\x2\x2\x2x\x83E\x3\x2\x2\x2z\x845\x3\x2\x2\x2|\x85C\x3\x2");
		sb.Append("\x2\x2~\x865\x3\x2\x2\x2\x80\x874\x3\x2\x2\x2\x82\x88A\x3\x2");
		sb.Append("\x2\x2\x84\x89E\x3\x2\x2\x2\x86\xA21\x3\x2\x2\x2\x88\xA23\x3");
		sb.Append("\x2\x2\x2\x8A\xA2A\x3\x2\x2\x2\x8C\xA31\x3\x2\x2\x2\x8E\xA48");
		sb.Append("\x3\x2\x2\x2\x90\xA50\x3\x2\x2\x2\x92\xA57\x3\x2\x2\x2\x94\xA5E");
		sb.Append("\x3\x2\x2\x2\x96\xA65\x3\x2\x2\x2\x98\xA71\x3\x2\x2\x2\x9A\xA7B");
		sb.Append("\x3\x2\x2\x2\x9C\xA82\x3\x2\x2\x2\x9E\xA92\x3\x2\x2\x2\xA0\xA9C");
		sb.Append("\x3\x2\x2\x2\xA2\xAA0\x3\x2\x2\x2\xA4\xAA6\x3\x2\x2\x2\xA6\xAB2");
		sb.Append("\x3\x2\x2\x2\xA8\xAB4\x3\x2\x2\x2\xAA\xABB\x3\x2\x2\x2\xAC\xABD");
		sb.Append("\x3\x2\x2\x2\xAE\xAEF\x3\x2\x2\x2\xB0\xB39\x3\x2\x2\x2\xB2\xB74");
		sb.Append("\x3\x2\x2\x2\xB4\xBCC\x3\x2\x2\x2\xB6\xBD0\x3\x2\x2\x2\xB8\xBE1");
		sb.Append("\x3\x2\x2\x2\xBA\xBE3\x3\x2\x2\x2\xBC\xBEB\x3\x2\x2\x2\xBE\xBF3");
		sb.Append("\x3\x2\x2\x2\xC0\xBF5\x3\x2\x2\x2\xC2\xC13\x3\x2\x2\x2\xC4\xC4A");
		sb.Append("\x3\x2\x2\x2\xC6\xC53\x3\x2\x2\x2\xC8\xC67\x3\x2\x2\x2\xCA\xC73");
		sb.Append("\x3\x2\x2\x2\xCC\xC77\x3\x2\x2\x2\xCE\xC98\x3\x2\x2\x2\xD0\xCAD");
		sb.Append("\x3\x2\x2\x2\xD2\xCB7\x3\x2\x2\x2\xD4\xCBB\x3\x2\x2\x2\xD6\xCD4");
		sb.Append("\x3\x2\x2\x2\xD8\xCFE\x3\x2\x2\x2\xDA\xD00\x3\x2\x2\x2\xDC\xD0F");
		sb.Append("\x3\x2\x2\x2\xDE\xD3D\x3\x2\x2\x2\xE0\xD47\x3\x2\x2\x2\xE2\xD51");
		sb.Append("\x3\x2\x2\x2\xE4\xD7B\x3\x2\x2\x2\xE6\xD7D\x3\x2\x2\x2\xE8\xD8E");
		sb.Append("\x3\x2\x2\x2\xEA\xD94\x3\x2\x2\x2\xEC\xDA4\x3\x2\x2\x2\xEE\xDA8");
		sb.Append("\x3\x2\x2\x2\xF0\xDCE\x3\x2\x2\x2\xF2\xDF4\x3\x2\x2\x2\xF4\xE02");
		sb.Append("\x3\x2\x2\x2\xF6\xE0A\x3\x2\x2\x2\xF8\xE0C\x3\x2\x2\x2\xFA\xE26");
		sb.Append("\x3\x2\x2\x2\xFC\xE2A\x3\x2\x2\x2\xFE\xE39\x3\x2\x2\x2\x100");
		sb.Append("\xE3B\x3\x2\x2\x2\x102\xE47\x3\x2\x2\x2\x104\xE4B\x3\x2\x2\x2");
		sb.Append("\x106\xE5C\x3\x2\x2\x2\x108\xE6D\x3\x2\x2\x2\x10A\xE70\x3\x2");
		sb.Append("\x2\x2\x10C\xE7A\x3\x2\x2\x2\x10E\xE7E\x3\x2\x2\x2\x110\xE88");
		sb.Append("\x3\x2\x2\x2\x112\xE8B\x3\x2\x2\x2\x114\xE90\x3\x2\x2\x2\x116");
		sb.Append("\xEA4\x3\x2\x2\x2\x118\xEA6\x3\x2\x2\x2\x11A\xEB7\x3\x2\x2\x2");
		sb.Append("\x11C\xEC0\x3\x2\x2\x2\x11E\xEC9\x3\x2\x2\x2\x120\xECB\x3\x2");
		sb.Append("\x2\x2\x122\xED9\x3\x2\x2\x2\x124\xEE4\x3\x2\x2\x2\x126\xEED");
		sb.Append("\x3\x2\x2\x2\x128\xEF0\x3\x2\x2\x2\x12A\xEF8\x3\x2\x2\x2\x12C");
		sb.Append("\xF11\x3\x2\x2\x2\x12E\xF1D\x3\x2\x2\x2\x130\xF20\x3\x2\x2\x2");
		sb.Append("\x132\xF40\x3\x2\x2\x2\x134\xF42\x3\x2\x2\x2\x136\xF44\x3\x2");
		sb.Append("\x2\x2\x138\xF46\x3\x2\x2\x2\x13A\xF48\x3\x2\x2\x2\x13C\xF7D");
		sb.Append("\x3\x2\x2\x2\x13E\xF7F\x3\x2\x2\x2\x140\xF85\x3\x2\x2\x2\x142");
		sb.Append("\xF99\x3\x2\x2\x2\x144\xFA7\x3\x2\x2\x2\x146\xFB2\x3\x2\x2\x2");
		sb.Append("\x148\xFB4\x3\x2\x2\x2\x14A\xFBA\x3\x2\x2\x2\x14C\xFC4\x3\x2");
		sb.Append("\x2\x2\x14E\xFC8\x3\x2\x2\x2\x150\xFCF\x3\x2\x2\x2\x152\xFD3");
		sb.Append("\x3\x2\x2\x2\x154\xFD9\x3\x2\x2\x2\x156\xFE0\x3\x2\x2\x2\x158");
		sb.Append("\xFE6\x3\x2\x2\x2\x15A\xFEC\x3\x2\x2\x2\x15C\xFF1\x3\x2\x2\x2");
		sb.Append("\x15E\x1020\x3\x2\x2\x2\x160\x1035\x3\x2\x2\x2\x162\x104E\x3");
		sb.Append("\x2\x2\x2\x164\x1051\x3\x2\x2\x2\x166\x1057\x3\x2\x2\x2\x168");
		sb.Append("\x1067\x3\x2\x2\x2\x16A\x1076\x3\x2\x2\x2\x16C\x107C\x3\x2\x2");
		sb.Append("\x2\x16E\x109A\x3\x2\x2\x2\x170\x109C\x3\x2\x2\x2\x172\x10A3");
		sb.Append("\x3\x2\x2\x2\x174\x10AF\x3\x2\x2\x2\x176\x10B5\x3\x2\x2\x2\x178");
		sb.Append("\x10CE\x3\x2\x2\x2\x17A\x10D2\x3\x2\x2\x2\x17C\x10D6\x3\x2\x2");
		sb.Append("\x2\x17E\x10E1\x3\x2\x2\x2\x180\x111F\x3\x2\x2\x2\x182\x1157");
		sb.Append("\x3\x2\x2\x2\x184\x1159\x3\x2\x2\x2\x186\x1166\x3\x2\x2\x2\x188");
		sb.Append("\x1198\x3\x2\x2\x2\x18A\x11AA\x3\x2\x2\x2\x18C\x11DC\x3\x2\x2");
		sb.Append("\x2\x18E\x11DE\x3\x2\x2\x2\x190\x11EB\x3\x2\x2\x2\x192\x11F6");
		sb.Append("\x3\x2\x2\x2\x194\x1211\x3\x2\x2\x2\x196\x121B\x3\x2\x2\x2\x198");
		sb.Append("\x1225\x3\x2\x2\x2\x19A\x1227\x3\x2\x2\x2\x19C\x1231\x3\x2\x2");
		sb.Append("\x2\x19E\x1234\x3\x2\x2\x2\x1A0\x1266\x3\x2\x2\x2\x1A2\x1278");
		sb.Append("\x3\x2\x2\x2\x1A4\x127A\x3\x2\x2\x2\x1A6\x127E\x3\x2\x2\x2\x1A8");
		sb.Append("\x1285\x3\x2\x2\x2\x1AA\x128E\x3\x2\x2\x2\x1AC\x1294\x3\x2\x2");
		sb.Append("\x2\x1AE\x129B\x3\x2\x2\x2\x1B0\x12B1\x3\x2\x2\x2\x1B2\x12B3");
		sb.Append("\x3\x2\x2\x2\x1B4\x12BE\x3\x2\x2\x2\x1B6\x12C4\x3\x2\x2\x2\x1B8");
		sb.Append("\x12F2\x3\x2\x2\x2\x1BA\x138B\x3\x2\x2\x2\x1BC\x1397\x3\x2\x2");
		sb.Append("\x2\x1BE\x13A6\x3\x2\x2\x2\x1C0\x13AC\x3\x2\x2\x2\x1C2\x13BF");
		sb.Append("\x3\x2\x2\x2\x1C4\x13C9\x3\x2\x2\x2\x1C6\x13D7\x3\x2\x2\x2\x1C8");
		sb.Append("\x13D9\x3\x2\x2\x2\x1CA\x13DC\x3\x2\x2\x2\x1CC\x13F2\x3\x2\x2");
		sb.Append("\x2\x1CE\x13FE\x3\x2\x2\x2\x1D0\x1407\x3\x2\x2\x2\x1D2\x1413");
		sb.Append("\x3\x2\x2\x2\x1D4\x1417\x3\x2\x2\x2\x1D6\x1419\x3\x2\x2\x2\x1D8");
		sb.Append("\x1441\x3\x2\x2\x2\x1DA\x1448\x3\x2\x2\x2\x1DC\x144A\x3\x2\x2");
		sb.Append("\x2\x1DE\x1461\x3\x2\x2\x2\x1E0\x1467\x3\x2\x2\x2\x1E2\x146F");
		sb.Append("\x3\x2\x2\x2\x1E4\x1472\x3\x2\x2\x2\x1E6\x1475\x3\x2\x2\x2\x1E8");
		sb.Append("\x148A\x3\x2\x2\x2\x1EA\x149A\x3\x2\x2\x2\x1EC\x149C\x3\x2\x2");
		sb.Append("\x2\x1EE\x14A2\x3\x2\x2\x2\x1F0\x14A4\x3\x2\x2\x2\x1F2\x14AD");
		sb.Append("\x3\x2\x2\x2\x1F4\x14B8\x3\x2\x2\x2\x1F6\x14BA\x3\x2\x2\x2\x1F8");
		sb.Append("\x14C0\x3\x2\x2\x2\x1FA\x14C4\x3\x2\x2\x2\x1FC\x14C6\x3\x2\x2");
		sb.Append("\x2\x1FE\x14C8\x3\x2\x2\x2\x200\x14DA\x3\x2\x2\x2\x202\x14EA");
		sb.Append("\x3\x2\x2\x2\x204\x14EE\x3\x2\x2\x2\x206\x14F3\x3\x2\x2\x2\x208");
		sb.Append("\x14FE\x3\x2\x2\x2\x20A\x1503\x3\x2\x2\x2\x20C\x1505\x3\x2\x2");
		sb.Append("\x2\x20E\x1509\x3\x2\x2\x2\x210\x1522\x3\x2\x2\x2\x212\x1524");
		sb.Append("\x3\x2\x2\x2\x214\x1527\x3\x2\x2\x2\x216\x152C\x3\x2\x2\x2\x218");
		sb.Append("\x153C\x3\x2\x2\x2\x21A\x15A8\x3\x2\x2\x2\x21C\x15AA\x3\x2\x2");
		sb.Append("\x2\x21E\x15CE\x3\x2\x2\x2\x220\x15D0\x3\x2\x2\x2\x222\x15D4");
		sb.Append("\x3\x2\x2\x2\x224\x15DA\x3\x2\x2\x2\x226\x15E2\x3\x2\x2\x2\x228");
		sb.Append("\x15EA\x3\x2\x2\x2\x22A\x15F2\x3\x2\x2\x2\x22C\x15FD\x3\x2\x2");
		sb.Append("\x2\x22E\x1605\x3\x2\x2\x2\x230\x160D\x3\x2\x2\x2\x232\x1615");
		sb.Append("\x3\x2\x2\x2\x234\x161D\x3\x2\x2\x2\x236\x1630\x3\x2\x2\x2\x238");
		sb.Append("\x1640\x3\x2\x2\x2\x23A\x1644\x3\x2\x2\x2\x23C\x1646\x3\x2\x2");
		sb.Append("\x2\x23E\x1649\x3\x2\x2\x2\x240\x165E\x3\x2\x2\x2\x242\x16FD");
		sb.Append("\x3\x2\x2\x2\x244\x16FF\x3\x2\x2\x2\x246\x1712\x3\x2\x2\x2\x248");
		sb.Append("\x1714\x3\x2\x2\x2\x24A\x1750\x3\x2\x2\x2\x24C\x1769\x3\x2\x2");
		sb.Append("\x2\x24E\x176B\x3\x2\x2\x2\x250\x1774\x3\x2\x2\x2\x252\x1786");
		sb.Append("\x3\x2\x2\x2\x254\x1793\x3\x2\x2\x2\x256\x179E\x3\x2\x2\x2\x258");
		sb.Append("\x180E\x3\x2\x2\x2\x25A\x1820\x3\x2\x2\x2\x25C\x1830\x3\x2\x2");
		sb.Append("\x2\x25E\x1839\x3\x2\x2\x2\x260\x1842\x3\x2\x2\x2\x262\x1844");
		sb.Append("\x3\x2\x2\x2\x264\x1846\x3\x2\x2\x2\x266\x1848\x3\x2\x2\x2\x268");
		sb.Append("\x184A\x3\x2\x2\x2\x26A\x184C\x3\x2\x2\x2\x26C\x184E\x3\x2\x2");
		sb.Append("\x2\x26E\x1850\x3\x2\x2\x2\x270\x1852\x3\x2\x2\x2\x272\x274");
		sb.Append("\x5\x4\x3\x2\x273\x272\x3\x2\x2\x2\x273\x274\x3\x2\x2\x2\x274");
		sb.Append("\x276\x3\x2\x2\x2\x275\x277\a\x3C3\x2\x2\x276\x275\x3\x2\x2");
		sb.Append("\x2\x276\x277\x3\x2\x2\x2\x277\x278\x3\x2\x2\x2\x278\x279\a");
		sb.Append("\x2\x2\x3\x279\x3\x3\x2\x2\x2\x27A\x27C\x5\x6\x4\x2\x27B\x27D");
		sb.Append("\a\x3C3\x2\x2\x27C\x27B\x3\x2\x2\x2\x27C\x27D\x3\x2\x2\x2\x27D");
		sb.Append("\x27F\x3\x2\x2\x2\x27E\x280\a\x3D3\x2\x2\x27F\x27E\x3\x2\x2");
		sb.Append("\x2\x27F\x280\x3\x2\x2\x2\x280\x283\x3\x2\x2\x2\x281\x283\x5");
		sb.Append("\b\x5\x2\x282\x27A\x3\x2\x2\x2\x282\x281\x3\x2\x2\x2\x283\x286");
		sb.Append("\x3\x2\x2\x2\x284\x282\x3\x2\x2\x2\x284\x285\x3\x2\x2\x2\x285");
		sb.Append("\x28F\x3\x2\x2\x2\x286\x284\x3\x2\x2\x2\x287\x28C\x5\x6\x4\x2");
		sb.Append("\x288\x28A\a\x3C3\x2\x2\x289\x288\x3\x2\x2\x2\x289\x28A\x3\x2");
		sb.Append("\x2\x2\x28A\x28B\x3\x2\x2\x2\x28B\x28D\a\x3D3\x2\x2\x28C\x289");
		sb.Append("\x3\x2\x2\x2\x28C\x28D\x3\x2\x2\x2\x28D\x290\x3\x2\x2\x2\x28E");
		sb.Append("\x290\x5\b\x5\x2\x28F\x287\x3\x2\x2\x2\x28F\x28E\x3\x2\x2\x2");
		sb.Append("\x290\x5\x3\x2\x2\x2\x291\x299\x5\n\x6\x2\x292\x299\x5\f\a\x2");
		sb.Append("\x293\x299\x5\xE\b\x2\x294\x299\x5\x10\t\x2\x295\x299\x5\x12");
		sb.Append("\n\x2\x296\x299\x5\x16\f\x2\x297\x299\x5\x18\r\x2\x298\x291");
		sb.Append("\x3\x2\x2\x2\x298\x292\x3\x2\x2\x2\x298\x293\x3\x2\x2\x2\x298");
		sb.Append("\x294\x3\x2\x2\x2\x298\x295\x3\x2\x2\x2\x298\x296\x3\x2\x2\x2");
		sb.Append("\x298\x297\x3\x2\x2\x2\x299\a\x3\x2\x2\x2\x29A\x29B\a\x3D3\x2");
		sb.Append("\x2\x29B\t\x3\x2\x2\x2\x29C\x2C0\x5\x1A\xE\x2\x29D\x2C0\x5\x1C");
		sb.Append("\xF\x2\x29E\x2C0\x5\x1E\x10\x2\x29F\x2C0\x5 \x11\x2\x2A0\x2C0");
		sb.Append("\x5\"\x12\x2\x2A1\x2C0\x5$\x13\x2\x2A2\x2C0\x5&\x14\x2\x2A3");
		sb.Append("\x2C0\x5(\x15\x2\x2A4\x2C0\x5*\x16\x2\x2A5\x2C0\x5,\x17\x2\x2A6");
		sb.Append("\x2C0\x5.\x18\x2\x2A7\x2C0\x5\x30\x19\x2\x2A8\x2C0\x5r:\x2\x2A9");
		sb.Append("\x2C0\x5t;\x2\x2AA\x2C0\x5v<\x2\x2AB\x2C0\x5x=\x2\x2AC\x2C0");
		sb.Append("\x5z>\x2\x2AD\x2C0\x5|?\x2\x2AE\x2C0\x5~@\x2\x2AF\x2C0\x5\x80");
		sb.Append("\x41\x2\x2B0\x2C0\x5\x82\x42\x2\x2B1\x2C0\x5\x84\x43\x2\x2B2");
		sb.Append("\x2C0\x5\x88\x45\x2\x2B3\x2C0\x5\x8A\x46\x2\x2B4\x2C0\x5\x8C");
		sb.Append("G\x2\x2B5\x2C0\x5\x8EH\x2\x2B6\x2C0\x5\x90I\x2\x2B7\x2C0\x5");
		sb.Append("\x92J\x2\x2B8\x2C0\x5\x94K\x2\x2B9\x2C0\x5\x96L\x2\x2BA\x2C0");
		sb.Append("\x5\x98M\x2\x2BB\x2C0\x5\x9AN\x2\x2BC\x2C0\x5\x9CO\x2\x2BD\x2C0");
		sb.Append("\x5\x9EP\x2\x2BE\x2C0\x5\xA2R\x2\x2BF\x29C\x3\x2\x2\x2\x2BF");
		sb.Append("\x29D\x3\x2\x2\x2\x2BF\x29E\x3\x2\x2\x2\x2BF\x29F\x3\x2\x2\x2");
		sb.Append("\x2BF\x2A0\x3\x2\x2\x2\x2BF\x2A1\x3\x2\x2\x2\x2BF\x2A2\x3\x2");
		sb.Append("\x2\x2\x2BF\x2A3\x3\x2\x2\x2\x2BF\x2A4\x3\x2\x2\x2\x2BF\x2A5");
		sb.Append("\x3\x2\x2\x2\x2BF\x2A6\x3\x2\x2\x2\x2BF\x2A7\x3\x2\x2\x2\x2BF");
		sb.Append("\x2A8\x3\x2\x2\x2\x2BF\x2A9\x3\x2\x2\x2\x2BF\x2AA\x3\x2\x2\x2");
		sb.Append("\x2BF\x2AB\x3\x2\x2\x2\x2BF\x2AC\x3\x2\x2\x2\x2BF\x2AD\x3\x2");
		sb.Append("\x2\x2\x2BF\x2AE\x3\x2\x2\x2\x2BF\x2AF\x3\x2\x2\x2\x2BF\x2B0");
		sb.Append("\x3\x2\x2\x2\x2BF\x2B1\x3\x2\x2\x2\x2BF\x2B2\x3\x2\x2\x2\x2BF");
		sb.Append("\x2B3\x3\x2\x2\x2\x2BF\x2B4\x3\x2\x2\x2\x2BF\x2B5\x3\x2\x2\x2");
		sb.Append("\x2BF\x2B6\x3\x2\x2\x2\x2BF\x2B7\x3\x2\x2\x2\x2BF\x2B8\x3\x2");
		sb.Append("\x2\x2\x2BF\x2B9\x3\x2\x2\x2\x2BF\x2BA\x3\x2\x2\x2\x2BF\x2BB");
		sb.Append("\x3\x2\x2\x2\x2BF\x2BC\x3\x2\x2\x2\x2BF\x2BD\x3\x2\x2\x2\x2BF");
		sb.Append("\x2BE\x3\x2\x2\x2\x2C0\v\x3\x2\x2\x2\x2C1\x2CC\x5\xB4[\x2\x2C2");
		sb.Append("\x2CC\x5\xACW\x2\x2C3\x2CC\x5\xB6\\\x2\x2C4\x2CC\x5\xA6T\x2");
		sb.Append("\x2C5\x2CC\x5\xB2Z\x2\x2C6\x2CC\x5\xA4S\x2\x2C7\x2CC\x5\xAE");
		sb.Append("X\x2\x2C8\x2CC\x5\xB0Y\x2\x2C9\x2CC\x5\xA8U\x2\x2CA\x2CC\x5");
		sb.Append("\xAAV\x2\x2CB\x2C1\x3\x2\x2\x2\x2CB\x2C2\x3\x2\x2\x2\x2CB\x2C3");
		sb.Append("\x3\x2\x2\x2\x2CB\x2C4\x3\x2\x2\x2\x2CB\x2C5\x3\x2\x2\x2\x2CB");
		sb.Append("\x2C6\x3\x2\x2\x2\x2CB\x2C7\x3\x2\x2\x2\x2CB\x2C8\x3\x2\x2\x2");
		sb.Append("\x2CB\x2C9\x3\x2\x2\x2\x2CB\x2CA\x3\x2\x2\x2\x2CC\r\x3\x2\x2");
		sb.Append("\x2\x2CD\x2D7\x5\x100\x81\x2\x2CE\x2D7\x5\x102\x82\x2\x2CF\x2D7");
		sb.Append("\x5\x104\x83\x2\x2D0\x2D7\x5\x106\x84\x2\x2D1\x2D7\x5\x108\x85");
		sb.Append("\x2\x2D2\x2D7\x5\x10A\x86\x2\x2D3\x2D7\x5\x10C\x87\x2\x2D4\x2D7");
		sb.Append("\x5\x10E\x88\x2\x2D5\x2D7\x5\x110\x89\x2\x2D6\x2CD\x3\x2\x2");
		sb.Append("\x2\x2D6\x2CE\x3\x2\x2\x2\x2D6\x2CF\x3\x2\x2\x2\x2D6\x2D0\x3");
		sb.Append("\x2\x2\x2\x2D6\x2D1\x3\x2\x2\x2\x2D6\x2D2\x3\x2\x2\x2\x2D6\x2D3");
		sb.Append("\x3\x2\x2\x2\x2D6\x2D4\x3\x2\x2\x2\x2D6\x2D5\x3\x2\x2\x2\x2D7");
		sb.Append("\xF\x3\x2\x2\x2\x2D8\x2E8\x5\x120\x91\x2\x2D9\x2E8\x5\x122\x92");
		sb.Append("\x2\x2DA\x2E8\x5\x124\x93\x2\x2DB\x2E8\x5\x126\x94\x2\x2DC\x2E8");
		sb.Append("\x5\x128\x95\x2\x2DD\x2E8\x5\x12A\x96\x2\x2DE\x2E8\x5\x12C\x97");
		sb.Append("\x2\x2DF\x2E8\x5\x12E\x98\x2\x2E0\x2E8\x5\x130\x99\x2\x2E1\x2E8");
		sb.Append("\x5\x148\xA5\x2\x2E2\x2E8\x5\x14A\xA6\x2\x2E3\x2E8\x5\x14C\xA7");
		sb.Append("\x2\x2E4\x2E8\x5\x14E\xA8\x2\x2E5\x2E8\x5\x150\xA9\x2\x2E6\x2E8");
		sb.Append("\x5\x152\xAA\x2\x2E7\x2D8\x3\x2\x2\x2\x2E7\x2D9\x3\x2\x2\x2");
		sb.Append("\x2E7\x2DA\x3\x2\x2\x2\x2E7\x2DB\x3\x2\x2\x2\x2E7\x2DC\x3\x2");
		sb.Append("\x2\x2\x2E7\x2DD\x3\x2\x2\x2\x2E7\x2DE\x3\x2\x2\x2\x2E7\x2DF");
		sb.Append("\x3\x2\x2\x2\x2E7\x2E0\x3\x2\x2\x2\x2E7\x2E1\x3\x2\x2\x2\x2E7");
		sb.Append("\x2E2\x3\x2\x2\x2\x2E7\x2E3\x3\x2\x2\x2\x2E7\x2E4\x3\x2\x2\x2");
		sb.Append("\x2E7\x2E5\x3\x2\x2\x2\x2E7\x2E6\x3\x2\x2\x2\x2E8\x11\x3\x2");
		sb.Append("\x2\x2\x2E9\x2ED\x5\x154\xAB\x2\x2EA\x2ED\x5\x156\xAC\x2\x2EB");
		sb.Append("\x2ED\x5\x158\xAD\x2\x2EC\x2E9\x3\x2\x2\x2\x2EC\x2EA\x3\x2\x2");
		sb.Append("\x2\x2EC\x2EB\x3\x2\x2\x2\x2ED\x13\x3\x2\x2\x2\x2EE\x2F9\x5");
		sb.Append("\x15C\xAF\x2\x2EF\x2F9\x5\x15E\xB0\x2\x2F0\x2F9\x5\x160\xB1");
		sb.Append("\x2\x2F1\x2F9\x5\x164\xB3\x2\x2F2\x2F9\x5\x166\xB4\x2\x2F3\x2F9");
		sb.Append("\x5\x168\xB5\x2\x2F4\x2F9\x5\x16C\xB7\x2\x2F5\x2F9\x5\x162\xB2");
		sb.Append("\x2\x2F6\x2F9\x5\x16A\xB6\x2\x2F7\x2F9\x5\x16E\xB8\x2\x2F8\x2EE");
		sb.Append("\x3\x2\x2\x2\x2F8\x2EF\x3\x2\x2\x2\x2F8\x2F0\x3\x2\x2\x2\x2F8");
		sb.Append("\x2F1\x3\x2\x2\x2\x2F8\x2F2\x3\x2\x2\x2\x2F8\x2F3\x3\x2\x2\x2");
		sb.Append("\x2F8\x2F4\x3\x2\x2\x2\x2F8\x2F5\x3\x2\x2\x2\x2F8\x2F6\x3\x2");
		sb.Append("\x2\x2\x2F8\x2F7\x3\x2\x2\x2\x2F9\x15\x3\x2\x2\x2\x2FA\x314");
		sb.Append("\x5\x180\xC1\x2\x2FB\x314\x5\x182\xC2\x2\x2FC\x314\x5\x184\xC3");
		sb.Append("\x2\x2FD\x314\x5\x186\xC4\x2\x2FE\x314\x5\x188\xC5\x2\x2FF\x314");
		sb.Append("\x5\x18A\xC6\x2\x300\x314\x5\x18C\xC7\x2\x301\x314\x5\x18E\xC8");
		sb.Append("\x2\x302\x314\x5\x1A6\xD4\x2\x303\x314\x5\x1A8\xD5\x2\x304\x314");
		sb.Append("\x5\x1AA\xD6\x2\x305\x314\x5\x1AC\xD7\x2\x306\x314\x5\x1AE\xD8");
		sb.Append("\x2\x307\x314\x5\x1B2\xDA\x2\x308\x314\x5\x1B4\xDB\x2\x309\x314");
		sb.Append("\x5\x1B6\xDC\x2\x30A\x314\x5\x1B8\xDD\x2\x30B\x314\x5\x1BA\xDE");
		sb.Append("\x2\x30C\x314\x5\x1C8\xE5\x2\x30D\x314\x5\x1CA\xE6\x2\x30E\x314");
		sb.Append("\x5\x1CC\xE7\x2\x30F\x314\x5\x1CE\xE8\x2\x310\x314\x5\x1D0\xE9");
		sb.Append("\x2\x311\x314\x5\x1D2\xEA\x2\x312\x314\x5\x1D4\xEB\x2\x313\x2FA");
		sb.Append("\x3\x2\x2\x2\x313\x2FB\x3\x2\x2\x2\x313\x2FC\x3\x2\x2\x2\x313");
		sb.Append("\x2FD\x3\x2\x2\x2\x313\x2FE\x3\x2\x2\x2\x313\x2FF\x3\x2\x2\x2");
		sb.Append("\x313\x300\x3\x2\x2\x2\x313\x301\x3\x2\x2\x2\x313\x302\x3\x2");
		sb.Append("\x2\x2\x313\x303\x3\x2\x2\x2\x313\x304\x3\x2\x2\x2\x313\x305");
		sb.Append("\x3\x2\x2\x2\x313\x306\x3\x2\x2\x2\x313\x307\x3\x2\x2\x2\x313");
		sb.Append("\x308\x3\x2\x2\x2\x313\x309\x3\x2\x2\x2\x313\x30A\x3\x2\x2\x2");
		sb.Append("\x313\x30B\x3\x2\x2\x2\x313\x30C\x3\x2\x2\x2\x313\x30D\x3\x2");
		sb.Append("\x2\x2\x313\x30E\x3\x2\x2\x2\x313\x30F\x3\x2\x2\x2\x313\x310");
		sb.Append("\x3\x2\x2\x2\x313\x311\x3\x2\x2\x2\x313\x312\x3\x2\x2\x2\x314");
		sb.Append("\x17\x3\x2\x2\x2\x315\x31B\x5\x1DE\xF0\x2\x316\x31B\x5\x1E0");
		sb.Append("\xF1\x2\x317\x31B\x5\x1E2\xF2\x2\x318\x31B\x5\x1E4\xF3\x2\x319");
		sb.Append("\x31B\x5\x1E6\xF4\x2\x31A\x315\x3\x2\x2\x2\x31A\x316\x3\x2\x2");
		sb.Append("\x2\x31A\x317\x3\x2\x2\x2\x31A\x318\x3\x2\x2\x2\x31A\x319\x3");
		sb.Append("\x2\x2\x2\x31B\x19\x3\x2\x2\x2\x31C\x31D\a \x2\x2\x31D\x31F");
		sb.Append("\t\x2\x2\x2\x31E\x320\x5\x23E\x120\x2\x31F\x31E\x3\x2\x2\x2");
		sb.Append("\x31F\x320\x3\x2\x2\x2\x320\x321\x3\x2\x2\x2\x321\x325\x5\x206");
		sb.Append("\x104\x2\x322\x324\x5\x32\x1A\x2\x323\x322\x3\x2\x2\x2\x324");
		sb.Append("\x327\x3\x2\x2\x2\x325\x323\x3\x2\x2\x2\x325\x326\x3\x2\x2\x2");
		sb.Append("\x326\x1B\x3\x2\x2\x2\x327\x325\x3\x2\x2\x2\x328\x32A\a \x2");
		sb.Append("\x2\x329\x32B\x5\x34\x1B\x2\x32A\x329\x3\x2\x2\x2\x32A\x32B");
		sb.Append("\x3\x2\x2\x2\x32B\x32C\x3\x2\x2\x2\x32C\x32E\a\x14C\x2\x2\x32D");
		sb.Append("\x32F\x5\x23E\x120\x2\x32E\x32D\x3\x2\x2\x2\x32E\x32F\x3\x2");
		sb.Append("\x2\x2\x32F\x330\x3\x2\x2\x2\x330\x331\x5\x1EC\xF7\x2\x331\x332");
		sb.Append("\ah\x2\x2\x332\x333\a\x1F1\x2\x2\x333\x33A\x5\x36\x1C\x2\x334");
		sb.Append("\x335\ah\x2\x2\x335\x337\a\x125\x2\x2\x336\x338\a\x65\x2\x2");
		sb.Append("\x337\x336\x3\x2\x2\x2\x337\x338\x3\x2\x2\x2\x338\x339\x3\x2");
		sb.Append("\x2\x2\x339\x33B\a\x1CC\x2\x2\x33A\x334\x3\x2\x2\x2\x33A\x33B");
		sb.Append("\x3\x2\x2\x2\x33B\x33D\x3\x2\x2\x2\x33C\x33E\x5> \x2\x33D\x33C");
		sb.Append("\x3\x2\x2\x2\x33D\x33E\x3\x2\x2\x2\x33E\x341\x3\x2\x2\x2\x33F");
		sb.Append("\x340\a\x122\x2\x2\x340\x342\a\x3DF\x2\x2\x341\x33F\x3\x2\x2");
		sb.Append("\x2\x341\x342\x3\x2\x2\x2\x342\x343\x3\x2\x2\x2\x343\x344\a");
		sb.Append("\x13E\x2\x2\x344\x345\x5\x15A\xAE\x2\x345\x1D\x3\x2\x2\x2\x346");
		sb.Append("\x348\a \x2\x2\x347\x349\t\x3\x2\x2\x348\x347\x3\x2\x2\x2\x348");
		sb.Append("\x349\x3\x2\x2\x2\x349\x34B\x3\x2\x2\x2\x34A\x34C\t\x4\x2\x2");
		sb.Append("\x34B\x34A\x3\x2\x2\x2\x34B\x34C\x3\x2\x2\x2\x34C\x34D\x3\x2");
		sb.Append("\x2\x2\x34D\x34E\aG\x2\x2\x34E\x350\x5\x206\x104\x2\x34F\x351");
		sb.Append("\x5@!\x2\x350\x34F\x3\x2\x2\x2\x350\x351\x3\x2\x2\x2\x351\x352");
		sb.Append("\x3\x2\x2\x2\x352\x353\ah\x2\x2\x353\x354\x5\x1EE\xF8\x2\x354");
		sb.Append("\x358\x5\x22A\x116\x2\x355\x357\x5\x42\"\x2\x356\x355\x3\x2");
		sb.Append("\x2\x2\x357\x35A\x3\x2\x2\x2\x358\x356\x3\x2\x2\x2\x358\x359");
		sb.Append("\x3\x2\x2\x2\x359\x367\x3\x2\x2\x2\x35A\x358\x3\x2\x2\x2\x35B");
		sb.Append("\x35D\a\x103\x2\x2\x35C\x35E\a\x3C7\x2\x2\x35D\x35C\x3\x2\x2");
		sb.Append("\x2\x35D\x35E\x3\x2\x2\x2\x35E\x35F\x3\x2\x2\x2\x35F\x366\t");
		sb.Append("\x5\x2\x2\x360\x362\a\\\x2\x2\x361\x363\a\x3C7\x2\x2\x362\x361");
		sb.Append("\x3\x2\x2\x2\x362\x363\x3\x2\x2\x2\x363\x364\x3\x2\x2\x2\x364");
		sb.Append("\x366\t\x6\x2\x2\x365\x35B\x3\x2\x2\x2\x365\x360\x3\x2\x2\x2");
		sb.Append("\x366\x369\x3\x2\x2\x2\x367\x365\x3\x2\x2\x2\x367\x368\x3\x2");
		sb.Append("\x2\x2\x368\x1F\x3\x2\x2\x2\x369\x367\x3\x2\x2\x2\x36A\x36B");
		sb.Append("\a \x2\x2\x36B\x36C\a\x183\x2\x2\x36C\x36D\a\x41\x2\x2\x36D");
		sb.Append("\x36E\x5\x206\x104\x2\x36E\x36F\a\a\x2\x2\x36F\x370\a\x223\x2");
		sb.Append("\x2\x370\x376\a\x3DF\x2\x2\x371\x373\a\x16E\x2\x2\x372\x374");
		sb.Append("\a\x3C7\x2\x2\x373\x372\x3\x2\x2\x2\x373\x374\x3\x2\x2\x2\x374");
		sb.Append("\x375\x3\x2\x2\x2\x375\x377\x5\x20E\x108\x2\x376\x371\x3\x2");
		sb.Append("\x2\x2\x376\x377\x3\x2\x2\x2\x377\x37D\x3\x2\x2\x2\x378\x37A");
		sb.Append("\a\x224\x2\x2\x379\x37B\a\x3C7\x2\x2\x37A\x379\x3\x2\x2\x2\x37A");
		sb.Append("\x37B\x3\x2\x2\x2\x37B\x37C\x3\x2\x2\x2\x37C\x37E\x5\x20E\x108");
		sb.Append("\x2\x37D\x378\x3\x2\x2\x2\x37D\x37E\x3\x2\x2\x2\x37E\x384\x3");
		sb.Append("\x2\x2\x2\x37F\x381\a\x1D6\x2\x2\x380\x382\a\x3C7\x2\x2\x381");
		sb.Append("\x380\x3\x2\x2\x2\x381\x382\x3\x2\x2\x2\x382\x383\x3\x2\x2\x2");
		sb.Append("\x383\x385\x5\x20E\x108\x2\x384\x37F\x3\x2\x2\x2\x384\x385\x3");
		sb.Append("\x2\x2\x2\x385\x38B\x3\x2\x2\x2\x386\x388\a\x1B1\x2\x2\x387");
		sb.Append("\x389\a\x3C7\x2\x2\x388\x387\x3\x2\x2\x2\x388\x389\x3\x2\x2");
		sb.Append("\x2\x389\x38A\x3\x2\x2\x2\x38A\x38C\x5\x206\x104\x2\x38B\x386");
		sb.Append("\x3\x2\x2\x2\x38B\x38C\x3\x2\x2\x2\x38C\x38E\x3\x2\x2\x2\x38D");
		sb.Append("\x38F\a\x232\x2\x2\x38E\x38D\x3\x2\x2\x2\x38E\x38F\x3\x2\x2");
		sb.Append("\x2\x38F\x395\x3\x2\x2\x2\x390\x392\a\x122\x2\x2\x391\x393\a");
		sb.Append("\x3C7\x2\x2\x392\x391\x3\x2\x2\x2\x392\x393\x3\x2\x2\x2\x393");
		sb.Append("\x394\x3\x2\x2\x2\x394\x396\a\x3DF\x2\x2\x395\x390\x3\x2\x2");
		sb.Append("\x2\x395\x396\x3\x2\x2\x2\x396\x397\x3\x2\x2\x2\x397\x399\a");
		sb.Append("\x146\x2\x2\x398\x39A\a\x3C7\x2\x2\x399\x398\x3\x2\x2\x2\x399");
		sb.Append("\x39A\x3\x2\x2\x2\x39A\x39B\x3\x2\x2\x2\x39B\x39C\x5\x1FC\xFF");
		sb.Append("\x2\x39C!\x3\x2\x2\x2\x39D\x39F\a \x2\x2\x39E\x3A0\x5\x34\x1B");
		sb.Append("\x2\x39F\x39E\x3\x2\x2\x2\x39F\x3A0\x3\x2\x2\x2\x3A0\x3A1\x3");
		sb.Append("\x2\x2\x2\x3A1\x3A2\as\x2\x2\x3A2\x3A3\x5\x1EC\xF7\x2\x3A3\x3A5");
		sb.Append("\a\x3D0\x2\x2\x3A4\x3A6\x5\x44#\x2\x3A5\x3A4\x3\x2\x2\x2\x3A5");
		sb.Append("\x3A6\x3\x2\x2\x2\x3A6\x3AB\x3\x2\x2\x2\x3A7\x3A8\a\x3D2\x2");
		sb.Append("\x2\x3A8\x3AA\x5\x44#\x2\x3A9\x3A7\x3\x2\x2\x2\x3AA\x3AD\x3");
		sb.Append("\x2\x2\x2\x3AB\x3A9\x3\x2\x2\x2\x3AB\x3AC\x3\x2\x2\x2\x3AC\x3AE");
		sb.Append("\x3\x2\x2\x2\x3AD\x3AB\x3\x2\x2\x2\x3AE\x3B2\a\x3D1\x2\x2\x3AF");
		sb.Append("\x3B1\x5H%\x2\x3B0\x3AF\x3\x2\x2\x2\x3B1\x3B4\x3\x2\x2\x2\x3B2");
		sb.Append("\x3B0\x3\x2\x2\x2\x3B2\x3B3\x3\x2\x2\x2\x3B3\x3B5\x3\x2\x2\x2");
		sb.Append("\x3B4\x3B2\x3\x2\x2\x2\x3B5\x3B6\x5\x15A\xAE\x2\x3B6#\x3\x2");
		sb.Append("\x2\x2\x3B7\x3B9\a \x2\x2\x3B8\x3BA\x5\x34\x1B\x2\x3B9\x3B8");
		sb.Append("\x3\x2\x2\x2\x3B9\x3BA\x3\x2\x2\x2\x3BA\x3BB\x3\x2\x2\x2\x3BB");
		sb.Append("\x3BC\a\x160\x2\x2\x3BC\x3BD\x5\x1EC\xF7\x2\x3BD\x3BF\a\x3D0");
		sb.Append("\x2\x2\x3BE\x3C0\x5\x46$\x2\x3BF\x3BE\x3\x2\x2\x2\x3BF\x3C0");
		sb.Append("\x3\x2\x2\x2\x3C0\x3C5\x3\x2\x2\x2\x3C1\x3C2\a\x3D2\x2\x2\x3C2");
		sb.Append("\x3C4\x5\x46$\x2\x3C3\x3C1\x3\x2\x2\x2\x3C4\x3C7\x3\x2\x2\x2");
		sb.Append("\x3C5\x3C3\x3\x2\x2\x2\x3C5\x3C6\x3\x2\x2\x2\x3C6\x3C8\x3\x2");
		sb.Append("\x2\x2\x3C7\x3C5\x3\x2\x2\x2\x3C8\x3C9\a\x3D1\x2\x2\x3C9\x3CA");
		sb.Append("\a\x1E9\x2\x2\x3CA\x3CE\x5\x21A\x10E\x2\x3CB\x3CD\x5H%\x2\x3CC");
		sb.Append("\x3CB\x3\x2\x2\x2\x3CD\x3D0\x3\x2\x2\x2\x3CE\x3CC\x3\x2\x2\x2");
		sb.Append("\x3CE\x3CF\x3\x2\x2\x2\x3CF\x3D3\x3\x2\x2\x2\x3D0\x3CE\x3\x2");
		sb.Append("\x2\x2\x3D1\x3D4\x5\x15A\xAE\x2\x3D2\x3D4\x5\x16A\xB6\x2\x3D3");
		sb.Append("\x3D1\x3\x2\x2\x2\x3D3\x3D2\x3\x2\x2\x2\x3D4%\x3\x2\x2\x2\x3D5");
		sb.Append("\x3D6\a \x2\x2\x3D6\x3D7\a\x1F3\x2\x2\x3D7\x3D8\x5\x206\x104");
		sb.Append("\x2\x3D8\x3D9\a<\x2\x2\x3D9\x3DA\a\x133\x2\x2\x3DA\x3DB\a\x236");
		sb.Append("\x2\x2\x3DB\x3DC\t\a\x2\x2\x3DC\x3DD\a\x1BC\x2\x2\x3DD\x3DE");
		sb.Append("\a\x3D0\x2\x2\x3DE\x3E3\x5J&\x2\x3DF\x3E0\a\x3D2\x2\x2\x3E0");
		sb.Append("\x3E2\x5J&\x2\x3E1\x3DF\x3\x2\x2\x2\x3E2\x3E5\x3\x2\x2\x2\x3E3");
		sb.Append("\x3E1\x3\x2\x2\x2\x3E3\x3E4\x3\x2\x2\x2\x3E4\x3E6\x3\x2\x2\x2");
		sb.Append("\x3E5\x3E3\x3\x2\x2\x2\x3E6\x3E7\a\x3D1\x2\x2\x3E7\'\x3\x2\x2");
		sb.Append("\x2\x3E8\x3EA\a \x2\x2\x3E9\x3EB\a\x21B\x2\x2\x3EA\x3E9\x3\x2");
		sb.Append("\x2\x2\x3EA\x3EB\x3\x2\x2\x2\x3EB\x3EC\x3\x2\x2\x2\x3EC\x3EE");
		sb.Append("\a\x96\x2\x2\x3ED\x3EF\x5\x23E\x120\x2\x3EE\x3ED\x3\x2\x2\x2");
		sb.Append("\x3EE\x3EF\x3\x2\x2\x2\x3EF\x3F0\x3\x2\x2\x2\x3F0\x3F8\x5\x1EE");
		sb.Append("\xF8\x2\x3F1\x3F2\aW\x2\x2\x3F2\x3F9\x5\x1EE\xF8\x2\x3F3\x3F4");
		sb.Append("\a\x3D0\x2\x2\x3F4\x3F5\aW\x2\x2\x3F5\x3F6\x5\x1EE\xF8\x2\x3F6");
		sb.Append("\x3F7\a\x3D1\x2\x2\x3F7\x3F9\x3\x2\x2\x2\x3F8\x3F1\x3\x2\x2");
		sb.Append("\x2\x3F8\x3F3\x3\x2\x2\x2\x3F9\x437\x3\x2\x2\x2\x3FA\x3FC\a");
		sb.Append(" \x2\x2\x3FB\x3FD\a\x21B\x2\x2\x3FC\x3FB\x3\x2\x2\x2\x3FC\x3FD");
		sb.Append("\x3\x2\x2\x2\x3FD\x3FE\x3\x2\x2\x2\x3FE\x400\a\x96\x2\x2\x3FF");
		sb.Append("\x401\x5\x23E\x120\x2\x400\x3FF\x3\x2\x2\x2\x400\x401\x3\x2");
		sb.Append("\x2\x2\x401\x402\x3\x2\x2\x2\x402\x404\x5\x1EE\xF8\x2\x403\x405");
		sb.Append("\x5L\'\x2\x404\x403\x3\x2\x2\x2\x404\x405\x3\x2\x2\x2\x405\x410");
		sb.Append("\x3\x2\x2\x2\x406\x40D\x5^\x30\x2\x407\x409\a\x3D2\x2\x2\x408");
		sb.Append("\x407\x3\x2\x2\x2\x408\x409\x3\x2\x2\x2\x409\x40A\x3\x2\x2\x2");
		sb.Append("\x40A\x40C\x5^\x30\x2\x40B\x408\x3\x2\x2\x2\x40C\x40F\x3\x2");
		sb.Append("\x2\x2\x40D\x40B\x3\x2\x2\x2\x40D\x40E\x3\x2\x2\x2\x40E\x411");
		sb.Append("\x3\x2\x2\x2\x40F\x40D\x3\x2\x2\x2\x410\x406\x3\x2\x2\x2\x410");
		sb.Append("\x411\x3\x2\x2\x2\x411\x413\x3\x2\x2\x2\x412\x414\x5\x62\x32");
		sb.Append("\x2\x413\x412\x3\x2\x2\x2\x413\x414\x3\x2\x2\x2\x414\x416\x3");
		sb.Append("\x2\x2\x2\x415\x417\t\b\x2\x2\x416\x415\x3\x2\x2\x2\x416\x417");
		sb.Append("\x3\x2\x2\x2\x417\x419\x3\x2\x2\x2\x418\x41A\a\r\x2\x2\x419");
		sb.Append("\x418\x3\x2\x2\x2\x419\x41A\x3\x2\x2\x2\x41A\x41B\x3\x2\x2\x2");
		sb.Append("\x41B\x41C\x5\xB4[\x2\x41C\x437\x3\x2\x2\x2\x41D\x41F\a \x2");
		sb.Append("\x2\x41E\x420\a\x21B\x2\x2\x41F\x41E\x3\x2\x2\x2\x41F\x420\x3");
		sb.Append("\x2\x2\x2\x420\x421\x3\x2\x2\x2\x421\x423\a\x96\x2\x2\x422\x424");
		sb.Append("\x5\x23E\x120\x2\x423\x422\x3\x2\x2\x2\x423\x424\x3\x2\x2\x2");
		sb.Append("\x424\x425\x3\x2\x2\x2\x425\x426\x5\x1EE\xF8\x2\x426\x431\x5");
		sb.Append("L\'\x2\x427\x42E\x5^\x30\x2\x428\x42A\a\x3D2\x2\x2\x429\x428");
		sb.Append("\x3\x2\x2\x2\x429\x42A\x3\x2\x2\x2\x42A\x42B\x3\x2\x2\x2\x42B");
		sb.Append("\x42D\x5^\x30\x2\x42C\x429\x3\x2\x2\x2\x42D\x430\x3\x2\x2\x2");
		sb.Append("\x42E\x42C\x3\x2\x2\x2\x42E\x42F\x3\x2\x2\x2\x42F\x432\x3\x2");
		sb.Append("\x2\x2\x430\x42E\x3\x2\x2\x2\x431\x427\x3\x2\x2\x2\x431\x432");
		sb.Append("\x3\x2\x2\x2\x432\x434\x3\x2\x2\x2\x433\x435\x5\x62\x32\x2\x434");
		sb.Append("\x433\x3\x2\x2\x2\x434\x435\x3\x2\x2\x2\x435\x437\x3\x2\x2\x2");
		sb.Append("\x436\x3E8\x3\x2\x2\x2\x436\x3FA\x3\x2\x2\x2\x436\x41D\x3\x2");
		sb.Append("\x2\x2\x437)\x3\x2\x2\x2\x438\x439\a \x2\x2\x439\x43A\a\x21A");
		sb.Append("\x2\x2\x43A\x43B\x5\x206\x104\x2\x43B\x43C\a\a\x2\x2\x43C\x43D");
		sb.Append("\a\x134\x2\x2\x43D\x441\a\x3DF\x2\x2\x43E\x43F\a\x158\x2\x2");
		sb.Append("\x43F\x440\a\x3C7\x2\x2\x440\x442\x5\x20E\x108\x2\x441\x43E");
		sb.Append("\x3\x2\x2\x2\x441\x442\x3\x2\x2\x2\x442\x448\x3\x2\x2\x2\x443");
		sb.Append("\x445\a\x146\x2\x2\x444\x446\a\x3C7\x2\x2\x445\x444\x3\x2\x2");
		sb.Append("\x2\x445\x446\x3\x2\x2\x2\x446\x447\x3\x2\x2\x2\x447\x449\x5");
		sb.Append("\x1FC\xFF\x2\x448\x443\x3\x2\x2\x2\x448\x449\x3\x2\x2\x2\x449");
		sb.Append("+\x3\x2\x2\x2\x44A\x44B\a \x2\x2\x44B\x44C\a\x21A\x2\x2\x44C");
		sb.Append("\x44D\x5\x206\x104\x2\x44D\x44E\a\a\x2\x2\x44E\x44F\a\x134\x2");
		sb.Append("\x2\x44F\x450\a\x3DF\x2\x2\x450\x451\a\xA4\x2\x2\x451\x452\a");
		sb.Append("\x183\x2\x2\x452\x453\a\x41\x2\x2\x453\x459\x5\x206\x104\x2");
		sb.Append("\x454\x456\a\x154\x2\x2\x455\x457\a\x3C7\x2\x2\x456\x455\x3");
		sb.Append("\x2\x2\x2\x456\x457\x3\x2\x2\x2\x457\x458\x3\x2\x2\x2\x458\x45A");
		sb.Append("\x5\x20E\x108\x2\x459\x454\x3\x2\x2\x2\x459\x45A\x3\x2\x2\x2");
		sb.Append("\x45A\x460\x3\x2\x2\x2\x45B\x45D\a\x16E\x2\x2\x45C\x45E\a\x3C7");
		sb.Append("\x2\x2\x45D\x45C\x3\x2\x2\x2\x45D\x45E\x3\x2\x2\x2\x45E\x45F");
		sb.Append("\x3\x2\x2\x2\x45F\x461\x5\x20E\x108\x2\x460\x45B\x3\x2\x2\x2");
		sb.Append("\x460\x461\x3\x2\x2\x2\x461\x467\x3\x2\x2\x2\x462\x464\a\x108");
		sb.Append("\x2\x2\x463\x465\a\x3C7\x2\x2\x464\x463\x3\x2\x2\x2\x464\x465");
		sb.Append("\x3\x2\x2\x2\x465\x466\x3\x2\x2\x2\x466\x468\x5\x20E\x108\x2");
		sb.Append("\x467\x462\x3\x2\x2\x2\x467\x468\x3\x2\x2\x2\x468\x46E\x3\x2");
		sb.Append("\x2\x2\x469\x46B\a\x19D\x2\x2\x46A\x46C\a\x3C7\x2\x2\x46B\x46A");
		sb.Append("\x3\x2\x2\x2\x46B\x46C\x3\x2\x2\x2\x46C\x46D\x3\x2\x2\x2\x46D");
		sb.Append("\x46F\x5\x20E\x108\x2\x46E\x469\x3\x2\x2\x2\x46E\x46F\x3\x2");
		sb.Append("\x2\x2\x46F\x475\x3\x2\x2\x2\x470\x472\a\x1B1\x2\x2\x471\x473");
		sb.Append("\a\x3C7\x2\x2\x472\x471\x3\x2\x2\x2\x472\x473\x3\x2\x2\x2\x473");
		sb.Append("\x474\x3\x2\x2\x2\x474\x476\x5\x206\x104\x2\x475\x470\x3\x2");
		sb.Append("\x2\x2\x475\x476\x3\x2\x2\x2\x476\x478\x3\x2\x2\x2\x477\x479");
		sb.Append("\a\x232\x2\x2\x478\x477\x3\x2\x2\x2\x478\x479\x3\x2\x2\x2\x479");
		sb.Append("\x47F\x3\x2\x2\x2\x47A\x47C\a\x122\x2\x2\x47B\x47D\a\x3C7\x2");
		sb.Append("\x2\x47C\x47B\x3\x2\x2\x2\x47C\x47D\x3\x2\x2\x2\x47D\x47E\x3");
		sb.Append("\x2\x2\x2\x47E\x480\a\x3DF\x2\x2\x47F\x47A\x3\x2\x2\x2\x47F");
		sb.Append("\x480\x3\x2\x2\x2\x480\x481\x3\x2\x2\x2\x481\x483\a\x146\x2");
		sb.Append("\x2\x482\x484\a\x3C7\x2\x2\x483\x482\x3\x2\x2\x2\x483\x484\x3");
		sb.Append("\x2\x2\x2\x484\x485\x3\x2\x2\x2\x485\x486\x5\x1FC\xFF\x2\x486");
		sb.Append("-\x3\x2\x2\x2\x487\x489\a \x2\x2\x488\x48A\x5\x34\x1B\x2\x489");
		sb.Append("\x488\x3\x2\x2\x2\x489\x48A\x3\x2\x2\x2\x48A\x48B\x3\x2\x2\x2");
		sb.Append("\x48B\x48C\a\x9B\x2\x2\x48C\x48D\x5\x1EC\xF7\x2\x48D\x48E\t");
		sb.Append("\t\x2\x2\x48E\x48F\t\n\x2\x2\x48F\x490\ah\x2\x2\x490\x491\x5");
		sb.Append("\x1EE\xF8\x2\x491\x492\a:\x2\x2\x492\x493\a\x30\x2\x2\x493\x496");
		sb.Append("\a\x1ED\x2\x2\x494\x495\t\v\x2\x2\x495\x497\x5\x1EC\xF7\x2\x496");
		sb.Append("\x494\x3\x2\x2\x2\x496\x497\x3\x2\x2\x2\x497\x498\x3\x2\x2\x2");
		sb.Append("\x498\x499\x5\x15A\xAE\x2\x499/\x3\x2\x2\x2\x49A\x49D\a \x2");
		sb.Append("\x2\x49B\x49C\al\x2\x2\x49C\x49E\a}\x2\x2\x49D\x49B\x3\x2\x2");
		sb.Append("\x2\x49D\x49E\x3\x2\x2\x2\x49E\x4A2\x3\x2\x2\x2\x49F\x4A0\a");
		sb.Append("\x103\x2\x2\x4A0\x4A1\a\x3C7\x2\x2\x4A1\x4A3\t\f\x2\x2\x4A2");
		sb.Append("\x49F\x3\x2\x2\x2\x4A2\x4A3\x3\x2\x2\x2\x4A3\x4A5\x3\x2\x2\x2");
		sb.Append("\x4A4\x4A6\x5\x34\x1B\x2\x4A5\x4A4\x3\x2\x2\x2\x4A5\x4A6\x3");
		sb.Append("\x2\x2\x2\x4A6\x4AA\x3\x2\x2\x2\x4A7\x4A8\a\x8C\x2\x2\x4A8\x4A9");
		sb.Append("\a\x1F2\x2\x2\x4A9\x4AB\t\r\x2\x2\x4AA\x4A7\x3\x2\x2\x2\x4AA");
		sb.Append("\x4AB\x3\x2\x2\x2\x4AB\x4AC\x3\x2\x2\x2\x4AC\x4AD\a\x22F\x2");
		sb.Append("\x2\x4AD\x4B2\x5\x1EC\xF7\x2\x4AE\x4AF\a\x3D0\x2\x2\x4AF\x4B0");
		sb.Append("\x5\x226\x114\x2\x4B0\x4B1\a\x3D1\x2\x2\x4B1\x4B3\x3\x2\x2\x2");
		sb.Append("\x4B2\x4AE\x3\x2\x2\x2\x4B2\x4B3\x3\x2\x2\x2\x4B3\x4B4\x3\x2");
		sb.Append("\x2\x2\x4B4\x4B5\a\r\x2\x2\x4B5\x4BC\x5\xB4[\x2\x4B6\x4B8\a");
		sb.Append("\xAA\x2\x2\x4B7\x4B9\t\xE\x2\x2\x4B8\x4B7\x3\x2\x2\x2\x4B8\x4B9");
		sb.Append("\x3\x2\x2\x2\x4B9\x4BA\x3\x2\x2\x2\x4BA\x4BB\a\x19\x2\x2\x4BB");
		sb.Append("\x4BD\aj\x2\x2\x4BC\x4B6\x3\x2\x2\x2\x4BC\x4BD\x3\x2\x2\x2\x4BD");
		sb.Append("\x31\x3\x2\x2\x2\x4BE\x4C0\a\'\x2\x2\x4BF\x4BE\x3\x2\x2\x2\x4BF");
		sb.Append("\x4C0\x3\x2\x2\x2\x4C0\x4C4\x3\x2\x2\x2\x4C1\x4C2\a\x18\x2\x2");
		sb.Append("\x4C2\x4C5\a\x87\x2\x2\x4C3\x4C5\a\x2AF\x2\x2\x4C4\x4C1\x3\x2");
		sb.Append("\x2\x2\x4C4\x4C3\x3\x2\x2\x2\x4C5\x4C7\x3\x2\x2\x2\x4C6\x4C8");
		sb.Append("\a\x3C7\x2\x2\x4C7\x4C6\x3\x2\x2\x2\x4C7\x4C8\x3\x2\x2\x2\x4C8");
		sb.Append("\x4CB\x3\x2\x2\x2\x4C9\x4CC\x5\x1F8\xFD\x2\x4CA\x4CC\a\'\x2");
		sb.Append("\x2\x4CB\x4C9\x3\x2\x2\x2\x4CB\x4CA\x3\x2\x2\x2\x4CC\x4D6\x3");
		sb.Append("\x2\x2\x2\x4CD\x4CF\a\'\x2\x2\x4CE\x4CD\x3\x2\x2\x2\x4CE\x4CF");
		sb.Append("\x3\x2\x2\x2\x4CF\x4D0\x3\x2\x2\x2\x4D0\x4D2\a\x1A\x2\x2\x4D1");
		sb.Append("\x4D3\a\x3C7\x2\x2\x4D2\x4D1\x3\x2\x2\x2\x4D2\x4D3\x3\x2\x2");
		sb.Append("\x2\x4D3\x4D4\x3\x2\x2\x2\x4D4\x4D6\x5\x1FA\xFE\x2\x4D5\x4BF");
		sb.Append("\x3\x2\x2\x2\x4D5\x4CE\x3\x2\x2\x2\x4D6\x33\x3\x2\x2\x2\x4D7");
		sb.Append("\x4D8\a\x137\x2\x2\x4D8\x4DF\a\x3C7\x2\x2\x4D9\x4E0\x5\x1F4");
		sb.Append("\xFB\x2\x4DA\x4DD\a\"\x2\x2\x4DB\x4DC\a\x3D0\x2\x2\x4DC\x4DE");
		sb.Append("\a\x3D1\x2\x2\x4DD\x4DB\x3\x2\x2\x2\x4DD\x4DE\x3\x2\x2\x2\x4DE");
		sb.Append("\x4E0\x3\x2\x2\x2\x4DF\x4D9\x3\x2\x2\x2\x4DF\x4DA\x3\x2\x2\x2");
		sb.Append("\x4E0\x35\x3\x2\x2\x2\x4E1\x4E2\a\x105\x2\x2\x4E2\x4E6\x5\x38");
		sb.Append("\x1D\x2\x4E3\x4E5\x5:\x1E\x2\x4E4\x4E3\x3\x2\x2\x2\x4E5\x4E8");
		sb.Append("\x3\x2\x2\x2\x4E6\x4E4\x3\x2\x2\x2\x4E6\x4E7\x3\x2\x2\x2\x4E7");
		sb.Append("\x504\x3\x2\x2\x2\x4E8\x4E6\x3\x2\x2\x2\x4E9\x4EC\a\x14E\x2");
		sb.Append("\x2\x4EA\x4ED\x5\x20C\x107\x2\x4EB\x4ED\x5\x254\x12B\x2\x4EC");
		sb.Append("\x4EA\x3\x2\x2\x2\x4EC\x4EB\x3\x2\x2\x2\x4ED\x4EE\x3\x2\x2\x2");
		sb.Append("\x4EE\x4F7\x5<\x1F\x2\x4EF\x4F0\a\x209\x2\x2\x4F0\x4F4\x5\x38");
		sb.Append("\x1D\x2\x4F1\x4F3\x5:\x1E\x2\x4F2\x4F1\x3\x2\x2\x2\x4F3\x4F6");
		sb.Append("\x3\x2\x2\x2\x4F4\x4F2\x3\x2\x2\x2\x4F4\x4F5\x3\x2\x2\x2\x4F5");
		sb.Append("\x4F8\x3\x2\x2\x2\x4F6\x4F4\x3\x2\x2\x2\x4F7\x4EF\x3\x2\x2\x2");
		sb.Append("\x4F7\x4F8\x3\x2\x2\x2\x4F8\x501\x3\x2\x2\x2\x4F9\x4FA\a\x145");
		sb.Append("\x2\x2\x4FA\x4FE\x5\x38\x1D\x2\x4FB\x4FD\x5:\x1E\x2\x4FC\x4FB");
		sb.Append("\x3\x2\x2\x2\x4FD\x500\x3\x2\x2\x2\x4FE\x4FC\x3\x2\x2\x2\x4FE");
		sb.Append("\x4FF\x3\x2\x2\x2\x4FF\x502\x3\x2\x2\x2\x500\x4FE\x3\x2\x2\x2");
		sb.Append("\x501\x4F9\x3\x2\x2\x2\x501\x502\x3\x2\x2\x2\x502\x504\x3\x2");
		sb.Append("\x2\x2\x503\x4E1\x3\x2\x2\x2\x503\x4E9\x3\x2\x2\x2\x504\x37");
		sb.Append("\x3\x2\x2\x2\x505\x50A\a\xEE\x2\x2\x506\x50A\x5\x210\x109\x2");
		sb.Append("\x507\x50A\x5\x20C\x107\x2\x508\x50A\x5\x254\x12B\x2\x509\x505");
		sb.Append("\x3\x2\x2\x2\x509\x506\x3\x2\x2\x2\x509\x507\x3\x2\x2\x2\x509");
		sb.Append("\x508\x3\x2\x2\x2\x50A\x39\x3\x2\x2\x2\x50B\x50C\a\x3C2\x2\x2");
		sb.Append("\x50C\x50F\aL\x2\x2\x50D\x510\x5\x20C\x107\x2\x50E\x510\x5\x254");
		sb.Append("\x12B\x2\x50F\x50D\x3\x2\x2\x2\x50F\x50E\x3\x2\x2\x2\x510\x511");
		sb.Append("\x3\x2\x2\x2\x511\x512\x5<\x1F\x2\x512;\x3\x2\x2\x2\x513\x521");
		sb.Append("\x5\x26A\x136\x2\x514\x521\a\xBF\x2\x2\x515\x521\a\xD1\x2\x2");
		sb.Append("\x516\x521\a\xD2\x2\x2\x517\x521\a\xD3\x2\x2\x518\x521\a\xD4");
		sb.Append("\x2\x2\x519\x521\a\xD5\x2\x2\x51A\x521\a\xD6\x2\x2\x51B\x521");
		sb.Append("\a\xD7\x2\x2\x51C\x521\a\xD8\x2\x2\x51D\x521\a\xD9\x2\x2\x51E");
		sb.Append("\x521\a\xDA\x2\x2\x51F\x521\a\xDB\x2\x2\x520\x513\x3\x2\x2\x2");
		sb.Append("\x520\x514\x3\x2\x2\x2\x520\x515\x3\x2\x2\x2\x520\x516\x3\x2");
		sb.Append("\x2\x2\x520\x517\x3\x2\x2\x2\x520\x518\x3\x2\x2\x2\x520\x519");
		sb.Append("\x3\x2\x2\x2\x520\x51A\x3\x2\x2\x2\x520\x51B\x3\x2\x2\x2\x520");
		sb.Append("\x51C\x3\x2\x2\x2\x520\x51D\x3\x2\x2\x2\x520\x51E\x3\x2\x2\x2");
		sb.Append("\x520\x51F\x3\x2\x2\x2\x521=\x3\x2\x2\x2\x522\x528\a\x142\x2");
		sb.Append("\x2\x523\x528\a\x13B\x2\x2\x524\x525\a\x13B\x2\x2\x525\x526");
		sb.Append("\ah\x2\x2\x526\x528\a\x1F9\x2\x2\x527\x522\x3\x2\x2\x2\x527");
		sb.Append("\x523\x3\x2\x2\x2\x527\x524\x3\x2\x2\x2\x528?\x3\x2\x2\x2\x529");
		sb.Append("\x52A\a\xA5\x2\x2\x52A\x52B\t\xF\x2\x2\x52B\x41\x3\x2\x2\x2");
		sb.Append("\x52C\x52E\a\x17B\x2\x2\x52D\x52F\a\x3C7\x2\x2\x52E\x52D\x3");
		sb.Append("\x2\x2\x2\x52E\x52F\x3\x2\x2\x2\x52F\x530\x3\x2\x2\x2\x530\x53A");
		sb.Append("\x5\x20E\x108\x2\x531\x53A\x5@!\x2\x532\x533\a\xAA\x2\x2\x533");
		sb.Append("\x534\a\x1C0\x2\x2\x534\x53A\x5\x206\x104\x2\x535\x536\a\x122");
		sb.Append("\x2\x2\x536\x53A\a\x3DF\x2\x2\x537\x53A\a\x173\x2\x2\x538\x53A");
		sb.Append("\a\x231\x2\x2\x539\x52C\x3\x2\x2\x2\x539\x531\x3\x2\x2\x2\x539");
		sb.Append("\x532\x3\x2\x2\x2\x539\x535\x3\x2\x2\x2\x539\x537\x3\x2\x2\x2");
		sb.Append("\x539\x538\x3\x2\x2\x2\x53A\x43\x3\x2\x2\x2\x53B\x53D\t\x10");
		sb.Append("\x2\x2\x53C\x53B\x3\x2\x2\x2\x53C\x53D\x3\x2\x2\x2\x53D\x53E");
		sb.Append("\x3\x2\x2\x2\x53E\x53F\x5\x206\x104\x2\x53F\x540\x5\x21A\x10E");
		sb.Append("\x2\x540\x45\x3\x2\x2\x2\x541\x542\x5\x206\x104\x2\x542\x543");
		sb.Append("\x5\x21A\x10E\x2\x543G\x3\x2\x2\x2\x544\x545\a\x122\x2\x2\x545");
		sb.Append("\x55C\a\x3DF\x2\x2\x546\x547\a\x17C\x2\x2\x547\x55C\a\x8C\x2");
		sb.Append("\x2\x548\x54A\a\x65\x2\x2\x549\x548\x3\x2\x2\x2\x549\x54A\x3");
		sb.Append("\x2\x2\x2\x54A\x54B\x3\x2\x2\x2\x54B\x55C\a,\x2\x2\x54C\x54D");
		sb.Append("\a\x12E\x2\x2\x54D\x557\a\x8C\x2\x2\x54E\x54F\a\x1B0\x2\x2\x54F");
		sb.Append("\x557\a\x8C\x2\x2\x550\x551\aw\x2\x2\x551\x552\a\x8C\x2\x2\x552");
		sb.Append("\x557\a\x133\x2\x2\x553\x554\a\x63\x2\x2\x554\x555\a\x8C\x2");
		sb.Append("\x2\x555\x557\a\x133\x2\x2\x556\x54C\x3\x2\x2\x2\x556\x54E\x3");
		sb.Append("\x2\x2\x2\x556\x550\x3\x2\x2\x2\x556\x553\x3\x2\x2\x2\x557\x55C");
		sb.Append("\x3\x2\x2\x2\x558\x559\a\x8C\x2\x2\x559\x55A\a\x1F2\x2\x2\x55A");
		sb.Append("\x55C\t\r\x2\x2\x55B\x544\x3\x2\x2\x2\x55B\x546\x3\x2\x2\x2");
		sb.Append("\x55B\x549\x3\x2\x2\x2\x55B\x556\x3\x2\x2\x2\x55B\x558\x3\x2");
		sb.Append("\x2\x2\x55CI\x3\x2\x2\x2\x55D\x55E\a\x168\x2\x2\x55E\x56C\a");
		sb.Append("\x3DF\x2\x2\x55F\x560\a$\x2\x2\x560\x56C\a\x3DF\x2\x2\x561\x562");
		sb.Append("\a\x229\x2\x2\x562\x56C\a\x3DF\x2\x2\x563\x564\a\x1C4\x2\x2");
		sb.Append("\x564\x56C\a\x3DF\x2\x2\x565\x566\a\x1FC\x2\x2\x566\x56C\a\x3DF");
		sb.Append("\x2\x2\x567\x568\a\x1BD\x2\x2\x568\x56C\a\x3DF\x2\x2\x569\x56A");
		sb.Append("\a\x1C9\x2\x2\x56A\x56C\x5\x20C\x107\x2\x56B\x55D\x3\x2\x2\x2");
		sb.Append("\x56B\x55F\x3\x2\x2\x2\x56B\x561\x3\x2\x2\x2\x56B\x563\x3\x2");
		sb.Append("\x2\x2\x56B\x565\x3\x2\x2\x2\x56B\x567\x3\x2\x2\x2\x56B\x569");
		sb.Append("\x3\x2\x2\x2\x56CK\x3\x2\x2\x2\x56D\x56E\a\x3D0\x2\x2\x56E\x573");
		sb.Append("\x5N(\x2\x56F\x570\a\x3D2\x2\x2\x570\x572\x5N(\x2\x571\x56F");
		sb.Append("\x3\x2\x2\x2\x572\x575\x3\x2\x2\x2\x573\x571\x3\x2\x2\x2\x573");
		sb.Append("\x574\x3\x2\x2\x2\x574\x576\x3\x2\x2\x2\x575\x573\x3\x2\x2\x2");
		sb.Append("\x576\x577\a\x3D1\x2\x2\x577M\x3\x2\x2\x2\x578\x579\x5\x206");
		sb.Append("\x104\x2\x579\x57A\x5P)\x2\x57A\x57E\x3\x2\x2\x2\x57B\x57E\x5");
		sb.Append("T+\x2\x57C\x57E\x5\\/\x2\x57D\x578\x3\x2\x2\x2\x57D\x57B\x3");
		sb.Append("\x2\x2\x2\x57D\x57C\x3\x2\x2\x2\x57EO\x3\x2\x2\x2\x57F\x583");
		sb.Append("\x5\x21A\x10E\x2\x580\x582\x5R*\x2\x581\x580\x3\x2\x2\x2\x582");
		sb.Append("\x585\x3\x2\x2\x2\x583\x581\x3\x2\x2\x2\x583\x584\x3\x2\x2\x2");
		sb.Append("\x584Q\x3\x2\x2\x2\x585\x583\x3\x2\x2\x2\x586\x5AF\x5\x216\x10C");
		sb.Append("\x2\x587\x588\a\'\x2\x2\x588\x5AF\x5\x236\x11C\x2\x589\x58E");
		sb.Append("\a\x109\x2\x2\x58A\x58B\ah\x2\x2\x58B\x58C\a\xA2\x2\x2\x58C");
		sb.Append("\x58E\x5\x238\x11D\x2\x58D\x589\x3\x2\x2\x2\x58D\x58A\x3\x2");
		sb.Append("\x2\x2\x58E\x5AF\x3\x2\x2\x2\x58F\x591\ar\x2\x2\x590\x58F\x3");
		sb.Append("\x2\x2\x2\x590\x591\x3\x2\x2\x2\x591\x592\x3\x2\x2\x2\x592\x5AF");
		sb.Append("\aQ\x2\x2\x593\x595\a\x9F\x2\x2\x594\x596\aQ\x2\x2\x595\x594");
		sb.Append("\x3\x2\x2\x2\x595\x596\x3\x2\x2\x2\x596\x5AF\x3\x2\x2\x2\x597");
		sb.Append("\x598\a\x122\x2\x2\x598\x5AF\a\x3DF\x2\x2\x599\x59A\a\x120\x2");
		sb.Append("\x2\x59A\x5AF\t\x11\x2\x2\x59B\x59C\a\x20F\x2\x2\x59C\x5AF\t");
		sb.Append("\x12\x2\x2\x59D\x5AF\x5V,\x2\x59E\x59F\a\x1A\x2\x2\x59F\x5AF");
		sb.Append("\x5\x1FA\xFE\x2\x5A0\x5A1\a?\x2\x2\x5A1\x5A3\a\n\x2\x2\x5A2");
		sb.Append("\x5A0\x3\x2\x2\x2\x5A2\x5A3\x3\x2\x2\x2\x5A3\x5A4\x3\x2\x2\x2");
		sb.Append("\x5A4\x5A5\a\r\x2\x2\x5A5\x5A6\a\x3D0\x2\x2\x5A6\x5A7\x5\x254");
		sb.Append("\x12B\x2\x5A7\x5A9\a\x3D1\x2\x2\x5A8\x5AA\t\x13\x2\x2\x5A9\x5A8");
		sb.Append("\x3\x2\x2\x2\x5A9\x5AA\x3\x2\x2\x2\x5AA\x5AF\x3\x2\x2\x2\x5AB");
		sb.Append("\x5AC\a\xD0\x2\x2\x5AC\x5AD\a\'\x2\x2\x5AD\x5AF\a\x22D\x2\x2");
		sb.Append("\x5AE\x586\x3\x2\x2\x2\x5AE\x587\x3\x2\x2\x2\x5AE\x58D\x3\x2");
		sb.Append("\x2\x2\x5AE\x590\x3\x2\x2\x2\x5AE\x593\x3\x2\x2\x2\x5AE\x597");
		sb.Append("\x3\x2\x2\x2\x5AE\x599\x3\x2\x2\x2\x5AE\x59B\x3\x2\x2\x2\x5AE");
		sb.Append("\x59D\x3\x2\x2\x2\x5AE\x59E\x3\x2\x2\x2\x5AE\x5A2\x3\x2\x2\x2");
		sb.Append("\x5AE\x5AB\x3\x2\x2\x2\x5AFS\x3\x2\x2\x2\x5B0\x5B2\a\x1D\x2");
		sb.Append("\x2\x5B1\x5B3\x5\x206\x104\x2\x5B2\x5B1\x3\x2\x2\x2\x5B2\x5B3");
		sb.Append("\x3\x2\x2\x2\x5B3\x5B5\x3\x2\x2\x2\x5B4\x5B0\x3\x2\x2\x2\x5B4");
		sb.Append("\x5B5\x3\x2\x2\x2\x5B5\x5B6\x3\x2\x2\x2\x5B6\x5B7\ar\x2\x2\x5B7");
		sb.Append("\x5B9\aQ\x2\x2\x5B8\x5BA\x5\x206\x104\x2\x5B9\x5B8\x3\x2\x2");
		sb.Append("\x2\x5B9\x5BA\x3\x2\x2\x2\x5BA\x5BC\x3\x2\x2\x2\x5BB\x5BD\x5");
		sb.Append("@!\x2\x5BC\x5BB\x3\x2\x2\x2\x5BC\x5BD\x3\x2\x2\x2\x5BD\x5BE");
		sb.Append("\x3\x2\x2\x2\x5BE\x5C2\x5\x22A\x116\x2\x5BF\x5C1\x5\x42\"\x2");
		sb.Append("\x5C0\x5BF\x3\x2\x2\x2\x5C1\x5C4\x3\x2\x2\x2\x5C2\x5C0\x3\x2");
		sb.Append("\x2\x2\x5C2\x5C3\x3\x2\x2\x2\x5C3\x5F6\x3\x2\x2\x2\x5C4\x5C2");
		sb.Append("\x3\x2\x2\x2\x5C5\x5C7\a\x1D\x2\x2\x5C6\x5C8\x5\x206\x104\x2");
		sb.Append("\x5C7\x5C6\x3\x2\x2\x2\x5C7\x5C8\x3\x2\x2\x2\x5C8\x5CA\x3\x2");
		sb.Append("\x2\x2\x5C9\x5C5\x3\x2\x2\x2\x5C9\x5CA\x3\x2\x2\x2\x5CA\x5CB");
		sb.Append("\x3\x2\x2\x2\x5CB\x5CD\a\x9F\x2\x2\x5CC\x5CE\t\x14\x2\x2\x5CD");
		sb.Append("\x5CC\x3\x2\x2\x2\x5CD\x5CE\x3\x2\x2\x2\x5CE\x5D0\x3\x2\x2\x2");
		sb.Append("\x5CF\x5D1\x5\x206\x104\x2\x5D0\x5CF\x3\x2\x2\x2\x5D0\x5D1\x3");
		sb.Append("\x2\x2\x2\x5D1\x5D3\x3\x2\x2\x2\x5D2\x5D4\x5@!\x2\x5D3\x5D2");
		sb.Append("\x3\x2\x2\x2\x5D3\x5D4\x3\x2\x2\x2\x5D4\x5D5\x3\x2\x2\x2\x5D5");
		sb.Append("\x5D9\x5\x22A\x116\x2\x5D6\x5D8\x5\x42\"\x2\x5D7\x5D6\x3\x2");
		sb.Append("\x2\x2\x5D8\x5DB\x3\x2\x2\x2\x5D9\x5D7\x3\x2\x2\x2\x5D9\x5DA");
		sb.Append("\x3\x2\x2\x2\x5DA\x5F6\x3\x2\x2\x2\x5DB\x5D9\x3\x2\x2\x2\x5DC");
		sb.Append("\x5DE\a\x1D\x2\x2\x5DD\x5DF\x5\x206\x104\x2\x5DE\x5DD\x3\x2");
		sb.Append("\x2\x2\x5DE\x5DF\x3\x2\x2\x2\x5DF\x5E1\x3\x2\x2\x2\x5E0\x5DC");
		sb.Append("\x3\x2\x2\x2\x5E0\x5E1\x3\x2\x2\x2\x5E1\x5E2\x3\x2\x2\x2\x5E2");
		sb.Append("\x5E3\a<\x2\x2\x5E3\x5E5\aQ\x2\x2\x5E4\x5E6\x5\x206\x104\x2");
		sb.Append("\x5E5\x5E4\x3\x2\x2\x2\x5E5\x5E6\x3\x2\x2\x2\x5E6\x5E7\x3\x2");
		sb.Append("\x2\x2\x5E7\x5E8\x5\x22A\x116\x2\x5E8\x5E9\x5V,\x2\x5E9\x5F6");
		sb.Append("\x3\x2\x2\x2\x5EA\x5EC\a\x1D\x2\x2\x5EB\x5ED\x5\x206\x104\x2");
		sb.Append("\x5EC\x5EB\x3\x2\x2\x2\x5EC\x5ED\x3\x2\x2\x2\x5ED\x5EF\x3\x2");
		sb.Append("\x2\x2\x5EE\x5EA\x3\x2\x2\x2\x5EE\x5EF\x3\x2\x2\x2\x5EF\x5F0");
		sb.Append("\x3\x2\x2\x2\x5F0\x5F1\a\x19\x2\x2\x5F1\x5F2\a\x3D0\x2\x2\x5F2");
		sb.Append("\x5F3\x5\x254\x12B\x2\x5F3\x5F4\a\x3D1\x2\x2\x5F4\x5F6\x3\x2");
		sb.Append("\x2\x2\x5F5\x5B4\x3\x2\x2\x2\x5F5\x5C9\x3\x2\x2\x2\x5F5\x5E0");
		sb.Append("\x3\x2\x2\x2\x5F5\x5EE\x3\x2\x2\x2\x5F6U\x3\x2\x2\x2\x5F7\x5F8");
		sb.Append("\ax\x2\x2\x5F8\x5FA\x5\x1EE\xF8\x2\x5F9\x5FB\x5\x22A\x116\x2");
		sb.Append("\x5FA\x5F9\x3\x2\x2\x2\x5FA\x5FB\x3\x2\x2\x2\x5FB\x5FE\x3\x2");
		sb.Append("\x2\x2\x5FC\x5FD\a\x61\x2\x2\x5FD\x5FF\t\x15\x2\x2\x5FE\x5FC");
		sb.Append("\x3\x2\x2\x2\x5FE\x5FF\x3\x2\x2\x2\x5FF\x601\x3\x2\x2\x2\x600");
		sb.Append("\x602\x5X-\x2\x601\x600\x3\x2\x2\x2\x601\x602\x3\x2\x2\x2\x602");
		sb.Append("W\x3\x2\x2\x2\x603\x604\ah\x2\x2\x604\x605\a)\x2\x2\x605\x609");
		sb.Append("\x5Z.\x2\x606\x607\ah\x2\x2\x607\x608\a\xA2\x2\x2\x608\x60A");
		sb.Append("\x5Z.\x2\x609\x606\x3\x2\x2\x2\x609\x60A\x3\x2\x2\x2\x60A\x614");
		sb.Append("\x3\x2\x2\x2\x60B\x60C\ah\x2\x2\x60C\x60D\a\xA2\x2\x2\x60D\x611");
		sb.Append("\x5Z.\x2\x60E\x60F\ah\x2\x2\x60F\x610\a)\x2\x2\x610\x612\x5");
		sb.Append("Z.\x2\x611\x60E\x3\x2\x2\x2\x611\x612\x3\x2\x2\x2\x612\x614");
		sb.Append("\x3\x2\x2\x2\x613\x603\x3\x2\x2\x2\x613\x60B\x3\x2\x2\x2\x614");
		sb.Append("Y\x3\x2\x2\x2\x615\x61C\a\x7F\x2\x2\x616\x61C\a\x14\x2\x2\x617");
		sb.Append("\x618\a\x87\x2\x2\x618\x61C\ag\x2\x2\x619\x61A\a\x1B0\x2\x2");
		sb.Append("\x61A\x61C\a\x100\x2\x2\x61B\x615\x3\x2\x2\x2\x61B\x616\x3\x2");
		sb.Append("\x2\x2\x61B\x617\x3\x2\x2\x2\x61B\x619\x3\x2\x2\x2\x61C[\x3");
		sb.Append("\x2\x2\x2\x61D\x61F\t\x14\x2\x2\x61E\x620\x5\x206\x104\x2\x61F");
		sb.Append("\x61E\x3\x2\x2\x2\x61F\x620\x3\x2\x2\x2\x620\x622\x3\x2\x2\x2");
		sb.Append("\x621\x623\x5@!\x2\x622\x621\x3\x2\x2\x2\x622\x623\x3\x2\x2");
		sb.Append("\x2\x623\x624\x3\x2\x2\x2\x624\x628\x5\x22A\x116\x2\x625\x627");
		sb.Append("\x5\x42\"\x2\x626\x625\x3\x2\x2\x2\x627\x62A\x3\x2\x2\x2\x628");
		sb.Append("\x626\x3\x2\x2\x2\x628\x629\x3\x2\x2\x2\x629\x63A\x3\x2\x2\x2");
		sb.Append("\x62A\x628\x3\x2\x2\x2\x62B\x62D\t\x16\x2\x2\x62C\x62E\t\x14");
		sb.Append("\x2\x2\x62D\x62C\x3\x2\x2\x2\x62D\x62E\x3\x2\x2\x2\x62E\x630");
		sb.Append("\x3\x2\x2\x2\x62F\x631\x5\x206\x104\x2\x630\x62F\x3\x2\x2\x2");
		sb.Append("\x630\x631\x3\x2\x2\x2\x631\x632\x3\x2\x2\x2\x632\x636\x5\x22A");
		sb.Append("\x116\x2\x633\x635\x5\x42\"\x2\x634\x633\x3\x2\x2\x2\x635\x638");
		sb.Append("\x3\x2\x2\x2\x636\x634\x3\x2\x2\x2\x636\x637\x3\x2\x2\x2\x637");
		sb.Append("\x63A\x3\x2\x2\x2\x638\x636\x3\x2\x2\x2\x639\x61D\x3\x2\x2\x2");
		sb.Append("\x639\x62B\x3\x2\x2\x2\x63A]\x3\x2\x2\x2\x63B\x63D\a\x146\x2");
		sb.Append("\x2\x63C\x63E\a\x3C7\x2\x2\x63D\x63C\x3\x2\x2\x2\x63D\x63E\x3");
		sb.Append("\x2\x2\x2\x63E\x63F\x3\x2\x2\x2\x63F\x6CC\x5\x1FC\xFF\x2\x640");
		sb.Append("\x642\a\x109\x2\x2\x641\x643\a\x3C7\x2\x2\x642\x641\x3\x2\x2");
		sb.Append("\x2\x642\x643\x3\x2\x2\x2\x643\x644\x3\x2\x2\x2\x644\x6CC\x5");
		sb.Append("\x20C\x107\x2\x645\x647\a\x10A\x2\x2\x646\x648\a\x3C7\x2\x2");
		sb.Append("\x647\x646\x3\x2\x2\x2\x647\x648\x3\x2\x2\x2\x648\x649\x3\x2");
		sb.Append("\x2\x2\x649\x6CC\x5\x20C\x107\x2\x64A\x64C\a\'\x2\x2\x64B\x64A");
		sb.Append("\x3\x2\x2\x2\x64B\x64C\x3\x2\x2\x2\x64C\x650\x3\x2\x2\x2\x64D");
		sb.Append("\x64E\a\x18\x2\x2\x64E\x651\a\x87\x2\x2\x64F\x651\a\x2AF\x2");
		sb.Append("\x2\x650\x64D\x3\x2\x2\x2\x650\x64F\x3\x2\x2\x2\x651\x653\x3");
		sb.Append("\x2\x2\x2\x652\x654\a\x3C7\x2\x2\x653\x652\x3\x2\x2\x2\x653");
		sb.Append("\x654\x3\x2\x2\x2\x654\x657\x3\x2\x2\x2\x655\x658\x5\x1F8\xFD");
		sb.Append("\x2\x656\x658\a\'\x2\x2\x657\x655\x3\x2\x2\x2\x657\x656\x3\x2");
		sb.Append("\x2\x2\x658\x6CC\x3\x2\x2\x2\x659\x65B\t\x17\x2\x2\x65A\x65C");
		sb.Append("\a\x3C7\x2\x2\x65B\x65A\x3\x2\x2\x2\x65B\x65C\x3\x2\x2\x2\x65C");
		sb.Append("\x65D\x3\x2\x2\x2\x65D\x6CC\t\x18\x2\x2\x65E\x660\a\'\x2\x2");
		sb.Append("\x65F\x65E\x3\x2\x2\x2\x65F\x660\x3\x2\x2\x2\x660\x661\x3\x2");
		sb.Append("\x2\x2\x661\x663\a\x1A\x2\x2\x662\x664\a\x3C7\x2\x2\x663\x662");
		sb.Append("\x3\x2\x2\x2\x663\x664\x3\x2\x2\x2\x664\x665\x3\x2\x2\x2\x665");
		sb.Append("\x6CC\x5\x1FA\xFE\x2\x666\x668\a\x122\x2\x2\x667\x669\a\x3C7");
		sb.Append("\x2\x2\x668\x667\x3\x2\x2\x2\x668\x669\x3\x2\x2\x2\x669\x66A");
		sb.Append("\x3\x2\x2\x2\x66A\x6CC\a\x3DF\x2\x2\x66B\x66D\a\x127\x2\x2\x66C");
		sb.Append("\x66E\a\x3C7\x2\x2\x66D\x66C\x3\x2\x2\x2\x66D\x66E\x3\x2\x2");
		sb.Append("\x2\x66E\x66F\x3\x2\x2\x2\x66F\x6CC\t\x19\x2\x2\x670\x672\a");
		sb.Append("\x129\x2\x2\x671\x673\a\x3C7\x2\x2\x672\x671\x3\x2\x2\x2\x672");
		sb.Append("\x673\x3\x2\x2\x2\x673\x674\x3\x2\x2\x2\x674\x6CC\a\x3DF\x2");
		sb.Append("\x2\x675\x676\a\x133\x2\x2\x676\x678\a\x13A\x2\x2\x677\x679");
		sb.Append("\a\x3C7\x2\x2\x678\x677\x3\x2\x2\x2\x678\x679\x3\x2\x2\x2\x679");
		sb.Append("\x67A\x3\x2\x2\x2\x67A\x6CC\a\x3DF\x2\x2\x67B\x67D\a\x138\x2");
		sb.Append("\x2\x67C\x67E\a\x3C7\x2\x2\x67D\x67C\x3\x2\x2\x2\x67D\x67E\x3");
		sb.Append("\x2\x2\x2\x67E\x67F\x3\x2\x2\x2\x67F\x6CC\t\x18\x2\x2\x680\x682");
		sb.Append("\a\x143\x2\x2\x681\x683\a\x3C7\x2\x2\x682\x681\x3\x2\x2\x2\x682");
		sb.Append("\x683\x3\x2\x2\x2\x683\x684\x3\x2\x2\x2\x684\x6CC\a\x3DF\x2");
		sb.Append("\x2\x685\x686\aG\x2\x2\x686\x688\a\x13A\x2\x2\x687\x689\a\x3C7");
		sb.Append("\x2\x2\x688\x687\x3\x2\x2\x2\x688\x689\x3\x2\x2\x2\x689\x68A");
		sb.Append("\x3\x2\x2\x2\x68A\x6CC\a\x3DF\x2\x2\x68B\x68D\a\x170\x2\x2\x68C");
		sb.Append("\x68E\a\x3C7\x2\x2\x68D\x68C\x3\x2\x2\x2\x68D\x68E\x3\x2\x2");
		sb.Append("\x2\x68E\x68F\x3\x2\x2\x2\x68F\x6CC\t\x1A\x2\x2\x690\x692\a");
		sb.Append("\x17B\x2\x2\x691\x693\a\x3C7\x2\x2\x692\x691\x3\x2\x2\x2\x692");
		sb.Append("\x693\x3\x2\x2\x2\x693\x694\x3\x2\x2\x2\x694\x6CC\x5\x20E\x108");
		sb.Append("\x2\x695\x697\a\x19C\x2\x2\x696\x698\a\x3C7\x2\x2\x697\x696");
		sb.Append("\x3\x2\x2\x2\x697\x698\x3\x2\x2\x2\x698\x699\x3\x2\x2\x2\x699");
		sb.Append("\x6CC\x5\x20C\x107\x2\x69A\x69C\a\x1A5\x2\x2\x69B\x69D\a\x3C7");
		sb.Append("\x2\x2\x69C\x69B\x3\x2\x2\x2\x69C\x69D\x3\x2\x2\x2\x69D\x69E");
		sb.Append("\x3\x2\x2\x2\x69E\x6CC\x5\x20C\x107\x2\x69F\x6A1\a\x1BE\x2\x2");
		sb.Append("\x6A0\x6A2\a\x3C7\x2\x2\x6A1\x6A0\x3\x2\x2\x2\x6A1\x6A2\x3\x2");
		sb.Append("\x2\x2\x6A2\x6A3\x3\x2\x2\x2\x6A3\x6CC\t\x1B\x2\x2\x6A4\x6A6");
		sb.Append("\a\x1C4\x2\x2\x6A5\x6A7\a\x3C7\x2\x2\x6A6\x6A5\x3\x2\x2\x2\x6A6");
		sb.Append("\x6A7\x3\x2\x2\x2\x6A7\x6A8\x3\x2\x2\x2\x6A8\x6CC\a\x3DF\x2");
		sb.Append("\x2\x6A9\x6AB\a\x1EF\x2\x2\x6AA\x6AC\a\x3C7\x2\x2\x6AB\x6AA");
		sb.Append("\x3\x2\x2\x2\x6AB\x6AC\x3\x2\x2\x2\x6AC\x6AD\x3\x2\x2\x2\x6AD");
		sb.Append("\x6CC\t\x1C\x2\x2\x6AE\x6B0\a\x20A\x2\x2\x6AF\x6B1\a\x3C7\x2");
		sb.Append("\x2\x6B0\x6AF\x3\x2\x2\x2\x6B0\x6B1\x3\x2\x2\x2\x6B1\x6B2\x3");
		sb.Append("\x2\x2\x2\x6B2\x6CC\t\x1B\x2\x2\x6B3\x6B5\a\x20B\x2\x2\x6B4");
		sb.Append("\x6B6\a\x3C7\x2\x2\x6B5\x6B4\x3\x2\x2\x2\x6B5\x6B6\x3\x2\x2");
		sb.Append("\x2\x6B6\x6B7\x3\x2\x2\x2\x6B7\x6CC\t\x1B\x2\x2\x6B8\x6BA\a");
		sb.Append("\x20C\x2\x2\x6B9\x6BB\a\x3C7\x2\x2\x6BA\x6B9\x3\x2\x2\x2\x6BA");
		sb.Append("\x6BB\x3\x2\x2\x2\x6BB\x6BC\x3\x2\x2\x2\x6BC\x6CC\x5\x20C\x107");
		sb.Append("\x2\x6BD\x6BE\a\x21A\x2\x2\x6BE\x6C0\x5\x206\x104\x2\x6BF\x6C1");
		sb.Append("\x5`\x31\x2\x6C0\x6BF\x3\x2\x2\x2\x6C0\x6C1\x3\x2\x2\x2\x6C1");
		sb.Append("\x6CC\x3\x2\x2\x2\x6C2\x6CC\x5`\x31\x2\x6C3\x6C5\a\x9E\x2\x2");
		sb.Append("\x6C4\x6C6\a\x3C7\x2\x2\x6C5\x6C4\x3\x2\x2\x2\x6C5\x6C6\x3\x2");
		sb.Append("\x2\x2\x6C6\x6C7\x3\x2\x2\x2\x6C7\x6C8\a\x3D0\x2\x2\x6C8\x6C9");
		sb.Append("\x5\x228\x115\x2\x6C9\x6CA\a\x3D1\x2\x2\x6CA\x6CC\x3\x2\x2\x2");
		sb.Append("\x6CB\x63B\x3\x2\x2\x2\x6CB\x640\x3\x2\x2\x2\x6CB\x645\x3\x2");
		sb.Append("\x2\x2\x6CB\x64B\x3\x2\x2\x2\x6CB\x659\x3\x2\x2\x2\x6CB\x65F");
		sb.Append("\x3\x2\x2\x2\x6CB\x666\x3\x2\x2\x2\x6CB\x66B\x3\x2\x2\x2\x6CB");
		sb.Append("\x670\x3\x2\x2\x2\x6CB\x675\x3\x2\x2\x2\x6CB\x67B\x3\x2\x2\x2");
		sb.Append("\x6CB\x680\x3\x2\x2\x2\x6CB\x685\x3\x2\x2\x2\x6CB\x68B\x3\x2");
		sb.Append("\x2\x2\x6CB\x690\x3\x2\x2\x2\x6CB\x695\x3\x2\x2\x2\x6CB\x69A");
		sb.Append("\x3\x2\x2\x2\x6CB\x69F\x3\x2\x2\x2\x6CB\x6A4\x3\x2\x2\x2\x6CB");
		sb.Append("\x6A9\x3\x2\x2\x2\x6CB\x6AE\x3\x2\x2\x2\x6CB\x6B3\x3\x2\x2\x2");
		sb.Append("\x6CB\x6B8\x3\x2\x2\x2\x6CB\x6BD\x3\x2\x2\x2\x6CB\x6C2\x3\x2");
		sb.Append("\x2\x2\x6CB\x6C3\x3\x2\x2\x2\x6CC_\x3\x2\x2\x2\x6CD\x6CE\a\x20F");
		sb.Append("\x2\x2\x6CE\x6CF\t\x12\x2\x2\x6CF\x61\x3\x2\x2\x2\x6D0\x6D1");
		sb.Append("\aq\x2\x2\x6D1\x6D2\a\x12\x2\x2\x6D2\x6D5\x5\x64\x33\x2\x6D3");
		sb.Append("\x6D4\a\x1C3\x2\x2\x6D4\x6D6\x5\x20C\x107\x2\x6D5\x6D3\x3\x2");
		sb.Append("\x2\x2\x6D5\x6D6\x3\x2\x2\x2\x6D6\x6DE\x3\x2\x2\x2\x6D7\x6D8");
		sb.Append("\a\x214\x2\x2\x6D8\x6D9\a\x12\x2\x2\x6D9\x6DC\x5\x66\x34\x2");
		sb.Append("\x6DA\x6DB\a\x215\x2\x2\x6DB\x6DD\x5\x20C\x107\x2\x6DC\x6DA");
		sb.Append("\x3\x2\x2\x2\x6DC\x6DD\x3\x2\x2\x2\x6DD\x6DF\x3\x2\x2\x2\x6DE");
		sb.Append("\x6D7\x3\x2\x2\x2\x6DE\x6DF\x3\x2\x2\x2\x6DF\x6EB\x3\x2\x2\x2");
		sb.Append("\x6E0\x6E1\a\x3D0\x2\x2\x6E1\x6E6\x5h\x35\x2\x6E2\x6E3\a\x3D2");
		sb.Append("\x2\x2\x6E3\x6E5\x5h\x35\x2\x6E4\x6E2\x3\x2\x2\x2\x6E5\x6E8");
		sb.Append("\x3\x2\x2\x2\x6E6\x6E4\x3\x2\x2\x2\x6E6\x6E7\x3\x2\x2\x2\x6E7");
		sb.Append("\x6E9\x3\x2\x2\x2\x6E8\x6E6\x3\x2\x2\x2\x6E9\x6EA\a\x3D1\x2");
		sb.Append("\x2\x6EA\x6EC\x3\x2\x2\x2\x6EB\x6E0\x3\x2\x2\x2\x6EB\x6EC\x3");
		sb.Append("\x2\x2\x2\x6EC\x63\x3\x2\x2\x2\x6ED\x6EF\aY\x2\x2\x6EE\x6ED");
		sb.Append("\x3\x2\x2\x2\x6EE\x6EF\x3\x2\x2\x2\x6EF\x6F0\x3\x2\x2\x2\x6F0");
		sb.Append("\x6F1\a\x166\x2\x2\x6F1\x6F2\a\x3D0\x2\x2\x6F2\x6F3\x5\x254");
		sb.Append("\x12B\x2\x6F3\x6F4\a\x3D1\x2\x2\x6F4\x71B\x3\x2\x2\x2\x6F5\x6F7");
		sb.Append("\aY\x2\x2\x6F6\x6F5\x3\x2\x2\x2\x6F6\x6F7\x3\x2\x2\x2\x6F7\x6F8");
		sb.Append("\x3\x2\x2\x2\x6F8\x6FC\aQ\x2\x2\x6F9\x6FA\a\x103\x2\x2\x6FA");
		sb.Append("\x6FB\a\x3C7\x2\x2\x6FB\x6FD\t\x1D\x2\x2\x6FC\x6F9\x3\x2\x2");
		sb.Append("\x2\x6FC\x6FD\x3\x2\x2\x2\x6FD\x6FE\x3\x2\x2\x2\x6FE\x6FF\a");
		sb.Append("\x3D0\x2\x2\x6FF\x700\x5\x226\x114\x2\x700\x701\a\x3D1\x2\x2");
		sb.Append("\x701\x71B\x3\x2\x2\x2\x702\x70C\au\x2\x2\x703\x704\a\x3D0\x2");
		sb.Append("\x2\x704\x705\x5\x254\x12B\x2\x705\x706\a\x3D1\x2\x2\x706\x70D");
		sb.Append("\x3\x2\x2\x2\x707\x708\a\x11F\x2\x2\x708\x709\a\x3D0\x2\x2\x709");
		sb.Append("\x70A\x5\x226\x114\x2\x70A\x70B\a\x3D1\x2\x2\x70B\x70D\x3\x2");
		sb.Append("\x2\x2\x70C\x703\x3\x2\x2\x2\x70C\x707\x3\x2\x2\x2\x70D\x71B");
		sb.Append("\x3\x2\x2\x2\x70E\x718\a\x181\x2\x2\x70F\x710\a\x3D0\x2\x2\x710");
		sb.Append("\x711\x5\x254\x12B\x2\x711\x712\a\x3D1\x2\x2\x712\x719\x3\x2");
		sb.Append("\x2\x2\x713\x714\a\x11F\x2\x2\x714\x715\a\x3D0\x2\x2\x715\x716");
		sb.Append("\x5\x226\x114\x2\x716\x717\a\x3D1\x2\x2\x717\x719\x3\x2\x2\x2");
		sb.Append("\x718\x70F\x3\x2\x2\x2\x718\x713\x3\x2\x2\x2\x719\x71B\x3\x2");
		sb.Append("\x2\x2\x71A\x6EE\x3\x2\x2\x2\x71A\x6F6\x3\x2\x2\x2\x71A\x702");
		sb.Append("\x3\x2\x2\x2\x71A\x70E\x3\x2\x2\x2\x71B\x65\x3\x2\x2\x2\x71C");
		sb.Append("\x71E\aY\x2\x2\x71D\x71C\x3\x2\x2\x2\x71D\x71E\x3\x2\x2\x2\x71E");
		sb.Append("\x71F\x3\x2\x2\x2\x71F\x720\a\x166\x2\x2\x720\x721\a\x3D0\x2");
		sb.Append("\x2\x721\x722\x5\x254\x12B\x2\x722\x723\a\x3D1\x2\x2\x723\x732");
		sb.Append("\x3\x2\x2\x2\x724\x726\aY\x2\x2\x725\x724\x3\x2\x2\x2\x725\x726");
		sb.Append("\x3\x2\x2\x2\x726\x727\x3\x2\x2\x2\x727\x72B\aQ\x2\x2\x728\x729");
		sb.Append("\a\x103\x2\x2\x729\x72A\a\x3C7\x2\x2\x72A\x72C\t\x1D\x2\x2\x72B");
		sb.Append("\x728\x3\x2\x2\x2\x72B\x72C\x3\x2\x2\x2\x72C\x72D\x3\x2\x2\x2");
		sb.Append("\x72D\x72E\a\x3D0\x2\x2\x72E\x72F\x5\x226\x114\x2\x72F\x730");
		sb.Append("\a\x3D1\x2\x2\x730\x732\x3\x2\x2\x2\x731\x71D\x3\x2\x2\x2\x731");
		sb.Append("\x725\x3\x2\x2\x2\x732g\x3\x2\x2\x2\x733\x734\aq\x2\x2\x734");
		sb.Append("\x735\x5\x206\x104\x2\x735\x736\a\xA6\x2\x2\x736\x737\a\x17F");
		sb.Append("\x2\x2\x737\x738\a\x21D\x2\x2\x738\x739\a\x3D0\x2\x2\x739\x73E");
		sb.Append("\x5j\x36\x2\x73A\x73B\a\x3D2\x2\x2\x73B\x73D\x5j\x36\x2\x73C");
		sb.Append("\x73A\x3\x2\x2\x2\x73D\x740\x3\x2\x2\x2\x73E\x73C\x3\x2\x2\x2");
		sb.Append("\x73E\x73F\x3\x2\x2\x2\x73F\x741\x3\x2\x2\x2\x740\x73E\x3\x2");
		sb.Append("\x2\x2\x741\x745\a\x3D1\x2\x2\x742\x744\x5p\x39\x2\x743\x742");
		sb.Append("\x3\x2\x2\x2\x744\x747\x3\x2\x2\x2\x745\x743\x3\x2\x2\x2\x745");
		sb.Append("\x746\x3\x2\x2\x2\x746\x750\x3\x2\x2\x2\x747\x745\x3\x2\x2\x2");
		sb.Append("\x748\x74D\x5n\x38\x2\x749\x74A\a\x3D2\x2\x2\x74A\x74C\x5n\x38");
		sb.Append("\x2\x74B\x749\x3\x2\x2\x2\x74C\x74F\x3\x2\x2\x2\x74D\x74B\x3");
		sb.Append("\x2\x2\x2\x74D\x74E\x3\x2\x2\x2\x74E\x751\x3\x2\x2\x2\x74F\x74D");
		sb.Append("\x3\x2\x2\x2\x750\x748\x3\x2\x2\x2\x750\x751\x3\x2\x2\x2\x751");
		sb.Append("\x7B7\x3\x2\x2\x2\x752\x753\aq\x2\x2\x753\x754\x5\x206\x104");
		sb.Append("\x2\x754\x755\a\xA6\x2\x2\x755\x756\a\x17F\x2\x2\x756\x757\a");
		sb.Append("\x21D\x2\x2\x757\x75B\x5j\x36\x2\x758\x75A\x5p\x39\x2\x759\x758");
		sb.Append("\x3\x2\x2\x2\x75A\x75D\x3\x2\x2\x2\x75B\x759\x3\x2\x2\x2\x75B");
		sb.Append("\x75C\x3\x2\x2\x2\x75C\x766\x3\x2\x2\x2\x75D\x75B\x3\x2\x2\x2");
		sb.Append("\x75E\x763\x5n\x38\x2\x75F\x760\a\x3D2\x2\x2\x760\x762\x5n\x38");
		sb.Append("\x2\x761\x75F\x3\x2\x2\x2\x762\x765\x3\x2\x2\x2\x763\x761\x3");
		sb.Append("\x2\x2\x2\x763\x764\x3\x2\x2\x2\x764\x767\x3\x2\x2\x2\x765\x763");
		sb.Append("\x3\x2\x2\x2\x766\x75E\x3\x2\x2\x2\x766\x767\x3\x2\x2\x2\x767");
		sb.Append("\x7B7\x3\x2\x2\x2\x768\x769\aq\x2\x2\x769\x76A\x5\x206\x104");
		sb.Append("\x2\x76A\x76B\a\xA6\x2\x2\x76B\x76C\a\x46\x2\x2\x76C\x76D\a");
		sb.Append("\x3D0\x2\x2\x76D\x772\x5j\x36\x2\x76E\x76F\a\x3D2\x2\x2\x76F");
		sb.Append("\x771\x5j\x36\x2\x770\x76E\x3\x2\x2\x2\x771\x774\x3\x2\x2\x2");
		sb.Append("\x772\x770\x3\x2\x2\x2\x772\x773\x3\x2\x2\x2\x773\x775\x3\x2");
		sb.Append("\x2\x2\x774\x772\x3\x2\x2\x2\x775\x779\a\x3D1\x2\x2\x776\x778");
		sb.Append("\x5p\x39\x2\x777\x776\x3\x2\x2\x2\x778\x77B\x3\x2\x2\x2\x779");
		sb.Append("\x777\x3\x2\x2\x2\x779\x77A\x3\x2\x2\x2\x77A\x784\x3\x2\x2\x2");
		sb.Append("\x77B\x779\x3\x2\x2\x2\x77C\x781\x5n\x38\x2\x77D\x77E\a\x3D2");
		sb.Append("\x2\x2\x77E\x780\x5n\x38\x2\x77F\x77D\x3\x2\x2\x2\x780\x783");
		sb.Append("\x3\x2\x2\x2\x781\x77F\x3\x2\x2\x2\x781\x782\x3\x2\x2\x2\x782");
		sb.Append("\x785\x3\x2\x2\x2\x783\x781\x3\x2\x2\x2\x784\x77C\x3\x2\x2\x2");
		sb.Append("\x784\x785\x3\x2\x2\x2\x785\x7B7\x3\x2\x2\x2\x786\x787\aq\x2");
		sb.Append("\x2\x787\x788\x5\x206\x104\x2\x788\x789\a\xA6\x2\x2\x789\x78A");
		sb.Append("\a\x46\x2\x2\x78A\x78B\a\x3D0\x2\x2\x78B\x790\x5l\x37\x2\x78C");
		sb.Append("\x78D\a\x3D2\x2\x2\x78D\x78F\x5l\x37\x2\x78E\x78C\x3\x2\x2\x2");
		sb.Append("\x78F\x792\x3\x2\x2\x2\x790\x78E\x3\x2\x2\x2\x790\x791\x3\x2");
		sb.Append("\x2\x2\x791\x793\x3\x2\x2\x2\x792\x790\x3\x2\x2\x2\x793\x797");
		sb.Append("\a\x3D1\x2\x2\x794\x796\x5p\x39\x2\x795\x794\x3\x2\x2\x2\x796");
		sb.Append("\x799\x3\x2\x2\x2\x797\x795\x3\x2\x2\x2\x797\x798\x3\x2\x2\x2");
		sb.Append("\x798\x7A2\x3\x2\x2\x2\x799\x797\x3\x2\x2\x2\x79A\x79F\x5n\x38");
		sb.Append("\x2\x79B\x79C\a\x3D2\x2\x2\x79C\x79E\x5n\x38\x2\x79D\x79B\x3");
		sb.Append("\x2\x2\x2\x79E\x7A1\x3\x2\x2\x2\x79F\x79D\x3\x2\x2\x2\x79F\x7A0");
		sb.Append("\x3\x2\x2\x2\x7A0\x7A3\x3\x2\x2\x2\x7A1\x79F\x3\x2\x2\x2\x7A2");
		sb.Append("\x79A\x3\x2\x2\x2\x7A2\x7A3\x3\x2\x2\x2\x7A3\x7B7\x3\x2\x2\x2");
		sb.Append("\x7A4\x7A5\aq\x2\x2\x7A5\x7A9\x5\x206\x104\x2\x7A6\x7A8\x5p");
		sb.Append("\x39\x2\x7A7\x7A6\x3\x2\x2\x2\x7A8\x7AB\x3\x2\x2\x2\x7A9\x7A7");
		sb.Append("\x3\x2\x2\x2\x7A9\x7AA\x3\x2\x2\x2\x7AA\x7B4\x3\x2\x2\x2\x7AB");
		sb.Append("\x7A9\x3\x2\x2\x2\x7AC\x7B1\x5n\x38\x2\x7AD\x7AE\a\x3D2\x2\x2");
		sb.Append("\x7AE\x7B0\x5n\x38\x2\x7AF\x7AD\x3\x2\x2\x2\x7B0\x7B3\x3\x2");
		sb.Append("\x2\x2\x7B1\x7AF\x3\x2\x2\x2\x7B1\x7B2\x3\x2\x2\x2\x7B2\x7B5");
		sb.Append("\x3\x2\x2\x2\x7B3\x7B1\x3\x2\x2\x2\x7B4\x7AC\x3\x2\x2\x2\x7B4");
		sb.Append("\x7B5\x3\x2\x2\x2\x7B5\x7B7\x3\x2\x2\x2\x7B6\x733\x3\x2\x2\x2");
		sb.Append("\x7B6\x752\x3\x2\x2\x2\x7B6\x768\x3\x2\x2\x2\x7B6\x786\x3\x2");
		sb.Append("\x2\x2\x7B6\x7A4\x3\x2\x2\x2\x7B7i\x3\x2\x2\x2\x7B8\x7BC\x5");
		sb.Append("\x218\x10D\x2\x7B9\x7BC\x5\x254\x12B\x2\x7BA\x7BC\a\x62\x2\x2");
		sb.Append("\x7BB\x7B8\x3\x2\x2\x2\x7BB\x7B9\x3\x2\x2\x2\x7BB\x7BA\x3\x2");
		sb.Append("\x2\x2\x7BCk\x3\x2\x2\x2\x7BD\x7BE\a\x3D0\x2\x2\x7BE\x7C1\x5");
		sb.Append("j\x36\x2\x7BF\x7C0\a\x3D2\x2\x2\x7C0\x7C2\x5j\x36\x2\x7C1\x7BF");
		sb.Append("\x3\x2\x2\x2\x7C2\x7C3\x3\x2\x2\x2\x7C3\x7C1\x3\x2\x2\x2\x7C3");
		sb.Append("\x7C4\x3\x2\x2\x2\x7C4\x7C5\x3\x2\x2\x2\x7C5\x7C6\a\x3D1\x2");
		sb.Append("\x2\x7C6m\x3\x2\x2\x2\x7C7\x7C8\a\x214\x2\x2\x7C8\x7CC\x5\x206");
		sb.Append("\x104\x2\x7C9\x7CB\x5p\x39\x2\x7CA\x7C9\x3\x2\x2\x2\x7CB\x7CE");
		sb.Append("\x3\x2\x2\x2\x7CC\x7CA\x3\x2\x2\x2\x7CC\x7CD\x3\x2\x2\x2\x7CD");
		sb.Append("o\x3\x2\x2\x2\x7CE\x7CC\x3\x2\x2\x2\x7CF\x7D1\a\x20F\x2\x2\x7D0");
		sb.Append("\x7CF\x3\x2\x2\x2\x7D0\x7D1\x3\x2\x2\x2\x7D1\x7D2\x3\x2\x2\x2");
		sb.Append("\x7D2\x7D4\a\x146\x2\x2\x7D3\x7D5\a\x3C7\x2\x2\x7D4\x7D3\x3");
		sb.Append("\x2\x2\x2\x7D4\x7D5\x3\x2\x2\x2\x7D5\x7D6\x3\x2\x2\x2\x7D6\x7FD");
		sb.Append("\x5\x1FC\xFF\x2\x7D7\x7D9\a\x122\x2\x2\x7D8\x7DA\a\x3C7\x2\x2");
		sb.Append("\x7D9\x7D8\x3\x2\x2\x2\x7D9\x7DA\x3\x2\x2\x2\x7DA\x7DB\x3\x2");
		sb.Append("\x2\x2\x7DB\x7FD\a\x3DF\x2\x2\x7DC\x7DD\a\x133\x2\x2\x7DD\x7DF");
		sb.Append("\a\x13A\x2\x2\x7DE\x7E0\a\x3C7\x2\x2\x7DF\x7DE\x3\x2\x2\x2\x7DF");
		sb.Append("\x7E0\x3\x2\x2\x2\x7E0\x7E1\x3\x2\x2\x2\x7E1\x7FD\a\x3DF\x2");
		sb.Append("\x2\x7E2\x7E3\aG\x2\x2\x7E3\x7E5\a\x13A\x2\x2\x7E4\x7E6\a\x3C7");
		sb.Append("\x2\x2\x7E5\x7E4\x3\x2\x2\x2\x7E5\x7E6\x3\x2\x2\x2\x7E6\x7E7");
		sb.Append("\x3\x2\x2\x2\x7E7\x7FD\a\x3DF\x2\x2\x7E8\x7EA\a\x19C\x2\x2\x7E9");
		sb.Append("\x7EB\a\x3C7\x2\x2\x7EA\x7E9\x3\x2\x2\x2\x7EA\x7EB\x3\x2\x2");
		sb.Append("\x2\x7EB\x7EC\x3\x2\x2\x2\x7EC\x7FD\x5\x20C\x107\x2\x7ED\x7EF");
		sb.Append("\a\x1A5\x2\x2\x7EE\x7F0\a\x3C7\x2\x2\x7EF\x7EE\x3\x2\x2\x2\x7EF");
		sb.Append("\x7F0\x3\x2\x2\x2\x7F0\x7F1\x3\x2\x2\x2\x7F1\x7FD\x5\x20C\x107");
		sb.Append("\x2\x7F2\x7F4\a\x21A\x2\x2\x7F3\x7F5\a\x3C7\x2\x2\x7F4\x7F3");
		sb.Append("\x3\x2\x2\x2\x7F4\x7F5\x3\x2\x2\x2\x7F5\x7F6\x3\x2\x2\x2\x7F6");
		sb.Append("\x7FD\x5\x206\x104\x2\x7F7\x7F9\a\x1B1\x2\x2\x7F8\x7FA\a\x3C7");
		sb.Append("\x2\x2\x7F9\x7F8\x3\x2\x2\x2\x7F9\x7FA\x3\x2\x2\x2\x7FA\x7FB");
		sb.Append("\x3\x2\x2\x2\x7FB\x7FD\x5\x206\x104\x2\x7FC\x7D0\x3\x2\x2\x2");
		sb.Append("\x7FC\x7D7\x3\x2\x2\x2\x7FC\x7DC\x3\x2\x2\x2\x7FC\x7E2\x3\x2");
		sb.Append("\x2\x2\x7FC\x7E8\x3\x2\x2\x2\x7FC\x7ED\x3\x2\x2\x2\x7FC\x7F2");
		sb.Append("\x3\x2\x2\x2\x7FC\x7F7\x3\x2\x2\x2\x7FDq\x3\x2\x2\x2\x7FE\x7FF");
		sb.Append("\a\t\x2\x2\x7FF\x801\t\x2\x2\x2\x800\x802\x5\x206\x104\x2\x801");
		sb.Append("\x800\x3\x2\x2\x2\x801\x802\x3\x2\x2\x2\x802\x804\x3\x2\x2\x2");
		sb.Append("\x803\x805\x5\x32\x1A\x2\x804\x803\x3\x2\x2\x2\x805\x806\x3");
		sb.Append("\x2\x2\x2\x806\x804\x3\x2\x2\x2\x806\x807\x3\x2\x2\x2\x807\x811");
		sb.Append("\x3\x2\x2\x2\x808\x809\a\t\x2\x2\x809\x80A\t\x2\x2\x2\x80A\x80B");
		sb.Append("\x5\x206\x104\x2\x80B\x80C\a\x228\x2\x2\x80C\x80D\a\x133\x2");
		sb.Append("\x2\x80D\x80E\a\x13A\x2\x2\x80E\x80F\a\x1AB\x2\x2\x80F\x811");
		sb.Append("\x3\x2\x2\x2\x810\x7FE\x3\x2\x2\x2\x810\x808\x3\x2\x2\x2\x811");
		sb.Append("s\x3\x2\x2\x2\x812\x814\a\t\x2\x2\x813\x815\x5\x34\x1B\x2\x814");
		sb.Append("\x813\x3\x2\x2\x2\x814\x815\x3\x2\x2\x2\x815\x816\x3\x2\x2\x2");
		sb.Append("\x816\x817\a\x14C\x2\x2\x817\x81B\x5\x1EC\xF7\x2\x818\x819\a");
		sb.Append("h\x2\x2\x819\x81A\a\x1F1\x2\x2\x81A\x81C\x5\x36\x1C\x2\x81B");
		sb.Append("\x818\x3\x2\x2\x2\x81B\x81C\x3\x2\x2\x2\x81C\x823\x3\x2\x2\x2");
		sb.Append("\x81D\x81E\ah\x2\x2\x81E\x820\a\x125\x2\x2\x81F\x821\a\x65\x2");
		sb.Append("\x2\x820\x81F\x3\x2\x2\x2\x820\x821\x3\x2\x2\x2\x821\x822\x3");
		sb.Append("\x2\x2\x2\x822\x824\a\x1CC\x2\x2\x823\x81D\x3\x2\x2\x2\x823");
		sb.Append("\x824\x3\x2\x2\x2\x824\x828\x3\x2\x2\x2\x825\x826\a{\x2\x2\x826");
		sb.Append("\x827\a\x99\x2\x2\x827\x829\x5\x1EC\xF7\x2\x828\x825\x3\x2\x2");
		sb.Append("\x2\x828\x829\x3\x2\x2\x2\x829\x82B\x3\x2\x2\x2\x82A\x82C\x5");
		sb.Append("> \x2\x82B\x82A\x3\x2\x2\x2\x82B\x82C\x3\x2\x2\x2\x82C\x82F");
		sb.Append("\x3\x2\x2\x2\x82D\x82E\a\x122\x2\x2\x82E\x830\a\x3DF\x2\x2\x82F");
		sb.Append("\x82D\x3\x2\x2\x2\x82F\x830\x3\x2\x2\x2\x830\x833\x3\x2\x2\x2");
		sb.Append("\x831\x832\a\x13E\x2\x2\x832\x834\x5\x15A\xAE\x2\x833\x831\x3");
		sb.Append("\x2\x2\x2\x833\x834\x3\x2\x2\x2\x834u\x3\x2\x2\x2\x835\x836");
		sb.Append("\a\t\x2\x2\x836\x837\a\x160\x2\x2\x837\x83B\x5\x1EC\xF7\x2\x838");
		sb.Append("\x83A\x5H%\x2\x839\x838\x3\x2\x2\x2\x83A\x83D\x3\x2\x2\x2\x83B");
		sb.Append("\x839\x3\x2\x2\x2\x83B\x83C\x3\x2\x2\x2\x83Cw\x3\x2\x2\x2\x83D");
		sb.Append("\x83B\x3\x2\x2\x2\x83E\x83F\a\t\x2\x2\x83F\x840\a\x172\x2\x2");
		sb.Append("\x840\x841\a\x1EC\x2\x2\x841\x842\a\x27D\x2\x2\x842\x843\a\x185");
		sb.Append("\x2\x2\x843\x844\aQ\x2\x2\x844y\x3\x2\x2\x2\x845\x846\a\t\x2");
		sb.Append("\x2\x846\x847\a\x183\x2\x2\x847\x848\a\x41\x2\x2\x848\x849\x5");
		sb.Append("\x206\x104\x2\x849\x84A\a\a\x2\x2\x84A\x84B\a\x223\x2\x2\x84B");
		sb.Append("\x851\a\x3DF\x2\x2\x84C\x84E\a\x16E\x2\x2\x84D\x84F\a\x3C7\x2");
		sb.Append("\x2\x84E\x84D\x3\x2\x2\x2\x84E\x84F\x3\x2\x2\x2\x84F\x850\x3");
		sb.Append("\x2\x2\x2\x850\x852\x5\x20E\x108\x2\x851\x84C\x3\x2\x2\x2\x851");
		sb.Append("\x852\x3\x2\x2\x2\x852\x854\x3\x2\x2\x2\x853\x855\a\x232\x2");
		sb.Append("\x2\x854\x853\x3\x2\x2\x2\x854\x855\x3\x2\x2\x2\x855\x856\x3");
		sb.Append("\x2\x2\x2\x856\x858\a\x146\x2\x2\x857\x859\a\x3C7\x2\x2\x858");
		sb.Append("\x857\x3\x2\x2\x2\x858\x859\x3\x2\x2\x2\x859\x85A\x3\x2\x2\x2");
		sb.Append("\x85A\x85B\x5\x1FC\xFF\x2\x85B{\x3\x2\x2\x2\x85C\x85D\a\t\x2");
		sb.Append("\x2\x85D\x85E\as\x2\x2\x85E\x862\x5\x1EC\xF7\x2\x85F\x861\x5");
		sb.Append("H%\x2\x860\x85F\x3\x2\x2\x2\x861\x864\x3\x2\x2\x2\x862\x860");
		sb.Append("\x3\x2\x2\x2\x862\x863\x3\x2\x2\x2\x863}\x3\x2\x2\x2\x864\x862");
		sb.Append("\x3\x2\x2\x2\x865\x866\a\t\x2\x2\x866\x867\a\x1F3\x2\x2\x867");
		sb.Append("\x868\x5\x206\x104\x2\x868\x869\a\x1BC\x2\x2\x869\x86A\a\x3D0");
		sb.Append("\x2\x2\x86A\x86F\x5J&\x2\x86B\x86C\a\x3D2\x2\x2\x86C\x86E\x5");
		sb.Append("J&\x2\x86D\x86B\x3\x2\x2\x2\x86E\x871\x3\x2\x2\x2\x86F\x86D");
		sb.Append("\x3\x2\x2\x2\x86F\x870\x3\x2\x2\x2\x870\x872\x3\x2\x2\x2\x871");
		sb.Append("\x86F\x3\x2\x2\x2\x872\x873\a\x3D1\x2\x2\x873\x7F\x3\x2\x2\x2");
		sb.Append("\x874\x876\a\t\x2\x2\x875\x877\t\x3\x2\x2\x876\x875\x3\x2\x2");
		sb.Append("\x2\x876\x877\x3\x2\x2\x2\x877\x879\x3\x2\x2\x2\x878\x87A\a");
		sb.Append("\x45\x2\x2\x879\x878\x3\x2\x2\x2\x879\x87A\x3\x2\x2\x2\x87A");
		sb.Append("\x87B\x3\x2\x2\x2\x87B\x87C\a\x96\x2\x2\x87C\x885\x5\x1EE\xF8");
		sb.Append("\x2\x87D\x882\x5\x86\x44\x2\x87E\x87F\a\x3D2\x2\x2\x87F\x881");
		sb.Append("\x5\x86\x44\x2\x880\x87E\x3\x2\x2\x2\x881\x884\x3\x2\x2\x2\x882");
		sb.Append("\x880\x3\x2\x2\x2\x882\x883\x3\x2\x2\x2\x883\x886\x3\x2\x2\x2");
		sb.Append("\x884\x882\x3\x2\x2\x2\x885\x87D\x3\x2\x2\x2\x885\x886\x3\x2");
		sb.Append("\x2\x2\x886\x888\x3\x2\x2\x2\x887\x889\x5\x62\x32\x2\x888\x887");
		sb.Append("\x3\x2\x2\x2\x888\x889\x3\x2\x2\x2\x889\x81\x3\x2\x2\x2\x88A");
		sb.Append("\x88B\a\t\x2\x2\x88B\x88C\a\x21A\x2\x2\x88C\x88D\x5\x206\x104");
		sb.Append("\x2\x88D\x88E\t\x1E\x2\x2\x88E\x88F\a\x134\x2\x2\x88F\x893\a");
		sb.Append("\x3DF\x2\x2\x890\x891\a\x16E\x2\x2\x891\x892\a\x3C7\x2\x2\x892");
		sb.Append("\x894\x5\x20E\x108\x2\x893\x890\x3\x2\x2\x2\x893\x894\x3\x2");
		sb.Append("\x2\x2\x894\x896\x3\x2\x2\x2\x895\x897\a\x232\x2\x2\x896\x895");
		sb.Append("\x3\x2\x2\x2\x896\x897\x3\x2\x2\x2\x897\x898\x3\x2\x2\x2\x898");
		sb.Append("\x89A\a\x146\x2\x2\x899\x89B\a\x3C7\x2\x2\x89A\x899\x3\x2\x2");
		sb.Append("\x2\x89A\x89B\x3\x2\x2\x2\x89B\x89C\x3\x2\x2\x2\x89C\x89D\x5");
		sb.Append("\x1FC\xFF\x2\x89D\x83\x3\x2\x2\x2\x89E\x8A2\a\t\x2\x2\x89F\x8A0");
		sb.Append("\a\x103\x2\x2\x8A0\x8A1\a\x3C7\x2\x2\x8A1\x8A3\t\f\x2\x2\x8A2");
		sb.Append("\x89F\x3\x2\x2\x2\x8A2\x8A3\x3\x2\x2\x2\x8A3\x8A5\x3\x2\x2\x2");
		sb.Append("\x8A4\x8A6\x5\x34\x1B\x2\x8A5\x8A4\x3\x2\x2\x2\x8A5\x8A6\x3");
		sb.Append("\x2\x2\x2\x8A6\x8AA\x3\x2\x2\x2\x8A7\x8A8\a\x8C\x2\x2\x8A8\x8A9");
		sb.Append("\a\x1F2\x2\x2\x8A9\x8AB\t\r\x2\x2\x8AA\x8A7\x3\x2\x2\x2\x8AA");
		sb.Append("\x8AB\x3\x2\x2\x2\x8AB\x8AC\x3\x2\x2\x2\x8AC\x8AD\a\x22F\x2");
		sb.Append("\x2\x8AD\x8B2\x5\x1EC\xF7\x2\x8AE\x8AF\a\x3D0\x2\x2\x8AF\x8B0");
		sb.Append("\x5\x226\x114\x2\x8B0\x8B1\a\x3D1\x2\x2\x8B1\x8B3\x3\x2\x2\x2");
		sb.Append("\x8B2\x8AE\x3\x2\x2\x2\x8B2\x8B3\x3\x2\x2\x2\x8B3\x8B4\x3\x2");
		sb.Append("\x2\x2\x8B4\x8B5\a\r\x2\x2\x8B5\x8BC\x5\xB4[\x2\x8B6\x8B8\a");
		sb.Append("\xAA\x2\x2\x8B7\x8B9\t\xE\x2\x2\x8B8\x8B7\x3\x2\x2\x2\x8B8\x8B9");
		sb.Append("\x3\x2\x2\x2\x8B9\x8BA\x3\x2\x2\x2\x8BA\x8BB\a\x19\x2\x2\x8BB");
		sb.Append("\x8BD\aj\x2\x2\x8BC\x8B6\x3\x2\x2\x2\x8BC\x8BD\x3\x2\x2\x2\x8BD");
		sb.Append("\x85\x3\x2\x2\x2\x8BE\x8C5\x5^\x30\x2\x8BF\x8C1\a\x3D2\x2\x2");
		sb.Append("\x8C0\x8BF\x3\x2\x2\x2\x8C0\x8C1\x3\x2\x2\x2\x8C1\x8C2\x3\x2");
		sb.Append("\x2\x2\x8C2\x8C4\x5^\x30\x2\x8C3\x8C0\x3\x2\x2\x2\x8C4\x8C7");
		sb.Append("\x3\x2\x2\x2\x8C5\x8C3\x3\x2\x2\x2\x8C5\x8C6\x3\x2\x2\x2\x8C6");
		sb.Append("\xA22\x3\x2\x2\x2\x8C7\x8C5\x3\x2\x2\x2\x8C8\x8CA\a\a\x2\x2");
		sb.Append("\x8C9\x8CB\a\x1B\x2\x2\x8CA\x8C9\x3\x2\x2\x2\x8CA\x8CB\x3\x2");
		sb.Append("\x2\x2\x8CB\x8CC\x3\x2\x2\x2\x8CC\x8CD\x5\x206\x104\x2\x8CD");
		sb.Append("\x8D1\x5P)\x2\x8CE\x8D2\a\x15A\x2\x2\x8CF\x8D0\a\x101\x2\x2");
		sb.Append("\x8D0\x8D2\x5\x206\x104\x2\x8D1\x8CE\x3\x2\x2\x2\x8D1\x8CF\x3");
		sb.Append("\x2\x2\x2\x8D1\x8D2\x3\x2\x2\x2\x8D2\xA22\x3\x2\x2\x2\x8D3\x8D5");
		sb.Append("\a\a\x2\x2\x8D4\x8D6\a\x1B\x2\x2\x8D5\x8D4\x3\x2\x2\x2\x8D5");
		sb.Append("\x8D6\x3\x2\x2\x2\x8D6\x8D7\x3\x2\x2\x2\x8D7\x8D8\a\x3D0\x2");
		sb.Append("\x2\x8D8\x8D9\x5\x206\x104\x2\x8D9\x8E0\x5P)\x2\x8DA\x8DB\a");
		sb.Append("\x3D2\x2\x2\x8DB\x8DC\x5\x206\x104\x2\x8DC\x8DD\x5P)\x2\x8DD");
		sb.Append("\x8DF\x3\x2\x2\x2\x8DE\x8DA\x3\x2\x2\x2\x8DF\x8E2\x3\x2\x2\x2");
		sb.Append("\x8E0\x8DE\x3\x2\x2\x2\x8E0\x8E1\x3\x2\x2\x2\x8E1\x8E3\x3\x2");
		sb.Append("\x2\x2\x8E2\x8E0\x3\x2\x2\x2\x8E3\x8E4\a\x3D1\x2\x2\x8E4\xA22");
		sb.Append("\x3\x2\x2\x2\x8E5\x8E6\a\a\x2\x2\x8E6\x8E8\t\x14\x2\x2\x8E7");
		sb.Append("\x8E9\x5\x206\x104\x2\x8E8\x8E7\x3\x2\x2\x2\x8E8\x8E9\x3\x2");
		sb.Append("\x2\x2\x8E9\x8EB\x3\x2\x2\x2\x8EA\x8EC\x5@!\x2\x8EB\x8EA\x3");
		sb.Append("\x2\x2\x2\x8EB\x8EC\x3\x2\x2\x2\x8EC\x8ED\x3\x2\x2\x2\x8ED\x8F1");
		sb.Append("\x5\x22A\x116\x2\x8EE\x8F0\x5\x42\"\x2\x8EF\x8EE\x3\x2\x2\x2");
		sb.Append("\x8F0\x8F3\x3\x2\x2\x2\x8F1\x8EF\x3\x2\x2\x2\x8F1\x8F2\x3\x2");
		sb.Append("\x2\x2\x8F2\xA22\x3\x2\x2\x2\x8F3\x8F1\x3\x2\x2\x2\x8F4\x8F9");
		sb.Append("\a\a\x2\x2\x8F5\x8F7\a\x1D\x2\x2\x8F6\x8F8\x5\x206\x104\x2\x8F7");
		sb.Append("\x8F6\x3\x2\x2\x2\x8F7\x8F8\x3\x2\x2\x2\x8F8\x8FA\x3\x2\x2\x2");
		sb.Append("\x8F9\x8F5\x3\x2\x2\x2\x8F9\x8FA\x3\x2\x2\x2\x8FA\x8FB\x3\x2");
		sb.Append("\x2\x2\x8FB\x8FC\ar\x2\x2\x8FC\x8FE\aQ\x2\x2\x8FD\x8FF\x5@!");
		sb.Append("\x2\x8FE\x8FD\x3\x2\x2\x2\x8FE\x8FF\x3\x2\x2\x2\x8FF\x900\x3");
		sb.Append("\x2\x2\x2\x900\x904\x5\x22A\x116\x2\x901\x903\x5\x42\"\x2\x902");
		sb.Append("\x901\x3\x2\x2\x2\x903\x906\x3\x2\x2\x2\x904\x902\x3\x2\x2\x2");
		sb.Append("\x904\x905\x3\x2\x2\x2\x905\xA22\x3\x2\x2\x2\x906\x904\x3\x2");
		sb.Append("\x2\x2\x907\x90C\a\a\x2\x2\x908\x90A\a\x1D\x2\x2\x909\x90B\x5");
		sb.Append("\x206\x104\x2\x90A\x909\x3\x2\x2\x2\x90A\x90B\x3\x2\x2\x2\x90B");
		sb.Append("\x90D\x3\x2\x2\x2\x90C\x908\x3\x2\x2\x2\x90C\x90D\x3\x2\x2\x2");
		sb.Append("\x90D\x90E\x3\x2\x2\x2\x90E\x910\a\x9F\x2\x2\x90F\x911\t\x14");
		sb.Append("\x2\x2\x910\x90F\x3\x2\x2\x2\x910\x911\x3\x2\x2\x2\x911\x913");
		sb.Append("\x3\x2\x2\x2\x912\x914\x5\x206\x104\x2\x913\x912\x3\x2\x2\x2");
		sb.Append("\x913\x914\x3\x2\x2\x2\x914\x916\x3\x2\x2\x2\x915\x917\x5@!");
		sb.Append("\x2\x916\x915\x3\x2\x2\x2\x916\x917\x3\x2\x2\x2\x917\x918\x3");
		sb.Append("\x2\x2\x2\x918\x91C\x5\x22A\x116\x2\x919\x91B\x5\x42\"\x2\x91A");
		sb.Append("\x919\x3\x2\x2\x2\x91B\x91E\x3\x2\x2\x2\x91C\x91A\x3\x2\x2\x2");
		sb.Append("\x91C\x91D\x3\x2\x2\x2\x91D\xA22\x3\x2\x2\x2\x91E\x91C\x3\x2");
		sb.Append("\x2\x2\x91F\x920\a\a\x2\x2\x920\x922\t\x16\x2\x2\x921\x923\t");
		sb.Append("\x14\x2\x2\x922\x921\x3\x2\x2\x2\x922\x923\x3\x2\x2\x2\x923");
		sb.Append("\x925\x3\x2\x2\x2\x924\x926\x5\x206\x104\x2\x925\x924\x3\x2");
		sb.Append("\x2\x2\x925\x926\x3\x2\x2\x2\x926\x927\x3\x2\x2\x2\x927\x92B");
		sb.Append("\x5\x22A\x116\x2\x928\x92A\x5\x42\"\x2\x929\x928\x3\x2\x2\x2");
		sb.Append("\x92A\x92D\x3\x2\x2\x2\x92B\x929\x3\x2\x2\x2\x92B\x92C\x3\x2");
		sb.Append("\x2\x2\x92C\xA22\x3\x2\x2\x2\x92D\x92B\x3\x2\x2\x2\x92E\x933");
		sb.Append("\a\a\x2\x2\x92F\x931\a\x1D\x2\x2\x930\x932\x5\x206\x104\x2\x931");
		sb.Append("\x930\x3\x2\x2\x2\x931\x932\x3\x2\x2\x2\x932\x934\x3\x2\x2\x2");
		sb.Append("\x933\x92F\x3\x2\x2\x2\x933\x934\x3\x2\x2\x2\x934\x935\x3\x2");
		sb.Append("\x2\x2\x935\x936\a<\x2\x2\x936\x938\aQ\x2\x2\x937\x939\x5\x206");
		sb.Append("\x104\x2\x938\x937\x3\x2\x2\x2\x938\x939\x3\x2\x2\x2\x939\x93A");
		sb.Append("\x3\x2\x2\x2\x93A\x93B\x5\x22A\x116\x2\x93B\x93C\x5V,\x2\x93C");
		sb.Append("\xA22\x3\x2\x2\x2\x93D\x942\a\a\x2\x2\x93E\x940\a\x1D\x2\x2");
		sb.Append("\x93F\x941\x5\x206\x104\x2\x940\x93F\x3\x2\x2\x2\x940\x941\x3");
		sb.Append("\x2\x2\x2\x941\x943\x3\x2\x2\x2\x942\x93E\x3\x2\x2\x2\x942\x943");
		sb.Append("\x3\x2\x2\x2\x943\x944\x3\x2\x2\x2\x944\x945\a\x19\x2\x2\x945");
		sb.Append("\x946\a\x3D0\x2\x2\x946\x947\x5\x254\x12B\x2\x947\x948\a\x3D1");
		sb.Append("\x2\x2\x948\xA22\x3\x2\x2\x2\x949\x94B\a\x103\x2\x2\x94A\x94C");
		sb.Append("\a\x3C7\x2\x2\x94B\x94A\x3\x2\x2\x2\x94B\x94C\x3\x2\x2\x2\x94C");
		sb.Append("\x94D\x3\x2\x2\x2\x94D\xA22\t\x5\x2\x2\x94E\x950\a\t\x2\x2\x94F");
		sb.Append("\x951\a\x1B\x2\x2\x950\x94F\x3\x2\x2\x2\x950\x951\x3\x2\x2\x2");
		sb.Append("\x951\x952\x3\x2\x2\x2\x952\x958\x5\x206\x104\x2\x953\x954\a");
		sb.Append("\x87\x2\x2\x954\x955\a\'\x2\x2\x955\x959\x5\x236\x11C\x2\x956");
		sb.Append("\x957\a/\x2\x2\x957\x959\a\'\x2\x2\x958\x953\x3\x2\x2\x2\x958");
		sb.Append("\x956\x3\x2\x2\x2\x959\xA22\x3\x2\x2\x2\x95A\x95C\a\x17\x2\x2");
		sb.Append("\x95B\x95D\a\x1B\x2\x2\x95C\x95B\x3\x2\x2\x2\x95C\x95D\x3\x2");
		sb.Append("\x2\x2\x95D\x95E\x3\x2\x2\x2\x95E\x95F\x5\x206\x104\x2\x95F");
		sb.Append("\x960\x5\x206\x104\x2\x960\x964\x5P)\x2\x961\x965\a\x15A\x2");
		sb.Append("\x2\x962\x963\a\x101\x2\x2\x963\x965\x5\x206\x104\x2\x964\x961");
		sb.Append("\x3\x2\x2\x2\x964\x962\x3\x2\x2\x2\x964\x965\x3\x2\x2\x2\x965");
		sb.Append("\xA22\x3\x2\x2\x2\x966\x967\a{\x2\x2\x967\x968\a\x1B\x2\x2\x968");
		sb.Append("\x969\x5\x206\x104\x2\x969\x96A\a\x99\x2\x2\x96A\x96B\x5\x206");
		sb.Append("\x104\x2\x96B\xA22\x3\x2\x2\x2\x96C\x96E\a\\\x2\x2\x96D\x96F");
		sb.Append("\a\x3C7\x2\x2\x96E\x96D\x3\x2\x2\x2\x96E\x96F\x3\x2\x2\x2\x96F");
		sb.Append("\x970\x3\x2\x2\x2\x970\xA22\t\x6\x2\x2\x971\x973\a\x1A7\x2\x2");
		sb.Append("\x972\x974\a\x1B\x2\x2\x973\x972\x3\x2\x2\x2\x973\x974\x3\x2");
		sb.Append("\x2\x2\x974\x975\x3\x2\x2\x2\x975\x976\x5\x206\x104\x2\x976");
		sb.Append("\x97A\x5P)\x2\x977\x97B\a\x15A\x2\x2\x978\x979\a\x101\x2\x2");
		sb.Append("\x979\x97B\x5\x206\x104\x2\x97A\x977\x3\x2\x2\x2\x97A\x978\x3");
		sb.Append("\x2\x2\x2\x97A\x97B\x3\x2\x2\x2\x97B\xA22\x3\x2\x2\x2\x97C\x97E");
		sb.Append("\a/\x2\x2\x97D\x97F\a\x1B\x2\x2\x97E\x97D\x3\x2\x2\x2\x97E\x97F");
		sb.Append("\x3\x2\x2\x2\x97F\x980\x3\x2\x2\x2\x980\x982\x5\x206\x104\x2");
		sb.Append("\x981\x983\a\x7F\x2\x2\x982\x981\x3\x2\x2\x2\x982\x983\x3\x2");
		sb.Append("\x2\x2\x983\xA22\x3\x2\x2\x2\x984\x985\a/\x2\x2\x985\x986\a");
		sb.Append("r\x2\x2\x986\xA22\aQ\x2\x2\x987\x988\a{\x2\x2\x988\x989\t\x14");
		sb.Append("\x2\x2\x989\x98A\x5\x206\x104\x2\x98A\x98B\a\x99\x2\x2\x98B");
		sb.Append("\x98C\x5\x206\x104\x2\x98C\xA22\x3\x2\x2\x2\x98D\x98E\a/\x2");
		sb.Append("\x2\x98E\x98F\t\x14\x2\x2\x98F\xA22\x5\x206\x104\x2\x990\x991");
		sb.Append("\a/\x2\x2\x991\x992\a<\x2\x2\x992\x993\aQ\x2\x2\x993\xA22\x5");
		sb.Append("\x206\x104\x2\x994\x995\a\x13B\x2\x2\x995\xA22\aR\x2\x2\x996");
		sb.Append("\x997\a\x142\x2\x2\x997\xA22\aR\x2\x2\x998\x99A\a{\x2\x2\x999");
		sb.Append("\x99B\t\x1F\x2\x2\x99A\x999\x3\x2\x2\x2\x99A\x99B\x3\x2\x2\x2");
		sb.Append("\x99B\x99E\x3\x2\x2\x2\x99C\x99F\x5\x206\x104\x2\x99D\x99F\x5");
		sb.Append("\x1EC\xF7\x2\x99E\x99C\x3\x2\x2\x2\x99E\x99D\x3\x2\x2\x2\x99F");
		sb.Append("\xA22\x3\x2\x2\x2\x9A0\x9A1\am\x2\x2\x9A1\x9A2\a\x12\x2\x2\x9A2");
		sb.Append("\xA22\x5\x226\x114\x2\x9A3\x9A4\a\x1F\x2\x2\x9A4\x9A5\a\x99");
		sb.Append("\x2\x2\x9A5\x9A6\a\x18\x2\x2\x9A6\x9A7\a\x87\x2\x2\x9A7\x9AA");
		sb.Append("\x5\x1F8\xFD\x2\x9A8\x9A9\a\x1A\x2\x2\x9A9\x9AB\x5\x1FA\xFE");
		sb.Append("\x2\x9AA\x9A8\x3\x2\x2\x2\x9AA\x9AB\x3\x2\x2\x2\x9AB\xA22\x3");
		sb.Append("\x2\x2\x2\x9AC\x9AE\a\'\x2\x2\x9AD\x9AC\x3\x2\x2\x2\x9AD\x9AE");
		sb.Append("\x3\x2\x2\x2\x9AE\x9AF\x3\x2\x2\x2\x9AF\x9B0\a\x18\x2\x2\x9B0");
		sb.Append("\x9B1\a\x87\x2\x2\x9B1\x9B2\a\x3C7\x2\x2\x9B2\x9B6\x5\x1F8\xFD");
		sb.Append("\x2\x9B3\x9B4\a\x1A\x2\x2\x9B4\x9B5\a\x3C7\x2\x2\x9B5\x9B7\x5");
		sb.Append("\x1FA\xFE\x2\x9B6\x9B3\x3\x2\x2\x2\x9B6\x9B7\x3\x2\x2\x2\x9B7");
		sb.Append("\xA22\x3\x2\x2\x2\x9B8\x9B9\a\x13C\x2\x2\x9B9\xA22\a\x21A\x2");
		sb.Append("\x2\x9BA\x9BB\a\x16C\x2\x2\x9BB\xA22\a\x21A\x2\x2\x9BC\xA22");
		sb.Append("\a;\x2\x2\x9BD\x9BE\t \x2\x2\x9BE\xA22\a\x22C\x2\x2\x9BF\x9C0");
		sb.Append("\a\a\x2\x2\x9C0\x9C1\aq\x2\x2\x9C1\x9C2\a\x3D0\x2\x2\x9C2\x9C7");
		sb.Append("\x5h\x35\x2\x9C3\x9C4\a\x3D2\x2\x2\x9C4\x9C6\x5h\x35\x2\x9C5");
		sb.Append("\x9C3\x3\x2\x2\x2\x9C6\x9C9\x3\x2\x2\x2\x9C7\x9C5\x3\x2\x2\x2");
		sb.Append("\x9C7\x9C8\x3\x2\x2\x2\x9C8\x9CA\x3\x2\x2\x2\x9C9\x9C7\x3\x2");
		sb.Append("\x2\x2\x9CA\x9CB\a\x3D1\x2\x2\x9CB\xA22\x3\x2\x2\x2\x9CC\x9CD");
		sb.Append("\a/\x2\x2\x9CD\x9CE\aq\x2\x2\x9CE\xA22\x5\x226\x114\x2\x9CF");
		sb.Append("\x9D0\a\x13C\x2\x2\x9D0\x9D3\aq\x2\x2\x9D1\x9D4\x5\x226\x114");
		sb.Append("\x2\x9D2\x9D4\a\b\x2\x2\x9D3\x9D1\x3\x2\x2\x2\x9D3\x9D2\x3\x2");
		sb.Append("\x2\x2\x9D4\x9D5\x3\x2\x2\x2\x9D5\xA22\a\x21A\x2\x2\x9D6\x9D7");
		sb.Append("\a\x16C\x2\x2\x9D7\x9DA\aq\x2\x2\x9D8\x9DB\x5\x226\x114\x2\x9D9");
		sb.Append("\x9DB\a\b\x2\x2\x9DA\x9D8\x3\x2\x2\x2\x9DA\x9D9\x3\x2\x2\x2");
		sb.Append("\x9DB\x9DC\x3\x2\x2\x2\x9DC\xA22\a\x21A\x2\x2\x9DD\x9DE\a\x221");
		sb.Append("\x2\x2\x9DE\x9E1\aq\x2\x2\x9DF\x9E2\x5\x226\x114\x2\x9E0\x9E2");
		sb.Append("\a\b\x2\x2\x9E1\x9DF\x3\x2\x2\x2\x9E1\x9E0\x3\x2\x2\x2\x9E2");
		sb.Append("\xA22\x3\x2\x2\x2\x9E3\x9E4\a\x11D\x2\x2\x9E4\x9E5\aq\x2\x2");
		sb.Append("\x9E5\xA22\x5\x20C\x107\x2\x9E6\x9E7\a\x1DD\x2\x2\x9E7\x9E8");
		sb.Append("\aq\x2\x2\x9E8\x9E9\x5\x226\x114\x2\x9E9\x9EA\aM\x2\x2\x9EA");
		sb.Append("\x9EB\a\x3D0\x2\x2\x9EB\x9F0\x5h\x35\x2\x9EC\x9ED\a\x3D2\x2");
		sb.Append("\x2\x9ED\x9EF\x5h\x35\x2\x9EE\x9EC\x3\x2\x2\x2\x9EF\x9F2\x3");
		sb.Append("\x2\x2\x2\x9F0\x9EE\x3\x2\x2\x2\x9F0\x9F1\x3\x2\x2\x2\x9F1\x9F3");
		sb.Append("\x3\x2\x2\x2\x9F2\x9F0\x3\x2\x2\x2\x9F3\x9F4\a\x3D1\x2\x2\x9F4");
		sb.Append("\xA22\x3\x2\x2\x2\x9F5\x9F6\a\x14F\x2\x2\x9F6\x9F7\aq\x2\x2");
		sb.Append("\x9F7\x9F8\x5\x206\x104\x2\x9F8\x9F9\a\xAA\x2\x2\x9F9\x9FA\a");
		sb.Append("\x96\x2\x2\x9FA\x9FD\x5\x1EE\xF8\x2\x9FB\x9FC\t \x2\x2\x9FC");
		sb.Append("\x9FE\a\x22C\x2\x2\x9FD\x9FB\x3\x2\x2\x2\x9FD\x9FE\x3\x2\x2");
		sb.Append("\x2\x9FE\xA22\x3\x2\x2\x2\x9FF\xA00\a\v\x2\x2\xA00\xA03\aq\x2");
		sb.Append("\x2\xA01\xA04\x5\x226\x114\x2\xA02\xA04\a\b\x2\x2\xA03\xA01");
		sb.Append("\x3\x2\x2\x2\xA03\xA02\x3\x2\x2\x2\xA04\xA22\x3\x2\x2\x2\xA05");
		sb.Append("\xA06\a\x19\x2\x2\xA06\xA09\aq\x2\x2\xA07\xA0A\x5\x226\x114");
		sb.Append("\x2\xA08\xA0A\a\b\x2\x2\xA09\xA07\x3\x2\x2\x2\xA09\xA08\x3\x2");
		sb.Append("\x2\x2\xA0A\xA22\x3\x2\x2\x2\xA0B\xA0C\ai\x2\x2\xA0C\xA0F\a");
		sb.Append("q\x2\x2\xA0D\xA10\x5\x226\x114\x2\xA0E\xA10\a\b\x2\x2\xA0F\xA0D");
		sb.Append("\x3\x2\x2\x2\xA0F\xA0E\x3\x2\x2\x2\xA10\xA22\x3\x2\x2\x2\xA11");
		sb.Append("\xA12\a\x1D4\x2\x2\xA12\xA15\aq\x2\x2\xA13\xA16\x5\x226\x114");
		sb.Append("\x2\xA14\xA16\a\b\x2\x2\xA15\xA13\x3\x2\x2\x2\xA15\xA14\x3\x2");
		sb.Append("\x2\x2\xA16\xA22\x3\x2\x2\x2\xA17\xA18\a\x1DE\x2\x2\xA18\xA1B");
		sb.Append("\aq\x2\x2\xA19\xA1C\x5\x226\x114\x2\xA1A\xA1C\a\b\x2\x2\xA1B");
		sb.Append("\xA19\x3\x2\x2\x2\xA1B\xA1A\x3\x2\x2\x2\xA1C\xA22\x3\x2\x2\x2");
		sb.Append("\xA1D\xA1E\a\x1DC\x2\x2\xA1E\xA22\a\x1C2\x2\x2\xA1F\xA20\a\x228");
		sb.Append("\x2\x2\xA20\xA22\a\x1C2\x2\x2\xA21\x8BE\x3\x2\x2\x2\xA21\x8C8");
		sb.Append("\x3\x2\x2\x2\xA21\x8D3\x3\x2\x2\x2\xA21\x8E5\x3\x2\x2\x2\xA21");
		sb.Append("\x8F4\x3\x2\x2\x2\xA21\x907\x3\x2\x2\x2\xA21\x91F\x3\x2\x2\x2");
		sb.Append("\xA21\x92E\x3\x2\x2\x2\xA21\x93D\x3\x2\x2\x2\xA21\x949\x3\x2");
		sb.Append("\x2\x2\xA21\x94E\x3\x2\x2\x2\xA21\x95A\x3\x2\x2\x2\xA21\x966");
		sb.Append("\x3\x2\x2\x2\xA21\x96C\x3\x2\x2\x2\xA21\x971\x3\x2\x2\x2\xA21");
		sb.Append("\x97C\x3\x2\x2\x2\xA21\x984\x3\x2\x2\x2\xA21\x987\x3\x2\x2\x2");
		sb.Append("\xA21\x98D\x3\x2\x2\x2\xA21\x990\x3\x2\x2\x2\xA21\x994\x3\x2");
		sb.Append("\x2\x2\xA21\x996\x3\x2\x2\x2\xA21\x998\x3\x2\x2\x2\xA21\x9A0");
		sb.Append("\x3\x2\x2\x2\xA21\x9A3\x3\x2\x2\x2\xA21\x9AD\x3\x2\x2\x2\xA21");
		sb.Append("\x9B8\x3\x2\x2\x2\xA21\x9BA\x3\x2\x2\x2\xA21\x9BC\x3\x2\x2\x2");
		sb.Append("\xA21\x9BD\x3\x2\x2\x2\xA21\x9BF\x3\x2\x2\x2\xA21\x9CC\x3\x2");
		sb.Append("\x2\x2\xA21\x9CF\x3\x2\x2\x2\xA21\x9D6\x3\x2\x2\x2\xA21\x9DD");
		sb.Append("\x3\x2\x2\x2\xA21\x9E3\x3\x2\x2\x2\xA21\x9E6\x3\x2\x2\x2\xA21");
		sb.Append("\x9F5\x3\x2\x2\x2\xA21\x9FF\x3\x2\x2\x2\xA21\xA05\x3\x2\x2\x2");
		sb.Append("\xA21\xA0B\x3\x2\x2\x2\xA21\xA11\x3\x2\x2\x2\xA21\xA17\x3\x2");
		sb.Append("\x2\x2\xA21\xA1D\x3\x2\x2\x2\xA21\xA1F\x3\x2\x2\x2\xA22\x87");
		sb.Append("\x3\x2\x2\x2\xA23\xA24\a/\x2\x2\xA24\xA26\t\x2\x2\x2\xA25\xA27");
		sb.Append("\x5\x23C\x11F\x2\xA26\xA25\x3\x2\x2\x2\xA26\xA27\x3\x2\x2\x2");
		sb.Append("\xA27\xA28\x3\x2\x2\x2\xA28\xA29\x5\x206\x104\x2\xA29\x89\x3");
		sb.Append("\x2\x2\x2\xA2A\xA2B\a/\x2\x2\xA2B\xA2D\a\x14C\x2\x2\xA2C\xA2E");
		sb.Append("\x5\x23C\x11F\x2\xA2D\xA2C\x3\x2\x2\x2\xA2D\xA2E\x3\x2\x2\x2");
		sb.Append("\xA2E\xA2F\x3\x2\x2\x2\xA2F\xA30\x5\x1EC\xF7\x2\xA30\x8B\x3");
		sb.Append("\x2\x2\x2\xA31\xA32\a/\x2\x2\xA32\xA34\aG\x2\x2\xA33\xA35\t");
		sb.Append("\x3\x2\x2\xA34\xA33\x3\x2\x2\x2\xA34\xA35\x3\x2\x2\x2\xA35\xA36");
		sb.Append("\x3\x2\x2\x2\xA36\xA37\x5\x206\x104\x2\xA37\xA38\ah\x2\x2\xA38");
		sb.Append("\xA45\x5\x1EE\xF8\x2\xA39\xA3B\a\x103\x2\x2\xA3A\xA3C\a\x3C7");
		sb.Append("\x2\x2\xA3B\xA3A\x3\x2\x2\x2\xA3B\xA3C\x3\x2\x2\x2\xA3C\xA3D");
		sb.Append("\x3\x2\x2\x2\xA3D\xA44\t\x5\x2\x2\xA3E\xA40\a\\\x2\x2\xA3F\xA41");
		sb.Append("\a\x3C7\x2\x2\xA40\xA3F\x3\x2\x2\x2\xA40\xA41\x3\x2\x2\x2\xA41");
		sb.Append("\xA42\x3\x2\x2\x2\xA42\xA44\t\x6\x2\x2\xA43\xA39\x3\x2\x2\x2");
		sb.Append("\xA43\xA3E\x3\x2\x2\x2\xA44\xA47\x3\x2\x2\x2\xA45\xA43\x3\x2");
		sb.Append("\x2\x2\xA45\xA46\x3\x2\x2\x2\xA46\x8D\x3\x2\x2\x2\xA47\xA45");
		sb.Append("\x3\x2\x2\x2\xA48\xA49\a/\x2\x2\xA49\xA4A\a\x183\x2\x2\xA4A");
		sb.Append("\xA4B\a\x41\x2\x2\xA4B\xA4C\x5\x206\x104\x2\xA4C\xA4D\a\x146");
		sb.Append("\x2\x2\xA4D\xA4E\a\x3C7\x2\x2\xA4E\xA4F\x5\x1FC\xFF\x2\xA4F");
		sb.Append("\x8F\x3\x2\x2\x2\xA50\xA51\a/\x2\x2\xA51\xA53\as\x2\x2\xA52");
		sb.Append("\xA54\x5\x23C\x11F\x2\xA53\xA52\x3\x2\x2\x2\xA53\xA54\x3\x2");
		sb.Append("\x2\x2\xA54\xA55\x3\x2\x2\x2\xA55\xA56\x5\x1EC\xF7\x2\xA56\x91");
		sb.Append("\x3\x2\x2\x2\xA57\xA58\a/\x2\x2\xA58\xA5A\a\x160\x2\x2\xA59");
		sb.Append("\xA5B\x5\x23C\x11F\x2\xA5A\xA59\x3\x2\x2\x2\xA5A\xA5B\x3\x2");
		sb.Append("\x2\x2\xA5B\xA5C\x3\x2\x2\x2\xA5C\xA5D\x5\x1EC\xF7\x2\xA5D\x93");
		sb.Append("\x3\x2\x2\x2\xA5E\xA5F\a/\x2\x2\xA5F\xA61\a\x1F3\x2\x2\xA60");
		sb.Append("\xA62\x5\x23C\x11F\x2\xA61\xA60\x3\x2\x2\x2\xA61\xA62\x3\x2");
		sb.Append("\x2\x2\xA62\xA63\x3\x2\x2\x2\xA63\xA64\x5\x206\x104\x2\xA64");
		sb.Append("\x95\x3\x2\x2\x2\xA65\xA67\a/\x2\x2\xA66\xA68\a\x21B\x2\x2\xA67");
		sb.Append("\xA66\x3\x2\x2\x2\xA67\xA68\x3\x2\x2\x2\xA68\xA69\x3\x2\x2\x2");
		sb.Append("\xA69\xA6B\a\x96\x2\x2\xA6A\xA6C\x5\x23C\x11F\x2\xA6B\xA6A\x3");
		sb.Append("\x2\x2\x2\xA6B\xA6C\x3\x2\x2\x2\xA6C\xA6D\x3\x2\x2\x2\xA6D\xA6F");
		sb.Append("\x5\x228\x115\x2\xA6E\xA70\t!\x2\x2\xA6F\xA6E\x3\x2\x2\x2\xA6F");
		sb.Append("\xA70\x3\x2\x2\x2\xA70\x97\x3\x2\x2\x2\xA71\xA72\a/\x2\x2\xA72");
		sb.Append("\xA73\a\x21A\x2\x2\xA73\xA79\x5\x206\x104\x2\xA74\xA76\a\x146");
		sb.Append("\x2\x2\xA75\xA77\a\x3C7\x2\x2\xA76\xA75\x3\x2\x2\x2\xA76\xA77");
		sb.Append("\x3\x2\x2\x2\xA77\xA78\x3\x2\x2\x2\xA78\xA7A\x5\x1FC\xFF\x2");
		sb.Append("\xA79\xA74\x3\x2\x2\x2\xA79\xA7A\x3\x2\x2\x2\xA7A\x99\x3\x2");
		sb.Append("\x2\x2\xA7B\xA7C\a/\x2\x2\xA7C\xA7E\a\x9B\x2\x2\xA7D\xA7F\x5");
		sb.Append("\x23C\x11F\x2\xA7E\xA7D\x3\x2\x2\x2\xA7E\xA7F\x3\x2\x2\x2\xA7F");
		sb.Append("\xA80\x3\x2\x2\x2\xA80\xA81\x5\x1EC\xF7\x2\xA81\x9B\x3\x2\x2");
		sb.Append("\x2\xA82\xA83\a/\x2\x2\xA83\xA85\a\x22F\x2\x2\xA84\xA86\x5\x23C");
		sb.Append("\x11F\x2\xA85\xA84\x3\x2\x2\x2\xA85\xA86\x3\x2\x2\x2\xA86\xA87");
		sb.Append("\x3\x2\x2\x2\xA87\xA8C\x5\x1EC\xF7\x2\xA88\xA89\a\x3D2\x2\x2");
		sb.Append("\xA89\xA8B\x5\x1EC\xF7\x2\xA8A\xA88\x3\x2\x2\x2\xA8B\xA8E\x3");
		sb.Append("\x2\x2\x2\xA8C\xA8A\x3\x2\x2\x2\xA8C\xA8D\x3\x2\x2\x2\xA8D\xA90");
		sb.Append("\x3\x2\x2\x2\xA8E\xA8C\x3\x2\x2\x2\xA8F\xA91\t!\x2\x2\xA90\xA8F");
		sb.Append("\x3\x2\x2\x2\xA90\xA91\x3\x2\x2\x2\xA91\x9D\x3\x2\x2\x2\xA92");
		sb.Append("\xA93\a{\x2\x2\xA93\xA94\a\x96\x2\x2\xA94\xA99\x5\xA0Q\x2\xA95");
		sb.Append("\xA96\a\x3D2\x2\x2\xA96\xA98\x5\xA0Q\x2\xA97\xA95\x3\x2\x2\x2");
		sb.Append("\xA98\xA9B\x3\x2\x2\x2\xA99\xA97\x3\x2\x2\x2\xA99\xA9A\x3\x2");
		sb.Append("\x2\x2\xA9A\x9F\x3\x2\x2\x2\xA9B\xA99\x3\x2\x2\x2\xA9C\xA9D");
		sb.Append("\x5\x1EE\xF8\x2\xA9D\xA9E\a\x99\x2\x2\xA9E\xA9F\x5\x1EE\xF8");
		sb.Append("\x2\xA9F\xA1\x3\x2\x2\x2\xAA0\xAA2\a\x221\x2\x2\xAA1\xAA3\a");
		sb.Append("\x96\x2\x2\xAA2\xAA1\x3\x2\x2\x2\xAA2\xAA3\x3\x2\x2\x2\xAA3");
		sb.Append("\xAA4\x3\x2\x2\x2\xAA4\xAA5\x5\x1EE\xF8\x2\xAA5\xA3\x3\x2\x2");
		sb.Append("\x2\xAA6\xAA7\a\x13\x2\x2\xAA7\xAAE\x5\x1EC\xF7\x2\xAA8\xAAB");
		sb.Append("\a\x3D0\x2\x2\xAA9\xAAC\x5\x230\x119\x2\xAAA\xAAC\x5\x22C\x117");
		sb.Append("\x2\xAAB\xAA9\x3\x2\x2\x2\xAAB\xAAA\x3\x2\x2\x2\xAAB\xAAC\x3");
		sb.Append("\x2\x2\x2\xAAC\xAAD\x3\x2\x2\x2\xAAD\xAAF\a\x3D1\x2\x2\xAAE");
		sb.Append("\xAA8\x3\x2\x2\x2\xAAE\xAAF\x3\x2\x2\x2\xAAF\xA5\x3\x2\x2\x2");
		sb.Append("\xAB0\xAB3\x5\xC0\x61\x2\xAB1\xAB3\x5\xC2\x62\x2\xAB2\xAB0\x3");
		sb.Append("\x2\x2\x2\xAB2\xAB1\x3\x2\x2\x2\xAB3\xA7\x3\x2\x2\x2\xAB4\xAB5");
		sb.Append("\a\x13E\x2\x2\xAB5\xAB6\x5\x22C\x117\x2\xAB6\xA9\x3\x2\x2\x2");
		sb.Append("\xAB7\xABC\x5\xC4\x63\x2\xAB8\xABC\x5\xC6\x64\x2\xAB9\xABC\x5");
		sb.Append("\xC8\x65\x2\xABA\xABC\x5\xCA\x66\x2\xABB\xAB7\x3\x2\x2\x2\xABB");
		sb.Append("\xAB8\x3\x2\x2\x2\xABB\xAB9\x3\x2\x2\x2\xABB\xABA\x3\x2\x2\x2");
		sb.Append("\xABC\xAB\x3\x2\x2\x2\xABD\xABF\aK\x2\x2\xABE\xAC0\t\"\x2\x2");
		sb.Append("\xABF\xABE\x3\x2\x2\x2\xABF\xAC0\x3\x2\x2\x2\xAC0\xAC2\x3\x2");
		sb.Append("\x2\x2\xAC1\xAC3\a\x45\x2\x2\xAC2\xAC1\x3\x2\x2\x2\xAC2\xAC3");
		sb.Append("\x3\x2\x2\x2\xAC3\xAC5\x3\x2\x2\x2\xAC4\xAC6\aM\x2\x2\xAC5\xAC4");
		sb.Append("\x3\x2\x2\x2\xAC5\xAC6\x3\x2\x2\x2\xAC6\xAC7\x3\x2\x2\x2\xAC7");
		sb.Append("\xACD\x5\x1EE\xF8\x2\xAC8\xAC9\aq\x2\x2\xAC9\xACA\a\x3D0\x2");
		sb.Append("\x2\xACA\xACB\x5\x226\x114\x2\xACB\xACC\a\x3D1\x2\x2\xACC\xACE");
		sb.Append("\x3\x2\x2\x2\xACD\xAC8\x3\x2\x2\x2\xACD\xACE\x3\x2\x2\x2\xACE");
		sb.Append("\xADF\x3\x2\x2\x2\xACF\xAD0\a\x3D0\x2\x2\xAD0\xAD1\x5\x226\x114");
		sb.Append("\x2\xAD1\xAD2\a\x3D1\x2\x2\xAD2\xAD4\x3\x2\x2\x2\xAD3\xACF\x3");
		sb.Append("\x2\x2\x2\xAD3\xAD4\x3\x2\x2\x2\xAD4\xAD5\x3\x2\x2\x2\xAD5\xAE0");
		sb.Append("\x5\xB8]\x2\xAD6\xAD7\a\x87\x2\x2\xAD7\xADC\x5\xBA^\x2\xAD8");
		sb.Append("\xAD9\a\x3D2\x2\x2\xAD9\xADB\x5\xBA^\x2\xADA\xAD8\x3\x2\x2\x2");
		sb.Append("\xADB\xADE\x3\x2\x2\x2\xADC\xADA\x3\x2\x2\x2\xADC\xADD\x3\x2");
		sb.Append("\x2\x2\xADD\xAE0\x3\x2\x2\x2\xADE\xADC\x3\x2\x2\x2\xADF\xAD3");
		sb.Append("\x3\x2\x2\x2\xADF\xAD6\x3\x2\x2\x2\xAE0\xAED\x3\x2\x2\x2\xAE1");
		sb.Append("\xAE2\ah\x2\x2\xAE2\xAE3\a\x140\x2\x2\xAE3\xAE4\aQ\x2\x2\xAE4");
		sb.Append("\xAE5\a\xA2\x2\x2\xAE5\xAEA\x5\xBA^\x2\xAE6\xAE7\a\x3D2\x2\x2");
		sb.Append("\xAE7\xAE9\x5\xBA^\x2\xAE8\xAE6\x3\x2\x2\x2\xAE9\xAEC\x3\x2");
		sb.Append("\x2\x2\xAEA\xAE8\x3\x2\x2\x2\xAEA\xAEB\x3\x2\x2\x2\xAEB\xAEE");
		sb.Append("\x3\x2\x2\x2\xAEC\xAEA\x3\x2\x2\x2\xAED\xAE1\x3\x2\x2\x2\xAED");
		sb.Append("\xAEE\x3\x2\x2\x2\xAEE\xAD\x3\x2\x2\x2\xAEF\xAF0\a[\x2\x2\xAF0");
		sb.Append("\xAF2\a\x133\x2\x2\xAF1\xAF3\t#\x2\x2\xAF2\xAF1\x3\x2\x2\x2");
		sb.Append("\xAF2\xAF3\x3\x2\x2\x2\xAF3\xAF5\x3\x2\x2\x2\xAF4\xAF6\a\x182");
		sb.Append("\x2\x2\xAF5\xAF4\x3\x2\x2\x2\xAF5\xAF6\x3\x2\x2\x2\xAF6\xAF7");
		sb.Append("\x3\x2\x2\x2\xAF7\xAF8\aH\x2\x2\xAF8\xAFA\a\x3DF\x2\x2\xAF9");
		sb.Append("\xAFB\t\b\x2\x2\xAFA\xAF9\x3\x2\x2\x2\xAFA\xAFB\x3\x2\x2\x2");
		sb.Append("\xAFB\xAFC\x3\x2\x2\x2\xAFC\xAFD\aM\x2\x2\xAFD\xAFE\a\x96\x2");
		sb.Append("\x2\xAFE\xB04\x5\x1EE\xF8\x2\xAFF\xB00\aq\x2\x2\xB00\xB01\a");
		sb.Append("\x3D0\x2\x2\xB01\xB02\x5\x226\x114\x2\xB02\xB03\a\x3D1\x2\x2");
		sb.Append("\xB03\xB05\x3\x2\x2\x2\xB04\xAFF\x3\x2\x2\x2\xB04\xB05\x3\x2");
		sb.Append("\x2\x2\xB05\xB09\x3\x2\x2\x2\xB06\xB07\a\x18\x2\x2\xB07\xB08");
		sb.Append("\a\x87\x2\x2\xB08\xB0A\x5\x1F8\xFD\x2\xB09\xB06\x3\x2\x2\x2");
		sb.Append("\xB09\xB0A\x3\x2\x2\x2\xB0A\xB11\x3\x2\x2\x2\xB0B\xB0D\t$\x2");
		sb.Append("\x2\xB0C\xB0E\x5\xF4{\x2\xB0D\xB0C\x3\x2\x2\x2\xB0E\xB0F\x3");
		sb.Append("\x2\x2\x2\xB0F\xB0D\x3\x2\x2\x2\xB0F\xB10\x3\x2\x2\x2\xB10\xB12");
		sb.Append("\x3\x2\x2\x2\xB11\xB0B\x3\x2\x2\x2\xB11\xB12\x3\x2\x2\x2\xB12");
		sb.Append("\xB19\x3\x2\x2\x2\xB13\xB15\aZ\x2\x2\xB14\xB16\x5\xF6|\x2\xB15");
		sb.Append("\xB14\x3\x2\x2\x2\xB16\xB17\x3\x2\x2\x2\xB17\xB15\x3\x2\x2\x2");
		sb.Append("\xB17\xB18\x3\x2\x2\x2\xB18\xB1A\x3\x2\x2\x2\xB19\xB13\x3\x2");
		sb.Append("\x2\x2\xB19\xB1A\x3\x2\x2\x2\xB1A\xB1F\x3\x2\x2\x2\xB1B\xB1C");
		sb.Append("\a\x45\x2\x2\xB1C\xB1D\x5\x20C\x107\x2\xB1D\xB1E\t%\x2\x2\xB1E");
		sb.Append("\xB20\x3\x2\x2\x2\xB1F\xB1B\x3\x2\x2\x2\xB1F\xB20\x3\x2\x2\x2");
		sb.Append("\xB20\xB2C\x3\x2\x2\x2\xB21\xB22\a\x3D0\x2\x2\xB22\xB27\x5\xBC");
		sb.Append("_\x2\xB23\xB24\a\x3D2\x2\x2\xB24\xB26\x5\xBC_\x2\xB25\xB23\x3");
		sb.Append("\x2\x2\x2\xB26\xB29\x3\x2\x2\x2\xB27\xB25\x3\x2\x2\x2\xB27\xB28");
		sb.Append("\x3\x2\x2\x2\xB28\xB2A\x3\x2\x2\x2\xB29\xB27\x3\x2\x2\x2\xB2A");
		sb.Append("\xB2B\a\x3D1\x2\x2\xB2B\xB2D\x3\x2\x2\x2\xB2C\xB21\x3\x2\x2");
		sb.Append("\x2\xB2C\xB2D\x3\x2\x2\x2\xB2D\xB37\x3\x2\x2\x2\xB2E\xB2F\a");
		sb.Append("\x87\x2\x2\xB2F\xB34\x5\xBA^\x2\xB30\xB31\a\x3D2\x2\x2\xB31");
		sb.Append("\xB33\x5\xBA^\x2\xB32\xB30\x3\x2\x2\x2\xB33\xB36\x3\x2\x2\x2");
		sb.Append("\xB34\xB32\x3\x2\x2\x2\xB34\xB35\x3\x2\x2\x2\xB35\xB38\x3\x2");
		sb.Append("\x2\x2\xB36\xB34\x3\x2\x2\x2\xB37\xB2E\x3\x2\x2\x2\xB37\xB38");
		sb.Append("\x3\x2\x2\x2\xB38\xAF\x3\x2\x2\x2\xB39\xB3A\a[\x2\x2\xB3A\xB3C");
		sb.Append("\a\x239\x2\x2\xB3B\xB3D\t#\x2\x2\xB3C\xB3B\x3\x2\x2\x2\xB3C");
		sb.Append("\xB3D\x3\x2\x2\x2\xB3D\xB3F\x3\x2\x2\x2\xB3E\xB40\a\x182\x2");
		sb.Append("\x2\xB3F\xB3E\x3\x2\x2\x2\xB3F\xB40\x3\x2\x2\x2\xB40\xB41\x3");
		sb.Append("\x2\x2\x2\xB41\xB42\aH\x2\x2\xB42\xB44\a\x3DF\x2\x2\xB43\xB45");
		sb.Append("\t\b\x2\x2\xB44\xB43\x3\x2\x2\x2\xB44\xB45\x3\x2\x2\x2\xB45");
		sb.Append("\xB46\x3\x2\x2\x2\xB46\xB47\aM\x2\x2\xB47\xB48\a\x96\x2\x2\xB48");
		sb.Append("\xB4C\x5\x1EE\xF8\x2\xB49\xB4A\a\x18\x2\x2\xB4A\xB4B\a\x87\x2");
		sb.Append("\x2\xB4B\xB4D\x5\x1F8\xFD\x2\xB4C\xB49\x3\x2\x2\x2\xB4C\xB4D");
		sb.Append("\x3\x2\x2\x2\xB4D\xB54\x3\x2\x2\x2\xB4E\xB4F\a\x1EE\x2\x2\xB4F");
		sb.Append("\xB50\a\x16A\x2\x2\xB50\xB51\a\x12\x2\x2\xB51\xB52\a\x3C9\x2");
		sb.Append("\x2\xB52\xB53\a\x3DF\x2\x2\xB53\xB55\a\x3C8\x2\x2\xB54\xB4E");
		sb.Append("\x3\x2\x2\x2\xB54\xB55\x3\x2\x2\x2\xB55\xB5A\x3\x2\x2\x2\xB56");
		sb.Append("\xB57\a\x45\x2\x2\xB57\xB58\x5\x20C\x107\x2\xB58\xB59\t%\x2");
		sb.Append("\x2\xB59\xB5B\x3\x2\x2\x2\xB5A\xB56\x3\x2\x2\x2\xB5A\xB5B\x3");
		sb.Append("\x2\x2\x2\xB5B\xB67\x3\x2\x2\x2\xB5C\xB5D\a\x3D0\x2\x2\xB5D");
		sb.Append("\xB62\x5\xBC_\x2\xB5E\xB5F\a\x3D2\x2\x2\xB5F\xB61\x5\xBC_\x2");
		sb.Append("\xB60\xB5E\x3\x2\x2\x2\xB61\xB64\x3\x2\x2\x2\xB62\xB60\x3\x2");
		sb.Append("\x2\x2\xB62\xB63\x3\x2\x2\x2\xB63\xB65\x3\x2\x2\x2\xB64\xB62");
		sb.Append("\x3\x2\x2\x2\xB65\xB66\a\x3D1\x2\x2\xB66\xB68\x3\x2\x2\x2\xB67");
		sb.Append("\xB5C\x3\x2\x2\x2\xB67\xB68\x3\x2\x2\x2\xB68\xB72\x3\x2\x2\x2");
		sb.Append("\xB69\xB6A\a\x87\x2\x2\xB6A\xB6F\x5\xBA^\x2\xB6B\xB6C\a\x3D2");
		sb.Append("\x2\x2\xB6C\xB6E\x5\xBA^\x2\xB6D\xB6B\x3\x2\x2\x2\xB6E\xB71");
		sb.Append("\x3\x2\x2\x2\xB6F\xB6D\x3\x2\x2\x2\xB6F\xB70\x3\x2\x2\x2\xB70");
		sb.Append("\xB73\x3\x2\x2\x2\xB71\xB6F\x3\x2\x2\x2\xB72\xB69\x3\x2\x2\x2");
		sb.Append("\xB72\xB73\x3\x2\x2\x2\xB73\xB1\x3\x2\x2\x2\xB74\xB76\a}\x2");
		sb.Append("\x2\xB75\xB77\t&\x2\x2\xB76\xB75\x3\x2\x2\x2\xB76\xB77\x3\x2");
		sb.Append("\x2\x2\xB77\xB79\x3\x2\x2\x2\xB78\xB7A\aM\x2\x2\xB79\xB78\x3");
		sb.Append("\x2\x2\x2\xB79\xB7A\x3\x2\x2\x2\xB7A\xB7B\x3\x2\x2\x2\xB7B\xB81");
		sb.Append("\x5\x1EE\xF8\x2\xB7C\xB7D\aq\x2\x2\xB7D\xB7E\a\x3D0\x2\x2\xB7E");
		sb.Append("\xB7F\x5\x226\x114\x2\xB7F\xB80\a\x3D1\x2\x2\xB80\xB82\x3\x2");
		sb.Append("\x2\x2\xB81\xB7C\x3\x2\x2\x2\xB81\xB82\x3\x2\x2\x2\xB82\xB93");
		sb.Append("\x3\x2\x2\x2\xB83\xB84\a\x3D0\x2\x2\xB84\xB85\x5\x226\x114\x2");
		sb.Append("\xB85\xB86\a\x3D1\x2\x2\xB86\xB88\x3\x2\x2\x2\xB87\xB83\x3\x2");
		sb.Append("\x2\x2\xB87\xB88\x3\x2\x2\x2\xB88\xB89\x3\x2\x2\x2\xB89\xB94");
		sb.Append("\x5\xB8]\x2\xB8A\xB8B\a\x87\x2\x2\xB8B\xB90\x5\xBA^\x2\xB8C");
		sb.Append("\xB8D\a\x3D2\x2\x2\xB8D\xB8F\x5\xBA^\x2\xB8E\xB8C\x3\x2\x2\x2");
		sb.Append("\xB8F\xB92\x3\x2\x2\x2\xB90\xB8E\x3\x2\x2\x2\xB90\xB91\x3\x2");
		sb.Append("\x2\x2\xB91\xB94\x3\x2\x2\x2\xB92\xB90\x3\x2\x2\x2\xB93\xB87");
		sb.Append("\x3\x2\x2\x2\xB93\xB8A\x3\x2\x2\x2\xB94\xB3\x3\x2\x2\x2\xB95");
		sb.Append("\xB97\x5\xE4s\x2\xB96\xB98\x5\xBE`\x2\xB97\xB96\x3\x2\x2\x2");
		sb.Append("\xB97\xB98\x3\x2\x2\x2\xB98\xBCD\x3\x2\x2\x2\xB99\xB9B\x5\xE0");
		sb.Append("q\x2\xB9A\xB9C\x5\xBE`\x2\xB9B\xB9A\x3\x2\x2\x2\xB9B\xB9C\x3");
		sb.Append("\x2\x2\x2\xB9C\xBCD\x3\x2\x2\x2\xB9D\xB9F\x5\xE6t\x2\xB9E\xBA0");
		sb.Append("\x5\xEAv\x2\xB9F\xB9E\x3\x2\x2\x2\xBA0\xBA1\x3\x2\x2\x2\xBA1");
		sb.Append("\xB9F\x3\x2\x2\x2\xBA1\xBA2\x3\x2\x2\x2\xBA2\xBAB\x3\x2\x2\x2");
		sb.Append("\xBA3\xBA5\a\x9E\x2\x2\xBA4\xBA6\t\'\x2\x2\xBA5\xBA4\x3\x2\x2");
		sb.Append("\x2\xBA5\xBA6\x3\x2\x2\x2\xBA6\xBA9\x3\x2\x2\x2\xBA7\xBAA\x5");
		sb.Append("\xE4s\x2\xBA8\xBAA\x5\xE0q\x2\xBA9\xBA7\x3\x2\x2\x2\xBA9\xBA8");
		sb.Append("\x3\x2\x2\x2\xBAA\xBAC\x3\x2\x2\x2\xBAB\xBA3\x3\x2\x2\x2\xBAB");
		sb.Append("\xBAC\x3\x2\x2\x2\xBAC\xBAE\x3\x2\x2\x2\xBAD\xBAF\x5\xD0i\x2");
		sb.Append("\xBAE\xBAD\x3\x2\x2\x2\xBAE\xBAF\x3\x2\x2\x2\xBAF\xBB1\x3\x2");
		sb.Append("\x2\x2\xBB0\xBB2\x5\xFC\x7F\x2\xBB1\xBB0\x3\x2\x2\x2\xBB1\xBB2");
		sb.Append("\x3\x2\x2\x2\xBB2\xBB4\x3\x2\x2\x2\xBB3\xBB5\x5\xBE`\x2\xBB4");
		sb.Append("\xBB3\x3\x2\x2\x2\xBB4\xBB5\x3\x2\x2\x2\xBB5\xBCD\x3\x2\x2\x2");
		sb.Append("\xBB6\xBB8\x5\xE2r\x2\xBB7\xBB9\x5\xE8u\x2\xBB8\xBB7\x3\x2\x2");
		sb.Append("\x2\xBB9\xBBA\x3\x2\x2\x2\xBBA\xBB8\x3\x2\x2\x2\xBBA\xBBB\x3");
		sb.Append("\x2\x2\x2\xBBB\xBC1\x3\x2\x2\x2\xBBC\xBBE\a\x9E\x2\x2\xBBD\xBBF");
		sb.Append("\t\'\x2\x2\xBBE\xBBD\x3\x2\x2\x2\xBBE\xBBF\x3\x2\x2\x2\xBBF");
		sb.Append("\xBC0\x3\x2\x2\x2\xBC0\xBC2\x5\xE0q\x2\xBC1\xBBC\x3\x2\x2\x2");
		sb.Append("\xBC1\xBC2\x3\x2\x2\x2\xBC2\xBC4\x3\x2\x2\x2\xBC3\xBC5\x5\xD0");
		sb.Append("i\x2\xBC4\xBC3\x3\x2\x2\x2\xBC4\xBC5\x3\x2\x2\x2\xBC5\xBC7\x3");
		sb.Append("\x2\x2\x2\xBC6\xBC8\x5\xFC\x7F\x2\xBC7\xBC6\x3\x2\x2\x2\xBC7");
		sb.Append("\xBC8\x3\x2\x2\x2\xBC8\xBCA\x3\x2\x2\x2\xBC9\xBCB\x5\xBE`\x2");
		sb.Append("\xBCA\xBC9\x3\x2\x2\x2\xBCA\xBCB\x3\x2\x2\x2\xBCB\xBCD\x3\x2");
		sb.Append("\x2\x2\xBCC\xB95\x3\x2\x2\x2\xBCC\xB99\x3\x2\x2\x2\xBCC\xB9D");
		sb.Append("\x3\x2\x2\x2\xBCC\xBB6\x3\x2\x2\x2\xBCD\xB5\x3\x2\x2\x2\xBCE");
		sb.Append("\xBD1\x5\xCCg\x2\xBCF\xBD1\x5\xCEh\x2\xBD0\xBCE\x3\x2\x2\x2");
		sb.Append("\xBD0\xBCF\x3\x2\x2\x2\xBD1\xB7\x3\x2\x2\x2\xBD2\xBE2\x5\xB4");
		sb.Append("[\x2\xBD3\xBD4\t(\x2\x2\xBD4\xBD5\a\x3D0\x2\x2\xBD5\xBD6\x5");
		sb.Append("\x22E\x118\x2\xBD6\xBDE\a\x3D1\x2\x2\xBD7\xBD8\a\x3D2\x2\x2");
		sb.Append("\xBD8\xBD9\a\x3D0\x2\x2\xBD9\xBDA\x5\x22E\x118\x2\xBDA\xBDB");
		sb.Append("\a\x3D1\x2\x2\xBDB\xBDD\x3\x2\x2\x2\xBDC\xBD7\x3\x2\x2\x2\xBDD");
		sb.Append("\xBE0\x3\x2\x2\x2\xBDE\xBDC\x3\x2\x2\x2\xBDE\xBDF\x3\x2\x2\x2");
		sb.Append("\xBDF\xBE2\x3\x2\x2\x2\xBE0\xBDE\x3\x2\x2\x2\xBE1\xBD2\x3\x2");
		sb.Append("\x2\x2\xBE1\xBD3\x3\x2\x2\x2\xBE2\xB9\x3\x2\x2\x2\xBE3\xBE4");
		sb.Append("\x5\x1F0\xF9\x2\xBE4\xBE7\a\x3C7\x2\x2\xBE5\xBE8\x5\x254\x12B");
		sb.Append("\x2\xBE6\xBE8\a\'\x2\x2\xBE7\xBE5\x3\x2\x2\x2\xBE7\xBE6\x3\x2");
		sb.Append("\x2\x2\xBE8\xBB\x3\x2\x2\x2\xBE9\xBEC\x5\x206\x104\x2\xBEA\xBEC");
		sb.Append("\a\x3EA\x2\x2\xBEB\xBE9\x3\x2\x2\x2\xBEB\xBEA\x3\x2\x2\x2\xBEC");
		sb.Append("\xBD\x3\x2\x2\x2\xBED\xBEE\a:\x2\x2\xBEE\xBF4\a\xA2\x2\x2\xBEF");
		sb.Append("\xBF0\a\\\x2\x2\xBF0\xBF1\a\x46\x2\x2\xBF1\xBF2\a\x1F5\x2\x2");
		sb.Append("\xBF2\xBF4\a\x1A6\x2\x2\xBF3\xBED\x3\x2\x2\x2\xBF3\xBEF\x3\x2");
		sb.Append("\x2\x2\xBF4\xBF\x3\x2\x2\x2\xBF5\xBF7\a)\x2\x2\xBF6\xBF8\a^");
		sb.Append("\x2\x2\xBF7\xBF6\x3\x2\x2\x2\xBF7\xBF8\x3\x2\x2\x2\xBF8\xBFA");
		sb.Append("\x3\x2\x2\x2\xBF9\xBFB\a\x1D3\x2\x2\xBFA\xBF9\x3\x2\x2\x2\xBFA");
		sb.Append("\xBFB\x3\x2\x2\x2\xBFB\xBFD\x3\x2\x2\x2\xBFC\xBFE\a\x45\x2\x2");
		sb.Append("\xBFD\xBFC\x3\x2\x2\x2\xBFD\xBFE\x3\x2\x2\x2\xBFE\xBFF\x3\x2");
		sb.Append("\x2\x2\xBFF\xC00\a=\x2\x2\xC00\xC06\x5\x1EE\xF8\x2\xC01\xC02");
		sb.Append("\aq\x2\x2\xC02\xC03\a\x3D0\x2\x2\xC03\xC04\x5\x226\x114\x2\xC04");
		sb.Append("\xC05\a\x3D1\x2\x2\xC05\xC07\x3\x2\x2\x2\xC06\xC01\x3\x2\x2");
		sb.Append("\x2\xC06\xC07\x3\x2\x2\x2\xC07\xC0A\x3\x2\x2\x2\xC08\xC09\a");
		sb.Append("\xA8\x2\x2\xC09\xC0B\x5\x254\x12B\x2\xC0A\xC08\x3\x2\x2\x2\xC0A");
		sb.Append("\xC0B\x3\x2\x2\x2\xC0B\xC0D\x3\x2\x2\x2\xC0C\xC0E\x5\xD0i\x2");
		sb.Append("\xC0D\xC0C\x3\x2\x2\x2\xC0D\xC0E\x3\x2\x2\x2\xC0E\xC11\x3\x2");
		sb.Append("\x2\x2\xC0F\xC10\aX\x2\x2\xC10\xC12\x5\x20C\x107\x2\xC11\xC0F");
		sb.Append("\x3\x2\x2\x2\xC11\xC12\x3\x2\x2\x2\xC12\xC1\x3\x2\x2\x2\xC13");
		sb.Append("\xC15\a)\x2\x2\xC14\xC16\a^\x2\x2\xC15\xC14\x3\x2\x2\x2\xC15");
		sb.Append("\xC16\x3\x2\x2\x2\xC16\xC18\x3\x2\x2\x2\xC17\xC19\a\x1D3\x2");
		sb.Append("\x2\xC18\xC17\x3\x2\x2\x2\xC18\xC19\x3\x2\x2\x2\xC19\xC1B\x3");
		sb.Append("\x2\x2\x2\xC1A\xC1C\a\x45\x2\x2\xC1B\xC1A\x3\x2\x2\x2\xC1B\xC1C");
		sb.Append("\x3\x2\x2\x2\xC1C\xC44\x3\x2\x2\x2\xC1D\xC20\x5\x1EE\xF8\x2");
		sb.Append("\xC1E\xC1F\a\x3CF\x2\x2\xC1F\xC21\a\x3BF\x2\x2\xC20\xC1E\x3");
		sb.Append("\x2\x2\x2\xC20\xC21\x3\x2\x2\x2\xC21\xC2A\x3\x2\x2\x2\xC22\xC23");
		sb.Append("\a\x3D2\x2\x2\xC23\xC26\x5\x1EE\xF8\x2\xC24\xC25\a\x3CF\x2\x2");
		sb.Append("\xC25\xC27\a\x3BF\x2\x2\xC26\xC24\x3\x2\x2\x2\xC26\xC27\x3\x2");
		sb.Append("\x2\x2\xC27\xC29\x3\x2\x2\x2\xC28\xC22\x3\x2\x2\x2\xC29\xC2C");
		sb.Append("\x3\x2\x2\x2\xC2A\xC28\x3\x2\x2\x2\xC2A\xC2B\x3\x2\x2\x2\xC2B");
		sb.Append("\xC2D\x3\x2\x2\x2\xC2C\xC2A\x3\x2\x2\x2\xC2D\xC2E\a=\x2\x2\xC2E");
		sb.Append("\xC2F\x5\xD4k\x2\xC2F\xC45\x3\x2\x2\x2\xC30\xC31\a=\x2\x2\xC31");
		sb.Append("\xC34\x5\x1EE\xF8\x2\xC32\xC33\a\x3CF\x2\x2\xC33\xC35\a\x3BF");
		sb.Append("\x2\x2\xC34\xC32\x3\x2\x2\x2\xC34\xC35\x3\x2\x2\x2\xC35\xC3E");
		sb.Append("\x3\x2\x2\x2\xC36\xC37\a\x3D2\x2\x2\xC37\xC3A\x5\x1EE\xF8\x2");
		sb.Append("\xC38\xC39\a\x3CF\x2\x2\xC39\xC3B\a\x3BF\x2\x2\xC3A\xC38\x3");
		sb.Append("\x2\x2\x2\xC3A\xC3B\x3\x2\x2\x2\xC3B\xC3D\x3\x2\x2\x2\xC3C\xC36");
		sb.Append("\x3\x2\x2\x2\xC3D\xC40\x3\x2\x2\x2\xC3E\xC3C\x3\x2\x2\x2\xC3E");
		sb.Append("\xC3F\x3\x2\x2\x2\xC3F\xC41\x3\x2\x2\x2\xC40\xC3E\x3\x2\x2\x2");
		sb.Append("\xC41\xC42\a\xA5\x2\x2\xC42\xC43\x5\xD4k\x2\xC43\xC45\x3\x2");
		sb.Append("\x2\x2\xC44\xC1D\x3\x2\x2\x2\xC44\xC30\x3\x2\x2\x2\xC45\xC48");
		sb.Append("\x3\x2\x2\x2\xC46\xC47\a\xA8\x2\x2\xC47\xC49\x5\x254\x12B\x2");
		sb.Append("\xC48\xC46\x3\x2\x2\x2\xC48\xC49\x3\x2\x2\x2\xC49\xC3\x3\x2");
		sb.Append("\x2\x2\xC4A\xC4B\a\x165\x2\x2\xC4B\xC4C\x5\x1EE\xF8\x2\xC4C");
		sb.Append("\xC51\a\x1BA\x2\x2\xC4D\xC4F\a\r\x2\x2\xC4E\xC4D\x3\x2\x2\x2");
		sb.Append("\xC4E\xC4F\x3\x2\x2\x2\xC4F\xC50\x3\x2\x2\x2\xC50\xC52\x5\x206");
		sb.Append("\x104\x2\xC51\xC4E\x3\x2\x2\x2\xC51\xC52\x3\x2\x2\x2\xC52\xC5");
		sb.Append("\x3\x2\x2\x2\xC53\xC54\a\x165\x2\x2\xC54\xC55\x5\x1EE\xF8\x2");
		sb.Append("\xC55\xC56\av\x2\x2\xC56\xC5D\x5\x206\x104\x2\xC57\xC58\x5\x25C");
		sb.Append("\x12F\x2\xC58\xC59\a\x3D0\x2\x2\xC59\xC5A\x5\x230\x119\x2\xC5A");
		sb.Append("\xC5B\a\x3D1\x2\x2\xC5B\xC5E\x3\x2\x2\x2\xC5C\xC5E\t)\x2\x2");
		sb.Append("\xC5D\xC57\x3\x2\x2\x2\xC5D\xC5C\x3\x2\x2\x2\xC5E\xC61\x3\x2");
		sb.Append("\x2\x2\xC5F\xC60\a\xA8\x2\x2\xC60\xC62\x5\x254\x12B\x2\xC61");
		sb.Append("\xC5F\x3\x2\x2\x2\xC61\xC62\x3\x2\x2\x2\xC62\xC65\x3\x2\x2\x2");
		sb.Append("\xC63\xC64\aX\x2\x2\xC64\xC66\x5\x20C\x107\x2\xC65\xC63\x3\x2");
		sb.Append("\x2\x2\xC65\xC66\x3\x2\x2\x2\xC66\xC7\x3\x2\x2\x2\xC67\xC68");
		sb.Append("\a\x165\x2\x2\xC68\xC69\x5\x1EE\xF8\x2\xC69\xC6A\av\x2\x2\xC6A");
		sb.Append("\xC6D\t*\x2\x2\xC6B\xC6C\a\xA8\x2\x2\xC6C\xC6E\x5\x254\x12B");
		sb.Append("\x2\xC6D\xC6B\x3\x2\x2\x2\xC6D\xC6E\x3\x2\x2\x2\xC6E\xC71\x3");
		sb.Append("\x2\x2\x2\xC6F\xC70\aX\x2\x2\xC70\xC72\x5\x20C\x107\x2\xC71");
		sb.Append("\xC6F\x3\x2\x2\x2\xC71\xC72\x3\x2\x2\x2\xC72\xC9\x3\x2\x2\x2");
		sb.Append("\xC73\xC74\a\x165\x2\x2\xC74\xC75\x5\x1EE\xF8\x2\xC75\xC76\a");
		sb.Append("\x11C\x2\x2\xC76\xCB\x3\x2\x2\x2\xC77\xC79\a\xA2\x2\x2\xC78");
		sb.Append("\xC7A\a^\x2\x2\xC79\xC78\x3\x2\x2\x2\xC79\xC7A\x3\x2\x2\x2\xC7A");
		sb.Append("\xC7C\x3\x2\x2\x2\xC7B\xC7D\a\x45\x2\x2\xC7C\xC7B\x3\x2\x2\x2");
		sb.Append("\xC7C\xC7D\x3\x2\x2\x2\xC7D\xC7E\x3\x2\x2\x2\xC7E\xC83\x5\x1EE");
		sb.Append("\xF8\x2\xC7F\xC81\a\r\x2\x2\xC80\xC7F\x3\x2\x2\x2\xC80\xC81");
		sb.Append("\x3\x2\x2\x2\xC81\xC82\x3\x2\x2\x2\xC82\xC84\x5\x206\x104\x2");
		sb.Append("\xC83\xC80\x3\x2\x2\x2\xC83\xC84\x3\x2\x2\x2\xC84\xC85\x3\x2");
		sb.Append("\x2\x2\xC85\xC86\a\x87\x2\x2\xC86\xC8B\x5\xBA^\x2\xC87\xC88");
		sb.Append("\a\x3D2\x2\x2\xC88\xC8A\x5\xBA^\x2\xC89\xC87\x3\x2\x2\x2\xC8A");
		sb.Append("\xC8D\x3\x2\x2\x2\xC8B\xC89\x3\x2\x2\x2\xC8B\xC8C\x3\x2\x2\x2");
		sb.Append("\xC8C\xC90\x3\x2\x2\x2\xC8D\xC8B\x3\x2\x2\x2\xC8E\xC8F\a\xA8");
		sb.Append("\x2\x2\xC8F\xC91\x5\x254\x12B\x2\xC90\xC8E\x3\x2\x2\x2\xC90");
		sb.Append("\xC91\x3\x2\x2\x2\xC91\xC93\x3\x2\x2\x2\xC92\xC94\x5\xD0i\x2");
		sb.Append("\xC93\xC92\x3\x2\x2\x2\xC93\xC94\x3\x2\x2\x2\xC94\xC96\x3\x2");
		sb.Append("\x2\x2\xC95\xC97\x5\xFC\x7F\x2\xC96\xC95\x3\x2\x2\x2\xC96\xC97");
		sb.Append("\x3\x2\x2\x2\xC97\xCD\x3\x2\x2\x2\xC98\xC9A\a\xA2\x2\x2\xC99");
		sb.Append("\xC9B\a^\x2\x2\xC9A\xC99\x3\x2\x2\x2\xC9A\xC9B\x3\x2\x2\x2\xC9B");
		sb.Append("\xC9D\x3\x2\x2\x2\xC9C\xC9E\a\x45\x2\x2\xC9D\xC9C\x3\x2\x2\x2");
		sb.Append("\xC9D\xC9E\x3\x2\x2\x2\xC9E\xC9F\x3\x2\x2\x2\xC9F\xCA0\x5\xD4");
		sb.Append("k\x2\xCA0\xCA1\a\x87\x2\x2\xCA1\xCA6\x5\xBA^\x2\xCA2\xCA3\a");
		sb.Append("\x3D2\x2\x2\xCA3\xCA5\x5\xBA^\x2\xCA4\xCA2\x3\x2\x2\x2\xCA5");
		sb.Append("\xCA8\x3\x2\x2\x2\xCA6\xCA4\x3\x2\x2\x2\xCA6\xCA7\x3\x2\x2\x2");
		sb.Append("\xCA7\xCAB\x3\x2\x2\x2\xCA8\xCA6\x3\x2\x2\x2\xCA9\xCAA\a\xA8");
		sb.Append("\x2\x2\xCAA\xCAC\x5\x254\x12B\x2\xCAB\xCA9\x3\x2\x2\x2\xCAB");
		sb.Append("\xCAC\x3\x2\x2\x2\xCAC\xCF\x3\x2\x2\x2\xCAD\xCAE\am\x2\x2\xCAE");
		sb.Append("\xCAF\a\x12\x2\x2\xCAF\xCB4\x5\xD2j\x2\xCB0\xCB1\a\x3D2\x2\x2");
		sb.Append("\xCB1\xCB3\x5\xD2j\x2\xCB2\xCB0\x3\x2\x2\x2\xCB3\xCB6\x3\x2");
		sb.Append("\x2\x2\xCB4\xCB2\x3\x2\x2\x2\xCB4\xCB5\x3\x2\x2\x2\xCB5\xD1");
		sb.Append("\x3\x2\x2\x2\xCB6\xCB4\x3\x2\x2\x2\xCB7\xCB9\x5\x254\x12B\x2");
		sb.Append("\xCB8\xCBA\t+\x2\x2\xCB9\xCB8\x3\x2\x2\x2\xCB9\xCBA\x3\x2\x2");
		sb.Append("\x2\xCBA\xD3\x3\x2\x2\x2\xCBB\xCC0\x5\xD6l\x2\xCBC\xCBD\a\x3D2");
		sb.Append("\x2\x2\xCBD\xCBF\x5\xD6l\x2\xCBE\xCBC\x3\x2\x2\x2\xCBF\xCC2");
		sb.Append("\x3\x2\x2\x2\xCC0\xCBE\x3\x2\x2\x2\xCC0\xCC1\x3\x2\x2\x2\xCC1");
		sb.Append("\xD5\x3\x2\x2\x2\xCC2\xCC0\x3\x2\x2\x2\xCC3\xCC7\x5\xD8m\x2");
		sb.Append("\xCC4\xCC6\x5\xDEp\x2\xCC5\xCC4\x3\x2\x2\x2\xCC6\xCC9\x3\x2");
		sb.Append("\x2\x2\xCC7\xCC5\x3\x2\x2\x2\xCC7\xCC8\x3\x2\x2\x2\xCC8\xCD5");
		sb.Append("\x3\x2\x2\x2\xCC9\xCC7\x3\x2\x2\x2\xCCA\xCCB\a\x3D0\x2\x2\xCCB");
		sb.Append("\xCCF\x5\xD8m\x2\xCCC\xCCE\x5\xDEp\x2\xCCD\xCCC\x3\x2\x2\x2");
		sb.Append("\xCCE\xCD1\x3\x2\x2\x2\xCCF\xCCD\x3\x2\x2\x2\xCCF\xCD0\x3\x2");
		sb.Append("\x2\x2\xCD0\xCD2\x3\x2\x2\x2\xCD1\xCCF\x3\x2\x2\x2\xCD2\xCD3");
		sb.Append("\a\x3D1\x2\x2\xCD3\xCD5\x3\x2\x2\x2\xCD4\xCC3\x3\x2\x2\x2\xCD4");
		sb.Append("\xCCA\x3\x2\x2\x2\xCD5\xD7\x3\x2\x2\x2\xCD6\xCDC\x5\x1EE\xF8");
		sb.Append("\x2\xCD7\xCD8\aq\x2\x2\xCD8\xCD9\a\x3D0\x2\x2\xCD9\xCDA\x5\x226");
		sb.Append("\x114\x2\xCDA\xCDB\a\x3D1\x2\x2\xCDB\xCDD\x3\x2\x2\x2\xCDC\xCD7");
		sb.Append("\x3\x2\x2\x2\xCDC\xCDD\x3\x2\x2\x2\xCDD\xCE2\x3\x2\x2\x2\xCDE");
		sb.Append("\xCE0\a\r\x2\x2\xCDF\xCDE\x3\x2\x2\x2\xCDF\xCE0\x3\x2\x2\x2");
		sb.Append("\xCE0\xCE1\x3\x2\x2\x2\xCE1\xCE3\x5\x206\x104\x2\xCE2\xCDF\x3");
		sb.Append("\x2\x2\x2\xCE2\xCE3\x3\x2\x2\x2\xCE3\xCEC\x3\x2\x2\x2\xCE4\xCE9");
		sb.Append("\x5\xDAn\x2\xCE5\xCE6\a\x3D2\x2\x2\xCE6\xCE8\x5\xDAn\x2\xCE7");
		sb.Append("\xCE5\x3\x2\x2\x2\xCE8\xCEB\x3\x2\x2\x2\xCE9\xCE7\x3\x2\x2\x2");
		sb.Append("\xCE9\xCEA\x3\x2\x2\x2\xCEA\xCED\x3\x2\x2\x2\xCEB\xCE9\x3\x2");
		sb.Append("\x2\x2\xCEC\xCE4\x3\x2\x2\x2\xCEC\xCED\x3\x2\x2\x2\xCED\xCFF");
		sb.Append("\x3\x2\x2\x2\xCEE\xCF4\x5\xB4[\x2\xCEF\xCF0\a\x3D0\x2\x2\xCF0");
		sb.Append("\xCF1\x5\xB4[\x2\xCF1\xCF2\a\x3D1\x2\x2\xCF2\xCF4\x3\x2\x2\x2");
		sb.Append("\xCF3\xCEE\x3\x2\x2\x2\xCF3\xCEF\x3\x2\x2\x2\xCF4\xCF6\x3\x2");
		sb.Append("\x2\x2\xCF5\xCF7\a\r\x2\x2\xCF6\xCF5\x3\x2\x2\x2\xCF6\xCF7\x3");
		sb.Append("\x2\x2\x2\xCF7\xCF8\x3\x2\x2\x2\xCF8\xCF9\x5\x206\x104\x2\xCF9");
		sb.Append("\xCFF\x3\x2\x2\x2\xCFA\xCFB\a\x3D0\x2\x2\xCFB\xCFC\x5\xD4k\x2");
		sb.Append("\xCFC\xCFD\a\x3D1\x2\x2\xCFD\xCFF\x3\x2\x2\x2\xCFE\xCD6\x3\x2");
		sb.Append("\x2\x2\xCFE\xCF3\x3\x2\x2\x2\xCFE\xCFA\x3\x2\x2\x2\xCFF\xD9");
		sb.Append("\x3\x2\x2\x2\xD00\xD01\t,\x2\x2\xD01\xD04\t\x14\x2\x2\xD02\xD03");
		sb.Append("\a:\x2\x2\xD03\xD05\x5\xDCo\x2\xD04\xD02\x3\x2\x2\x2\xD04\xD05");
		sb.Append("\x3\x2\x2\x2\xD05\xD06\x3\x2\x2\x2\xD06\xD07\a\x3D0\x2\x2\xD07");
		sb.Append("\xD08\x5\x226\x114\x2\xD08\xD09\a\x3D1\x2\x2\xD09\xDB\x3\x2");
		sb.Append("\x2\x2\xD0A\xD10\aP\x2\x2\xD0B\xD0C\am\x2\x2\xD0C\xD10\a\x12");
		sb.Append("\x2\x2\xD0D\xD0E\a\x41\x2\x2\xD0E\xD10\a\x12\x2\x2\xD0F\xD0A");
		sb.Append("\x3\x2\x2\x2\xD0F\xD0B\x3\x2\x2\x2\xD0F\xD0D\x3\x2\x2\x2\xD10");
		sb.Append("\xDD\x3\x2\x2\x2\xD11\xD13\t-\x2\x2\xD12\xD11\x3\x2\x2\x2\xD12");
		sb.Append("\xD13\x3\x2\x2\x2\xD13\xD14\x3\x2\x2\x2\xD14\xD15\aP\x2\x2\xD15");
		sb.Append("\xD1D\x5\xD8m\x2\xD16\xD17\ah\x2\x2\xD17\xD1E\x5\x254\x12B\x2");
		sb.Append("\xD18\xD19\a\xA5\x2\x2\xD19\xD1A\a\x3D0\x2\x2\xD1A\xD1B\x5\x226");
		sb.Append("\x114\x2\xD1B\xD1C\a\x3D1\x2\x2\xD1C\xD1E\x3\x2\x2\x2\xD1D\xD16");
		sb.Append("\x3\x2\x2\x2\xD1D\xD18\x3\x2\x2\x2\xD1D\xD1E\x3\x2\x2\x2\xD1E");
		sb.Append("\xD3E\x3\x2\x2\x2\xD1F\xD20\a\x95\x2\x2\xD20\xD23\x5\xD8m\x2");
		sb.Append("\xD21\xD22\ah\x2\x2\xD22\xD24\x5\x254\x12B\x2\xD23\xD21\x3\x2");
		sb.Append("\x2\x2\xD23\xD24\x3\x2\x2\x2\xD24\xD3E\x3\x2\x2\x2\xD25\xD27");
		sb.Append("\t.\x2\x2\xD26\xD28\ao\x2\x2\xD27\xD26\x3\x2\x2\x2\xD27\xD28");
		sb.Append("\x3\x2\x2\x2\xD28\xD29\x3\x2\x2\x2\xD29\xD2A\aP\x2\x2\xD2A\xD32");
		sb.Append("\x5\xD8m\x2\xD2B\xD2C\ah\x2\x2\xD2C\xD33\x5\x254\x12B\x2\xD2D");
		sb.Append("\xD2E\a\xA5\x2\x2\xD2E\xD2F\a\x3D0\x2\x2\xD2F\xD30\x5\x226\x114");
		sb.Append("\x2\xD30\xD31\a\x3D1\x2\x2\xD31\xD33\x3\x2\x2\x2\xD32\xD2B\x3");
		sb.Append("\x2\x2\x2\xD32\xD2D\x3\x2\x2\x2\xD33\xD3E\x3\x2\x2\x2\xD34\xD39");
		sb.Append("\a\x64\x2\x2\xD35\xD37\t.\x2\x2\xD36\xD38\ao\x2\x2\xD37\xD36");
		sb.Append("\x3\x2\x2\x2\xD37\xD38\x3\x2\x2\x2\xD38\xD3A\x3\x2\x2\x2\xD39");
		sb.Append("\xD35\x3\x2\x2\x2\xD39\xD3A\x3\x2\x2\x2\xD3A\xD3B\x3\x2\x2\x2");
		sb.Append("\xD3B\xD3C\aP\x2\x2\xD3C\xD3E\x5\xD8m\x2\xD3D\xD12\x3\x2\x2");
		sb.Append("\x2\xD3D\xD1F\x3\x2\x2\x2\xD3D\xD25\x3\x2\x2\x2\xD3D\xD34\x3");
		sb.Append("\x2\x2\x2\xD3E\xDF\x3\x2\x2\x2\xD3F\xD40\a\x3D0\x2\x2\xD40\xD41");
		sb.Append("\x5\xE4s\x2\xD41\xD42\a\x3D1\x2\x2\xD42\xD48\x3\x2\x2\x2\xD43");
		sb.Append("\xD44\a\x3D0\x2\x2\xD44\xD45\x5\xE0q\x2\xD45\xD46\a\x3D1\x2");
		sb.Append("\x2\xD46\xD48\x3\x2\x2\x2\xD47\xD3F\x3\x2\x2\x2\xD47\xD43\x3");
		sb.Append("\x2\x2\x2\xD48\xE1\x3\x2\x2\x2\xD49\xD4A\a\x3D0\x2\x2\xD4A\xD4B");
		sb.Append("\x5\xE6t\x2\xD4B\xD4C\a\x3D1\x2\x2\xD4C\xD52\x3\x2\x2\x2\xD4D");
		sb.Append("\xD4E\a\x3D0\x2\x2\xD4E\xD4F\x5\xE2r\x2\xD4F\xD50\a\x3D1\x2");
		sb.Append("\x2\xD50\xD52\x3\x2\x2\x2\xD51\xD49\x3\x2\x2\x2\xD51\xD4D\x3");
		sb.Append("\x2\x2\x2\xD52\xE3\x3\x2\x2\x2\xD53\xD57\a\x86\x2\x2\xD54\xD56");
		sb.Append("\x5\xECw\x2\xD55\xD54\x3\x2\x2\x2\xD56\xD59\x3\x2\x2\x2\xD57");
		sb.Append("\xD55\x3\x2\x2\x2\xD57\xD58\x3\x2\x2\x2\xD58\xD5A\x3\x2\x2\x2");
		sb.Append("\xD59\xD57\x3\x2\x2\x2\xD5A\xD5C\x5\xEEx\x2\xD5B\xD5D\x5\xF2");
		sb.Append("z\x2\xD5C\xD5B\x3\x2\x2\x2\xD5C\xD5D\x3\x2\x2\x2\xD5D\xD5F\x3");
		sb.Append("\x2\x2\x2\xD5E\xD60\x5\xF8}\x2\xD5F\xD5E\x3\x2\x2\x2\xD5F\xD60");
		sb.Append("\x3\x2\x2\x2\xD60\xD62\x3\x2\x2\x2\xD61\xD63\x5\xD0i\x2\xD62");
		sb.Append("\xD61\x3\x2\x2\x2\xD62\xD63\x3\x2\x2\x2\xD63\xD65\x3\x2\x2\x2");
		sb.Append("\xD64\xD66\x5\xFC\x7F\x2\xD65\xD64\x3\x2\x2\x2\xD65\xD66\x3");
		sb.Append("\x2\x2\x2\xD66\xD7C\x3\x2\x2\x2\xD67\xD6B\a\x86\x2\x2\xD68\xD6A");
		sb.Append("\x5\xECw\x2\xD69\xD68\x3\x2\x2\x2\xD6A\xD6D\x3\x2\x2\x2\xD6B");
		sb.Append("\xD69\x3\x2\x2\x2\xD6B\xD6C\x3\x2\x2\x2\xD6C\xD6E\x3\x2\x2\x2");
		sb.Append("\xD6D\xD6B\x3\x2\x2\x2\xD6E\xD70\x5\xEEx\x2\xD6F\xD71\x5\xF8");
		sb.Append("}\x2\xD70\xD6F\x3\x2\x2\x2\xD70\xD71\x3\x2\x2\x2\xD71\xD73\x3");
		sb.Append("\x2\x2\x2\xD72\xD74\x5\xD0i\x2\xD73\xD72\x3\x2\x2\x2\xD73\xD74");
		sb.Append("\x3\x2\x2\x2\xD74\xD76\x3\x2\x2\x2\xD75\xD77\x5\xFC\x7F\x2\xD76");
		sb.Append("\xD75\x3\x2\x2\x2\xD76\xD77\x3\x2\x2\x2\xD77\xD79\x3\x2\x2\x2");
		sb.Append("\xD78\xD7A\x5\xF2z\x2\xD79\xD78\x3\x2\x2\x2\xD79\xD7A\x3\x2");
		sb.Append("\x2\x2\xD7A\xD7C\x3\x2\x2\x2\xD7B\xD53\x3\x2\x2\x2\xD7B\xD67");
		sb.Append("\x3\x2\x2\x2\xD7C\xE5\x3\x2\x2\x2\xD7D\xD81\a\x86\x2\x2\xD7E");
		sb.Append("\xD80\x5\xECw\x2\xD7F\xD7E\x3\x2\x2\x2\xD80\xD83\x3\x2\x2\x2");
		sb.Append("\xD81\xD7F\x3\x2\x2\x2\xD81\xD82\x3\x2\x2\x2\xD82\xD84\x3\x2");
		sb.Append("\x2\x2\xD83\xD81\x3\x2\x2\x2\xD84\xD86\x5\xEEx\x2\xD85\xD87");
		sb.Append("\x5\xF8}\x2\xD86\xD85\x3\x2\x2\x2\xD86\xD87\x3\x2\x2\x2\xD87");
		sb.Append("\xD89\x3\x2\x2\x2\xD88\xD8A\x5\xD0i\x2\xD89\xD88\x3\x2\x2\x2");
		sb.Append("\xD89\xD8A\x3\x2\x2\x2\xD8A\xD8C\x3\x2\x2\x2\xD8B\xD8D\x5\xFC");
		sb.Append("\x7F\x2\xD8C\xD8B\x3\x2\x2\x2\xD8C\xD8D\x3\x2\x2\x2\xD8D\xE7");
		sb.Append("\x3\x2\x2\x2\xD8E\xD90\a\x9E\x2\x2\xD8F\xD91\t\'\x2\x2\xD90");
		sb.Append("\xD8F\x3\x2\x2\x2\xD90\xD91\x3\x2\x2\x2\xD91\xD92\x3\x2\x2\x2");
		sb.Append("\xD92\xD93\x5\xE2r\x2\xD93\xE9\x3\x2\x2\x2\xD94\xD96\a\x9E\x2");
		sb.Append("\x2\xD95\xD97\t\'\x2\x2\xD96\xD95\x3\x2\x2\x2\xD96\xD97\x3\x2");
		sb.Append("\x2\x2\xD97\xD9A\x3\x2\x2\x2\xD98\xD9B\x5\xE6t\x2\xD99\xD9B");
		sb.Append("\x5\xE2r\x2\xD9A\xD98\x3\x2\x2\x2\xD9A\xD99\x3\x2\x2\x2\xD9B");
		sb.Append("\xEB\x3\x2\x2\x2\xD9C\xDA5\t/\x2\x2\xD9D\xDA5\a\x43\x2\x2\xD9E");
		sb.Append("\xDA5\a\x95\x2\x2\xD9F\xDA5\a\x92\x2\x2\xDA0\xDA5\a\x90\x2\x2");
		sb.Append("\xDA1\xDA5\a\x204\x2\x2\xDA2\xDA5\t\x30\x2\x2\xDA3\xDA5\a\x91");
		sb.Append("\x2\x2\xDA4\xD9C\x3\x2\x2\x2\xDA4\xD9D\x3\x2\x2\x2\xDA4\xD9E");
		sb.Append("\x3\x2\x2\x2\xDA4\xD9F\x3\x2\x2\x2\xDA4\xDA0\x3\x2\x2\x2\xDA4");
		sb.Append("\xDA1\x3\x2\x2\x2\xDA4\xDA2\x3\x2\x2\x2\xDA4\xDA3\x3\x2\x2\x2");
		sb.Append("\xDA5\xED\x3\x2\x2\x2\xDA6\xDA9\a\x3BF\x2\x2\xDA7\xDA9\x5\xF0");
		sb.Append("y\x2\xDA8\xDA6\x3\x2\x2\x2\xDA8\xDA7\x3\x2\x2\x2\xDA9\xDAE\x3");
		sb.Append("\x2\x2\x2\xDAA\xDAB\a\x3D2\x2\x2\xDAB\xDAD\x5\xF0y\x2\xDAC\xDAA");
		sb.Append("\x3\x2\x2\x2\xDAD\xDB0\x3\x2\x2\x2\xDAE\xDAC\x3\x2\x2\x2\xDAE");
		sb.Append("\xDAF\x3\x2\x2\x2\xDAF\xEF\x3\x2\x2\x2\xDB0\xDAE\x3\x2\x2\x2");
		sb.Append("\xDB1\xDB2\x5\x1EC\xF7\x2\xDB2\xDB3\a\x3CF\x2\x2\xDB3\xDB4\a");
		sb.Append("\x3BF\x2\x2\xDB4\xDCF\x3\x2\x2\x2\xDB5\xDBA\x5\x1F0\xF9\x2\xDB6");
		sb.Append("\xDB8\a\r\x2\x2\xDB7\xDB6\x3\x2\x2\x2\xDB7\xDB8\x3\x2\x2\x2");
		sb.Append("\xDB8\xDB9\x3\x2\x2\x2\xDB9\xDBB\x5\x206\x104\x2\xDBA\xDB7\x3");
		sb.Append("\x2\x2\x2\xDBA\xDBB\x3\x2\x2\x2\xDBB\xDCF\x3\x2\x2\x2\xDBC\xDC1");
		sb.Append("\x5\x240\x121\x2\xDBD\xDBF\a\r\x2\x2\xDBE\xDBD\x3\x2\x2\x2\xDBE");
		sb.Append("\xDBF\x3\x2\x2\x2\xDBF\xDC0\x3\x2\x2\x2\xDC0\xDC2\x5\x206\x104");
		sb.Append("\x2\xDC1\xDBE\x3\x2\x2\x2\xDC1\xDC2\x3\x2\x2\x2\xDC2\xDCF\x3");
		sb.Append("\x2\x2\x2\xDC3\xDC4\a\x3EA\x2\x2\xDC4\xDC6\a\x3B6\x2\x2\xDC5");
		sb.Append("\xDC3\x3\x2\x2\x2\xDC5\xDC6\x3\x2\x2\x2\xDC6\xDC7\x3\x2\x2\x2");
		sb.Append("\xDC7\xDCC\x5\x254\x12B\x2\xDC8\xDCA\a\r\x2\x2\xDC9\xDC8\x3");
		sb.Append("\x2\x2\x2\xDC9\xDCA\x3\x2\x2\x2\xDCA\xDCB\x3\x2\x2\x2\xDCB\xDCD");
		sb.Append("\x5\x206\x104\x2\xDCC\xDC9\x3\x2\x2\x2\xDCC\xDCD\x3\x2\x2\x2");
		sb.Append("\xDCD\xDCF\x3\x2\x2\x2\xDCE\xDB1\x3\x2\x2\x2\xDCE\xDB5\x3\x2");
		sb.Append("\x2\x2\xDCE\xDBC\x3\x2\x2\x2\xDCE\xDC5\x3\x2\x2\x2\xDCF\xF1");
		sb.Append("\x3\x2\x2\x2\xDD0\xDD1\aM\x2\x2\xDD1\xDD6\x5\xBC_\x2\xDD2\xDD3");
		sb.Append("\a\x3D2\x2\x2\xDD3\xDD5\x5\xBC_\x2\xDD4\xDD2\x3\x2\x2\x2\xDD5");
		sb.Append("\xDD8\x3\x2\x2\x2\xDD6\xDD4\x3\x2\x2\x2\xDD6\xDD7\x3\x2\x2\x2");
		sb.Append("\xDD7\xDF5\x3\x2\x2\x2\xDD8\xDD6\x3\x2\x2\x2\xDD9\xDDA\aM\x2");
		sb.Append("\x2\xDDA\xDDB\a\x13F\x2\x2\xDDB\xDF5\a\x3DF\x2\x2\xDDC\xDDD");
		sb.Append("\aM\x2\x2\xDDD\xDDE\ap\x2\x2\xDDE\xDE2\a\x3DF\x2\x2\xDDF\xDE0");
		sb.Append("\a\x18\x2\x2\xDE0\xDE1\a\x87\x2\x2\xDE1\xDE3\x5\x1F8\xFD\x2");
		sb.Append("\xDE2\xDDF\x3\x2\x2\x2\xDE2\xDE3\x3\x2\x2\x2\xDE3\xDEA\x3\x2");
		sb.Append("\x2\x2\xDE4\xDE6\t$\x2\x2\xDE5\xDE7\x5\xF4{\x2\xDE6\xDE5\x3");
		sb.Append("\x2\x2\x2\xDE7\xDE8\x3\x2\x2\x2\xDE8\xDE6\x3\x2\x2\x2\xDE8\xDE9");
		sb.Append("\x3\x2\x2\x2\xDE9\xDEB\x3\x2\x2\x2\xDEA\xDE4\x3\x2\x2\x2\xDEA");
		sb.Append("\xDEB\x3\x2\x2\x2\xDEB\xDF2\x3\x2\x2\x2\xDEC\xDEE\aZ\x2\x2\xDED");
		sb.Append("\xDEF\x5\xF6|\x2\xDEE\xDED\x3\x2\x2\x2\xDEF\xDF0\x3\x2\x2\x2");
		sb.Append("\xDF0\xDEE\x3\x2\x2\x2\xDF0\xDF1\x3\x2\x2\x2\xDF1\xDF3\x3\x2");
		sb.Append("\x2\x2\xDF2\xDEC\x3\x2\x2\x2\xDF2\xDF3\x3\x2\x2\x2\xDF3\xDF5");
		sb.Append("\x3\x2\x2\x2\xDF4\xDD0\x3\x2\x2\x2\xDF4\xDD9\x3\x2\x2\x2\xDF4");
		sb.Append("\xDDC\x3\x2\x2\x2\xDF5\xF3\x3\x2\x2\x2\xDF6\xDF7\a\x97\x2\x2");
		sb.Append("\xDF7\xDF8\a\x12\x2\x2\xDF8\xE03\a\x3DF\x2\x2\xDF9\xDFB\ak\x2");
		sb.Append("\x2\xDFA\xDF9\x3\x2\x2\x2\xDFA\xDFB\x3\x2\x2\x2\xDFB\xDFC\x3");
		sb.Append("\x2\x2\x2\xDFC\xDFD\a\x33\x2\x2\xDFD\xDFE\a\x12\x2\x2\xDFE\xE03");
		sb.Append("\a\x3DF\x2\x2\xDFF\xE00\a\x34\x2\x2\xE00\xE01\a\x12\x2\x2\xE01");
		sb.Append("\xE03\a\x3DF\x2\x2\xE02\xDF6\x3\x2\x2\x2\xE02\xDFA\x3\x2\x2");
		sb.Append("\x2\xE02\xDFF\x3\x2\x2\x2\xE03\xF5\x3\x2\x2\x2\xE04\xE05\a\x94");
		sb.Append("\x2\x2\xE05\xE06\a\x12\x2\x2\xE06\xE0B\a\x3DF\x2\x2\xE07\xE08");
		sb.Append("\a\x97\x2\x2\xE08\xE09\a\x12\x2\x2\xE09\xE0B\a\x3DF\x2\x2\xE0A");
		sb.Append("\xE04\x3\x2\x2\x2\xE0A\xE07\x3\x2\x2\x2\xE0B\xF7\x3\x2\x2\x2");
		sb.Append("\xE0C\xE0D\a=\x2\x2\xE0D\xE10\x5\xD4k\x2\xE0E\xE0F\a\xA8\x2");
		sb.Append("\x2\xE0F\xE11\x5\x254\x12B\x2\xE10\xE0E\x3\x2\x2\x2\xE10\xE11");
		sb.Append("\x3\x2\x2\x2\xE11\xE20\x3\x2\x2\x2\xE12\xE13\a\x41\x2\x2\xE13");
		sb.Append("\xE14\a\x12\x2\x2\xE14\xE19\x5\xFA~\x2\xE15\xE16\a\x3D2\x2\x2");
		sb.Append("\xE16\xE18\x5\xFA~\x2\xE17\xE15\x3\x2\x2\x2\xE18\xE1B\x3\x2");
		sb.Append("\x2\x2\xE19\xE17\x3\x2\x2\x2\xE19\xE1A\x3\x2\x2\x2\xE1A\xE1E");
		sb.Append("\x3\x2\x2\x2\xE1B\xE19\x3\x2\x2\x2\xE1C\xE1D\a\xAA\x2\x2\xE1D");
		sb.Append("\xE1F\a\x1EB\x2\x2\xE1E\xE1C\x3\x2\x2\x2\xE1E\xE1F\x3\x2\x2");
		sb.Append("\x2\xE1F\xE21\x3\x2\x2\x2\xE20\xE12\x3\x2\x2\x2\xE20\xE21\x3");
		sb.Append("\x2\x2\x2\xE21\xE24\x3\x2\x2\x2\xE22\xE23\a\x42\x2\x2\xE23\xE25");
		sb.Append("\x5\x254\x12B\x2\xE24\xE22\x3\x2\x2\x2\xE24\xE25\x3\x2\x2\x2");
		sb.Append("\xE25\xF9\x3\x2\x2\x2\xE26\xE28\x5\x254\x12B\x2\xE27\xE29\t");
		sb.Append("+\x2\x2\xE28\xE27\x3\x2\x2\x2\xE28\xE29\x3\x2\x2\x2\xE29\xFB");
		sb.Append("\x3\x2\x2\x2\xE2A\xE35\aX\x2\x2\xE2B\xE2C\x5\xFE\x80\x2\xE2C");
		sb.Append("\xE2D\a\x3D2\x2\x2\xE2D\xE2F\x3\x2\x2\x2\xE2E\xE2B\x3\x2\x2");
		sb.Append("\x2\xE2E\xE2F\x3\x2\x2\x2\xE2F\xE30\x3\x2\x2\x2\xE30\xE36\x5");
		sb.Append("\xFE\x80\x2\xE31\xE32\x5\xFE\x80\x2\xE32\xE33\a\x1B4\x2\x2\xE33");
		sb.Append("\xE34\x5\xFE\x80\x2\xE34\xE36\x3\x2\x2\x2\xE35\xE2E\x3\x2\x2");
		sb.Append("\x2\xE35\xE31\x3\x2\x2\x2\xE36\xFD\x3\x2\x2\x2\xE37\xE3A\x5");
		sb.Append("\x20C\x107\x2\xE38\xE3A\x5\x1F6\xFC\x2\xE39\xE37\x3\x2\x2\x2");
		sb.Append("\xE39\xE38\x3\x2\x2\x2\xE3A\xFF\x3\x2\x2\x2\xE3B\xE3C\a\x208");
		sb.Append("\x2\x2\xE3C\xE45\a\x21F\x2\x2\xE3D\xE42\x5\x116\x8C\x2\xE3E");
		sb.Append("\xE3F\a\x3D2\x2\x2\xE3F\xE41\x5\x116\x8C\x2\xE40\xE3E\x3\x2");
		sb.Append("\x2\x2\xE41\xE44\x3\x2\x2\x2\xE42\xE40\x3\x2\x2\x2\xE42\xE43");
		sb.Append("\x3\x2\x2\x2\xE43\xE46\x3\x2\x2\x2\xE44\xE42\x3\x2\x2\x2\xE45");
		sb.Append("\xE3D\x3\x2\x2\x2\xE45\xE46\x3\x2\x2\x2\xE46\x101\x3\x2\x2\x2");
		sb.Append("\xE47\xE49\a\x10B\x2\x2\xE48\xE4A\a\x235\x2\x2\xE49\xE48\x3");
		sb.Append("\x2\x2\x2\xE49\xE4A\x3\x2\x2\x2\xE4A\x103\x3\x2\x2\x2\xE4B\xE4D");
		sb.Append("\a\x123\x2\x2\xE4C\xE4E\a\x235\x2\x2\xE4D\xE4C\x3\x2\x2\x2\xE4D");
		sb.Append("\xE4E\x3\x2\x2\x2\xE4E\xE54\x3\x2\x2\x2\xE4F\xE51\a\f\x2\x2");
		sb.Append("\xE50\xE52\a\x1B0\x2\x2\xE51\xE50\x3\x2\x2\x2\xE51\xE52\x3\x2");
		sb.Append("\x2\x2\xE52\xE53\x3\x2\x2\x2\xE53\xE55\a\x114\x2\x2\xE54\xE4F");
		sb.Append("\x3\x2\x2\x2\xE54\xE55\x3\x2\x2\x2\xE55\xE5A\x3\x2\x2\x2\xE56");
		sb.Append("\xE58\a\x1B0\x2\x2\xE57\xE56\x3\x2\x2\x2\xE57\xE58\x3\x2\x2");
		sb.Append("\x2\xE58\xE59\x3\x2\x2\x2\xE59\xE5B\az\x2\x2\xE5A\xE57\x3\x2");
		sb.Append("\x2\x2\xE5A\xE5B\x3\x2\x2\x2\xE5B\x105\x3\x2\x2\x2\xE5C\xE5E");
		sb.Append("\a\x1EA\x2\x2\xE5D\xE5F\a\x235\x2\x2\xE5E\xE5D\x3\x2\x2\x2\xE5E");
		sb.Append("\xE5F\x3\x2\x2\x2\xE5F\xE65\x3\x2\x2\x2\xE60\xE62\a\f\x2\x2");
		sb.Append("\xE61\xE63\a\x1B0\x2\x2\xE62\xE61\x3\x2\x2\x2\xE62\xE63\x3\x2");
		sb.Append("\x2\x2\xE63\xE64\x3\x2\x2\x2\xE64\xE66\a\x114\x2\x2\xE65\xE60");
		sb.Append("\x3\x2\x2\x2\xE65\xE66\x3\x2\x2\x2\xE66\xE6B\x3\x2\x2\x2\xE67");
		sb.Append("\xE69\a\x1B0\x2\x2\xE68\xE67\x3\x2\x2\x2\xE68\xE69\x3\x2\x2");
		sb.Append("\x2\xE69\xE6A\x3\x2\x2\x2\xE6A\xE6C\az\x2\x2\xE6B\xE68\x3\x2");
		sb.Append("\x2\x2\xE6B\xE6C\x3\x2\x2\x2\xE6C\x107\x3\x2\x2\x2\xE6D\xE6E");
		sb.Append("\a\x1F0\x2\x2\xE6E\xE6F\x5\x206\x104\x2\xE6F\x109\x3\x2\x2\x2");
		sb.Append("\xE70\xE72\a\x1EA\x2\x2\xE71\xE73\a\x235\x2\x2\xE72\xE71\x3");
		sb.Append("\x2\x2\x2\xE72\xE73\x3\x2\x2\x2\xE73\xE74\x3\x2\x2\x2\xE74\xE76");
		sb.Append("\a\x99\x2\x2\xE75\xE77\a\x1F0\x2\x2\xE76\xE75\x3\x2\x2\x2\xE76");
		sb.Append("\xE77\x3\x2\x2\x2\xE77\xE78\x3\x2\x2\x2\xE78\xE79\x5\x206\x104");
		sb.Append("\x2\xE79\x10B\x3\x2\x2\x2\xE7A\xE7B\az\x2\x2\xE7B\xE7C\a\x1F0");
		sb.Append("\x2\x2\xE7C\xE7D\x5\x206\x104\x2\xE7D\x10D\x3\x2\x2\x2\xE7E");
		sb.Append("\xE7F\a\\\x2\x2\xE7F\xE80\a\x247\x2\x2\xE80\xE85\x5\x118\x8D");
		sb.Append("\x2\xE81\xE82\a\x3D2\x2\x2\xE82\xE84\x5\x118\x8D\x2\xE83\xE81");
		sb.Append("\x3\x2\x2\x2\xE84\xE87\x3\x2\x2\x2\xE85\xE83\x3\x2\x2\x2\xE85");
		sb.Append("\xE86\x3\x2\x2\x2\xE86\x10F\x3\x2\x2\x2\xE87\xE85\x3\x2\x2\x2");
		sb.Append("\xE88\xE89\a\xA0\x2\x2\xE89\xE8A\a\x247\x2\x2\xE8A\x111\x3\x2");
		sb.Append("\x2\x2\xE8B\xE8C\a\x87\x2\x2\xE8C\xE8D\a\x107\x2\x2\xE8D\xE8E");
		sb.Append("\a\x3C7\x2\x2\xE8E\xE8F\t\x18\x2\x2\xE8F\x113\x3\x2\x2\x2\xE90");
		sb.Append("\xE92\a\x87\x2\x2\xE91\xE93\t\x31\x2\x2\xE92\xE91\x3\x2\x2\x2");
		sb.Append("\xE92\xE93\x3\x2\x2\x2\xE93\xE94\x3\x2\x2\x2\xE94\xE95\a\x21F");
		sb.Append("\x2\x2\xE95\xE9A\x5\x11C\x8F\x2\xE96\xE97\a\x3D2\x2\x2\xE97");
		sb.Append("\xE99\x5\x11C\x8F\x2\xE98\xE96\x3\x2\x2\x2\xE99\xE9C\x3\x2\x2");
		sb.Append("\x2\xE9A\xE98\x3\x2\x2\x2\xE9A\xE9B\x3\x2\x2\x2\xE9B\x115\x3");
		sb.Append("\x2\x2\x2\xE9C\xE9A\x3\x2\x2\x2\xE9D\xE9E\a\xAA\x2\x2\xE9E\xE9F");
		sb.Append("\a\x12A\x2\x2\xE9F\xEA5\a\x1FB\x2\x2\xEA0\xEA1\av\x2\x2\xEA1");
		sb.Append("\xEA5\a\xAB\x2\x2\xEA2\xEA3\av\x2\x2\xEA3\xEA5\a\x1B9\x2\x2");
		sb.Append("\xEA4\xE9D\x3\x2\x2\x2\xEA4\xEA0\x3\x2\x2\x2\xEA4\xEA2\x3\x2");
		sb.Append("\x2\x2\xEA5\x117\x3\x2\x2\x2\xEA6\xEAB\x5\x1EE\xF8\x2\xEA7\xEA9");
		sb.Append("\a\r\x2\x2\xEA8\xEA7\x3\x2\x2\x2\xEA8\xEA9\x3\x2\x2\x2\xEA9");
		sb.Append("\xEAA\x3\x2\x2\x2\xEAA\xEAC\x5\x206\x104\x2\xEAB\xEA8\x3\x2");
		sb.Append("\x2\x2\xEAB\xEAC\x3\x2\x2\x2\xEAC\xEAD\x3\x2\x2\x2\xEAD\xEAE");
		sb.Append("\x5\x11A\x8E\x2\xEAE\x119\x3\x2\x2\x2\xEAF\xEB1\av\x2\x2\xEB0");
		sb.Append("\xEB2\a\x182\x2\x2\xEB1\xEB0\x3\x2\x2\x2\xEB1\xEB2\x3\x2\x2");
		sb.Append("\x2\xEB2\xEB8\x3\x2\x2\x2\xEB3\xEB5\a^\x2\x2\xEB4\xEB3\x3\x2");
		sb.Append("\x2\x2\xEB4\xEB5\x3\x2\x2\x2\xEB5\xEB6\x3\x2\x2\x2\xEB6\xEB8");
		sb.Append("\a\xAB\x2\x2\xEB7\xEAF\x3\x2\x2\x2\xEB7\xEB4\x3\x2\x2\x2\xEB8");
		sb.Append("\x11B\x3\x2\x2\x2\xEB9\xEBA\a\x178\x2\x2\xEBA\xEBB\a\x180\x2");
		sb.Append("\x2\xEBB\xEC1\x5\x11E\x90\x2\xEBC\xEBD\av\x2\x2\xEBD\xEC1\a");
		sb.Append("\xAB\x2\x2\xEBE\xEBF\av\x2\x2\xEBF\xEC1\a\x1B9\x2\x2\xEC0\xEB9");
		sb.Append("\x3\x2\x2\x2\xEC0\xEBC\x3\x2\x2\x2\xEC0\xEBE\x3\x2\x2\x2\xEC1");
		sb.Append("\x11D\x3\x2\x2\x2\xEC2\xEC3\a\x285\x2\x2\xEC3\xECA\av\x2\x2");
		sb.Append("\xEC4\xEC5\av\x2\x2\xEC5\xECA\a\x286\x2\x2\xEC6\xEC7\av\x2\x2");
		sb.Append("\xEC7\xECA\a\x287\x2\x2\xEC8\xECA\a\x288\x2\x2\xEC9\xEC2\x3");
		sb.Append("\x2\x2\x2\xEC9\xEC4\x3\x2\x2\x2\xEC9\xEC6\x3\x2\x2\x2\xEC9\xEC8");
		sb.Append("\x3\x2\x2\x2\xECA\x11F\x3\x2\x2\x2\xECB\xECC\a\x17\x2\x2\xECC");
		sb.Append("\xECD\a\x185\x2\x2\xECD\xECE\a\x99\x2\x2\xECE\xED3\x5\x132\x9A");
		sb.Append("\x2\xECF\xED0\a\x3D2\x2\x2\xED0\xED2\x5\x132\x9A\x2\xED1\xECF");
		sb.Append("\x3\x2\x2\x2\xED2\xED5\x3\x2\x2\x2\xED3\xED1\x3\x2\x2\x2\xED3");
		sb.Append("\xED4\x3\x2\x2\x2\xED4\xED7\x3\x2\x2\x2\xED5\xED3\x3\x2\x2\x2");
		sb.Append("\xED6\xED8\x5\x13A\x9E\x2\xED7\xED6\x3\x2\x2\x2\xED7\xED8\x3");
		sb.Append("\x2\x2\x2\xED8\x121\x3\x2\x2\x2\xED9\xEDA\a\x17\x2\x2\xEDA\xEDB");
		sb.Append("\a\x1E6\x2\x2\xEDB\xEDC\a\x159\x2\x2\xEDC\xEE1\x5\x13C\x9F\x2");
		sb.Append("\xEDD\xEDE\a\x3D2\x2\x2\xEDE\xEE0\x5\x13C\x9F\x2\xEDF\xEDD\x3");
		sb.Append("\x2\x2\x2\xEE0\xEE3\x3\x2\x2\x2\xEE1\xEDF\x3\x2\x2\x2\xEE1\xEE2");
		sb.Append("\x3\x2\x2\x2\xEE2\x123\x3\x2\x2\x2\xEE3\xEE1\x3\x2\x2\x2\xEE4");
		sb.Append("\xEE5\at\x2\x2\xEE5\xEE6\t\x32\x2\x2\xEE6\xEEB\a\x184\x2\x2");
		sb.Append("\xEE7\xEE8\a\x99\x2\x2\xEE8\xEEC\a\x3DF\x2\x2\xEE9\xEEA\a\xF");
		sb.Append("\x2\x2\xEEA\xEEC\a\x3DF\x2\x2\xEEB\xEE7\x3\x2\x2\x2\xEEB\xEE9");
		sb.Append("\x3\x2\x2\x2\xEEC\x125\x3\x2\x2\x2\xEED\xEEE\a\x1E7\x2\x2\xEEE");
		sb.Append("\xEEF\a\x185\x2\x2\xEEF\x127\x3\x2\x2\x2\xEF0\xEF1\a\x1E7\x2");
		sb.Append("\x2\xEF1\xEF3\a\x1F9\x2\x2\xEF2\xEF4\a\b\x2\x2\xEF3\xEF2\x3");
		sb.Append("\x2\x2\x2\xEF3\xEF4\x3\x2\x2\x2\xEF4\xEF6\x3\x2\x2\x2\xEF5\xEF7");
		sb.Append("\x5\x13A\x9E\x2\xEF6\xEF5\x3\x2\x2\x2\xEF6\xEF7\x3\x2\x2\x2");
		sb.Append("\xEF7\x129\x3\x2\x2\x2\xEF8\xEF9\a\x208\x2\x2\xEF9\xF02\a\x1F9");
		sb.Append("\x2\x2\xEFA\xEFF\x5\x140\xA1\x2\xEFB\xEFC\a\x3D2\x2\x2\xEFC");
		sb.Append("\xEFE\x5\x140\xA1\x2\xEFD\xEFB\x3\x2\x2\x2\xEFE\xF01\x3\x2\x2");
		sb.Append("\x2\xEFF\xEFD\x3\x2\x2\x2\xEFF\xF00\x3\x2\x2\x2\xF00\xF03\x3");
		sb.Append("\x2\x2\x2\xF01\xEFF\x3\x2\x2\x2\xF02\xEFA\x3\x2\x2\x2\xF02\xF03");
		sb.Append("\x3\x2\x2\x2\xF03\xF06\x3\x2\x2\x2\xF04\xF05\a\x227\x2\x2\xF05");
		sb.Append("\xF07\x5\x142\xA2\x2\xF06\xF04\x3\x2\x2\x2\xF06\xF07\x3\x2\x2");
		sb.Append("\x2\xF07\xF0B\x3\x2\x2\x2\xF08\xF0A\x5\x144\xA3\x2\xF09\xF08");
		sb.Append("\x3\x2\x2\x2\xF0A\xF0D\x3\x2\x2\x2\xF0B\xF09\x3\x2\x2\x2\xF0B");
		sb.Append("\xF0C\x3\x2\x2\x2\xF0C\xF0F\x3\x2\x2\x2\xF0D\xF0B\x3\x2\x2\x2");
		sb.Append("\xF0E\xF10\x5\x13A\x9E\x2\xF0F\xF0E\x3\x2\x2\x2\xF0F\xF10\x3");
		sb.Append("\x2\x2\x2\xF10\x12B\x3\x2\x2\x2\xF11\xF12\a\x20E\x2\x2\xF12");
		sb.Append("\xF1B\a\x1F9\x2\x2\xF13\xF18\x5\x140\xA1\x2\xF14\xF15\a\x3D2");
		sb.Append("\x2\x2\xF15\xF17\x5\x140\xA1\x2\xF16\xF14\x3\x2\x2\x2\xF17\xF1A");
		sb.Append("\x3\x2\x2\x2\xF18\xF16\x3\x2\x2\x2\xF18\xF19\x3\x2\x2\x2\xF19");
		sb.Append("\xF1C\x3\x2\x2\x2\xF1A\xF18\x3\x2\x2\x2\xF1B\xF13\x3\x2\x2\x2");
		sb.Append("\xF1B\xF1C\x3\x2\x2\x2\xF1C\x12D\x3\x2\x2\x2\xF1D\xF1E\a\x208");
		sb.Append("\x2\x2\xF1E\xF1F\a\x164\x2\x2\xF1F\x12F\x3\x2\x2\x2\xF20\xF21");
		sb.Append("\a\x20E\x2\x2\xF21\xF22\a\x164\x2\x2\xF22\x131\x3\x2\x2\x2\xF23");
		sb.Append("\xF24\x5\x134\x9B\x2\xF24\xF25\a\x3C7\x2\x2\xF25\xF26\a\x3DF");
		sb.Append("\x2\x2\xF26\xF41\x3\x2\x2\x2\xF27\xF28\x5\x136\x9C\x2\xF28\xF29");
		sb.Append("\a\x3C7\x2\x2\xF29\xF2A\x5\x20C\x107\x2\xF2A\xF41\x3\x2\x2\x2");
		sb.Append("\xF2B\xF2C\x5\x138\x9D\x2\xF2C\xF2D\a\x3C7\x2\x2\xF2D\xF2E\t");
		sb.Append("\x18\x2\x2\xF2E\xF41\x3\x2\x2\x2\xF2F\xF30\a\x189\x2\x2\xF30");
		sb.Append("\xF31\a\x3C7\x2\x2\xF31\xF41\a\x3E2\x2\x2\xF32\xF33\a\x16B\x2");
		sb.Append("\x2\xF33\xF34\a\x3C7\x2\x2\xF34\xF3D\a\x3D0\x2\x2\xF35\xF3A");
		sb.Append("\x5\x206\x104\x2\xF36\xF37\a\x3D2\x2\x2\xF37\xF39\x5\x206\x104");
		sb.Append("\x2\xF38\xF36\x3\x2\x2\x2\xF39\xF3C\x3\x2\x2\x2\xF3A\xF38\x3");
		sb.Append("\x2\x2\x2\xF3A\xF3B\x3\x2\x2\x2\xF3B\xF3E\x3\x2\x2\x2\xF3C\xF3A");
		sb.Append("\x3\x2\x2\x2\xF3D\xF35\x3\x2\x2\x2\xF3D\xF3E\x3\x2\x2\x2\xF3E");
		sb.Append("\xF3F\x3\x2\x2\x2\xF3F\xF41\a\x3D1\x2\x2\xF40\xF23\x3\x2\x2");
		sb.Append("\x2\xF40\xF27\x3\x2\x2\x2\xF40\xF2B\x3\x2\x2\x2\xF40\xF2F\x3");
		sb.Append("\x2\x2\x2\xF40\xF32\x3\x2\x2\x2\xF41\x133\x3\x2\x2\x2\xF42\xF43");
		sb.Append("\t\x33\x2\x2\xF43\x135\x3\x2\x2\x2\xF44\xF45\t\x34\x2\x2\xF45");
		sb.Append("\x137\x3\x2\x2\x2\xF46\xF47\t\x35\x2\x2\xF47\x139\x3\x2\x2\x2");
		sb.Append("\xF48\xF49\a:\x2\x2\xF49\xF4A\a\x116\x2\x2\xF4A\xF4B\a\x3DF");
		sb.Append("\x2\x2\xF4B\x13B\x3\x2\x2\x2\xF4C\xF4D\a\x1DF\x2\x2\xF4D\xF4E");
		sb.Append("\a\x3C7\x2\x2\xF4E\xF4F\a\x3D0\x2\x2\xF4F\xF50\x5\x226\x114");
		sb.Append("\x2\xF50\xF51\a\x3D1\x2\x2\xF51\xF7E\x3\x2\x2\x2\xF52\xF53\a");
		sb.Append("\x1E1\x2\x2\xF53\xF54\a\x3C7\x2\x2\xF54\xF55\a\x3D0\x2\x2\xF55");
		sb.Append("\xF56\x5\x226\x114\x2\xF56\xF57\a\x3D1\x2\x2\xF57\xF7E\x3\x2");
		sb.Append("\x2\x2\xF58\xF59\a\x1E0\x2\x2\xF59\xF5A\a\x3C7\x2\x2\xF5A\xF5B");
		sb.Append("\a\x3D0\x2\x2\xF5B\xF5C\x5\x228\x115\x2\xF5C\xF5D\a\x3D1\x2");
		sb.Append("\x2\xF5D\xF7E\x3\x2\x2\x2\xF5E\xF5F\a\x1E2\x2\x2\xF5F\xF60\a");
		sb.Append("\x3C7\x2\x2\xF60\xF61\a\x3D0\x2\x2\xF61\xF62\x5\x228\x115\x2");
		sb.Append("\xF62\xF63\a\x3D1\x2\x2\xF63\xF7E\x3\x2\x2\x2\xF64\xF65\a\x1E4");
		sb.Append("\x2\x2\xF65\xF66\a\x3C7\x2\x2\xF66\xF67\a\x3D0\x2\x2\xF67\xF68");
		sb.Append("\x5\x232\x11A\x2\xF68\xF69\a\x3D1\x2\x2\xF69\xF7E\x3\x2\x2\x2");
		sb.Append("\xF6A\xF6B\a\x1E5\x2\x2\xF6B\xF6C\a\x3C7\x2\x2\xF6C\xF6D\a\x3D0");
		sb.Append("\x2\x2\xF6D\xF6E\x5\x232\x11A\x2\xF6E\xF6F\a\x3D1\x2\x2\xF6F");
		sb.Append("\xF7E\x3\x2\x2\x2\xF70\xF71\a\x1E3\x2\x2\xF71\xF72\a\x3C7\x2");
		sb.Append("\x2\xF72\xF73\a\x3D0\x2\x2\xF73\xF78\x5\x13E\xA0\x2\xF74\xF75");
		sb.Append("\a\x3D2\x2\x2\xF75\xF77\x5\x13E\xA0\x2\xF76\xF74\x3\x2\x2\x2");
		sb.Append("\xF77\xF7A\x3\x2\x2\x2\xF78\xF76\x3\x2\x2\x2\xF78\xF79\x3\x2");
		sb.Append("\x2\x2\xF79\xF7B\x3\x2\x2\x2\xF7A\xF78\x3\x2\x2\x2\xF7B\xF7C");
		sb.Append("\a\x3D1\x2\x2\xF7C\xF7E\x3\x2\x2\x2\xF7D\xF4C\x3\x2\x2\x2\xF7D");
		sb.Append("\xF52\x3\x2\x2\x2\xF7D\xF58\x3\x2\x2\x2\xF7D\xF5E\x3\x2\x2\x2");
		sb.Append("\xF7D\xF64\x3\x2\x2\x2\xF7D\xF6A\x3\x2\x2\x2\xF7D\xF70\x3\x2");
		sb.Append("\x2\x2\xF7E\x13D\x3\x2\x2\x2\xF7F\xF80\a\x3D0\x2\x2\xF80\xF81");
		sb.Append("\x5\x1EE\xF8\x2\xF81\xF82\a\x3D2\x2\x2\xF82\xF83\x5\x1EE\xF8");
		sb.Append("\x2\xF83\xF84\a\x3D1\x2\x2\xF84\x13F\x3\x2\x2\x2\xF85\xF86\t");
		sb.Append("\x36\x2\x2\xF86\x141\x3\x2\x2\x2\xF87\xF88\t\x37\x2\x2\xF88");
		sb.Append("\xF89\a\x3C7\x2\x2\xF89\xF9A\x5\x146\xA4\x2\xF8A\xF8B\a\x18B");
		sb.Append("\x2\x2\xF8B\xF8C\a\x3C7\x2\x2\xF8C\xF8D\a\x3DF\x2\x2\xF8D\xF8E");
		sb.Append("\a\x3D2\x2\x2\xF8E\xF8F\a\x18C\x2\x2\xF8F\xF90\a\x3C7\x2\x2");
		sb.Append("\xF90\xF9A\x5\x20C\x107\x2\xF91\xF92\a\x1D9\x2\x2\xF92\xF93");
		sb.Append("\a\x3C7\x2\x2\xF93\xF94\a\x3DF\x2\x2\xF94\xF95\a\x3D2\x2\x2");
		sb.Append("\xF95\xF96\a\x1DA\x2\x2\xF96\xF97\a\x3C7\x2\x2\xF97\xF9A\x5");
		sb.Append("\x20C\x107\x2\xF98\xF9A\a\x202\x2\x2\xF99\xF87\x3\x2\x2\x2\xF99");
		sb.Append("\xF8A\x3\x2\x2\x2\xF99\xF91\x3\x2\x2\x2\xF99\xF98\x3\x2\x2\x2");
		sb.Append("\xF9A\x143\x3\x2\x2\x2\xF9B\xF9C\a\x229\x2\x2\xF9C\xF9D\a\x3C7");
		sb.Append("\x2\x2\xF9D\xFA8\a\x3DF\x2\x2\xF9E\xF9F\a\x1C4\x2\x2\xF9F\xFA0");
		sb.Append("\a\x3C7\x2\x2\xFA0\xFA8\a\x3DF\x2\x2\xFA1\xFA2\a\x136\x2\x2");
		sb.Append("\xFA2\xFA3\a\x3C7\x2\x2\xFA3\xFA8\a\x3DF\x2\x2\xFA4\xFA5\a\x1C7");
		sb.Append("\x2\x2\xFA5\xFA6\a\x3C7\x2\x2\xFA6\xFA8\a\x3DF\x2\x2\xFA7\xF9B");
		sb.Append("\x3\x2\x2\x2\xFA7\xF9E\x3\x2\x2\x2\xFA7\xFA1\x3\x2\x2\x2\xFA7");
		sb.Append("\xFA4\x3\x2\x2\x2\xFA8\x145\x3\x2\x2\x2\xFA9\xFAE\x5\x1FE\x100");
		sb.Append("\x2\xFAA\xFAB\a\x3D2\x2\x2\xFAB\xFAD\x5\x1FE\x100\x2\xFAC\xFAA");
		sb.Append("\x3\x2\x2\x2\xFAD\xFB0\x3\x2\x2\x2\xFAE\xFAC\x3\x2\x2\x2\xFAE");
		sb.Append("\xFAF\x3\x2\x2\x2\xFAF\xFB3\x3\x2\x2\x2\xFB0\xFAE\x3\x2\x2\x2");
		sb.Append("\xFB1\xFB3\a\x3DF\x2\x2\xFB2\xFA9\x3\x2\x2\x2\xFB2\xFB1\x3\x2");
		sb.Append("\x2\x2\xFB3\x147\x3\x2\x2\x2\xFB4\xFB5\a\x238\x2\x2\xFB5\xFB6");
		sb.Append("\t\x38\x2\x2\xFB6\xFB8\x5\x200\x101\x2\xFB7\xFB9\t\x39\x2\x2");
		sb.Append("\xFB8\xFB7\x3\x2\x2\x2\xFB8\xFB9\x3\x2\x2\x2\xFB9\x149\x3\x2");
		sb.Append("\x2\x2\xFBA\xFBB\a\x238\x2\x2\xFBB\xFBC\a\x144\x2\x2\xFBC\xFC2");
		sb.Append("\x5\x200\x101\x2\xFBD\xFC0\a\x216\x2\x2\xFBE\xFBF\a:\x2\x2\xFBF");
		sb.Append("\xFC1\a\x1A4\x2\x2\xFC0\xFBE\x3\x2\x2\x2\xFC0\xFC1\x3\x2\x2");
		sb.Append("\x2\xFC1\xFC3\x3\x2\x2\x2\xFC2\xFBD\x3\x2\x2\x2\xFC2\xFC3\x3");
		sb.Append("\x2\x2\x2\xFC3\x14B\x3\x2\x2\x2\xFC4\xFC5\a\x238\x2\x2\xFC5");
		sb.Append("\xFC6\a\x1CB\x2\x2\xFC6\xFC7\x5\x200\x101\x2\xFC7\x14D\x3\x2");
		sb.Append("\x2\x2\xFC8\xFC9\a\x238\x2\x2\xFC9\xFCA\a\x123\x2\x2\xFCA\xFCD");
		sb.Append("\x5\x200\x101\x2\xFCB\xFCC\a\x1B7\x2\x2\xFCC\xFCE\a\x1C5\x2");
		sb.Append("\x2\xFCD\xFCB\x3\x2\x2\x2\xFCD\xFCE\x3\x2\x2\x2\xFCE\x14F\x3");
		sb.Append("\x2\x2\x2\xFCF\xFD0\a\x238\x2\x2\xFD0\xFD1\a\x1EA\x2\x2\xFD1");
		sb.Append("\xFD2\x5\x200\x101\x2\xFD2\x151\x3\x2\x2\x2\xFD3\xFD4\a\x238");
		sb.Append("\x2\x2\xFD4\xFD7\a\x1D5\x2\x2\xFD5\xFD6\a\x1F\x2\x2\xFD6\xFD8");
		sb.Append("\x5\x200\x101\x2\xFD7\xFD5\x3\x2\x2\x2\xFD7\xFD8\x3\x2\x2\x2");
		sb.Append("\xFD8\x153\x3\x2\x2\x2\xFD9\xFDA\a\x1CB\x2\x2\xFDA\xFDB\x5\x206");
		sb.Append("\x104\x2\xFDB\xFDE\a=\x2\x2\xFDC\xFDF\a\x3DF\x2\x2\xFDD\xFDF");
		sb.Append("\a\x3EA\x2\x2\xFDE\xFDC\x3\x2\x2\x2\xFDE\xFDD\x3\x2\x2\x2\xFDF");
		sb.Append("\x155\x3\x2\x2\x2\xFE0\xFE1\a\x249\x2\x2\xFE1\xFE4\x5\x206\x104");
		sb.Append("\x2\xFE2\xFE3\a\xA5\x2\x2\xFE3\xFE5\x5\x234\x11B\x2\xFE4\xFE2");
		sb.Append("\x3\x2\x2\x2\xFE4\xFE5\x3\x2\x2\x2\xFE5\x157\x3\x2\x2\x2\xFE6");
		sb.Append("\xFE7\t:\x2\x2\xFE7\xFE8\a\x1CB\x2\x2\xFE8\xFE9\x5\x206\x104");
		sb.Append("\x2\xFE9\x159\x3\x2\x2\x2\xFEA\xFED\x5\x15C\xAF\x2\xFEB\xFED");
		sb.Append("\x5\x6\x4\x2\xFEC\xFEA\x3\x2\x2\x2\xFEC\xFEB\x3\x2\x2\x2\xFED");
		sb.Append("\x15B\x3\x2\x2\x2\xFEE\xFEF\x5\x206\x104\x2\xFEF\xFF0\a\x3DB");
		sb.Append("\x2\x2\xFF0\xFF2\x3\x2\x2\x2\xFF1\xFEE\x3\x2\x2\x2\xFF1\xFF2");
		sb.Append("\x3\x2\x2\x2\xFF2\xFF3\x3\x2\x2\x2\xFF3\x101A\a\x10B\x2\x2\xFF4");
		sb.Append("\xFF5\x5\x170\xB9\x2\xFF5\xFF6\a\x3D3\x2\x2\xFF6\xFF8\x3\x2");
		sb.Append("\x2\x2\xFF7\xFF4\x3\x2\x2\x2\xFF8\xFFB\x3\x2\x2\x2\xFF9\xFF7");
		sb.Append("\x3\x2\x2\x2\xFF9\xFFA\x3\x2\x2\x2\xFFA\x1001\x3\x2\x2\x2\xFFB");
		sb.Append("\xFF9\x3\x2\x2\x2\xFFC\xFFD\x5\x172\xBA\x2\xFFD\xFFE\a\x3D3");
		sb.Append("\x2\x2\xFFE\x1000\x3\x2\x2\x2\xFFF\xFFC\x3\x2\x2\x2\x1000\x1003");
		sb.Append("\x3\x2\x2\x2\x1001\xFFF\x3\x2\x2\x2\x1001\x1002\x3\x2\x2\x2");
		sb.Append("\x1002\x1009\x3\x2\x2\x2\x1003\x1001\x3\x2\x2\x2\x1004\x1005");
		sb.Append("\x5\x174\xBB\x2\x1005\x1006\a\x3D3\x2\x2\x1006\x1008\x3\x2\x2");
		sb.Append("\x2\x1007\x1004\x3\x2\x2\x2\x1008\x100B\x3\x2\x2\x2\x1009\x1007");
		sb.Append("\x3\x2\x2\x2\x1009\x100A\x3\x2\x2\x2\x100A\x1011\x3\x2\x2\x2");
		sb.Append("\x100B\x1009\x3\x2\x2\x2\x100C\x100D\x5\x176\xBC\x2\x100D\x100E");
		sb.Append("\a\x3D3\x2\x2\x100E\x1010\x3\x2\x2\x2\x100F\x100C\x3\x2\x2\x2");
		sb.Append("\x1010\x1013\x3\x2\x2\x2\x1011\x100F\x3\x2\x2\x2\x1011\x1012");
		sb.Append("\x3\x2\x2\x2\x1012\x1017\x3\x2\x2\x2\x1013\x1011\x3\x2\x2\x2");
		sb.Append("\x1014\x1016\x5\x17A\xBE\x2\x1015\x1014\x3\x2\x2\x2\x1016\x1019");
		sb.Append("\x3\x2\x2\x2\x1017\x1015\x3\x2\x2\x2\x1017\x1018\x3\x2\x2\x2");
		sb.Append("\x1018\x101B\x3\x2\x2\x2\x1019\x1017\x3\x2\x2\x2\x101A\xFF9");
		sb.Append("\x3\x2\x2\x2\x101A\x101B\x3\x2\x2\x2\x101B\x101C\x3\x2\x2\x2");
		sb.Append("\x101C\x101E\a\x144\x2\x2\x101D\x101F\x5\x206\x104\x2\x101E");
		sb.Append("\x101D\x3\x2\x2\x2\x101E\x101F\x3\x2\x2\x2\x101F\x15D\x3\x2");
		sb.Append("\x2\x2\x1020\x1023\a\x15\x2\x2\x1021\x1024\x5\x206\x104\x2\x1022");
		sb.Append("\x1024\x5\x254\x12B\x2\x1023\x1021\x3\x2\x2\x2\x1023\x1022\x3");
		sb.Append("\x2\x2\x2\x1023\x1024\x3\x2\x2\x2\x1024\x1026\x3\x2\x2\x2\x1025");
		sb.Append("\x1027\x5\x17C\xBF\x2\x1026\x1025\x3\x2\x2\x2\x1027\x1028\x3");
		sb.Append("\x2\x2\x2\x1028\x1026\x3\x2\x2\x2\x1028\x1029\x3\x2\x2\x2\x1029");
		sb.Append("\x1030\x3\x2\x2\x2\x102A\x102C\a\x31\x2\x2\x102B\x102D\x5\x17A");
		sb.Append("\xBE\x2\x102C\x102B\x3\x2\x2\x2\x102D\x102E\x3\x2\x2\x2\x102E");
		sb.Append("\x102C\x3\x2\x2\x2\x102E\x102F\x3\x2\x2\x2\x102F\x1031\x3\x2");
		sb.Append("\x2\x2\x1030\x102A\x3\x2\x2\x2\x1030\x1031\x3\x2\x2\x2\x1031");
		sb.Append("\x1032\x3\x2\x2\x2\x1032\x1033\a\x144\x2\x2\x1033\x1034\a\x15");
		sb.Append("\x2\x2\x1034\x15F\x3\x2\x2\x2\x1035\x1036\a\x44\x2\x2\x1036");
		sb.Append("\x1037\x5\x254\x12B\x2\x1037\x1039\a\x98\x2\x2\x1038\x103A\x5");
		sb.Append("\x17A\xBE\x2\x1039\x1038\x3\x2\x2\x2\x103A\x103B\x3\x2\x2\x2");
		sb.Append("\x103B\x1039\x3\x2\x2\x2\x103B\x103C\x3\x2\x2\x2\x103C\x1040");
		sb.Append("\x3\x2\x2\x2\x103D\x103F\x5\x17E\xC0\x2\x103E\x103D\x3\x2\x2");
		sb.Append("\x2\x103F\x1042\x3\x2\x2\x2\x1040\x103E\x3\x2\x2\x2\x1040\x1041");
		sb.Append("\x3\x2\x2\x2\x1041\x1049\x3\x2\x2\x2\x1042\x1040\x3\x2\x2\x2");
		sb.Append("\x1043\x1045\a\x31\x2\x2\x1044\x1046\x5\x17A\xBE\x2\x1045\x1044");
		sb.Append("\x3\x2\x2\x2\x1046\x1047\x3\x2\x2\x2\x1047\x1045\x3\x2\x2\x2");
		sb.Append("\x1047\x1048\x3\x2\x2\x2\x1048\x104A\x3\x2\x2\x2\x1049\x1043");
		sb.Append("\x3\x2\x2\x2\x1049\x104A\x3\x2\x2\x2\x104A\x104B\x3\x2\x2\x2");
		sb.Append("\x104B\x104C\a\x144\x2\x2\x104C\x104D\a\x44\x2\x2\x104D\x161");
		sb.Append("\x3\x2\x2\x2\x104E\x104F\aO\x2\x2\x104F\x1050\x5\x206\x104\x2");
		sb.Append("\x1050\x163\x3\x2\x2\x2\x1051\x1052\aU\x2\x2\x1052\x1053\x5");
		sb.Append("\x206\x104\x2\x1053\x165\x3\x2\x2\x2\x1054\x1055\x5\x206\x104");
		sb.Append("\x2\x1055\x1056\a\x3DB\x2\x2\x1056\x1058\x3\x2\x2\x2\x1057\x1054");
		sb.Append("\x3\x2\x2\x2\x1057\x1058\x3\x2\x2\x2\x1058\x1059\x3\x2\x2\x2");
		sb.Append("\x1059\x105B\a]\x2\x2\x105A\x105C\x5\x17A\xBE\x2\x105B\x105A");
		sb.Append("\x3\x2\x2\x2\x105C\x105D\x3\x2\x2\x2\x105D\x105B\x3\x2\x2\x2");
		sb.Append("\x105D\x105E\x3\x2\x2\x2\x105E\x105F\x3\x2\x2\x2\x105F\x1060");
		sb.Append("\a\x144\x2\x2\x1060\x1062\a]\x2\x2\x1061\x1063\x5\x206\x104");
		sb.Append("\x2\x1062\x1061\x3\x2\x2\x2\x1062\x1063\x3\x2\x2\x2\x1063\x167");
		sb.Append("\x3\x2\x2\x2\x1064\x1065\x5\x206\x104\x2\x1065\x1066\a\x3DB");
		sb.Append("\x2\x2\x1066\x1068\x3\x2\x2\x2\x1067\x1064\x3\x2\x2\x2\x1067");
		sb.Append("\x1068\x3\x2\x2\x2\x1068\x1069\x3\x2\x2\x2\x1069\x106B\a|\x2");
		sb.Append("\x2\x106A\x106C\x5\x17A\xBE\x2\x106B\x106A\x3\x2\x2\x2\x106C");
		sb.Append("\x106D\x3\x2\x2\x2\x106D\x106B\x3\x2\x2\x2\x106D\x106E\x3\x2");
		sb.Append("\x2\x2\x106E\x106F\x3\x2\x2\x2\x106F\x1070\a\x227\x2\x2\x1070");
		sb.Append("\x1071\x5\x254\x12B\x2\x1071\x1072\a\x144\x2\x2\x1072\x1074");
		sb.Append("\a|\x2\x2\x1073\x1075\x5\x206\x104\x2\x1074\x1073\x3\x2\x2\x2");
		sb.Append("\x1074\x1075\x3\x2\x2\x2\x1075\x169\x3\x2\x2\x2\x1076\x1077");
		sb.Append("\a\x80\x2\x2\x1077\x1078\x5\x254\x12B\x2\x1078\x16B\x3\x2\x2");
		sb.Append("\x2\x1079\x107A\x5\x206\x104\x2\x107A\x107B\a\x3DB\x2\x2\x107B");
		sb.Append("\x107D\x3\x2\x2\x2\x107C\x1079\x3\x2\x2\x2\x107C\x107D\x3\x2");
		sb.Append("\x2\x2\x107D\x107E\x3\x2\x2\x2\x107E\x107F\a\xA9\x2\x2\x107F");
		sb.Append("\x1080\x5\x254\x12B\x2\x1080\x1082\a\x13E\x2\x2\x1081\x1083");
		sb.Append("\x5\x17A\xBE\x2\x1082\x1081\x3\x2\x2\x2\x1083\x1084\x3\x2\x2");
		sb.Append("\x2\x1084\x1082\x3\x2\x2\x2\x1084\x1085\x3\x2\x2\x2\x1085\x1086");
		sb.Append("\x3\x2\x2\x2\x1086\x1087\a\x144\x2\x2\x1087\x1089\a\xA9\x2\x2");
		sb.Append("\x1088\x108A\x5\x206\x104\x2\x1089\x1088\x3\x2\x2\x2\x1089\x108A");
		sb.Append("\x3\x2\x2\x2\x108A\x16D\x3\x2\x2\x2\x108B\x108C\a\x11C\x2\x2");
		sb.Append("\x108C\x109B\x5\x206\x104\x2\x108D\x1092\a\x39\x2\x2\x108E\x1090");
		sb.Append("\a\x1AF\x2\x2\x108F\x108E\x3\x2\x2\x2\x108F\x1090\x3\x2\x2\x2");
		sb.Append("\x1090\x1091\x3\x2\x2\x2\x1091\x1093\a=\x2\x2\x1092\x108F\x3");
		sb.Append("\x2\x2\x2\x1092\x1093\x3\x2\x2\x2\x1093\x1094\x3\x2\x2\x2\x1094");
		sb.Append("\x1095\x5\x206\x104\x2\x1095\x1096\aM\x2\x2\x1096\x1097\x5\x226");
		sb.Append("\x114\x2\x1097\x109B\x3\x2\x2\x2\x1098\x1099\a\x1BA\x2\x2\x1099");
		sb.Append("\x109B\x5\x206\x104\x2\x109A\x108B\x3\x2\x2\x2\x109A\x108D\x3");
		sb.Append("\x2\x2\x2\x109A\x1098\x3\x2\x2\x2\x109B\x16F\x3\x2\x2\x2\x109C");
		sb.Append("\x109D\a&\x2\x2\x109D\x109E\x5\x226\x114\x2\x109E\x10A1\x5\x21A");
		sb.Append("\x10E\x2\x109F\x10A0\a\'\x2\x2\x10A0\x10A2\x5\x236\x11C\x2\x10A1");
		sb.Append("\x109F\x3\x2\x2\x2\x10A1\x10A2\x3\x2\x2\x2\x10A2\x171\x3\x2");
		sb.Append("\x2\x2\x10A3\x10A4\a&\x2\x2\x10A4\x10A5\x5\x206\x104\x2\x10A5");
		sb.Append("\x10A6\a\x1C\x2\x2\x10A6\x10AD\a:\x2\x2\x10A7\x10AE\x5\x20C");
		sb.Append("\x107\x2\x10A8\x10AA\a\x8E\x2\x2\x10A9\x10AB\a\x22D\x2\x2\x10AA");
		sb.Append("\x10A9\x3\x2\x2\x2\x10AA\x10AB\x3\x2\x2\x2\x10AB\x10AC\x3\x2");
		sb.Append("\x2\x2\x10AC\x10AE\a\x3DF\x2\x2\x10AD\x10A7\x3\x2\x2\x2\x10AD");
		sb.Append("\x10A8\x3\x2\x2\x2\x10AE\x173\x3\x2\x2\x2\x10AF\x10B0\a&\x2");
		sb.Append("\x2\x10B0\x10B1\x5\x206\x104\x2\x10B1\x10B2\a#\x2\x2\x10B2\x10B3");
		sb.Append("\a:\x2\x2\x10B3\x10B4\x5\xB4[\x2\x10B4\x175\x3\x2\x2\x2\x10B5");
		sb.Append("\x10B6\a&\x2\x2\x10B6\x10B7\t;\x2\x2\x10B7\x10B8\a\x165\x2\x2");
		sb.Append("\x10B8\x10B9\a:\x2\x2\x10B9\x10BE\x5\x178\xBD\x2\x10BA\x10BB");
		sb.Append("\a\x3D2\x2\x2\x10BB\x10BD\x5\x178\xBD\x2\x10BC\x10BA\x3\x2\x2");
		sb.Append("\x2\x10BD\x10C0\x3\x2\x2\x2\x10BE\x10BC\x3\x2\x2\x2\x10BE\x10BF");
		sb.Append("\x3\x2\x2\x2\x10BF\x10C1\x3\x2\x2\x2\x10C0\x10BE\x3\x2\x2\x2");
		sb.Append("\x10C1\x10C2\x5\x15A\xAE\x2\x10C2\x177\x3\x2\x2\x2\x10C3\x10CF");
		sb.Append("\x5\x20C\x107\x2\x10C4\x10C6\a\x8E\x2\x2\x10C5\x10C7\a\x22D");
		sb.Append("\x2\x2\x10C6\x10C5\x3\x2\x2\x2\x10C6\x10C7\x3\x2\x2\x2\x10C7");
		sb.Append("\x10C8\x3\x2\x2\x2\x10C8\x10CF\a\x3DF\x2\x2\x10C9\x10CF\x5\x206");
		sb.Append("\x104\x2\x10CA\x10CF\a\x8F\x2\x2\x10CB\x10CC\a\x65\x2\x2\x10CC");
		sb.Append("\x10CF\a\x15E\x2\x2\x10CD\x10CF\a\x8D\x2\x2\x10CE\x10C3\x3\x2");
		sb.Append("\x2\x2\x10CE\x10C4\x3\x2\x2\x2\x10CE\x10C9\x3\x2\x2\x2\x10CE");
		sb.Append("\x10CA\x3\x2\x2\x2\x10CE\x10CB\x3\x2\x2\x2\x10CE\x10CD\x3\x2");
		sb.Append("\x2\x2\x10CF\x179\x3\x2\x2\x2\x10D0\x10D3\x5\x14\v\x2\x10D1");
		sb.Append("\x10D3\x5\x6\x4\x2\x10D2\x10D0\x3\x2\x2\x2\x10D2\x10D1\x3\x2");
		sb.Append("\x2\x2\x10D3\x10D4\x3\x2\x2\x2\x10D4\x10D5\a\x3D3\x2\x2\x10D5");
		sb.Append("\x17B\x3\x2\x2\x2\x10D6\x10D9\a\xA7\x2\x2\x10D7\x10DA\x5\x218");
		sb.Append("\x10D\x2\x10D8\x10DA\x5\x254\x12B\x2\x10D9\x10D7\x3\x2\x2\x2");
		sb.Append("\x10D9\x10D8\x3\x2\x2\x2\x10DA\x10DB\x3\x2\x2\x2\x10DB\x10DD");
		sb.Append("\a\x98\x2\x2\x10DC\x10DE\x5\x17A\xBE\x2\x10DD\x10DC\x3\x2\x2");
		sb.Append("\x2\x10DE\x10DF\x3\x2\x2\x2\x10DF\x10DD\x3\x2\x2\x2\x10DF\x10E0");
		sb.Append("\x3\x2\x2\x2\x10E0\x17D\x3\x2\x2\x2\x10E1\x10E2\a\x32\x2\x2");
		sb.Append("\x10E2\x10E3\x5\x254\x12B\x2\x10E3\x10E5\a\x98\x2\x2\x10E4\x10E6");
		sb.Append("\x5\x17A\xBE\x2\x10E5\x10E4\x3\x2\x2\x2\x10E6\x10E7\x3\x2\x2");
		sb.Append("\x2\x10E7\x10E5\x3\x2\x2\x2\x10E7\x10E8\x3\x2\x2\x2\x10E8\x17F");
		sb.Append("\x3\x2\x2\x2\x10E9\x10EA\a\t\x2\x2\x10EA\x10EB\a\x229\x2\x2");
		sb.Append("\x10EB\x10F0\x5\x192\xCA\x2\x10EC\x10ED\a\x3D2\x2\x2\x10ED\x10EF");
		sb.Append("\x5\x192\xCA\x2\x10EE\x10EC\x3\x2\x2\x2\x10EF\x10F2\x3\x2\x2");
		sb.Append("\x2\x10F0\x10EE\x3\x2\x2\x2\x10F0\x10F1\x3\x2\x2\x2\x10F1\x1120");
		sb.Append("\x3\x2\x2\x2\x10F2\x10F0\x3\x2\x2\x2\x10F3\x10F4\a\t\x2\x2\x10F4");
		sb.Append("\x10F6\a\x229\x2\x2\x10F5\x10F7\x5\x23C\x11F\x2\x10F6\x10F5");
		sb.Append("\x3\x2\x2\x2\x10F6\x10F7\x3\x2\x2\x2\x10F7\x10F8\x3\x2\x2\x2");
		sb.Append("\x10F8\x10FD\x5\x194\xCB\x2\x10F9\x10FA\a\x3D2\x2\x2\x10FA\x10FC");
		sb.Append("\x5\x194\xCB\x2\x10FB\x10F9\x3\x2\x2\x2\x10FC\x10FF\x3\x2\x2");
		sb.Append("\x2\x10FD\x10FB\x3\x2\x2\x2\x10FD\x10FE\x3\x2\x2\x2\x10FE\x110E");
		sb.Append("\x3\x2\x2\x2\x10FF\x10FD\x3\x2\x2\x2\x1100\x110C\a~\x2\x2\x1101");
		sb.Append("\x110D\a\x1B2\x2\x2\x1102\x1109\x5\x196\xCC\x2\x1103\x1105\a");
		sb.Append("\f\x2\x2\x1104\x1103\x3\x2\x2\x2\x1104\x1105\x3\x2\x2\x2\x1105");
		sb.Append("\x1106\x3\x2\x2\x2\x1106\x1108\x5\x196\xCC\x2\x1107\x1104\x3");
		sb.Append("\x2\x2\x2\x1108\x110B\x3\x2\x2\x2\x1109\x1107\x3\x2\x2\x2\x1109");
		sb.Append("\x110A\x3\x2\x2\x2\x110A\x110D\x3\x2\x2\x2\x110B\x1109\x3\x2");
		sb.Append("\x2\x2\x110C\x1101\x3\x2\x2\x2\x110C\x1102\x3\x2\x2\x2\x110D");
		sb.Append("\x110F\x3\x2\x2\x2\x110E\x1100\x3\x2\x2\x2\x110E\x110F\x3\x2");
		sb.Append("\x2\x2\x110F\x1116\x3\x2\x2\x2\x1110\x1112\a\xAA\x2\x2\x1111");
		sb.Append("\x1113\x5\x198\xCD\x2\x1112\x1111\x3\x2\x2\x2\x1113\x1114\x3");
		sb.Append("\x2\x2\x2\x1114\x1112\x3\x2\x2\x2\x1114\x1115\x3\x2\x2\x2\x1115");
		sb.Append("\x1117\x3\x2\x2\x2\x1116\x1110\x3\x2\x2\x2\x1116\x1117\x3\x2");
		sb.Append("\x2\x2\x1117\x111C\x3\x2\x2\x2\x1118\x111B\x5\x19A\xCE\x2\x1119");
		sb.Append("\x111B\x5\x19C\xCF\x2\x111A\x1118\x3\x2\x2\x2\x111A\x1119\x3");
		sb.Append("\x2\x2\x2\x111B\x111E\x3\x2\x2\x2\x111C\x111A\x3\x2\x2\x2\x111C");
		sb.Append("\x111D\x3\x2\x2\x2\x111D\x1120\x3\x2\x2\x2\x111E\x111C\x3\x2");
		sb.Append("\x2\x2\x111F\x10E9\x3\x2\x2\x2\x111F\x10F3\x3\x2\x2\x2\x1120");
		sb.Append("\x181\x3\x2\x2\x2\x1121\x1122\a \x2\x2\x1122\x1123\a\x229\x2");
		sb.Append("\x2\x1123\x1128\x5\x194\xCB\x2\x1124\x1125\a\x3D2\x2\x2\x1125");
		sb.Append("\x1127\x5\x194\xCB\x2\x1126\x1124\x3\x2\x2\x2\x1127\x112A\x3");
		sb.Append("\x2\x2\x2\x1128\x1126\x3\x2\x2\x2\x1128\x1129\x3\x2\x2\x2\x1129");
		sb.Append("\x1158\x3\x2\x2\x2\x112A\x1128\x3\x2\x2\x2\x112B\x112C\a \x2");
		sb.Append("\x2\x112C\x112E\a\x229\x2\x2\x112D\x112F\x5\x23E\x120\x2\x112E");
		sb.Append("\x112D\x3\x2\x2\x2\x112E\x112F\x3\x2\x2\x2\x112F\x1130\x3\x2");
		sb.Append("\x2\x2\x1130\x1135\x5\x194\xCB\x2\x1131\x1132\a\x3D2\x2\x2\x1132");
		sb.Append("\x1134\x5\x194\xCB\x2\x1133\x1131\x3\x2\x2\x2\x1134\x1137\x3");
		sb.Append("\x2\x2\x2\x1135\x1133\x3\x2\x2\x2\x1135\x1136\x3\x2\x2\x2\x1136");
		sb.Append("\x1146\x3\x2\x2\x2\x1137\x1135\x3\x2\x2\x2\x1138\x1144\a~\x2");
		sb.Append("\x2\x1139\x1145\a\x1B2\x2\x2\x113A\x1141\x5\x196\xCC\x2\x113B");
		sb.Append("\x113D\a\f\x2\x2\x113C\x113B\x3\x2\x2\x2\x113C\x113D\x3\x2\x2");
		sb.Append("\x2\x113D\x113E\x3\x2\x2\x2\x113E\x1140\x5\x196\xCC\x2\x113F");
		sb.Append("\x113C\x3\x2\x2\x2\x1140\x1143\x3\x2\x2\x2\x1141\x113F\x3\x2");
		sb.Append("\x2\x2\x1141\x1142\x3\x2\x2\x2\x1142\x1145\x3\x2\x2\x2\x1143");
		sb.Append("\x1141\x3\x2\x2\x2\x1144\x1139\x3\x2\x2\x2\x1144\x113A\x3\x2");
		sb.Append("\x2\x2\x1145\x1147\x3\x2\x2\x2\x1146\x1138\x3\x2\x2\x2\x1146");
		sb.Append("\x1147\x3\x2\x2\x2\x1147\x114E\x3\x2\x2\x2\x1148\x114A\a\xAA");
		sb.Append("\x2\x2\x1149\x114B\x5\x198\xCD\x2\x114A\x1149\x3\x2\x2\x2\x114B");
		sb.Append("\x114C\x3\x2\x2\x2\x114C\x114A\x3\x2\x2\x2\x114C\x114D\x3\x2");
		sb.Append("\x2\x2\x114D\x114F\x3\x2\x2\x2\x114E\x1148\x3\x2\x2\x2\x114E");
		sb.Append("\x114F\x3\x2\x2\x2\x114F\x1154\x3\x2\x2\x2\x1150\x1153\x5\x19A");
		sb.Append("\xCE\x2\x1151\x1153\x5\x19C\xCF\x2\x1152\x1150\x3\x2\x2\x2\x1152");
		sb.Append("\x1151\x3\x2\x2\x2\x1153\x1156\x3\x2\x2\x2\x1154\x1152\x3\x2");
		sb.Append("\x2\x2\x1154\x1155\x3\x2\x2\x2\x1155\x1158\x3\x2\x2\x2\x1156");
		sb.Append("\x1154\x3\x2\x2\x2\x1157\x1121\x3\x2\x2\x2\x1157\x112B\x3\x2");
		sb.Append("\x2\x2\x1158\x183\x3\x2\x2\x2\x1159\x115A\a/\x2\x2\x115A\x115C");
		sb.Append("\a\x229\x2\x2\x115B\x115D\x5\x23C\x11F\x2\x115C\x115B\x3\x2");
		sb.Append("\x2\x2\x115C\x115D\x3\x2\x2\x2\x115D\x115E\x3\x2\x2\x2\x115E");
		sb.Append("\x1163\x5\x1F4\xFB\x2\x115F\x1160\a\x3D2\x2\x2\x1160\x1162\x5");
		sb.Append("\x1F4\xFB\x2\x1161\x115F\x3\x2\x2\x2\x1162\x1165\x3\x2\x2\x2");
		sb.Append("\x1163\x1161\x3\x2\x2\x2\x1163\x1164\x3\x2\x2\x2\x1164\x185");
		sb.Append("\x3\x2\x2\x2\x1165\x1163\x3\x2\x2\x2\x1166\x1167\a@\x2\x2\x1167");
		sb.Append("\x116C\x5\x19E\xD0\x2\x1168\x1169\a\x3D2\x2\x2\x1169\x116B\x5");
		sb.Append("\x19E\xD0\x2\x116A\x1168\x3\x2\x2\x2\x116B\x116E\x3\x2\x2\x2");
		sb.Append("\x116C\x116A\x3\x2\x2\x2\x116C\x116D\x3\x2\x2\x2\x116D\x116F");
		sb.Append("\x3\x2\x2\x2\x116E\x116C\x3\x2\x2\x2\x116F\x1171\ah\x2\x2\x1170");
		sb.Append("\x1172\t<\x2\x2\x1171\x1170\x3\x2\x2\x2\x1171\x1172\x3\x2\x2");
		sb.Append("\x2\x1172\x1173\x3\x2\x2\x2\x1173\x1174\x5\x1A2\xD2\x2\x1174");
		sb.Append("\x1175\a\x99\x2\x2\x1175\x117A\x5\x194\xCB\x2\x1176\x1177\a");
		sb.Append("\x3D2\x2\x2\x1177\x1179\x5\x194\xCB\x2\x1178\x1176\x3\x2\x2");
		sb.Append("\x2\x1179\x117C\x3\x2\x2\x2\x117A\x1178\x3\x2\x2\x2\x117A\x117B");
		sb.Append("\x3\x2\x2\x2\x117B\x118B\x3\x2\x2\x2\x117C\x117A\x3\x2\x2\x2");
		sb.Append("\x117D\x1189\a~\x2\x2\x117E\x118A\a\x1B2\x2\x2\x117F\x1186\x5");
		sb.Append("\x196\xCC\x2\x1180\x1182\a\f\x2\x2\x1181\x1180\x3\x2\x2\x2\x1181");
		sb.Append("\x1182\x3\x2\x2\x2\x1182\x1183\x3\x2\x2\x2\x1183\x1185\x5\x196");
		sb.Append("\xCC\x2\x1184\x1181\x3\x2\x2\x2\x1185\x1188\x3\x2\x2\x2\x1186");
		sb.Append("\x1184\x3\x2\x2\x2\x1186\x1187\x3\x2\x2\x2\x1187\x118A\x3\x2");
		sb.Append("\x2\x2\x1188\x1186\x3\x2\x2\x2\x1189\x117E\x3\x2\x2\x2\x1189");
		sb.Append("\x117F\x3\x2\x2\x2\x118A\x118C\x3\x2\x2\x2\x118B\x117D\x3\x2");
		sb.Append("\x2\x2\x118B\x118C\x3\x2\x2\x2\x118C\x1196\x3\x2\x2\x2\x118D");
		sb.Append("\x1193\a\xAA\x2\x2\x118E\x118F\a@\x2\x2\x118F\x1192\aj\x2\x2");
		sb.Append("\x1190\x1192\x5\x198\xCD\x2\x1191\x118E\x3\x2\x2\x2\x1191\x1190");
		sb.Append("\x3\x2\x2\x2\x1192\x1195\x3\x2\x2\x2\x1193\x1191\x3\x2\x2\x2");
		sb.Append("\x1193\x1194\x3\x2\x2\x2\x1194\x1197\x3\x2\x2\x2\x1195\x1193");
		sb.Append("\x3\x2\x2\x2\x1196\x118D\x3\x2\x2\x2\x1196\x1197\x3\x2\x2\x2");
		sb.Append("\x1197\x187\x3\x2\x2\x2\x1198\x1199\a@\x2\x2\x1199\x119A\a\x1D1");
		sb.Append("\x2\x2\x119A\x119B\ah\x2\x2\x119B\x119C\x5\x1F4\xFB\x2\x119C");
		sb.Append("\x119D\a\x99\x2\x2\x119D\x11A2\x5\x1F4\xFB\x2\x119E\x119F\a");
		sb.Append("\x3D2\x2\x2\x119F\x11A1\x5\x1F4\xFB\x2\x11A0\x119E\x3\x2\x2");
		sb.Append("\x2\x11A1\x11A4\x3\x2\x2\x2\x11A2\x11A0\x3\x2\x2\x2\x11A2\x11A3");
		sb.Append("\x3\x2\x2\x2\x11A3\x11A8\x3\x2\x2\x2\x11A4\x11A2\x3\x2\x2\x2");
		sb.Append("\x11A5\x11A6\a\xAA\x2\x2\x11A6\x11A7\a@\x2\x2\x11A7\x11A9\a");
		sb.Append("j\x2\x2\x11A8\x11A5\x3\x2\x2\x2\x11A8\x11A9\x3\x2\x2\x2\x11A9");
		sb.Append("\x189\x3\x2\x2\x2\x11AA\x11AB\a{\x2\x2\x11AB\x11AC\a\x229\x2");
		sb.Append("\x2\x11AC\x11B1\x5\x1A4\xD3\x2\x11AD\x11AE\a\x3D2\x2\x2\x11AE");
		sb.Append("\x11B0\x5\x1A4\xD3\x2\x11AF\x11AD\x3\x2\x2\x2\x11B0\x11B3\x3");
		sb.Append("\x2\x2\x2\x11B1\x11AF\x3\x2\x2\x2\x11B1\x11B2\x3\x2\x2\x2\x11B2");
		sb.Append("\x18B\x3\x2\x2\x2\x11B3\x11B1\x3\x2\x2\x2\x11B4\x11B5\a\x81");
		sb.Append("\x2\x2\x11B5\x11BA\x5\x19E\xD0\x2\x11B6\x11B7\a\x3D2\x2\x2\x11B7");
		sb.Append("\x11B9\x5\x19E\xD0\x2\x11B8\x11B6\x3\x2\x2\x2\x11B9\x11BC\x3");
		sb.Append("\x2\x2\x2\x11BA\x11B8\x3\x2\x2\x2\x11BA\x11BB\x3\x2\x2\x2\x11BB");
		sb.Append("\x11BD\x3\x2\x2\x2\x11BC\x11BA\x3\x2\x2\x2\x11BD\x11BF\ah\x2");
		sb.Append("\x2\x11BE\x11C0\t<\x2\x2\x11BF\x11BE\x3\x2\x2\x2\x11BF\x11C0");
		sb.Append("\x3\x2\x2\x2\x11C0\x11C1\x3\x2\x2\x2\x11C1\x11C2\x5\x1A2\xD2");
		sb.Append("\x2\x11C2\x11C3\a=\x2\x2\x11C3\x11C8\x5\x1F4\xFB\x2\x11C4\x11C5");
		sb.Append("\a\x3D2\x2\x2\x11C5\x11C7\x5\x1F4\xFB\x2\x11C6\x11C4\x3\x2\x2");
		sb.Append("\x2\x11C7\x11CA\x3\x2\x2\x2\x11C8\x11C6\x3\x2\x2\x2\x11C8\x11C9");
		sb.Append("\x3\x2\x2\x2\x11C9\x11DD\x3\x2\x2\x2\x11CA\x11C8\x3\x2\x2\x2");
		sb.Append("\x11CB\x11CC\a\x81\x2\x2\x11CC\x11CE\a\b\x2\x2\x11CD\x11CF\a");
		sb.Append("\x24F\x2\x2\x11CE\x11CD\x3\x2\x2\x2\x11CE\x11CF\x3\x2\x2\x2");
		sb.Append("\x11CF\x11D0\x3\x2\x2\x2\x11D0\x11D1\a\x3D2\x2\x2\x11D1\x11D2");
		sb.Append("\a@\x2\x2\x11D2\x11D3\aj\x2\x2\x11D3\x11D4\a=\x2\x2\x11D4\x11D9");
		sb.Append("\x5\x1F4\xFB\x2\x11D5\x11D6\a\x3D2\x2\x2\x11D6\x11D8\x5\x1F4");
		sb.Append("\xFB\x2\x11D7\x11D5\x3\x2\x2\x2\x11D8\x11DB\x3\x2\x2\x2\x11D9");
		sb.Append("\x11D7\x3\x2\x2\x2\x11D9\x11DA\x3\x2\x2\x2\x11DA\x11DD\x3\x2");
		sb.Append("\x2\x2\x11DB\x11D9\x3\x2\x2\x2\x11DC\x11B4\x3\x2\x2\x2\x11DC");
		sb.Append("\x11CB\x3\x2\x2\x2\x11DD\x18D\x3\x2\x2\x2\x11DE\x11DF\a\x81");
		sb.Append("\x2\x2\x11DF\x11E0\a\x1D1\x2\x2\x11E0\x11E1\ah\x2\x2\x11E1\x11E2");
		sb.Append("\x5\x1F4\xFB\x2\x11E2\x11E3\a=\x2\x2\x11E3\x11E8\x5\x1F4\xFB");
		sb.Append("\x2\x11E4\x11E5\a\x3D2\x2\x2\x11E5\x11E7\x5\x1F4\xFB\x2\x11E6");
		sb.Append("\x11E4\x3\x2\x2\x2\x11E7\x11EA\x3\x2\x2\x2\x11E8\x11E6\x3\x2");
		sb.Append("\x2\x2\x11E8\x11E9\x3\x2\x2\x2\x11E9\x18F\x3\x2\x2\x2\x11EA");
		sb.Append("\x11E8\x3\x2\x2\x2\x11EB\x11EC\a\x87\x2\x2\x11EC\x11EF\a\x1C4");
		sb.Append("\x2\x2\x11ED\x11EE\a:\x2\x2\x11EE\x11F0\x5\x1F4\xFB\x2\x11EF");
		sb.Append("\x11ED\x3\x2\x2\x2\x11EF\x11F0\x3\x2\x2\x2\x11F0\x11F1\x3\x2");
		sb.Append("\x2\x2\x11F1\x11F4\a\x3C7\x2\x2\x11F2\x11F5\x5\x24E\x128\x2");
		sb.Append("\x11F3\x11F5\a\x3DF\x2\x2\x11F4\x11F2\x3\x2\x2\x2\x11F4\x11F3");
		sb.Append("\x3\x2\x2\x2\x11F5\x191\x3\x2\x2\x2\x11F6\x11F7\x5\x1F4\xFB");
		sb.Append("\x2\x11F7\x11F8\x5\x19A\xCE\x2\x11F8\x193\x3\x2\x2\x2\x11F9");
		sb.Append("\x11FA\x5\x1F4\xFB\x2\x11FA\x11FB\a\x16A\x2\x2\x11FB\x11FC\a");
		sb.Append("\x12\x2\x2\x11FC\x11FD\a\x1C4\x2\x2\x11FD\x11FE\a\x3DF\x2\x2");
		sb.Append("\x11FE\x1212\x3\x2\x2\x2\x11FF\x1200\x5\x1F4\xFB\x2\x1200\x1203");
		sb.Append("\a\x16A\x2\x2\x1201\x1202\a\xAA\x2\x2\x1202\x1204\x5\x204\x103");
		sb.Append("\x2\x1203\x1201\x3\x2\x2\x2\x1203\x1204\x3\x2\x2\x2\x1204\x1205");
		sb.Append("\x3\x2\x2\x2\x1205\x1206\a\x12\x2\x2\x1206\x1207\a\x3DF\x2\x2");
		sb.Append("\x1207\x1212\x3\x2\x2\x2\x1208\x1209\x5\x1F4\xFB\x2\x1209\x120A");
		sb.Append("\a\x16A\x2\x2\x120A\x120B\a\xAA\x2\x2\x120B\x120E\x5\x204\x103");
		sb.Append("\x2\x120C\x120D\a\r\x2\x2\x120D\x120F\a\x3DF\x2\x2\x120E\x120C");
		sb.Append("\x3\x2\x2\x2\x120E\x120F\x3\x2\x2\x2\x120F\x1212\x3\x2\x2\x2");
		sb.Append("\x1210\x1212\x5\x1F4\xFB\x2\x1211\x11F9\x3\x2\x2\x2\x1211\x11FF");
		sb.Append("\x3\x2\x2\x2\x1211\x1208\x3\x2\x2\x2\x1211\x1210\x3\x2\x2\x2");
		sb.Append("\x1212\x195\x3\x2\x2\x2\x1213\x121C\a\x93\x2\x2\x1214\x121C");
		sb.Append("\a\x237\x2\x2\x1215\x1216\a\x119\x2\x2\x1216\x121C\a\x3DF\x2");
		sb.Append("\x2\x1217\x1218\a\x179\x2\x2\x1218\x121C\a\x3DF\x2\x2\x1219");
		sb.Append("\x121A\a\x213\x2\x2\x121A\x121C\a\x3DF\x2\x2\x121B\x1213\x3");
		sb.Append("\x2\x2\x2\x121B\x1214\x3\x2\x2\x2\x121B\x1215\x3\x2\x2\x2\x121B");
		sb.Append("\x1217\x3\x2\x2\x2\x121B\x1219\x3\x2\x2\x2\x121C\x197\x3\x2");
		sb.Append("\x2\x2\x121D\x121E\a\x19B\x2\x2\x121E\x1226\x5\x20C\x107\x2");
		sb.Append("\x121F\x1220\a\x19E\x2\x2\x1220\x1226\x5\x20C\x107\x2\x1221");
		sb.Append("\x1222\a\x19A\x2\x2\x1222\x1226\x5\x20C\x107\x2\x1223\x1224");
		sb.Append("\a\x19F\x2\x2\x1224\x1226\x5\x20C\x107\x2\x1225\x121D\x3\x2");
		sb.Append("\x2\x2\x1225\x121F\x3\x2\x2\x2\x1225\x1221\x3\x2\x2\x2\x1225");
		sb.Append("\x1223\x3\x2\x2\x2\x1226\x199\x3\x2\x2\x2\x1227\x1228\a\x1C4");
		sb.Append("\x2\x2\x1228\x122F\a\x151\x2\x2\x1229\x1230\a\'\x2\x2\x122A");
		sb.Append("\x1230\a\x1AE\x2\x2\x122B\x122C\aL\x2\x2\x122C\x122D\x5\x20C");
		sb.Append("\x107\x2\x122D\x122E\a\x241\x2\x2\x122E\x1230\x3\x2\x2\x2\x122F");
		sb.Append("\x1229\x3\x2\x2\x2\x122F\x122A\x3\x2\x2\x2\x122F\x122B\x3\x2");
		sb.Append("\x2\x2\x122F\x1230\x3\x2\x2\x2\x1230\x19B\x3\x2\x2\x2\x1231");
		sb.Append("\x1232\a\xFF\x2\x2\x1232\x1233\t=\x2\x2\x1233\x19D\x3\x2\x2");
		sb.Append("\x2\x1234\x1239\x5\x1A0\xD1\x2\x1235\x1236\a\x3D0\x2\x2\x1236");
		sb.Append("\x1237\x5\x226\x114\x2\x1237\x1238\a\x3D1\x2\x2\x1238\x123A");
		sb.Append("\x3\x2\x2\x2\x1239\x1235\x3\x2\x2\x2\x1239\x123A\x3\x2\x2\x2");
		sb.Append("\x123A\x19F\x3\x2\x2\x2\x123B\x123D\a\b\x2\x2\x123C\x123E\a");
		sb.Append("\x24F\x2\x2\x123D\x123C\x3\x2\x2\x2\x123D\x123E\x3\x2\x2\x2");
		sb.Append("\x123E\x1267\x3\x2\x2\x2\x123F\x1241\a\t\x2\x2\x1240\x1242\a");
		sb.Append("\x248\x2\x2\x1241\x1240\x3\x2\x2\x2\x1241\x1242\x3\x2\x2\x2");
		sb.Append("\x1242\x1267\x3\x2\x2\x2\x1243\x124A\a \x2\x2\x1244\x1245\a");
		sb.Append("\x21B\x2\x2\x1245\x124B\a\x247\x2\x2\x1246\x124B\a\x248\x2\x2");
		sb.Append("\x1247\x124B\a\x22F\x2\x2\x1248\x124B\a\x229\x2\x2\x1249\x124B");
		sb.Append("\a\x21A\x2\x2\x124A\x1244\x3\x2\x2\x2\x124A\x1246\x3\x2\x2\x2");
		sb.Append("\x124A\x1247\x3\x2\x2\x2\x124A\x1248\x3\x2\x2\x2\x124A\x1249");
		sb.Append("\x3\x2\x2\x2\x124A\x124B\x3\x2\x2\x2\x124B\x1267\x3\x2\x2\x2");
		sb.Append("\x124C\x1267\a)\x2\x2\x124D\x1267\a/\x2\x2\x124E\x1267\a\x14C");
		sb.Append("\x2\x2\x124F\x1267\a\x249\x2\x2\x1250\x1267\a\x24A\x2\x2\x1251");
		sb.Append("\x1252\a@\x2\x2\x1252\x1267\aj\x2\x2\x1253\x1267\aG\x2\x2\x1254");
		sb.Append("\x1267\aK\x2\x2\x1255\x1256\a\\\x2\x2\x1256\x1267\a\x247\x2");
		sb.Append("\x2\x1257\x1267\a\x24B\x2\x2\x1258\x1267\a\x1D1\x2\x2\x1259");
		sb.Append("\x1267\ax\x2\x2\x125A\x1267\a\x24C\x2\x2\x125B\x125C\a\x1E6");
		sb.Append("\x2\x2\x125C\x1267\t>\x2\x2\x125D\x1267\a\x86\x2\x2\x125E\x125F");
		sb.Append("\a\x89\x2\x2\x125F\x1267\t?\x2\x2\x1260\x1267\a\x24D\x2\x2\x1261");
		sb.Append("\x1267\a\x24E\x2\x2\x1262\x1267\a\x9B\x2\x2\x1263\x1267\a\xA2");
		sb.Append("\x2\x2\x1264\x1267\a\xA3\x2\x2\x1265\x1267\a\x250\x2\x2\x1266");
		sb.Append("\x123B\x3\x2\x2\x2\x1266\x123F\x3\x2\x2\x2\x1266\x1243\x3\x2");
		sb.Append("\x2\x2\x1266\x124C\x3\x2\x2\x2\x1266\x124D\x3\x2\x2\x2\x1266");
		sb.Append("\x124E\x3\x2\x2\x2\x1266\x124F\x3\x2\x2\x2\x1266\x1250\x3\x2");
		sb.Append("\x2\x2\x1266\x1251\x3\x2\x2\x2\x1266\x1253\x3\x2\x2\x2\x1266");
		sb.Append("\x1254\x3\x2\x2\x2\x1266\x1255\x3\x2\x2\x2\x1266\x1257\x3\x2");
		sb.Append("\x2\x2\x1266\x1258\x3\x2\x2\x2\x1266\x1259\x3\x2\x2\x2\x1266");
		sb.Append("\x125A\x3\x2\x2\x2\x1266\x125B\x3\x2\x2\x2\x1266\x125D\x3\x2");
		sb.Append("\x2\x2\x1266\x125E\x3\x2\x2\x2\x1266\x1260\x3\x2\x2\x2\x1266");
		sb.Append("\x1261\x3\x2\x2\x2\x1266\x1262\x3\x2\x2\x2\x1266\x1263\x3\x2");
		sb.Append("\x2\x2\x1266\x1264\x3\x2\x2\x2\x1266\x1265\x3\x2\x2\x2\x1267");
		sb.Append("\x1A1\x3\x2\x2\x2\x1268\x1279\a\x3BF\x2\x2\x1269\x126A\a\x3BF");
		sb.Append("\x2\x2\x126A\x126B\a\x3CF\x2\x2\x126B\x1279\a\x3BF\x2\x2\x126C");
		sb.Append("\x126D\x5\x206\x104\x2\x126D\x126E\a\x3CF\x2\x2\x126E\x126F");
		sb.Append("\a\x3BF\x2\x2\x126F\x1279\x3\x2\x2\x2\x1270\x1271\x5\x206\x104");
		sb.Append("\x2\x1271\x1272\a\x3CF\x2\x2\x1272\x1273\x5\x206\x104\x2\x1273");
		sb.Append("\x1279\x3\x2\x2\x2\x1274\x1275\x5\x206\x104\x2\x1275\x1276\x5");
		sb.Append("\x20A\x106\x2\x1276\x1279\x3\x2\x2\x2\x1277\x1279\x5\x206\x104");
		sb.Append("\x2\x1278\x1268\x3\x2\x2\x2\x1278\x1269\x3\x2\x2\x2\x1278\x126C");
		sb.Append("\x3\x2\x2\x2\x1278\x1270\x3\x2\x2\x2\x1278\x1274\x3\x2\x2\x2");
		sb.Append("\x1278\x1277\x3\x2\x2\x2\x1279\x1A3\x3\x2\x2\x2\x127A\x127B");
		sb.Append("\x5\x1F4\xFB\x2\x127B\x127C\a\x99\x2\x2\x127C\x127D\x5\x1F4");
		sb.Append("\xFB\x2\x127D\x1A5\x3\x2\x2\x2\x127E\x1280\a\v\x2\x2\x127F\x1281");
		sb.Append("\t@\x2\x2\x1280\x127F\x3\x2\x2\x2\x1280\x1281\x3\x2\x2\x2\x1281");
		sb.Append("\x1282\x3\x2\x2\x2\x1282\x1283\a\x96\x2\x2\x1283\x1284\x5\x228");
		sb.Append("\x115\x2\x1284\x1A7\x3\x2\x2\x2\x1285\x1286\a\x19\x2\x2\x1286");
		sb.Append("\x1287\a\x96\x2\x2\x1287\x128B\x5\x228\x115\x2\x1288\x128A\x5");
		sb.Append("\x1B0\xD9\x2\x1289\x1288\x3\x2\x2\x2\x128A\x128D\x3\x2\x2\x2");
		sb.Append("\x128B\x1289\x3\x2\x2\x2\x128B\x128C\x3\x2\x2\x2\x128C\x1A9");
		sb.Append("\x3\x2\x2\x2\x128D\x128B\x3\x2\x2\x2\x128E\x128F\a\x117\x2\x2");
		sb.Append("\x128F\x1290\a\x96\x2\x2\x1290\x1292\x5\x228\x115\x2\x1291\x1293");
		sb.Append("\t\x41\x2\x2\x1292\x1291\x3\x2\x2\x2\x1292\x1293\x3\x2\x2\x2");
		sb.Append("\x1293\x1AB\x3\x2\x2\x2\x1294\x1296\ai\x2\x2\x1295\x1297\t@");
		sb.Append("\x2\x2\x1296\x1295\x3\x2\x2\x2\x1296\x1297\x3\x2\x2\x2\x1297");
		sb.Append("\x1298\x3\x2\x2\x2\x1298\x1299\a\x96\x2\x2\x1299\x129A\x5\x228");
		sb.Append("\x115\x2\x129A\x1AD\x3\x2\x2\x2\x129B\x129D\a\x1DE\x2\x2\x129C");
		sb.Append("\x129E\t@\x2\x2\x129D\x129C\x3\x2\x2\x2\x129D\x129E\x3\x2\x2");
		sb.Append("\x2\x129E\x129F\x3\x2\x2\x2\x129F\x12A0\a\x96\x2\x2\x12A0\x12A2");
		sb.Append("\x5\x228\x115\x2\x12A1\x12A3\a\x1D3\x2\x2\x12A2\x12A1\x3\x2");
		sb.Append("\x2\x2\x12A2\x12A3\x3\x2\x2\x2\x12A3\x12A5\x3\x2\x2\x2\x12A4");
		sb.Append("\x12A6\a\x153\x2\x2\x12A5\x12A4\x3\x2\x2\x2\x12A5\x12A6\x3\x2");
		sb.Append("\x2\x2\x12A6\x12A8\x3\x2\x2\x2\x12A7\x12A9\a\x22A\x2\x2\x12A8");
		sb.Append("\x12A7\x3\x2\x2\x2\x12A8\x12A9\x3\x2\x2\x2\x12A9\x1AF\x3\x2");
		sb.Append("\x2\x2\x12AA\x12AB\a:\x2\x2\x12AB\x12B2\a\x228\x2\x2\x12AC\x12B2");
		sb.Append("\a\x1D3\x2\x2\x12AD\x12B2\a\x155\x2\x2\x12AE\x12B2\a\x1A0\x2");
		sb.Append("\x2\x12AF\x12B2\a\x153\x2\x2\x12B0\x12B2\a\x115\x2\x2\x12B1");
		sb.Append("\x12AA\x3\x2\x2\x2\x12B1\x12AC\x3\x2\x2\x2\x12B1\x12AD\x3\x2");
		sb.Append("\x2\x2\x12B1\x12AE\x3\x2\x2\x2\x12B1\x12AF\x3\x2\x2\x2\x12B1");
		sb.Append("\x12B0\x3\x2\x2\x2\x12B2\x1B1\x3\x2\x2\x2\x12B3\x12B5\a \x2");
		sb.Append("\x2\x12B4\x12B6\a\x102\x2\x2\x12B5\x12B4\x3\x2\x2\x2\x12B5\x12B6");
		sb.Append("\x3\x2\x2\x2\x12B6\x12B7\x3\x2\x2\x2\x12B7\x12B8\a\x160\x2\x2");
		sb.Append("\x12B8\x12B9\x5\x206\x104\x2\x12B9\x12BA\a\x1E9\x2\x2\x12BA");
		sb.Append("\x12BB\t\x42\x2\x2\x12BB\x12BC\a\x1FE\x2\x2\x12BC\x12BD\a\x3DF");
		sb.Append("\x2\x2\x12BD\x1B3\x3\x2\x2\x2\x12BE\x12BF\a\x171\x2\x2\x12BF");
		sb.Append("\x12C0\a\x1C6\x2\x2\x12C0\x12C1\x5\x206\x104\x2\x12C1\x12C2");
		sb.Append("\a\x1FE\x2\x2\x12C2\x12C3\a\x3DF\x2\x2\x12C3\x1B5\x3\x2\x2\x2");
		sb.Append("\x12C4\x12C5\a\x225\x2\x2\x12C5\x12C6\a\x1C6\x2\x2\x12C6\x12C7");
		sb.Append("\x5\x206\x104\x2\x12C7\x1B7\x3\x2\x2\x2\x12C8\x12C9\a\x87\x2");
		sb.Append("\x2\x12C9\x12CA\x5\x1BC\xDF\x2\x12CA\x12CB\t\x43\x2\x2\x12CB");
		sb.Append("\x12D3\x5\x254\x12B\x2\x12CC\x12CD\a\x3D2\x2\x2\x12CD\x12CE");
		sb.Append("\x5\x1BC\xDF\x2\x12CE\x12CF\t\x43\x2\x2\x12CF\x12D0\x5\x254");
		sb.Append("\x12B\x2\x12D0\x12D2\x3\x2\x2\x2\x12D1\x12CC\x3\x2\x2\x2\x12D2");
		sb.Append("\x12D5\x3\x2\x2\x2\x12D3\x12D1\x3\x2\x2\x2\x12D3\x12D4\x3\x2");
		sb.Append("\x2\x2\x12D4\x12F3\x3\x2\x2\x2\x12D5\x12D3\x3\x2\x2\x2\x12D6");
		sb.Append("\x12DA\a\x87\x2\x2\x12D7\x12D8\a\x18\x2\x2\x12D8\x12DB\a\x87");
		sb.Append("\x2\x2\x12D9\x12DB\a\x2AF\x2\x2\x12DA\x12D7\x3\x2\x2\x2\x12DA");
		sb.Append("\x12D9\x3\x2\x2\x2\x12DB\x12DE\x3\x2\x2\x2\x12DC\x12DF\x5\x1F8");
		sb.Append("\xFD\x2\x12DD\x12DF\a\'\x2\x2\x12DE\x12DC\x3\x2\x2\x2\x12DE");
		sb.Append("\x12DD\x3\x2\x2\x2\x12DF\x12F3\x3\x2\x2\x2\x12E0\x12E1\a\x87");
		sb.Append("\x2\x2\x12E1\x12E8\a\x1AC\x2\x2\x12E2\x12E5\x5\x1F8\xFD\x2\x12E3");
		sb.Append("\x12E4\a\x1A\x2\x2\x12E4\x12E6\x5\x1FA\xFE\x2\x12E5\x12E3\x3");
		sb.Append("\x2\x2\x2\x12E5\x12E6\x3\x2\x2\x2\x12E6\x12E9\x3\x2\x2\x2\x12E7");
		sb.Append("\x12E9\a\'\x2\x2\x12E8\x12E2\x3\x2\x2\x2\x12E8\x12E7\x3\x2\x2");
		sb.Append("\x2\x12E9\x12F3\x3\x2\x2\x2\x12EA\x12F3\x5\x190\xC9\x2\x12EB");
		sb.Append("\x12F3\x5\x114\x8B\x2\x12EC\x12F3\x5\x112\x8A\x2\x12ED\x12EE");
		sb.Append("\a\x87\x2\x2\x12EE\x12EF\x5\x1EC\xF7\x2\x12EF\x12F0\t\x43\x2");
		sb.Append("\x2\x12F0\x12F1\x5\x254\x12B\x2\x12F1\x12F3\x3\x2\x2\x2\x12F2");
		sb.Append("\x12C8\x3\x2\x2\x2\x12F2\x12D6\x3\x2\x2\x2\x12F2\x12E0\x3\x2");
		sb.Append("\x2\x2\x12F2\x12EA\x3\x2\x2\x2\x12F2\x12EB\x3\x2\x2\x2\x12F2");
		sb.Append("\x12EC\x3\x2\x2\x2\x12F2\x12ED\x3\x2\x2\x2\x12F3\x1B9\x3\x2");
		sb.Append("\x2\x2\x12F4\x12F5\a\x89\x2\x2\x12F5\x12F6\t\x32\x2\x2\x12F6");
		sb.Append("\x138C\a\x184\x2\x2\x12F7\x12F8\a\x89\x2\x2\x12F8\x12F9\t\x44");
		sb.Append("\x2\x2\x12F9\x12FC\a\x14D\x2\x2\x12FA\x12FB\a\x46\x2\x2\x12FB");
		sb.Append("\x12FD\a\x3DF\x2\x2\x12FC\x12FA\x3\x2\x2\x2\x12FC\x12FD\x3\x2");
		sb.Append("\x2\x2\x12FD\x1300\x3\x2\x2\x2\x12FE\x12FF\a=\x2\x2\x12FF\x1301");
		sb.Append("\x5\x20C\x107\x2\x1300\x12FE\x3\x2\x2\x2\x1300\x1301\x3\x2\x2");
		sb.Append("\x2\x1301\x1309\x3\x2\x2\x2\x1302\x1306\aX\x2\x2\x1303\x1304");
		sb.Append("\x5\x20C\x107\x2\x1304\x1305\a\x3D2\x2\x2\x1305\x1307\x3\x2");
		sb.Append("\x2\x2\x1306\x1303\x3\x2\x2\x2\x1306\x1307\x3\x2\x2\x2\x1307");
		sb.Append("\x1308\x3\x2\x2\x2\x1308\x130A\x5\x20C\x107\x2\x1309\x1302\x3");
		sb.Append("\x2\x2\x2\x1309\x130A\x3\x2\x2\x2\x130A\x138C\x3\x2\x2\x2\x130B");
		sb.Append("\x130C\a\x89\x2\x2\x130C\x130E\x5\x1BE\xE0\x2\x130D\x130F\x5");
		sb.Append("\x1C0\xE1\x2\x130E\x130D\x3\x2\x2\x2\x130E\x130F\x3\x2\x2\x2");
		sb.Append("\x130F\x138C\x3\x2\x2\x2\x1310\x1312\a\x89\x2\x2\x1311\x1313");
		sb.Append("\a\x15F\x2\x2\x1312\x1311\x3\x2\x2\x2\x1312\x1313\x3\x2\x2\x2");
		sb.Append("\x1313\x1314\x3\x2\x2\x2\x1314\x1315\t$\x2\x2\x1315\x1316\t");
		sb.Append("\x45\x2\x2\x1316\x1319\x5\x1EE\xF8\x2\x1317\x1318\t\x45\x2\x2");
		sb.Append("\x1318\x131A\x5\x206\x104\x2\x1319\x1317\x3\x2\x2\x2\x1319\x131A");
		sb.Append("\x3\x2\x2\x2\x131A\x131C\x3\x2\x2\x2\x131B\x131D\x5\x1C0\xE1");
		sb.Append("\x2\x131C\x131B\x3\x2\x2\x2\x131C\x131D\x3\x2\x2\x2\x131D\x138C");
		sb.Append("\x3\x2\x2\x2\x131E\x131F\a\x89\x2\x2\x131F\x1320\a \x2\x2\x1320");
		sb.Append("\x1322\t\x2\x2\x2\x1321\x1323\x5\x23E\x120\x2\x1322\x1321\x3");
		sb.Append("\x2\x2\x2\x1322\x1323\x3\x2\x2\x2\x1323\x1324\x3\x2\x2\x2\x1324");
		sb.Append("\x138C\x5\x206\x104\x2\x1325\x1326\a\x89\x2\x2\x1326\x1327\a");
		sb.Append(" \x2\x2\x1327\x1328\t\x46\x2\x2\x1328\x138C\x5\x1EC\xF7\x2\x1329");
		sb.Append("\x132A\a\x89\x2\x2\x132A\x132B\a \x2\x2\x132B\x132C\a\x229\x2");
		sb.Append("\x2\x132C\x138C\x5\x1F4\xFB\x2\x132D\x132E\a\x89\x2\x2\x132E");
		sb.Append("\x132F\a\x146\x2\x2\x132F\x1330\x5\x1FC\xFF\x2\x1330\x1331\t");
		sb.Append("G\x2\x2\x1331\x138C\x3\x2\x2\x2\x1332\x1333\a\x89\x2\x2\x1333");
		sb.Append("\x138C\x5\x1C2\xE2\x2\x1334\x1335\a\x89\x2\x2\x1335\x1336\t");
		sb.Append("H\x2\x2\x1336\x133A\aX\x2\x2\x1337\x1338\x5\x20C\x107\x2\x1338");
		sb.Append("\x1339\a\x3D2\x2\x2\x1339\x133B\x3\x2\x2\x2\x133A\x1337\x3\x2");
		sb.Append("\x2\x2\x133A\x133B\x3\x2\x2\x2\x133B\x133C\x3\x2\x2\x2\x133C");
		sb.Append("\x138C\x5\x20C\x107\x2\x133D\x133E\a\x89\x2\x2\x133E\x133F\a");
		sb.Append("\xE0\x2\x2\x133F\x1340\a\x3D0\x2\x2\x1340\x1341\a\x3BF\x2\x2");
		sb.Append("\x1341\x1342\a\x3D1\x2\x2\x1342\x138C\tH\x2\x2\x1343\x1344\a");
		sb.Append("\x89\x2\x2\x1344\x1347\x5\x1C4\xE3\x2\x1345\x1346\t\x45\x2\x2");
		sb.Append("\x1346\x1348\x5\x206\x104\x2\x1347\x1345\x3\x2\x2\x2\x1347\x1348");
		sb.Append("\x3\x2\x2\x2\x1348\x134A\x3\x2\x2\x2\x1349\x134B\x5\x1C0\xE1");
		sb.Append("\x2\x134A\x1349\x3\x2\x2\x2\x134A\x134B\x3\x2\x2\x2\x134B\x138C");
		sb.Append("\x3\x2\x2\x2\x134C\x134D\a\x89\x2\x2\x134D\x134E\tI\x2\x2\x134E");
		sb.Append("\x134F\a\x11E\x2\x2\x134F\x138C\x5\x1EC\xF7\x2\x1350\x1351\a");
		sb.Append("\x89\x2\x2\x1351\x1354\a\x163\x2\x2\x1352\x1353\a:\x2\x2\x1353");
		sb.Append("\x1355\x5\x1F4\xFB\x2\x1354\x1352\x3\x2\x2\x2\x1354\x1355\x3");
		sb.Append("\x2\x2\x2\x1355\x138C\x3\x2\x2\x2\x1356\x1357\a\x89\x2\x2\x1357");
		sb.Append("\x1358\tJ\x2\x2\x1358\x1359\t\x45\x2\x2\x1359\x135C\x5\x1EE");
		sb.Append("\xF8\x2\x135A\x135B\t\x45\x2\x2\x135B\x135D\x5\x206\x104\x2");
		sb.Append("\x135C\x135A\x3\x2\x2\x2\x135C\x135D\x3\x2\x2\x2\x135D\x1360");
		sb.Append("\x3\x2\x2\x2\x135E\x135F\a\xA8\x2\x2\x135F\x1361\x5\x254\x12B");
		sb.Append("\x2\x1360\x135E\x3\x2\x2\x2\x1360\x1361\x3\x2\x2\x2\x1361\x138C");
		sb.Append("\x3\x2\x2\x2\x1362\x1363\a\x89\x2\x2\x1363\x1364\a\x1BA\x2\x2");
		sb.Append("\x1364\x1367\a\x247\x2\x2\x1365\x1366\t\x45\x2\x2\x1366\x1368");
		sb.Append("\x5\x206\x104\x2\x1367\x1365\x3\x2\x2\x2\x1367\x1368\x3\x2\x2");
		sb.Append("\x2\x1368\x136A\x3\x2\x2\x2\x1369\x136B\x5\x1C0\xE1\x2\x136A");
		sb.Append("\x1369\x3\x2\x2\x2\x136A\x136B\x3\x2\x2\x2\x136B\x138C\x3\x2");
		sb.Append("\x2\x2\x136C\x136D\a\x89\x2\x2\x136D\x136E\a\x1CF\x2\x2\x136E");
		sb.Append("\x1373\x5\x1C6\xE4\x2\x136F\x1370\a\x3D2\x2\x2\x1370\x1372\x5");
		sb.Append("\x1C6\xE4\x2\x1371\x136F\x3\x2\x2\x2\x1372\x1375\x3\x2\x2\x2");
		sb.Append("\x1373\x1371\x3\x2\x2\x2\x1373\x1374\x3\x2\x2\x2\x1374\x1379");
		sb.Append("\x3\x2\x2\x2\x1375\x1373\x3\x2\x2\x2\x1376\x1377\a:\x2\x2\x1377");
		sb.Append("\x1378\a\x1D2\x2\x2\x1378\x137A\x5\x20C\x107\x2\x1379\x1376");
		sb.Append("\x3\x2\x2\x2\x1379\x137A\x3\x2\x2\x2\x137A\x137B\x3\x2\x2\x2");
		sb.Append("\x137B\x137F\aX\x2\x2\x137C\x137D\x5\x20C\x107\x2\x137D\x137E");
		sb.Append("\a\x3D2\x2\x2\x137E\x1380\x3\x2\x2\x2\x137F\x137C\x3\x2\x2\x2");
		sb.Append("\x137F\x1380\x3\x2\x2\x2\x1380\x1381\x3\x2\x2\x2\x1381\x1382");
		sb.Append("\x5\x20C\x107\x2\x1382\x138C\x3\x2\x2\x2\x1383\x1384\a\x89\x2");
		sb.Append("\x2\x1384\x1385\a\x1F9\x2\x2\x1385\x1389\a\x20D\x2\x2\x1386");
		sb.Append("\x1387\a:\x2\x2\x1387\x1388\a\x116\x2\x2\x1388\x138A\a\x3DF");
		sb.Append("\x2\x2\x1389\x1386\x3\x2\x2\x2\x1389\x138A\x3\x2\x2\x2\x138A");
		sb.Append("\x138C\x3\x2\x2\x2\x138B\x12F4\x3\x2\x2\x2\x138B\x12F7\x3\x2");
		sb.Append("\x2\x2\x138B\x130B\x3\x2\x2\x2\x138B\x1310\x3\x2\x2\x2\x138B");
		sb.Append("\x131E\x3\x2\x2\x2\x138B\x1325\x3\x2\x2\x2\x138B\x1329\x3\x2");
		sb.Append("\x2\x2\x138B\x132D\x3\x2\x2\x2\x138B\x1332\x3\x2\x2\x2\x138B");
		sb.Append("\x1334\x3\x2\x2\x2\x138B\x133D\x3\x2\x2\x2\x138B\x1343\x3\x2");
		sb.Append("\x2\x2\x138B\x134C\x3\x2\x2\x2\x138B\x1350\x3\x2\x2\x2\x138B");
		sb.Append("\x1356\x3\x2\x2\x2\x138B\x1362\x3\x2\x2\x2\x138B\x136C\x3\x2");
		sb.Append("\x2\x2\x138B\x1383\x3\x2\x2\x2\x138C\x1BB\x3\x2\x2\x2\x138D");
		sb.Append("\x1398\a\x3EA\x2\x2\x138E\x1398\a\x3EB\x2\x2\x138F\x1390\a\x3D4");
		sb.Append("\x2\x2\x1390\x1392\a\x3D4\x2\x2\x1391\x138F\x3\x2\x2\x2\x1391");
		sb.Append("\x1392\x3\x2\x2\x2\x1392\x1393\x3\x2\x2\x2\x1393\x1395\tK\x2");
		sb.Append("\x2\x1394\x1391\x3\x2\x2\x2\x1394\x1395\x3\x2\x2\x2\x1395\x1396");
		sb.Append("\x3\x2\x2\x2\x1396\x1398\x5\x206\x104\x2\x1397\x138D\x3\x2\x2");
		sb.Append("\x2\x1397\x138E\x3\x2\x2\x2\x1397\x1394\x3\x2\x2\x2\x1398\x1BD");
		sb.Append("\x3\x2\x2\x2\x1399\x139A\a\x18\x2\x2\x139A\x13A7\a\x87\x2\x2");
		sb.Append("\x139B\x13A7\a\x2B2\x2\x2\x139C\x13A7\a%\x2\x2\x139D\x13A7\a");
		sb.Append("\x85\x2\x2\x139E\x139F\a\x160\x2\x2\x139F\x13A7\a\x20D\x2\x2");
		sb.Append("\x13A0\x13A1\as\x2\x2\x13A1\x13A7\a\x20D\x2\x2\x13A2\x13A4\t");
		sb.Append("\x31\x2\x2\x13A3\x13A2\x3\x2\x2\x2\x13A3\x13A4\x3\x2\x2\x2\x13A4");
		sb.Append("\x13A5\x3\x2\x2\x2\x13A5\x13A7\tL\x2\x2\x13A6\x1399\x3\x2\x2");
		sb.Append("\x2\x13A6\x139B\x3\x2\x2\x2\x13A6\x139C\x3\x2\x2\x2\x13A6\x139D");
		sb.Append("\x3\x2\x2\x2\x13A6\x139E\x3\x2\x2\x2\x13A6\x13A0\x3\x2\x2\x2");
		sb.Append("\x13A6\x13A3\x3\x2\x2\x2\x13A7\x1BF\x3\x2\x2\x2\x13A8\x13A9");
		sb.Append("\aW\x2\x2\x13A9\x13AD\a\x3DF\x2\x2\x13AA\x13AB\a\xA8\x2\x2\x13AB");
		sb.Append("\x13AD\x5\x254\x12B\x2\x13AC\x13A8\x3\x2\x2\x2\x13AC\x13AA\x3");
		sb.Append("\x2\x2\x2\x13AD\x1C1\x3\x2\x2\x2\x13AE\x13B0\a\x20F\x2\x2\x13AF");
		sb.Append("\x13AE\x3\x2\x2\x2\x13AF\x13B0\x3\x2\x2\x2\x13B0\x13B1\x3\x2");
		sb.Append("\x2\x2\x13B1\x13C0\a\x147\x2\x2\x13B2\x13B3\a\x185\x2\x2\x13B3");
		sb.Append("\x13C0\a\x20D\x2\x2\x13B4\x13C0\a\x1C8\x2\x2\x13B5\x13C0\a\x24F");
		sb.Append("\x2\x2\x13B6\x13B8\a\x15F\x2\x2\x13B7\x13B6\x3\x2\x2\x2\x13B7");
		sb.Append("\x13B8\x3\x2\x2\x2\x13B8\x13B9\x3\x2\x2\x2\x13B9\x13C0\a\x1CE");
		sb.Append("\x2\x2\x13BA\x13C0\a\x1D0\x2\x2\x13BB\x13BC\a\x1F9\x2\x2\x13BC");
		sb.Append("\x13C0\a\x169\x2\x2\x13BD\x13C0\a\x106\x2\x2\x13BE\x13C0\a\x130");
		sb.Append("\x2\x2\x13BF\x13AF\x3\x2\x2\x2\x13BF\x13B2\x3\x2\x2\x2\x13BF");
		sb.Append("\x13B4\x3\x2\x2\x2\x13BF\x13B5\x3\x2\x2\x2\x13BF\x13B7\x3\x2");
		sb.Append("\x2\x2\x13BF\x13BA\x3\x2\x2\x2\x13BF\x13BB\x3\x2\x2\x2\x13BF");
		sb.Append("\x13BD\x3\x2\x2\x2\x13BF\x13BE\x3\x2\x2\x2\x13C0\x1C3\x3\x2");
		sb.Append("\x2\x2\x13C1\x13CA\a\x14D\x2\x2\x13C2\x13C3\a\x96\x2\x2\x13C3");
		sb.Append("\x13CA\a\x20D\x2\x2\x13C4\x13C6\a\x15F\x2\x2\x13C5\x13C4\x3");
		sb.Append("\x2\x2\x2\x13C5\x13C6\x3\x2\x2\x2\x13C6\x13C7\x3\x2\x2\x2\x13C7");
		sb.Append("\x13CA\a\x247\x2\x2\x13C8\x13CA\a\x220\x2\x2\x13C9\x13C1\x3");
		sb.Append("\x2\x2\x2\x13C9\x13C2\x3\x2\x2\x2\x13C9\x13C5\x3\x2\x2\x2\x13C9");
		sb.Append("\x13C8\x3\x2\x2\x2\x13CA\x1C5\x3\x2\x2\x2\x13CB\x13D8\a\b\x2");
		sb.Append("\x2\x13CC\x13CD\a\x10E\x2\x2\x13CD\x13D8\a\x175\x2\x2\x13CE");
		sb.Append("\x13CF\a\x12F\x2\x2\x13CF\x13D8\a\x218\x2\x2\x13D0\x13D8\a\x132");
		sb.Append("\x2\x2\x13D1\x13D8\a\x177\x2\x2\x13D2\x13D8\a\x27E\x2\x2\x13D3");
		sb.Append("\x13D4\a\x1BF\x2\x2\x13D4\x13D8\a\x156\x2\x2\x13D5\x13D8\a\x200");
		sb.Append("\x2\x2\x13D6\x13D8\a\x217\x2\x2\x13D7\x13CB\x3\x2\x2\x2\x13D7");
		sb.Append("\x13CC\x3\x2\x2\x2\x13D7\x13CE\x3\x2\x2\x2\x13D7\x13D0\x3\x2");
		sb.Append("\x2\x2\x13D7\x13D1\x3\x2\x2\x2\x13D7\x13D2\x3\x2\x2\x2\x13D7");
		sb.Append("\x13D3\x3\x2\x2\x2\x13D7\x13D5\x3\x2\x2\x2\x13D7\x13D6\x3\x2");
		sb.Append("\x2\x2\x13D8\x1C7\x3\x2\x2\x2\x13D9\x13DA\a\x10C\x2\x2\x13DA");
		sb.Append("\x13DB\a\x3DF\x2\x2\x13DB\x1C9\x3\x2\x2\x2\x13DC\x13DD\a\x112");
		sb.Append("\x2\x2\x13DD\x13DE\aG\x2\x2\x13DE\x13E3\x5\x1D6\xEC\x2\x13DF");
		sb.Append("\x13E0\a\x3D2\x2\x2\x13E0\x13E2\x5\x1D6\xEC\x2\x13E1\x13DF\x3");
		sb.Append("\x2\x2\x2\x13E2\x13E5\x3\x2\x2\x2\x13E3\x13E1\x3\x2\x2\x2\x13E3");
		sb.Append("\x13E4\x3\x2\x2\x2\x13E4\x13ED\x3\x2\x2\x2\x13E5\x13E3\x3\x2");
		sb.Append("\x2\x2\x13E6\x13E7\aq\x2\x2\x13E7\x13EA\a\x3D0\x2\x2\x13E8\x13EB");
		sb.Append("\x5\x226\x114\x2\x13E9\x13EB\a\b\x2\x2\x13EA\x13E8\x3\x2\x2");
		sb.Append("\x2\x13EA\x13E9\x3\x2\x2\x2\x13EB\x13EC\x3\x2\x2\x2\x13EC\x13EE");
		sb.Append("\a\x3D1\x2\x2\x13ED\x13E6\x3\x2\x2\x2\x13ED\x13EE\x3\x2\x2\x2");
		sb.Append("\x13EE\x13EF\x3\x2\x2\x2\x13EF\x13F0\a\x46\x2\x2\x13F0\x13F1");
		sb.Append("\x5\x206\x104\x2\x13F1\x1CB\x3\x2\x2\x2\x13F2\x13F4\a\x15C\x2");
		sb.Append("\x2\x13F3\x13F5\t@\x2\x2\x13F4\x13F3\x3\x2\x2\x2\x13F4\x13F5");
		sb.Append("\x3\x2\x2\x2\x13F5\x13F6\x3\x2\x2\x2\x13F6\x13FB\x5\x1D8\xED");
		sb.Append("\x2\x13F7\x13F8\a\x3D2\x2\x2\x13F8\x13FA\x5\x1D8\xED\x2\x13F9");
		sb.Append("\x13F7\x3\x2\x2\x2\x13FA\x13FD\x3\x2\x2\x2\x13FB\x13F9\x3\x2");
		sb.Append("\x2\x2\x13FB\x13FC\x3\x2\x2\x2\x13FC\x1CD\x3\x2\x2\x2\x13FD");
		sb.Append("\x13FB\x3\x2\x2\x2\x13FE\x1400\aS\x2\x2\x13FF\x1401\tM\x2\x2");
		sb.Append("\x1400\x13FF\x3\x2\x2\x2\x1400\x1401\x3\x2\x2\x2\x1401\x1403");
		sb.Append("\x3\x2\x2\x2\x1402\x1404\x5\x20C\x107\x2\x1403\x1402\x3\x2\x2");
		sb.Append("\x2\x1404\x1405\x3\x2\x2\x2\x1405\x1403\x3\x2\x2\x2\x1405\x1406");
		sb.Append("\x3\x2\x2\x2\x1406\x1CF\x3\x2\x2\x2\x1407\x1408\a[\x2\x2\x1408");
		sb.Append("\x1409\aG\x2\x2\x1409\x140A\aM\x2\x2\x140A\x140B\a\x112\x2\x2");
		sb.Append("\x140B\x1410\x5\x1DC\xEF\x2\x140C\x140D\a\x3D2\x2\x2\x140D\x140F");
		sb.Append("\x5\x1DC\xEF\x2\x140E\x140C\x3\x2\x2\x2\x140F\x1412\x3\x2\x2");
		sb.Append("\x2\x1410\x140E\x3\x2\x2\x2\x1410\x1411\x3\x2\x2\x2\x1411\x1D1");
		sb.Append("\x3\x2\x2\x2\x1412\x1410\x3\x2\x2\x2\x1413\x1414\a\x1E7\x2\x2");
		sb.Append("\x1414\x1415\a\x1D2\x2\x2\x1415\x1416\a\x112\x2\x2\x1416\x1D3");
		sb.Append("\x3\x2\x2\x2\x1417\x1418\a\x24D\x2\x2\x1418\x1D5\x3\x2\x2\x2");
		sb.Append("\x1419\x1421\x5\x1EE\xF8\x2\x141A\x141C\t\x14\x2\x2\x141B\x141A");
		sb.Append("\x3\x2\x2\x2\x141B\x141C\x3\x2\x2\x2\x141C\x141D\x3\x2\x2\x2");
		sb.Append("\x141D\x141E\a\x3D0\x2\x2\x141E\x141F\x5\x226\x114\x2\x141F");
		sb.Append("\x1420\a\x3D1\x2\x2\x1420\x1422\x3\x2\x2\x2\x1421\x141B\x3\x2");
		sb.Append("\x2\x2\x1421\x1422\x3\x2\x2\x2\x1422\x1D7\x3\x2\x2\x2\x1423");
		sb.Append("\x1436\a\x139\x2\x2\x1424\x1436\a\x169\x2\x2\x1425\x1427\tN");
		sb.Append("\x2\x2\x1426\x1425\x3\x2\x2\x2\x1426\x1427\x3\x2\x2\x2\x1427");
		sb.Append("\x1428\x3\x2\x2\x2\x1428\x1436\a\x184\x2\x2\x1429\x1436\a\x1BB");
		sb.Append("\x2\x2\x142A\x1436\a\x24F\x2\x2\x142B\x142C\a\x1D2\x2\x2\x142C");
		sb.Append("\x1436\a\x112\x2\x2\x142D\x1436\a\x20D\x2\x2\x142E\x1436\a\x22B");
		sb.Append("\x2\x2\x142F\x1433\a\x247\x2\x2\x1430\x1431\a\xAA\x2\x2\x1431");
		sb.Append("\x1432\av\x2\x2\x1432\x1434\a\\\x2\x2\x1433\x1430\x3\x2\x2\x2");
		sb.Append("\x1433\x1434\x3\x2\x2\x2\x1434\x1436\x3\x2\x2\x2\x1435\x1423");
		sb.Append("\x3\x2\x2\x2\x1435\x1424\x3\x2\x2\x2\x1435\x1426\x3\x2\x2\x2");
		sb.Append("\x1435\x1429\x3\x2\x2\x2\x1435\x142A\x3\x2\x2\x2\x1435\x142B");
		sb.Append("\x3\x2\x2\x2\x1435\x142D\x3\x2\x2\x2\x1435\x142E\x3\x2\x2\x2");
		sb.Append("\x1435\x142F\x3\x2\x2\x2\x1436\x1442\x3\x2\x2\x2\x1437\x1438");
		sb.Append("\a\x1D8\x2\x2\x1438\x143A\a\x184\x2\x2\x1439\x143B\x5\x13A\x9E");
		sb.Append("\x2\x143A\x1439\x3\x2\x2\x2\x143A\x143B\x3\x2\x2\x2\x143B\x1442");
		sb.Append("\x3\x2\x2\x2\x143C\x143D\a\x247\x2\x2\x143D\x143F\x5\x228\x115");
		sb.Append("\x2\x143E\x1440\x5\x1DA\xEE\x2\x143F\x143E\x3\x2\x2\x2\x143F");
		sb.Append("\x1440\x3\x2\x2\x2\x1440\x1442\x3\x2\x2\x2\x1441\x1435\x3\x2");
		sb.Append("\x2\x2\x1441\x1437\x3\x2\x2\x2\x1441\x143C\x3\x2\x2\x2\x1442");
		sb.Append("\x1D9\x3\x2\x2\x2\x1443\x1444\a\xAA\x2\x2\x1444\x1445\av\x2");
		sb.Append("\x2\x1445\x1449\a\\\x2\x2\x1446\x1447\a:\x2\x2\x1447\x1449\a");
		sb.Append("\x152\x2\x2\x1448\x1443\x3\x2\x2\x2\x1448\x1446\x3\x2\x2\x2");
		sb.Append("\x1449\x1DB\x3\x2\x2\x2\x144A\x1452\x5\x1EE\xF8\x2\x144B\x144C");
		sb.Append("\aq\x2\x2\x144C\x144F\a\x3D0\x2\x2\x144D\x1450\x5\x226\x114");
		sb.Append("\x2\x144E\x1450\a\b\x2\x2\x144F\x144D\x3\x2\x2\x2\x144F\x144E");
		sb.Append("\x3\x2\x2\x2\x1450\x1451\x3\x2\x2\x2\x1451\x1453\a\x3D1\x2\x2");
		sb.Append("\x1452\x144B\x3\x2\x2\x2\x1452\x1453\x3\x2\x2\x2\x1453\x145B");
		sb.Append("\x3\x2\x2\x2\x1454\x1456\t\x14\x2\x2\x1455\x1454\x3\x2\x2\x2");
		sb.Append("\x1455\x1456\x3\x2\x2\x2\x1456\x1457\x3\x2\x2\x2\x1457\x1458");
		sb.Append("\a\x3D0\x2\x2\x1458\x1459\x5\x226\x114\x2\x1459\x145A\a\x3D1");
		sb.Append("\x2\x2\x145A\x145C\x3\x2\x2\x2\x145B\x1455\x3\x2\x2\x2\x145B");
		sb.Append("\x145C\x3\x2\x2\x2\x145C\x145F\x3\x2\x2\x2\x145D\x145E\a\x45");
		sb.Append("\x2\x2\x145E\x1460\a\x17E\x2\x2\x145F\x145D\x3\x2\x2\x2\x145F");
		sb.Append("\x1460\x3\x2\x2\x2\x1460\x1DD\x3\x2\x2\x2\x1461\x1462\tO\x2");
		sb.Append("\x2\x1462\x1465\x5\x1EE\xF8\x2\x1463\x1466\x5\x206\x104\x2\x1464");
		sb.Append("\x1466\a\x3DF\x2\x2\x1465\x1463\x3\x2\x2\x2\x1465\x1464\x3\x2");
		sb.Append("\x2\x2\x1465\x1466\x3\x2\x2\x2\x1466\x1DF\x3\x2\x2\x2\x1467");
		sb.Append("\x146B\tO\x2\x2\x1468\x1469\tP\x2\x2\x1469\x146A\a\x3C7\x2\x2");
		sb.Append("\x146A\x146C\tQ\x2\x2\x146B\x1468\x3\x2\x2\x2\x146B\x146C\x3");
		sb.Append("\x2\x2\x2\x146C\x146D\x3\x2\x2\x2\x146D\x146E\x5\x1EA\xF6\x2");
		sb.Append("\x146E\x1E1\x3\x2\x2\x2\x146F\x1470\a\x167\x2\x2\x1470\x1471");
		sb.Append("\a\x3DF\x2\x2\x1471\x1E3\x3\x2\x2\x2\x1472\x1473\a\xA4\x2\x2");
		sb.Append("\x1473\x1474\x5\x206\x104\x2\x1474\x1E5\x3\x2\x2\x2\x1475\x147D");
		sb.Append("\a\x8A\x2\x2\x1476\x1478\a\x8E\x2\x2\x1477\x1479\a\x22D\x2\x2");
		sb.Append("\x1478\x1477\x3\x2\x2\x2\x1478\x1479\x3\x2\x2\x2\x1479\x147A");
		sb.Append("\x3\x2\x2\x2\x147A\x147E\x5\x210\x109\x2\x147B\x147E\a\x3E7");
		sb.Append("\x2\x2\x147C\x147E\a\x3E8\x2\x2\x147D\x1476\x3\x2\x2\x2\x147D");
		sb.Append("\x147B\x3\x2\x2\x2\x147D\x147C\x3\x2\x2\x2\x147E\x1488\x3\x2");
		sb.Append("\x2\x2\x147F\x1480\a\x87\x2\x2\x1480\x1485\x5\x1E8\xF5\x2\x1481");
		sb.Append("\x1482\a\x3D2\x2\x2\x1482\x1484\x5\x1E8\xF5\x2\x1483\x1481\x3");
		sb.Append("\x2\x2\x2\x1484\x1487\x3\x2\x2\x2\x1485\x1483\x3\x2\x2\x2\x1485");
		sb.Append("\x1486\x3\x2\x2\x2\x1486\x1489\x3\x2\x2\x2\x1487\x1485\x3\x2");
		sb.Append("\x2\x2\x1488\x147F\x3\x2\x2\x2\x1488\x1489\x3\x2\x2\x2\x1489");
		sb.Append("\x1E7\x3\x2\x2\x2\x148A\x148B\tR\x2\x2\x148B\x148E\a\x3C7\x2");
		sb.Append("\x2\x148C\x148F\x5\x210\x109\x2\x148D\x148F\a\x3E0\x2\x2\x148E");
		sb.Append("\x148C\x3\x2\x2\x2\x148E\x148D\x3\x2\x2\x2\x148F\x1E9\x3\x2");
		sb.Append("\x2\x2\x1490\x1496\x5\xB4[\x2\x1491\x1496\x5\xA6T\x2\x1492\x1496");
		sb.Append("\x5\xACW\x2\x1493\x1496\x5\xB2Z\x2\x1494\x1496\x5\xB6\\\x2\x1495");
		sb.Append("\x1490\x3\x2\x2\x2\x1495\x1491\x3\x2\x2\x2\x1495\x1492\x3\x2");
		sb.Append("\x2\x2\x1495\x1493\x3\x2\x2\x2\x1495\x1494\x3\x2\x2\x2\x1496");
		sb.Append("\x149B\x3\x2\x2\x2\x1497\x1498\a:\x2\x2\x1498\x1499\a\x129\x2");
		sb.Append("\x2\x1499\x149B\x5\x206\x104\x2\x149A\x1495\x3\x2\x2\x2\x149A");
		sb.Append("\x1497\x3\x2\x2\x2\x149B\x1EB\x3\x2\x2\x2\x149C\x14A0\x5\x206");
		sb.Append("\x104\x2\x149D\x14A1\a\x3E6\x2\x2\x149E\x149F\a\x3CF\x2\x2\x149F");
		sb.Append("\x14A1\x5\x206\x104\x2\x14A0\x149D\x3\x2\x2\x2\x14A0\x149E\x3");
		sb.Append("\x2\x2\x2\x14A0\x14A1\x3\x2\x2\x2\x14A1\x1ED\x3\x2\x2\x2\x14A2");
		sb.Append("\x14A3\x5\x1EC\xF7\x2\x14A3\x1EF\x3\x2\x2\x2\x14A4\x14A9\x5");
		sb.Append("\x206\x104\x2\x14A5\x14A7\x5\x20A\x106\x2\x14A6\x14A8\x5\x20A");
		sb.Append("\x106\x2\x14A7\x14A6\x3\x2\x2\x2\x14A7\x14A8\x3\x2\x2\x2\x14A8");
		sb.Append("\x14AA\x3\x2\x2\x2\x14A9\x14A5\x3\x2\x2\x2\x14A9\x14AA\x3\x2");
		sb.Append("\x2\x2\x14AA\x1F1\x3\x2\x2\x2\x14AB\x14AE\x5\x206\x104\x2\x14AC");
		sb.Append("\x14AE\a\x3DF\x2\x2\x14AD\x14AB\x3\x2\x2\x2\x14AD\x14AC\x3\x2");
		sb.Append("\x2\x2\x14AE\x14B3\x3\x2\x2\x2\x14AF\x14B0\a\x3D0\x2\x2\x14B0");
		sb.Append("\x14B1\x5\x20C\x107\x2\x14B1\x14B2\a\x3D1\x2\x2\x14B2\x14B4");
		sb.Append("\x3\x2\x2\x2\x14B3\x14AF\x3\x2\x2\x2\x14B3\x14B4\x3\x2\x2\x2");
		sb.Append("\x14B4\x14B6\x3\x2\x2\x2\x14B5\x14B7\t+\x2\x2\x14B6\x14B5\x3");
		sb.Append("\x2\x2\x2\x14B6\x14B7\x3\x2\x2\x2\x14B7\x1F3\x3\x2\x2\x2\x14B8");
		sb.Append("\x14B9\tS\x2\x2\x14B9\x1F5\x3\x2\x2\x2\x14BA\x14BB\tT\x2\x2");
		sb.Append("\x14BB\x1F7\x3\x2\x2\x2\x14BC\x14C1\a\xC4\x2\x2\x14BD\x14C1");
		sb.Append("\x5\x264\x133\x2\x14BE\x14C1\a\x3DF\x2\x2\x14BF\x14C1\a\x3DC");
		sb.Append("\x2\x2\x14C0\x14BC\x3\x2\x2\x2\x14C0\x14BD\x3\x2\x2\x2\x14C0");
		sb.Append("\x14BE\x3\x2\x2\x2\x14C0\x14BF\x3\x2\x2\x2\x14C1\x1F9\x3\x2");
		sb.Append("\x2\x2\x14C2\x14C5\x5\x206\x104\x2\x14C3\x14C5\a\x3DF\x2\x2");
		sb.Append("\x14C4\x14C2\x3\x2\x2\x2\x14C4\x14C3\x3\x2\x2\x2\x14C5\x1FB");
		sb.Append("\x3\x2\x2\x2\x14C6\x14C7\tU\x2\x2\x14C7\x1FD\x3\x2\x2\x2\x14C8");
		sb.Append("\x14C9\x5\x20C\x107\x2\x14C9\x14CA\a\x3C4\x2\x2\x14CA\x14CB");
		sb.Append("\x5\x20C\x107\x2\x14CB\x14CC\a\x3C4\x2\x2\x14CC\x14CD\x5\x20C");
		sb.Append("\x107\x2\x14CD\x14CE\a\x3C4\x2\x2\x14CE\x14CF\x5\x20C\x107\x2");
		sb.Append("\x14CF\x14D0\a\x3C4\x2\x2\x14D0\x14D6\x5\x20C\x107\x2\x14D1");
		sb.Append("\x14D2\a\x3DB\x2\x2\x14D2\x14D3\x5\x20C\x107\x2\x14D3\x14D4");
		sb.Append("\a\x3C4\x2\x2\x14D4\x14D5\x5\x20C\x107\x2\x14D5\x14D7\x3\x2");
		sb.Append("\x2\x2\x14D6\x14D1\x3\x2\x2\x2\x14D7\x14D8\x3\x2\x2\x2\x14D8");
		sb.Append("\x14D6\x3\x2\x2\x2\x14D8\x14D9\x3\x2\x2\x2\x14D9\x1FF\x3\x2");
		sb.Append("\x2\x2\x14DA\x14E1\x5\x202\x102\x2\x14DB\x14DC\a\x3D2\x2\x2");
		sb.Append("\x14DC\x14DF\x5\x202\x102\x2\x14DD\x14DE\a\x3D2\x2\x2\x14DE");
		sb.Append("\x14E0\x5\x20C\x107\x2\x14DF\x14DD\x3\x2\x2\x2\x14DF\x14E0\x3");
		sb.Append("\x2\x2\x2\x14E0\x14E2\x3\x2\x2\x2\x14E1\x14DB\x3\x2\x2\x2\x14E1");
		sb.Append("\x14E2\x3\x2\x2\x2\x14E2\x201\x3\x2\x2\x2\x14E3\x14EB\a\x3DF");
		sb.Append("\x2\x2\x14E4\x14EB\a\x3E4\x2\x2\x14E5\x14E7\a\x3E1\x2\x2\x14E6");
		sb.Append("\x14E5\x3\x2\x2\x2\x14E7\x14E8\x3\x2\x2\x2\x14E8\x14E6\x3\x2");
		sb.Append("\x2\x2\x14E8\x14E9\x3\x2\x2\x2\x14E9\x14EB\x3\x2\x2\x2\x14EA");
		sb.Append("\x14E3\x3\x2\x2\x2\x14EA\x14E4\x3\x2\x2\x2\x14EA\x14E6\x3\x2");
		sb.Append("\x2\x2\x14EB\x203\x3\x2\x2\x2\x14EC\x14EF\x5\x206\x104\x2\x14ED");
		sb.Append("\x14EF\a\x3DF\x2\x2\x14EE\x14EC\x3\x2\x2\x2\x14EE\x14ED\x3\x2");
		sb.Append("\x2\x2\x14EF\x205\x3\x2\x2\x2\x14F0\x14F4\x5\x208\x105\x2\x14F1");
		sb.Append("\x14F4\a\x3E8\x2\x2\x14F2\x14F4\a\x3DC\x2\x2\x14F3\x14F0\x3");
		sb.Append("\x2\x2\x2\x14F3\x14F1\x3\x2\x2\x2\x14F3\x14F2\x3\x2\x2\x2\x14F4");
		sb.Append("\x207\x3\x2\x2\x2\x14F5\x14FF\a\x3E7\x2\x2\x14F6\x14FF\x5\x264");
		sb.Append("\x133\x2\x14F7\x14FF\x5\x266\x134\x2\x14F8\x14FF\x5\x1FC\xFF");
		sb.Append("\x2\x14F9\x14FF\x5\x268\x135\x2\x14FA\x14FF\x5\x26A\x136\x2");
		sb.Append("\x14FB\x14FF\x5\x26C\x137\x2\x14FC\x14FF\x5\x26E\x138\x2\x14FD");
		sb.Append("\x14FF\x5\x270\x139\x2\x14FE\x14F5\x3\x2\x2\x2\x14FE\x14F6\x3");
		sb.Append("\x2\x2\x2\x14FE\x14F7\x3\x2\x2\x2\x14FE\x14F8\x3\x2\x2\x2\x14FE");
		sb.Append("\x14F9\x3\x2\x2\x2\x14FE\x14FA\x3\x2\x2\x2\x14FE\x14FB\x3\x2");
		sb.Append("\x2\x2\x14FE\x14FC\x3\x2\x2\x2\x14FE\x14FD\x3\x2\x2\x2\x14FF");
		sb.Append("\x209\x3\x2\x2\x2\x1500\x1504\a\x3E6\x2\x2\x1501\x1502\a\x3CF");
		sb.Append("\x2\x2\x1502\x1504\x5\x206\x104\x2\x1503\x1500\x3\x2\x2\x2\x1503");
		sb.Append("\x1501\x3\x2\x2\x2\x1504\x20B\x3\x2\x2\x2\x1505\x1506\tV\x2");
		sb.Append("\x2\x1506\x20D\x3\x2\x2\x2\x1507\x150A\a\x3DD\x2\x2\x1508\x150A");
		sb.Append("\x5\x20C\x107\x2\x1509\x1507\x3\x2\x2\x2\x1509\x1508\x3\x2\x2");
		sb.Append("\x2\x150A\x20F\x3\x2\x2\x2\x150B\x150D\a\x3E5\x2\x2\x150C\x150B");
		sb.Append("\x3\x2\x2\x2\x150C\x150D\x3\x2\x2\x2\x150D\x150E\x3\x2\x2\x2");
		sb.Append("\x150E\x1511\a\x3DF\x2\x2\x150F\x1511\a\x3DE\x2\x2\x1510\x150C");
		sb.Append("\x3\x2\x2\x2\x1510\x150F\x3\x2\x2\x2\x1511\x1513\x3\x2\x2\x2");
		sb.Append("\x1512\x1514\a\x3DF\x2\x2\x1513\x1512\x3\x2\x2\x2\x1514\x1515");
		sb.Append("\x3\x2\x2\x2\x1515\x1513\x3\x2\x2\x2\x1515\x1516\x3\x2\x2\x2");
		sb.Append("\x1516\x1523\x3\x2\x2\x2\x1517\x1519\a\x3E5\x2\x2\x1518\x1517");
		sb.Append("\x3\x2\x2\x2\x1518\x1519\x3\x2\x2\x2\x1519\x151A\x3\x2\x2\x2");
		sb.Append("\x151A\x151D\a\x3DF\x2\x2\x151B\x151D\a\x3DE\x2\x2\x151C\x1518");
		sb.Append("\x3\x2\x2\x2\x151C\x151B\x3\x2\x2\x2\x151D\x1520\x3\x2\x2\x2");
		sb.Append("\x151E\x151F\a\x1A\x2\x2\x151F\x1521\x5\x1FA\xFE\x2\x1520\x151E");
		sb.Append("\x3\x2\x2\x2\x1520\x1521\x3\x2\x2\x2\x1521\x1523\x3\x2\x2\x2");
		sb.Append("\x1522\x1510\x3\x2\x2\x2\x1522\x151C\x3\x2\x2\x2\x1523\x211");
		sb.Append("\x3\x2\x2\x2\x1524\x1525\tW\x2\x2\x1525\x213\x3\x2\x2\x2\x1526");
		sb.Append("\x1528\a\x3E5\x2\x2\x1527\x1526\x3\x2\x2\x2\x1527\x1528\x3\x2");
		sb.Append("\x2\x2\x1528\x1529\x3\x2\x2\x2\x1529\x152A\a\x3E1\x2\x2\x152A");
		sb.Append("\x215\x3\x2\x2\x2\x152B\x152D\a\x65\x2\x2\x152C\x152B\x3\x2");
		sb.Append("\x2\x2\x152C\x152D\x3\x2\x2\x2\x152D\x152E\x3\x2\x2\x2\x152E");
		sb.Append("\x152F\tX\x2\x2\x152F\x217\x3\x2\x2\x2\x1530\x153D\x5\x210\x109");
		sb.Append("\x2\x1531\x153D\x5\x20C\x107\x2\x1532\x1533\a\x3C4\x2\x2\x1533");
		sb.Append("\x153D\x5\x20C\x107\x2\x1534\x153D\x5\x214\x10B\x2\x1535\x153D");
		sb.Append("\x5\x212\x10A\x2\x1536\x153D\a\x3E2\x2\x2\x1537\x153D\a\x3E4");
		sb.Append("\x2\x2\x1538\x153A\a\x65\x2\x2\x1539\x1538\x3\x2\x2\x2\x1539");
		sb.Append("\x153A\x3\x2\x2\x2\x153A\x153B\x3\x2\x2\x2\x153B\x153D\tX\x2");
		sb.Append("\x2\x153C\x1530\x3\x2\x2\x2\x153C\x1531\x3\x2\x2\x2\x153C\x1532");
		sb.Append("\x3\x2\x2\x2\x153C\x1534\x3\x2\x2\x2\x153C\x1535\x3\x2\x2\x2");
		sb.Append("\x153C\x1536\x3\x2\x2\x2\x153C\x1537\x3\x2\x2\x2\x153C\x1539");
		sb.Append("\x3\x2\x2\x2\x153D\x219\x3\x2\x2\x2\x153E\x1540\tY\x2\x2\x153F");
		sb.Append("\x1541\x5\x220\x111\x2\x1540\x153F\x3\x2\x2\x2\x1540\x1541\x3");
		sb.Append("\x2\x2\x2\x1541\x1543\x3\x2\x2\x2\x1542\x1544\a\xC4\x2\x2\x1543");
		sb.Append("\x1542\x3\x2\x2\x2\x1543\x1544\x3\x2\x2\x2\x1544\x154B\x3\x2");
		sb.Append("\x2\x2\x1545\x1546\a\x18\x2\x2\x1546\x1549\a\x87\x2\x2\x1547");
		sb.Append("\x1549\a\x2AF\x2\x2\x1548\x1545\x3\x2\x2\x2\x1548\x1547\x3\x2");
		sb.Append("\x2\x2\x1549\x154A\x3\x2\x2\x2\x154A\x154C\x5\x1F8\xFD\x2\x154B");
		sb.Append("\x1548\x3\x2\x2\x2\x154B\x154C\x3\x2\x2\x2\x154C\x154F\x3\x2");
		sb.Append("\x2\x2\x154D\x154E\a\x1A\x2\x2\x154E\x1550\x5\x1FA\xFE\x2\x154F");
		sb.Append("\x154D\x3\x2\x2\x2\x154F\x1550\x3\x2\x2\x2\x1550\x15A9\x3\x2");
		sb.Append("\x2\x2\x1551\x1552\a\xC3\x2\x2\x1552\x1554\tZ\x2\x2\x1553\x1555");
		sb.Append("\x5\x220\x111\x2\x1554\x1553\x3\x2\x2\x2\x1554\x1555\x3\x2\x2");
		sb.Append("\x2\x1555\x1557\x3\x2\x2\x2\x1556\x1558\a\xC4\x2\x2\x1557\x1556");
		sb.Append("\x3\x2\x2\x2\x1557\x1558\x3\x2\x2\x2\x1558\x15A9\x3\x2\x2\x2");
		sb.Append("\x1559\x155A\a\x1AD\x2\x2\x155A\x155C\a\xC1\x2\x2\x155B\x155D");
		sb.Append("\x5\x220\x111\x2\x155C\x155B\x3\x2\x2\x2\x155C\x155D\x3\x2\x2");
		sb.Append("\x2\x155D\x155F\x3\x2\x2\x2\x155E\x1560\a\xC4\x2\x2\x155F\x155E");
		sb.Append("\x3\x2\x2\x2\x155F\x1560\x3\x2\x2\x2\x1560\x15A9\x3\x2\x2\x2");
		sb.Append("\x1561\x1562\a\xC3\x2\x2\x1562\x1563\t[\x2\x2\x1563\x1565\a");
		sb.Append("\xCF\x2\x2\x1564\x1566\x5\x220\x111\x2\x1565\x1564\x3\x2\x2");
		sb.Append("\x2\x1565\x1566\x3\x2\x2\x2\x1566\x1568\x3\x2\x2\x2\x1567\x1569");
		sb.Append("\a\xC4\x2\x2\x1568\x1567\x3\x2\x2\x2\x1568\x1569\x3\x2\x2\x2");
		sb.Append("\x1569\x15A9\x3\x2\x2\x2\x156A\x156C\t\\\x2\x2\x156B\x156D\x5");
		sb.Append("\x220\x111\x2\x156C\x156B\x3\x2\x2\x2\x156C\x156D\x3\x2\x2\x2");
		sb.Append("\x156D\x156F\x3\x2\x2\x2\x156E\x1570\t]\x2\x2\x156F\x156E\x3");
		sb.Append("\x2\x2\x2\x156F\x1570\x3\x2\x2\x2\x1570\x1572\x3\x2\x2\x2\x1571");
		sb.Append("\x1573\a\xAD\x2\x2\x1572\x1571\x3\x2\x2\x2\x1572\x1573\x3\x2");
		sb.Append("\x2\x2\x1573\x15A9\x3\x2\x2\x2\x1574\x1576\a\xB4\x2\x2\x1575");
		sb.Append("\x1577\x5\x222\x112\x2\x1576\x1575\x3\x2\x2\x2\x1576\x1577\x3");
		sb.Append("\x2\x2\x2\x1577\x1579\x3\x2\x2\x2\x1578\x157A\t]\x2\x2\x1579");
		sb.Append("\x1578\x3\x2\x2\x2\x1579\x157A\x3\x2\x2\x2\x157A\x157C\x3\x2");
		sb.Append("\x2\x2\x157B\x157D\a\xAD\x2\x2\x157C\x157B\x3\x2\x2\x2\x157C");
		sb.Append("\x157D\x3\x2\x2\x2\x157D\x15A9\x3\x2\x2\x2\x157E\x1580\a\xB5");
		sb.Append("\x2\x2\x157F\x1581\a\xB6\x2\x2\x1580\x157F\x3\x2\x2\x2\x1580");
		sb.Append("\x1581\x3\x2\x2\x2\x1581\x1583\x3\x2\x2\x2\x1582\x1584\x5\x222");
		sb.Append("\x112\x2\x1583\x1582\x3\x2\x2\x2\x1583\x1584\x3\x2\x2\x2\x1584");
		sb.Append("\x1586\x3\x2\x2\x2\x1585\x1587\t]\x2\x2\x1586\x1585\x3\x2\x2");
		sb.Append("\x2\x1586\x1587\x3\x2\x2\x2\x1587\x1589\x3\x2\x2\x2\x1588\x158A");
		sb.Append("\a\xAD\x2\x2\x1589\x1588\x3\x2\x2\x2\x1589\x158A\x3\x2\x2\x2");
		sb.Append("\x158A\x15A9\x3\x2\x2\x2\x158B\x158D\t^\x2\x2\x158C\x158E\x5");
		sb.Append("\x224\x113\x2\x158D\x158C\x3\x2\x2\x2\x158D\x158E\x3\x2\x2\x2");
		sb.Append("\x158E\x1590\x3\x2\x2\x2\x158F\x1591\t]\x2\x2\x1590\x158F\x3");
		sb.Append("\x2\x2\x2\x1590\x1591\x3\x2\x2\x2\x1591\x1593\x3\x2\x2\x2\x1592");
		sb.Append("\x1594\a\xAD\x2\x2\x1593\x1592\x3\x2\x2\x2\x1593\x1594\x3\x2");
		sb.Append("\x2\x2\x1594\x15A9\x3\x2\x2\x2\x1595\x15A9\t_\x2\x2\x1596\x1598");
		sb.Append("\t`\x2\x2\x1597\x1599\x5\x220\x111\x2\x1598\x1597\x3\x2\x2\x2");
		sb.Append("\x1598\x1599\x3\x2\x2\x2\x1599\x15A9\x3\x2\x2\x2\x159A\x159B");
		sb.Append("\t\x61\x2\x2\x159B\x159D\x5\x21C\x10F\x2\x159C\x159E\a\xC4\x2");
		sb.Append("\x2\x159D\x159C\x3\x2\x2\x2\x159D\x159E\x3\x2\x2\x2\x159E\x15A5");
		sb.Append("\x3\x2\x2\x2\x159F\x15A0\a\x18\x2\x2\x15A0\x15A3\a\x87\x2\x2");
		sb.Append("\x15A1\x15A3\a\x2AF\x2\x2\x15A2\x159F\x3\x2\x2\x2\x15A2\x15A1");
		sb.Append("\x3\x2\x2\x2\x15A3\x15A4\x3\x2\x2\x2\x15A4\x15A6\x5\x1F8\xFD");
		sb.Append("\x2\x15A5\x15A2\x3\x2\x2\x2\x15A5\x15A6\x3\x2\x2\x2\x15A6\x15A9");
		sb.Append("\x3\x2\x2\x2\x15A7\x15A9\t\x62\x2\x2\x15A8\x153E\x3\x2\x2\x2");
		sb.Append("\x15A8\x1551\x3\x2\x2\x2\x15A8\x1559\x3\x2\x2\x2\x15A8\x1561");
		sb.Append("\x3\x2\x2\x2\x15A8\x156A\x3\x2\x2\x2\x15A8\x1574\x3\x2\x2\x2");
		sb.Append("\x15A8\x157E\x3\x2\x2\x2\x15A8\x158B\x3\x2\x2\x2\x15A8\x1595");
		sb.Append("\x3\x2\x2\x2\x15A8\x1596\x3\x2\x2\x2\x15A8\x159A\x3\x2\x2\x2");
		sb.Append("\x15A8\x15A7\x3\x2\x2\x2\x15A9\x21B\x3\x2\x2\x2\x15AA\x15AB");
		sb.Append("\a\x3D0\x2\x2\x15AB\x15B0\a\x3DF\x2\x2\x15AC\x15AD\a\x3D2\x2");
		sb.Append("\x2\x15AD\x15AF\a\x3DF\x2\x2\x15AE\x15AC\x3\x2\x2\x2\x15AF\x15B2");
		sb.Append("\x3\x2\x2\x2\x15B0\x15AE\x3\x2\x2\x2\x15B0\x15B1\x3\x2\x2\x2");
		sb.Append("\x15B1\x15B3\x3\x2\x2\x2\x15B2\x15B0\x3\x2\x2\x2\x15B3\x15B4");
		sb.Append("\a\x3D1\x2\x2\x15B4\x21D\x3\x2\x2\x2\x15B5\x15B7\t\x63\x2\x2");
		sb.Append("\x15B6\x15B8\x5\x220\x111\x2\x15B7\x15B6\x3\x2\x2\x2\x15B7\x15B8");
		sb.Append("\x3\x2\x2\x2\x15B8\x15CF\x3\x2\x2\x2\x15B9\x15BB\a\xC0\x2\x2");
		sb.Append("\x15BA\x15BC\x5\x220\x111\x2\x15BB\x15BA\x3\x2\x2\x2\x15BB\x15BC");
		sb.Append("\x3\x2\x2\x2\x15BC\x15C3\x3\x2\x2\x2\x15BD\x15BE\a\x18\x2\x2");
		sb.Append("\x15BE\x15C1\a\x87\x2\x2\x15BF\x15C1\a\x2AF\x2\x2\x15C0\x15BD");
		sb.Append("\x3\x2\x2\x2\x15C0\x15BF\x3\x2\x2\x2\x15C1\x15C2\x3\x2\x2\x2");
		sb.Append("\x15C2\x15C4\x5\x1F8\xFD\x2\x15C3\x15C0\x3\x2\x2\x2\x15C3\x15C4");
		sb.Append("\x3\x2\x2\x2\x15C4\x15CF\x3\x2\x2\x2\x15C5\x15CF\t\x64\x2\x2");
		sb.Append("\x15C6\x15C8\a\xB8\x2\x2\x15C7\x15C9\x5\x222\x112\x2\x15C8\x15C7");
		sb.Append("\x3\x2\x2\x2\x15C8\x15C9\x3\x2\x2\x2\x15C9\x15CF\x3\x2\x2\x2");
		sb.Append("\x15CA\x15CC\t]\x2\x2\x15CB\x15CD\a\xB2\x2\x2\x15CC\x15CB\x3");
		sb.Append("\x2\x2\x2\x15CC\x15CD\x3\x2\x2\x2\x15CD\x15CF\x3\x2\x2\x2\x15CE");
		sb.Append("\x15B5\x3\x2\x2\x2\x15CE\x15B9\x3\x2\x2\x2\x15CE\x15C5\x3\x2");
		sb.Append("\x2\x2\x15CE\x15C6\x3\x2\x2\x2\x15CE\x15CA\x3\x2\x2\x2\x15CF");
		sb.Append("\x21F\x3\x2\x2\x2\x15D0\x15D1\a\x3D0\x2\x2\x15D1\x15D2\x5\x20C");
		sb.Append("\x107\x2\x15D2\x15D3\a\x3D1\x2\x2\x15D3\x221\x3\x2\x2\x2\x15D4");
		sb.Append("\x15D5\a\x3D0\x2\x2\x15D5\x15D6\x5\x20C\x107\x2\x15D6\x15D7");
		sb.Append("\a\x3D2\x2\x2\x15D7\x15D8\x5\x20C\x107\x2\x15D8\x15D9\a\x3D1");
		sb.Append("\x2\x2\x15D9\x223\x3\x2\x2\x2\x15DA\x15DB\a\x3D0\x2\x2\x15DB");
		sb.Append("\x15DE\x5\x20C\x107\x2\x15DC\x15DD\a\x3D2\x2\x2\x15DD\x15DF");
		sb.Append("\x5\x20C\x107\x2\x15DE\x15DC\x3\x2\x2\x2\x15DE\x15DF\x3\x2\x2");
		sb.Append("\x2\x15DF\x15E0\x3\x2\x2\x2\x15E0\x15E1\a\x3D1\x2\x2\x15E1\x225");
		sb.Append("\x3\x2\x2\x2\x15E2\x15E7\x5\x206\x104\x2\x15E3\x15E4\a\x3D2");
		sb.Append("\x2\x2\x15E4\x15E6\x5\x206\x104\x2\x15E5\x15E3\x3\x2\x2\x2\x15E6");
		sb.Append("\x15E9\x3\x2\x2\x2\x15E7\x15E5\x3\x2\x2\x2\x15E7\x15E8\x3\x2");
		sb.Append("\x2\x2\x15E8\x227\x3\x2\x2\x2\x15E9\x15E7\x3\x2\x2\x2\x15EA");
		sb.Append("\x15EF\x5\x1EE\xF8\x2\x15EB\x15EC\a\x3D2\x2\x2\x15EC\x15EE\x5");
		sb.Append("\x1EE\xF8\x2\x15ED\x15EB\x3\x2\x2\x2\x15EE\x15F1\x3\x2\x2\x2");
		sb.Append("\x15EF\x15ED\x3\x2\x2\x2\x15EF\x15F0\x3\x2\x2\x2\x15F0\x229");
		sb.Append("\x3\x2\x2\x2\x15F1\x15EF\x3\x2\x2\x2\x15F2\x15F3\a\x3D0\x2\x2");
		sb.Append("\x15F3\x15F8\x5\x1F2\xFA\x2\x15F4\x15F5\a\x3D2\x2\x2\x15F5\x15F7");
		sb.Append("\x5\x1F2\xFA\x2\x15F6\x15F4\x3\x2\x2\x2\x15F7\x15FA\x3\x2\x2");
		sb.Append("\x2\x15F8\x15F6\x3\x2\x2\x2\x15F8\x15F9\x3\x2\x2\x2\x15F9\x15FB");
		sb.Append("\x3\x2\x2\x2\x15FA\x15F8\x3\x2\x2\x2\x15FB\x15FC\a\x3D1\x2\x2");
		sb.Append("\x15FC\x22B\x3\x2\x2\x2\x15FD\x1602\x5\x254\x12B\x2\x15FE\x15FF");
		sb.Append("\a\x3D2\x2\x2\x15FF\x1601\x5\x254\x12B\x2\x1600\x15FE\x3\x2");
		sb.Append("\x2\x2\x1601\x1604\x3\x2\x2\x2\x1602\x1600\x3\x2\x2\x2\x1602");
		sb.Append("\x1603\x3\x2\x2\x2\x1603\x22D\x3\x2\x2\x2\x1604\x1602\x3\x2");
		sb.Append("\x2\x2\x1605\x160A\x5\x23A\x11E\x2\x1606\x1607\a\x3D2\x2\x2");
		sb.Append("\x1607\x1609\x5\x23A\x11E\x2\x1608\x1606\x3\x2\x2\x2\x1609\x160C");
		sb.Append("\x3\x2\x2\x2\x160A\x1608\x3\x2\x2\x2\x160A\x160B\x3\x2\x2\x2");
		sb.Append("\x160B\x22F\x3\x2\x2\x2\x160C\x160A\x3\x2\x2\x2\x160D\x1612");
		sb.Append("\x5\x218\x10D\x2\x160E\x160F\a\x3D2\x2\x2\x160F\x1611\x5\x218");
		sb.Append("\x10D\x2\x1610\x160E\x3\x2\x2\x2\x1611\x1614\x3\x2\x2\x2\x1612");
		sb.Append("\x1610\x3\x2\x2\x2\x1612\x1613\x3\x2\x2\x2\x1613\x231\x3\x2");
		sb.Append("\x2\x2\x1614\x1612\x3\x2\x2\x2\x1615\x161A\a\x3DF\x2\x2\x1616");
		sb.Append("\x1617\a\x3D2\x2\x2\x1617\x1619\a\x3DF\x2\x2\x1618\x1616\x3");
		sb.Append("\x2\x2\x2\x1619\x161C\x3\x2\x2\x2\x161A\x1618\x3\x2\x2\x2\x161A");
		sb.Append("\x161B\x3\x2\x2\x2\x161B\x233\x3\x2\x2\x2\x161C\x161A\x3\x2");
		sb.Append("\x2\x2\x161D\x1622\a\x3EA\x2\x2\x161E\x161F\a\x3D2\x2\x2\x161F");
		sb.Append("\x1621\a\x3EA\x2\x2\x1620\x161E\x3\x2\x2\x2\x1621\x1624\x3\x2");
		sb.Append("\x2\x2\x1622\x1620\x3\x2\x2\x2\x1622\x1623\x3\x2\x2\x2\x1623");
		sb.Append("\x235\x3\x2\x2\x2\x1624\x1622\x3\x2\x2\x2\x1625\x1631\ag\x2");
		sb.Append("\x2\x1626\x1628\x5\x25A\x12E\x2\x1627\x1626\x3\x2\x2\x2\x1627");
		sb.Append("\x1628\x3\x2\x2\x2\x1628\x1629\x3\x2\x2\x2\x1629\x1631\x5\x218");
		sb.Append("\x10D\x2\x162A\x162E\x5\x238\x11D\x2\x162B\x162C\ah\x2\x2\x162C");
		sb.Append("\x162D\a\xA2\x2\x2\x162D\x162F\x5\x238\x11D\x2\x162E\x162B\x3");
		sb.Append("\x2\x2\x2\x162E\x162F\x3\x2\x2\x2\x162F\x1631\x3\x2\x2\x2\x1630");
		sb.Append("\x1625\x3\x2\x2\x2\x1630\x1627\x3\x2\x2\x2\x1630\x162A\x3\x2");
		sb.Append("\x2\x2\x1631\x237\x3\x2\x2\x2\x1632\x1638\t\x65\x2\x2\x1633");
		sb.Append("\x1635\a\x3D0\x2\x2\x1634\x1636\x5\x20C\x107\x2\x1635\x1634");
		sb.Append("\x3\x2\x2\x2\x1635\x1636\x3\x2\x2\x2\x1636\x1637\x3\x2\x2\x2");
		sb.Append("\x1637\x1639\a\x3D1\x2\x2\x1638\x1633\x3\x2\x2\x2\x1638\x1639");
		sb.Append("\x3\x2\x2\x2\x1639\x1641\x3\x2\x2\x2\x163A\x163B\a\xF6\x2\x2");
		sb.Append("\x163B\x163D\a\x3D0\x2\x2\x163C\x163E\x5\x20C\x107\x2\x163D");
		sb.Append("\x163C\x3\x2\x2\x2\x163D\x163E\x3\x2\x2\x2\x163E\x163F\x3\x2");
		sb.Append("\x2\x2\x163F\x1641\a\x3D1\x2\x2\x1640\x1632\x3\x2\x2\x2\x1640");
		sb.Append("\x163A\x3\x2\x2\x2\x1641\x239\x3\x2\x2\x2\x1642\x1645\x5\x254");
		sb.Append("\x12B\x2\x1643\x1645\a\'\x2\x2\x1644\x1642\x3\x2\x2\x2\x1644");
		sb.Append("\x1643\x3\x2\x2\x2\x1645\x23B\x3\x2\x2\x2\x1646\x1647\a\x44");
		sb.Append("\x2\x2\x1647\x1648\a\x35\x2\x2\x1648\x23D\x3\x2\x2\x2\x1649");
		sb.Append("\x164A\a\x44\x2\x2\x164A\x164B\a\x65\x2\x2\x164B\x164C\a\x35");
		sb.Append("\x2\x2\x164C\x23F\x3\x2\x2\x2\x164D\x165F\x5\x242\x122\x2\x164E");
		sb.Append("\x165F\x5\x24A\x126\x2\x164F\x1650\x5\x24C\x127\x2\x1650\x1652");
		sb.Append("\a\x3D0\x2\x2\x1651\x1653\x5\x250\x129\x2\x1652\x1651\x3\x2");
		sb.Append("\x2\x2\x1652\x1653\x3\x2\x2\x2\x1653\x1654\x3\x2\x2\x2\x1654");
		sb.Append("\x1655\a\x3D1\x2\x2\x1655\x165F\x3\x2\x2\x2\x1656\x1657\x5\x1EC");
		sb.Append("\xF7\x2\x1657\x1659\a\x3D0\x2\x2\x1658\x165A\x5\x250\x129\x2");
		sb.Append("\x1659\x1658\x3\x2\x2\x2\x1659\x165A\x3\x2\x2\x2\x165A\x165B");
		sb.Append("\x3\x2\x2\x2\x165B\x165C\a\x3D1\x2\x2\x165C\x165F\x3\x2\x2\x2");
		sb.Append("\x165D\x165F\x5\x24E\x128\x2\x165E\x164D\x3\x2\x2\x2\x165E\x164E");
		sb.Append("\x3\x2\x2\x2\x165E\x164F\x3\x2\x2\x2\x165E\x1656\x3\x2\x2\x2");
		sb.Append("\x165E\x165D\x3\x2\x2\x2\x165F\x241\x3\x2\x2\x2\x1660\x16FE");
		sb.Append("\t\x66\x2\x2\x1661\x1662\a\x1F\x2\x2\x1662\x1663\a\x3D0\x2\x2");
		sb.Append("\x1663\x1664\x5\x254\x12B\x2\x1664\x1665\a\x3D2\x2\x2\x1665");
		sb.Append("\x1666\x5\x21E\x110\x2\x1666\x1667\a\x3D1\x2\x2\x1667\x16FE");
		sb.Append("\x3\x2\x2\x2\x1668\x1669\a\x1F\x2\x2\x1669\x166A\a\x3D0\x2\x2");
		sb.Append("\x166A\x166B\x5\x254\x12B\x2\x166B\x166C\a\xA5\x2\x2\x166C\x166D");
		sb.Append("\x5\x1F8\xFD\x2\x166D\x166E\a\x3D1\x2\x2\x166E\x16FE\x3\x2\x2");
		sb.Append("\x2\x166F\x1670\a\x16\x2\x2\x1670\x1671\a\x3D0\x2\x2\x1671\x1672");
		sb.Append("\x5\x254\x12B\x2\x1672\x1673\a\r\x2\x2\x1673\x1674\x5\x21E\x110");
		sb.Append("\x2\x1674\x1675\a\x3D1\x2\x2\x1675\x16FE\x3\x2\x2\x2\x1676\x1677");
		sb.Append("\a\xA6\x2\x2\x1677\x1678\a\x3D0\x2\x2\x1678\x1679\x5\x1F0\xF9");
		sb.Append("\x2\x1679\x167A\a\x3D1\x2\x2\x167A\x16FE\x3\x2\x2\x2\x167B\x167C");
		sb.Append("\a\x15\x2\x2\x167C\x167E\x5\x254\x12B\x2\x167D\x167F\x5\x244");
		sb.Append("\x123\x2\x167E\x167D\x3\x2\x2\x2\x167F\x1680\x3\x2\x2\x2\x1680");
		sb.Append("\x167E\x3\x2\x2\x2\x1680\x1681\x3\x2\x2\x2\x1681\x1684\x3\x2");
		sb.Append("\x2\x2\x1682\x1683\a\x31\x2\x2\x1683\x1685\x5\x252\x12A\x2\x1684");
		sb.Append("\x1682\x3\x2\x2\x2\x1684\x1685\x3\x2\x2\x2\x1685\x1686\x3\x2");
		sb.Append("\x2\x2\x1686\x1687\a\x144\x2\x2\x1687\x16FE\x3\x2\x2\x2\x1688");
		sb.Append("\x168A\a\x15\x2\x2\x1689\x168B\x5\x244\x123\x2\x168A\x1689\x3");
		sb.Append("\x2\x2\x2\x168B\x168C\x3\x2\x2\x2\x168C\x168A\x3\x2\x2\x2\x168C");
		sb.Append("\x168D\x3\x2\x2\x2\x168D\x1690\x3\x2\x2\x2\x168E\x168F\a\x31");
		sb.Append("\x2\x2\x168F\x1691\x5\x252\x12A\x2\x1690\x168E\x3\x2\x2\x2\x1690");
		sb.Append("\x1691\x3\x2\x2\x2\x1691\x1692\x3\x2\x2\x2\x1692\x1693\a\x144");
		sb.Append("\x2\x2\x1693\x16FE\x3\x2\x2\x2\x1694\x1695\a\xC0\x2\x2\x1695");
		sb.Append("\x1696\a\x3D0\x2\x2\x1696\x1699\x5\x250\x129\x2\x1697\x1698");
		sb.Append("\a\xA5\x2\x2\x1698\x169A\x5\x1F8\xFD\x2\x1699\x1697\x3\x2\x2");
		sb.Append("\x2\x1699\x169A\x3\x2\x2\x2\x169A\x169B\x3\x2\x2\x2\x169B\x169C");
		sb.Append("\a\x3D1\x2\x2\x169C\x16FE\x3\x2\x2\x2\x169D\x169E\a\xF7\x2\x2");
		sb.Append("\x169E\x16A1\a\x3D0\x2\x2\x169F\x16A2\x5\x210\x109\x2\x16A0");
		sb.Append("\x16A2\x5\x254\x12B\x2\x16A1\x169F\x3\x2\x2\x2\x16A1\x16A0\x3");
		sb.Append("\x2\x2\x2\x16A2\x16A3\x3\x2\x2\x2\x16A3\x16A6\a\x46\x2\x2\x16A4");
		sb.Append("\x16A7\x5\x210\x109\x2\x16A5\x16A7\x5\x254\x12B\x2\x16A6\x16A4");
		sb.Append("\x3\x2\x2\x2\x16A6\x16A5\x3\x2\x2\x2\x16A7\x16A8\x3\x2\x2\x2");
		sb.Append("\x16A8\x16A9\a\x3D1\x2\x2\x16A9\x16FE\x3\x2\x2\x2\x16AA\x16AB");
		sb.Append("\tg\x2\x2\x16AB\x16AE\a\x3D0\x2\x2\x16AC\x16AF\x5\x210\x109");
		sb.Append("\x2\x16AD\x16AF\x5\x254\x12B\x2\x16AE\x16AC\x3\x2\x2\x2\x16AE");
		sb.Append("\x16AD\x3\x2\x2\x2\x16AF\x16B0\x3\x2\x2\x2\x16B0\x16B3\a=\x2");
		sb.Append("\x2\x16B1\x16B4\x5\x20C\x107\x2\x16B2\x16B4\x5\x254\x12B\x2");
		sb.Append("\x16B3\x16B1\x3\x2\x2\x2\x16B3\x16B2\x3\x2\x2\x2\x16B4\x16BA");
		sb.Append("\x3\x2\x2\x2\x16B5\x16B8\a:\x2\x2\x16B6\x16B9\x5\x20C\x107\x2");
		sb.Append("\x16B7\x16B9\x5\x254\x12B\x2\x16B8\x16B6\x3\x2\x2\x2\x16B8\x16B7");
		sb.Append("\x3\x2\x2\x2\x16B9\x16BB\x3\x2\x2\x2\x16BA\x16B5\x3\x2\x2\x2");
		sb.Append("\x16BA\x16BB\x3\x2\x2\x2\x16BB\x16BC\x3\x2\x2\x2\x16BC\x16BD");
		sb.Append("\a\x3D1\x2\x2\x16BD\x16FE\x3\x2\x2\x2\x16BE\x16BF\a\xFB\x2\x2");
		sb.Append("\x16BF\x16C0\a\x3D0\x2\x2\x16C0\x16C3\th\x2\x2\x16C1\x16C4\x5");
		sb.Append("\x210\x109\x2\x16C2\x16C4\x5\x254\x12B\x2\x16C3\x16C1\x3\x2");
		sb.Append("\x2\x2\x16C3\x16C2\x3\x2\x2\x2\x16C3\x16C4\x3\x2\x2\x2\x16C4");
		sb.Append("\x16C5\x3\x2\x2\x2\x16C5\x16C8\a=\x2\x2\x16C6\x16C9\x5\x210");
		sb.Append("\x109\x2\x16C7\x16C9\x5\x254\x12B\x2\x16C8\x16C6\x3\x2\x2\x2");
		sb.Append("\x16C8\x16C7\x3\x2\x2\x2\x16C9\x16CA\x3\x2\x2\x2\x16CA\x16CB");
		sb.Append("\a\x3D1\x2\x2\x16CB\x16FE\x3\x2\x2\x2\x16CC\x16CD\a\xFB\x2\x2");
		sb.Append("\x16CD\x16D0\a\x3D0\x2\x2\x16CE\x16D1\x5\x210\x109\x2\x16CF");
		sb.Append("\x16D1\x5\x254\x12B\x2\x16D0\x16CE\x3\x2\x2\x2\x16D0\x16CF\x3");
		sb.Append("\x2\x2\x2\x16D1\x16D2\x3\x2\x2\x2\x16D2\x16D5\a=\x2\x2\x16D3");
		sb.Append("\x16D6\x5\x210\x109\x2\x16D4\x16D6\x5\x254\x12B\x2\x16D5\x16D3");
		sb.Append("\x3\x2\x2\x2\x16D5\x16D4\x3\x2\x2\x2\x16D6\x16D7\x3\x2\x2\x2");
		sb.Append("\x16D7\x16D8\a\x3D1\x2\x2\x16D8\x16FE\x3\x2\x2\x2\x16D9\x16DA");
		sb.Append("\a\x3B1\x2\x2\x16DA\x16DD\a\x3D0\x2\x2\x16DB\x16DE\x5\x210\x109");
		sb.Append("\x2\x16DC\x16DE\x5\x254\x12B\x2\x16DD\x16DB\x3\x2\x2\x2\x16DD");
		sb.Append("\x16DC\x3\x2\x2\x2\x16DE\x16E5\x3\x2\x2\x2\x16DF\x16E0\a\r\x2");
		sb.Append("\x2\x16E0\x16E1\ti\x2\x2\x16E1\x16E2\a\x3D0\x2\x2\x16E2\x16E3");
		sb.Append("\x5\x20C\x107\x2\x16E3\x16E4\a\x3D1\x2\x2\x16E4\x16E6\x3\x2");
		sb.Append("\x2\x2\x16E5\x16DF\x3\x2\x2\x2\x16E5\x16E6\x3\x2\x2\x2\x16E6");
		sb.Append("\x16E8\x3\x2\x2\x2\x16E7\x16E9\x5\x246\x124\x2\x16E8\x16E7\x3");
		sb.Append("\x2\x2\x2\x16E8\x16E9\x3\x2\x2\x2\x16E9\x16EA\x3\x2\x2\x2\x16EA");
		sb.Append("\x16EB\a\x3D1\x2\x2\x16EB\x16FE\x3\x2\x2\x2\x16EC\x16ED\a\xF4");
		sb.Append("\x2\x2\x16ED\x16EE\a\x3D0\x2\x2\x16EE\x16EF\x5<\x1F\x2\x16EF");
		sb.Append("\x16F2\a=\x2\x2\x16F0\x16F3\x5\x210\x109\x2\x16F1\x16F3\x5\x254");
		sb.Append("\x12B\x2\x16F2\x16F0\x3\x2\x2\x2\x16F2\x16F1\x3\x2\x2\x2\x16F3");
		sb.Append("\x16F4\x3\x2\x2\x2\x16F4\x16F5\a\x3D1\x2\x2\x16F5\x16FE\x3\x2");
		sb.Append("\x2\x2\x16F6\x16F7\a\x2E9\x2\x2\x16F7\x16F8\a\x3D0\x2\x2\x16F8");
		sb.Append("\x16F9\tj\x2\x2\x16F9\x16FA\a\x3D2\x2\x2\x16FA\x16FB\x5\x210");
		sb.Append("\x109\x2\x16FB\x16FC\a\x3D1\x2\x2\x16FC\x16FE\x3\x2\x2\x2\x16FD");
		sb.Append("\x1660\x3\x2\x2\x2\x16FD\x1661\x3\x2\x2\x2\x16FD\x1668\x3\x2");
		sb.Append("\x2\x2\x16FD\x166F\x3\x2\x2\x2\x16FD\x1676\x3\x2\x2\x2\x16FD");
		sb.Append("\x167B\x3\x2\x2\x2\x16FD\x1688\x3\x2\x2\x2\x16FD\x1694\x3\x2");
		sb.Append("\x2\x2\x16FD\x169D\x3\x2\x2\x2\x16FD\x16AA\x3\x2\x2\x2\x16FD");
		sb.Append("\x16BE\x3\x2\x2\x2\x16FD\x16CC\x3\x2\x2\x2\x16FD\x16D9\x3\x2");
		sb.Append("\x2\x2\x16FD\x16EC\x3\x2\x2\x2\x16FD\x16F6\x3\x2\x2\x2\x16FE");
		sb.Append("\x243\x3\x2\x2\x2\x16FF\x1700\a\xA7\x2\x2\x1700\x1701\x5\x252");
		sb.Append("\x12A\x2\x1701\x1702\a\x98\x2\x2\x1702\x1703\x5\x252\x12A\x2");
		sb.Append("\x1703\x245\x3\x2\x2\x2\x1704\x1705\a\x180\x2\x2\x1705\x170A");
		sb.Append("\x5\x248\x125\x2\x1706\x1707\a\x3D2\x2\x2\x1707\x1709\x5\x248");
		sb.Append("\x125\x2\x1708\x1706\x3\x2\x2\x2\x1709\x170C\x3\x2\x2\x2\x170A");
		sb.Append("\x1708\x3\x2\x2\x2\x170A\x170B\x3\x2\x2\x2\x170B\x1713\x3\x2");
		sb.Append("\x2\x2\x170C\x170A\x3\x2\x2\x2\x170D\x170E\a\x180\x2\x2\x170E");
		sb.Append("\x170F\x5\x20C\x107\x2\x170F\x1710\a\x3C4\x2\x2\x1710\x1711");
		sb.Append("\x5\x20C\x107\x2\x1711\x1713\x3\x2\x2\x2\x1712\x1704\x3\x2\x2");
		sb.Append("\x2\x1712\x170D\x3\x2\x2\x2\x1713\x247\x3\x2\x2\x2\x1714\x1716");
		sb.Append("\x5\x20C\x107\x2\x1715\x1717\tk\x2\x2\x1716\x1715\x3\x2\x2\x2");
		sb.Append("\x1716\x1717\x3\x2\x2\x2\x1717\x249\x3\x2\x2\x2\x1718\x1719");
		sb.Append("\tl\x2\x2\x1719\x171B\a\x3D0\x2\x2\x171A\x171C\t\'\x2\x2\x171B");
		sb.Append("\x171A\x3\x2\x2\x2\x171B\x171C\x3\x2\x2\x2\x171C\x171D\x3\x2");
		sb.Append("\x2\x2\x171D\x171E\x5\x252\x12A\x2\x171E\x171F\a\x3D1\x2\x2");
		sb.Append("\x171F\x1751\x3\x2\x2\x2\x1720\x1721\a\xE0\x2\x2\x1721\x1727");
		sb.Append("\a\x3D0\x2\x2\x1722\x1728\a\x3BF\x2\x2\x1723\x1725\a\b\x2\x2");
		sb.Append("\x1724\x1723\x3\x2\x2\x2\x1724\x1725\x3\x2\x2\x2\x1725\x1726");
		sb.Append("\x3\x2\x2\x2\x1726\x1728\x5\x252\x12A\x2\x1727\x1722\x3\x2\x2");
		sb.Append("\x2\x1727\x1724\x3\x2\x2\x2\x1728\x1729\x3\x2\x2\x2\x1729\x1751");
		sb.Append("\a\x3D1\x2\x2\x172A\x172B\a\xE0\x2\x2\x172B\x172C\a\x3D0\x2");
		sb.Append("\x2\x172C\x172D\a-\x2\x2\x172D\x172E\x5\x250\x129\x2\x172E\x172F");
		sb.Append("\a\x3D1\x2\x2\x172F\x1751\x3\x2\x2\x2\x1730\x1731\tm\x2\x2\x1731");
		sb.Append("\x1733\a\x3D0\x2\x2\x1732\x1734\a\b\x2\x2\x1733\x1732\x3\x2");
		sb.Append("\x2\x2\x1733\x1734\x3\x2\x2\x2\x1734\x1735\x3\x2\x2\x2\x1735");
		sb.Append("\x1736\x5\x252\x12A\x2\x1736\x1737\a\x3D1\x2\x2\x1737\x1751");
		sb.Append("\x3\x2\x2\x2\x1738\x1739\a\xE1\x2\x2\x1739\x173B\a\x3D0\x2\x2");
		sb.Append("\x173A\x173C\a-\x2\x2\x173B\x173A\x3\x2\x2\x2\x173B\x173C\x3");
		sb.Append("\x2\x2\x2\x173C\x173D\x3\x2\x2\x2\x173D\x1748\x5\x250\x129\x2");
		sb.Append("\x173E\x173F\am\x2\x2\x173F\x1740\a\x12\x2\x2\x1740\x1745\x5");
		sb.Append("\xD2j\x2\x1741\x1742\a\x3D2\x2\x2\x1742\x1744\x5\xD2j\x2\x1743");
		sb.Append("\x1741\x3\x2\x2\x2\x1744\x1747\x3\x2\x2\x2\x1745\x1743\x3\x2");
		sb.Append("\x2\x2\x1745\x1746\x3\x2\x2\x2\x1746\x1749\x3\x2\x2\x2\x1747");
		sb.Append("\x1745\x3\x2\x2\x2\x1748\x173E\x3\x2\x2\x2\x1748\x1749\x3\x2");
		sb.Append("\x2\x2\x1749\x174C\x3\x2\x2\x2\x174A\x174B\a\x88\x2\x2\x174B");
		sb.Append("\x174D\a\x3DF\x2\x2\x174C\x174A\x3\x2\x2\x2\x174C\x174D\x3\x2");
		sb.Append("\x2\x2\x174D\x174E\x3\x2\x2\x2\x174E\x174F\a\x3D1\x2\x2\x174F");
		sb.Append("\x1751\x3\x2\x2\x2\x1750\x1718\x3\x2\x2\x2\x1750\x1720\x3\x2");
		sb.Append("\x2\x2\x1750\x172A\x3\x2\x2\x2\x1750\x1730\x3\x2\x2\x2\x1750");
		sb.Append("\x1738\x3\x2\x2\x2\x1751\x24B\x3\x2\x2\x2\x1752\x176A\x5\x270");
		sb.Append("\x139\x2\x1753\x176A\a\x252\x2\x2\x1754\x176A\a\xF0\x2\x2\x1755");
		sb.Append("\x176A\a\xEC\x2\x2\x1756\x176A\a\xED\x2\x2\x1757\x176A\a\xEE");
		sb.Append("\x2\x2\x1758\x176A\a\xF1\x2\x2\x1759\x176A\a\xF2\x2\x2\x175A");
		sb.Append("\x176A\a\xF3\x2\x2\x175B\x176A\a\x44\x2\x2\x175C\x176A\aK\x2");
		sb.Append("\x2\x175D\x176A\a\xEF\x2\x2\x175E\x176A\a\xF5\x2\x2\x175F\x176A");
		sb.Append("\a\x1A3\x2\x2\x1760\x176A\a\xF6\x2\x2\x1761\x176A\a}\x2\x2\x1762");
		sb.Append("\x176A\a\xF8\x2\x2\x1763\x176A\a\xF9\x2\x2\x1764\x176A\a\xFA");
		sb.Append("\x2\x2\x1765\x176A\a\xFB\x2\x2\x1766\x176A\a\xFC\x2\x2\x1767");
		sb.Append("\x176A\a\xFD\x2\x2\x1768\x176A\a\xFE\x2\x2\x1769\x1752\x3\x2");
		sb.Append("\x2\x2\x1769\x1753\x3\x2\x2\x2\x1769\x1754\x3\x2\x2\x2\x1769");
		sb.Append("\x1755\x3\x2\x2\x2\x1769\x1756\x3\x2\x2\x2\x1769\x1757\x3\x2");
		sb.Append("\x2\x2\x1769\x1758\x3\x2\x2\x2\x1769\x1759\x3\x2\x2\x2\x1769");
		sb.Append("\x175A\x3\x2\x2\x2\x1769\x175B\x3\x2\x2\x2\x1769\x175C\x3\x2");
		sb.Append("\x2\x2\x1769\x175D\x3\x2\x2\x2\x1769\x175E\x3\x2\x2\x2\x1769");
		sb.Append("\x175F\x3\x2\x2\x2\x1769\x1760\x3\x2\x2\x2\x1769\x1761\x3\x2");
		sb.Append("\x2\x2\x1769\x1762\x3\x2\x2\x2\x1769\x1763\x3\x2\x2\x2\x1769");
		sb.Append("\x1764\x3\x2\x2\x2\x1769\x1765\x3\x2\x2\x2\x1769\x1766\x3\x2");
		sb.Append("\x2\x2\x1769\x1767\x3\x2\x2\x2\x1769\x1768\x3\x2\x2\x2\x176A");
		sb.Append("\x24D\x3\x2\x2\x2\x176B\x176C\tn\x2\x2\x176C\x176D\a\x3D0\x2");
		sb.Append("\x2\x176D\x176E\x5\x252\x12A\x2\x176E\x176F\a\x3D1\x2\x2\x176F");
		sb.Append("\x24F\x3\x2\x2\x2\x1770\x1775\x5\x218\x10D\x2\x1771\x1775\x5");
		sb.Append("\x1F0\xF9\x2\x1772\x1775\x5\x240\x121\x2\x1773\x1775\x5\x254");
		sb.Append("\x12B\x2\x1774\x1770\x3\x2\x2\x2\x1774\x1771\x3\x2\x2\x2\x1774");
		sb.Append("\x1772\x3\x2\x2\x2\x1774\x1773\x3\x2\x2\x2\x1775\x177F\x3\x2");
		sb.Append("\x2\x2\x1776\x177B\a\x3D2\x2\x2\x1777\x177C\x5\x218\x10D\x2");
		sb.Append("\x1778\x177C\x5\x1F0\xF9\x2\x1779\x177C\x5\x240\x121\x2\x177A");
		sb.Append("\x177C\x5\x254\x12B\x2\x177B\x1777\x3\x2\x2\x2\x177B\x1778\x3");
		sb.Append("\x2\x2\x2\x177B\x1779\x3\x2\x2\x2\x177B\x177A\x3\x2\x2\x2\x177C");
		sb.Append("\x177E\x3\x2\x2\x2\x177D\x1776\x3\x2\x2\x2\x177E\x1781\x3\x2");
		sb.Append("\x2\x2\x177F\x177D\x3\x2\x2\x2\x177F\x1780\x3\x2\x2\x2\x1780");
		sb.Append("\x251\x3\x2\x2\x2\x1781\x177F\x3\x2\x2\x2\x1782\x1787\x5\x218");
		sb.Append("\x10D\x2\x1783\x1787\x5\x1F0\xF9\x2\x1784\x1787\x5\x240\x121");
		sb.Append("\x2\x1785\x1787\x5\x254\x12B\x2\x1786\x1782\x3\x2\x2\x2\x1786");
		sb.Append("\x1783\x3\x2\x2\x2\x1786\x1784\x3\x2\x2\x2\x1786\x1785\x3\x2");
		sb.Append("\x2\x2\x1787\x253\x3\x2\x2\x2\x1788\x1789\b\x12B\x1\x2\x1789");
		sb.Append("\x178A\to\x2\x2\x178A\x1794\x5\x254\x12B\x6\x178B\x178C\x5\x256");
		sb.Append("\x12C\x2\x178C\x178E\aN\x2\x2\x178D\x178F\a\x65\x2\x2\x178E");
		sb.Append("\x178D\x3\x2\x2\x2\x178E\x178F\x3\x2\x2\x2\x178F\x1790\x3\x2");
		sb.Append("\x2\x2\x1790\x1791\tp\x2\x2\x1791\x1794\x3\x2\x2\x2\x1792\x1794");
		sb.Append("\x5\x256\x12C\x2\x1793\x1788\x3\x2\x2\x2\x1793\x178B\x3\x2\x2");
		sb.Append("\x2\x1793\x1792\x3\x2\x2\x2\x1794\x179B\x3\x2\x2\x2\x1795\x1796");
		sb.Append("\f\x5\x2\x2\x1796\x1797\x5\x25E\x130\x2\x1797\x1798\x5\x254");
		sb.Append("\x12B\x6\x1798\x179A\x3\x2\x2\x2\x1799\x1795\x3\x2\x2\x2\x179A");
		sb.Append("\x179D\x3\x2\x2\x2\x179B\x1799\x3\x2\x2\x2\x179B\x179C\x3\x2");
		sb.Append("\x2\x2\x179C\x255\x3\x2\x2\x2\x179D\x179B\x3\x2\x2\x2\x179E");
		sb.Append("\x17A1\b\x12C\x1\x2\x179F\x17A0\a\x3EA\x2\x2\x17A0\x17A2\a\x3B6");
		sb.Append("\x2\x2\x17A1\x179F\x3\x2\x2\x2\x17A1\x17A2\x3\x2\x2\x2\x17A2");
		sb.Append("\x17A3\x3\x2\x2\x2\x17A3\x17A4\x5\x258\x12D\x2\x17A4\x17DE\x3");
		sb.Append("\x2\x2\x2\x17A5\x17A6\f\t\x2\x2\x17A6\x17A7\x5\x25C\x12F\x2");
		sb.Append("\x17A7\x17A8\x5\x256\x12C\n\x17A8\x17DD\x3\x2\x2\x2\x17A9\x17AB");
		sb.Append("\f\a\x2\x2\x17AA\x17AC\a\x65\x2\x2\x17AB\x17AA\x3\x2\x2\x2\x17AB");
		sb.Append("\x17AC\x3\x2\x2\x2\x17AC\x17AD\x3\x2\x2\x2\x17AD\x17AE\a\x10");
		sb.Append("\x2\x2\x17AE\x17AF\x5\x256\x12C\x2\x17AF\x17B0\a\f\x2\x2\x17B0");
		sb.Append("\x17B1\x5\x256\x12C\b\x17B1\x17DD\x3\x2\x2\x2\x17B2\x17B3\f");
		sb.Append("\x6\x2\x2\x17B3\x17B4\a\x1FF\x2\x2\x17B4\x17B5\aW\x2\x2\x17B5");
		sb.Append("\x17DD\x5\x256\x12C\a\x17B6\x17B8\f\x4\x2\x2\x17B7\x17B9\a\x65");
		sb.Append("\x2\x2\x17B8\x17B7\x3\x2\x2\x2\x17B8\x17B9\x3\x2\x2\x2\x17B9");
		sb.Append("\x17BA\x3\x2\x2\x2\x17BA\x17BB\tq\x2\x2\x17BB\x17DD\x5\x256");
		sb.Append("\x12C\x5\x17BC\x17BE\f\v\x2\x2\x17BD\x17BF\a\x65\x2\x2\x17BE");
		sb.Append("\x17BD\x3\x2\x2\x2\x17BE\x17BF\x3\x2\x2\x2\x17BF\x17C0\x3\x2");
		sb.Append("\x2\x2\x17C0\x17C1\a\x46\x2\x2\x17C1\x17C4\a\x3D0\x2\x2\x17C2");
		sb.Append("\x17C5\x5\xB4[\x2\x17C3\x17C5\x5\x22C\x117\x2\x17C4\x17C2\x3");
		sb.Append("\x2\x2\x2\x17C4\x17C3\x3\x2\x2\x2\x17C5\x17C6\x3\x2\x2\x2\x17C6");
		sb.Append("\x17C7\a\x3D1\x2\x2\x17C7\x17DD\x3\x2\x2\x2\x17C8\x17C9\f\n");
		sb.Append("\x2\x2\x17C9\x17CA\aN\x2\x2\x17CA\x17DD\x5\x216\x10C\x2\x17CB");
		sb.Append("\x17CC\f\b\x2\x2\x17CC\x17CD\x5\x25C\x12F\x2\x17CD\x17CE\tr");
		sb.Append("\x2\x2\x17CE\x17CF\a\x3D0\x2\x2\x17CF\x17D0\x5\xB4[\x2\x17D0");
		sb.Append("\x17D1\a\x3D1\x2\x2\x17D1\x17DD\x3\x2\x2\x2\x17D2\x17D4\f\x5");
		sb.Append("\x2\x2\x17D3\x17D5\a\x65\x2\x2\x17D4\x17D3\x3\x2\x2\x2\x17D4");
		sb.Append("\x17D5\x3\x2\x2\x2\x17D5\x17D6\x3\x2\x2\x2\x17D6\x17D7\aW\x2");
		sb.Append("\x2\x17D7\x17DA\x5\x256\x12C\x2\x17D8\x17D9\a\x14A\x2\x2\x17D9");
		sb.Append("\x17DB\a\x3DF\x2\x2\x17DA\x17D8\x3\x2\x2\x2\x17DA\x17DB\x3\x2");
		sb.Append("\x2\x2\x17DB\x17DD\x3\x2\x2\x2\x17DC\x17A5\x3\x2\x2\x2\x17DC");
		sb.Append("\x17A9\x3\x2\x2\x2\x17DC\x17B2\x3\x2\x2\x2\x17DC\x17B6\x3\x2");
		sb.Append("\x2\x2\x17DC\x17BC\x3\x2\x2\x2\x17DC\x17C8\x3\x2\x2\x2\x17DC");
		sb.Append("\x17CB\x3\x2\x2\x2\x17DC\x17D2\x3\x2\x2\x2\x17DD\x17E0\x3\x2");
		sb.Append("\x2\x2\x17DE\x17DC\x3\x2\x2\x2\x17DE\x17DF\x3\x2\x2\x2\x17DF");
		sb.Append("\x257\x3\x2\x2\x2\x17E0\x17DE\x3\x2\x2\x2\x17E1\x17E2\b\x12D");
		sb.Append("\x1\x2\x17E2\x180F\x5\x218\x10D\x2\x17E3\x180F\x5\x1F0\xF9\x2");
		sb.Append("\x17E4\x180F\x5\x240\x121\x2\x17E5\x180F\x5\x1F6\xFC\x2\x17E6");
		sb.Append("\x17E7\x5\x25A\x12E\x2\x17E7\x17E8\x5\x258\x12D\v\x17E8\x180F");
		sb.Append("\x3\x2\x2\x2\x17E9\x17EA\a\xC4\x2\x2\x17EA\x180F\x5\x258\x12D");
		sb.Append("\n\x17EB\x17EC\a\x3D0\x2\x2\x17EC\x17F1\x5\x254\x12B\x2\x17ED");
		sb.Append("\x17EE\a\x3D2\x2\x2\x17EE\x17F0\x5\x254\x12B\x2\x17EF\x17ED");
		sb.Append("\x3\x2\x2\x2\x17F0\x17F3\x3\x2\x2\x2\x17F1\x17EF\x3\x2\x2\x2");
		sb.Append("\x17F1\x17F2\x3\x2\x2\x2\x17F2\x17F4\x3\x2\x2\x2\x17F3\x17F1");
		sb.Append("\x3\x2\x2\x2\x17F4\x17F5\a\x3D1\x2\x2\x17F5\x180F\x3\x2\x2\x2");
		sb.Append("\x17F6\x17F7\a\x1ED\x2\x2\x17F7\x17F8\a\x3D0\x2\x2\x17F8\x17FB");
		sb.Append("\x5\x254\x12B\x2\x17F9\x17FA\a\x3D2\x2\x2\x17FA\x17FC\x5\x254");
		sb.Append("\x12B\x2\x17FB\x17F9\x3\x2\x2\x2\x17FC\x17FD\x3\x2\x2\x2\x17FD");
		sb.Append("\x17FB\x3\x2\x2\x2\x17FD\x17FE\x3\x2\x2\x2\x17FE\x17FF\x3\x2");
		sb.Append("\x2\x2\x17FF\x1800\a\x3D1\x2\x2\x1800\x180F\x3\x2\x2\x2\x1801");
		sb.Append("\x1802\a\x35\x2\x2\x1802\x1803\a\x3D0\x2\x2\x1803\x1804\x5\xB4");
		sb.Append("[\x2\x1804\x1805\a\x3D1\x2\x2\x1805\x180F\x3\x2\x2\x2\x1806");
		sb.Append("\x1807\a\x3D0\x2\x2\x1807\x1808\x5\xB4[\x2\x1808\x1809\a\x3D1");
		sb.Append("\x2\x2\x1809\x180F\x3\x2\x2\x2\x180A\x180B\aL\x2\x2\x180B\x180C");
		sb.Append("\x5\x254\x12B\x2\x180C\x180D\x5<\x1F\x2\x180D\x180F\x3\x2\x2");
		sb.Append("\x2\x180E\x17E1\x3\x2\x2\x2\x180E\x17E3\x3\x2\x2\x2\x180E\x17E4");
		sb.Append("\x3\x2\x2\x2\x180E\x17E5\x3\x2\x2\x2\x180E\x17E6\x3\x2\x2\x2");
		sb.Append("\x180E\x17E9\x3\x2\x2\x2\x180E\x17EB\x3\x2\x2\x2\x180E\x17F6");
		sb.Append("\x3\x2\x2\x2\x180E\x1801\x3\x2\x2\x2\x180E\x1806\x3\x2\x2\x2");
		sb.Append("\x180E\x180A\x3\x2\x2\x2\x180F\x181D\x3\x2\x2\x2\x1810\x1811");
		sb.Append("\f\x4\x2\x2\x1811\x1812\x5\x260\x131\x2\x1812\x1813\x5\x258");
		sb.Append("\x12D\x5\x1813\x181C\x3\x2\x2\x2\x1814\x1815\f\x3\x2\x2\x1815");
		sb.Append("\x1816\x5\x262\x132\x2\x1816\x1817\x5\x258\x12D\x4\x1817\x181C");
		sb.Append("\x3\x2\x2\x2\x1818\x1819\f\r\x2\x2\x1819\x181A\a\x1A\x2\x2\x181A");
		sb.Append("\x181C\x5\x1FA\xFE\x2\x181B\x1810\x3\x2\x2\x2\x181B\x1814\x3");
		sb.Append("\x2\x2\x2\x181B\x1818\x3\x2\x2\x2\x181C\x181F\x3\x2\x2\x2\x181D");
		sb.Append("\x181B\x3\x2\x2\x2\x181D\x181E\x3\x2\x2\x2\x181E\x259\x3\x2");
		sb.Append("\x2\x2\x181F\x181D\x3\x2\x2\x2\x1820\x1821\ts\x2\x2\x1821\x25B");
		sb.Append("\x3\x2\x2\x2\x1822\x1831\a\x3C7\x2\x2\x1823\x1831\a\x3C8\x2");
		sb.Append("\x2\x1824\x1831\a\x3C9\x2\x2\x1825\x1826\a\x3C9\x2\x2\x1826");
		sb.Append("\x1831\a\x3C7\x2\x2\x1827\x1828\a\x3C8\x2\x2\x1828\x1831\a\x3C7");
		sb.Append("\x2\x2\x1829\x182A\a\x3C9\x2\x2\x182A\x1831\a\x3C8\x2\x2\x182B");
		sb.Append("\x182C\a\x3CA\x2\x2\x182C\x1831\a\x3C7\x2\x2\x182D\x182E\a\x3C9");
		sb.Append("\x2\x2\x182E\x182F\a\x3C7\x2\x2\x182F\x1831\a\x3C8\x2\x2\x1830");
		sb.Append("\x1822\x3\x2\x2\x2\x1830\x1823\x3\x2\x2\x2\x1830\x1824\x3\x2");
		sb.Append("\x2\x2\x1830\x1825\x3\x2\x2\x2\x1830\x1827\x3\x2\x2\x2\x1830");
		sb.Append("\x1829\x3\x2\x2\x2\x1830\x182B\x3\x2\x2\x2\x1830\x182D\x3\x2");
		sb.Append("\x2\x2\x1831\x25D\x3\x2\x2\x2\x1832\x183A\a\f\x2\x2\x1833\x1834");
		sb.Append("\a\x3CD\x2\x2\x1834\x183A\a\x3CD\x2\x2\x1835\x183A\a\xAC\x2");
		sb.Append("\x2\x1836\x183A\al\x2\x2\x1837\x1838\a\x3CC\x2\x2\x1838\x183A");
		sb.Append("\a\x3CC\x2\x2\x1839\x1832\x3\x2\x2\x2\x1839\x1833\x3\x2\x2\x2");
		sb.Append("\x1839\x1835\x3\x2\x2\x2\x1839\x1836\x3\x2\x2\x2\x1839\x1837");
		sb.Append("\x3\x2\x2\x2\x183A\x25F\x3\x2\x2\x2\x183B\x183C\a\x3C9\x2\x2");
		sb.Append("\x183C\x1843\a\x3C9\x2\x2\x183D\x183E\a\x3C8\x2\x2\x183E\x1843");
		sb.Append("\a\x3C8\x2\x2\x183F\x1843\a\x3CD\x2\x2\x1840\x1843\a\x3CE\x2");
		sb.Append("\x2\x1841\x1843\a\x3CC\x2\x2\x1842\x183B\x3\x2\x2\x2\x1842\x183D");
		sb.Append("\x3\x2\x2\x2\x1842\x183F\x3\x2\x2\x2\x1842\x1840\x3\x2\x2\x2");
		sb.Append("\x1842\x1841\x3\x2\x2\x2\x1843\x261\x3\x2\x2\x2\x1844\x1845");
		sb.Append("\tt\x2\x2\x1845\x263\x3\x2\x2\x2\x1846\x1847\tu\x2\x2\x1847");
		sb.Append("\x265\x3\x2\x2\x2\x1848\x1849\tv\x2\x2\x1849\x267\x3\x2\x2\x2");
		sb.Append("\x184A\x184B\tw\x2\x2\x184B\x269\x3\x2\x2\x2\x184C\x184D\tx");
		sb.Append("\x2\x2\x184D\x26B\x3\x2\x2\x2\x184E\x184F\ty\x2\x2\x184F\x26D");
		sb.Append("\x3\x2\x2\x2\x1850\x1851\tz\x2\x2\x1851\x26F\x3\x2\x2\x2\x1852");
		sb.Append("\x1853\t{\x2\x2\x1853\x271\x3\x2\x2\x2\x38C\x273\x276\x27C\x27F");
		sb.Append("\x282\x284\x289\x28C\x28F\x298\x2BF\x2CB\x2D6\x2E7\x2EC\x2F8");
		sb.Append("\x313\x31A\x31F\x325\x32A\x32E\x337\x33A\x33D\x341\x348\x34B");
		sb.Append("\x350\x358\x35D\x362\x365\x367\x373\x376\x37A\x37D\x381\x384");
		sb.Append("\x388\x38B\x38E\x392\x395\x399\x39F\x3A5\x3AB\x3B2\x3B9\x3BF");
		sb.Append("\x3C5\x3CE\x3D3\x3E3\x3EA\x3EE\x3F8\x3FC\x400\x404\x408\x40D");
		sb.Append("\x410\x413\x416\x419\x41F\x423\x429\x42E\x431\x434\x436\x441");
		sb.Append("\x445\x448\x456\x459\x45D\x460\x464\x467\x46B\x46E\x472\x475");
		sb.Append("\x478\x47C\x47F\x483\x489\x496\x49D\x4A2\x4A5\x4AA\x4B2\x4B8");
		sb.Append("\x4BC\x4BF\x4C4\x4C7\x4CB\x4CE\x4D2\x4D5\x4DD\x4DF\x4E6\x4EC");
		sb.Append("\x4F4\x4F7\x4FE\x501\x503\x509\x50F\x520\x527\x52E\x539\x53C");
		sb.Append("\x549\x556\x55B\x56B\x573\x57D\x583\x58D\x590\x595\x5A2\x5A9");
		sb.Append("\x5AE\x5B2\x5B4\x5B9\x5BC\x5C2\x5C7\x5C9\x5CD\x5D0\x5D3\x5D9");
		sb.Append("\x5DE\x5E0\x5E5\x5EC\x5EE\x5F5\x5FA\x5FE\x601\x609\x611\x613");
		sb.Append("\x61B\x61F\x622\x628\x62D\x630\x636\x639\x63D\x642\x647\x64B");
		sb.Append("\x650\x653\x657\x65B\x65F\x663\x668\x66D\x672\x678\x67D\x682");
		sb.Append("\x688\x68D\x692\x697\x69C\x6A1\x6A6\x6AB\x6B0\x6B5\x6BA\x6C0");
		sb.Append("\x6C5\x6CB\x6D5\x6DC\x6DE\x6E6\x6EB\x6EE\x6F6\x6FC\x70C\x718");
		sb.Append("\x71A\x71D\x725\x72B\x731\x73E\x745\x74D\x750\x75B\x763\x766");
		sb.Append("\x772\x779\x781\x784\x790\x797\x79F\x7A2\x7A9\x7B1\x7B4\x7B6");
		sb.Append("\x7BB\x7C3\x7CC\x7D0\x7D4\x7D9\x7DF\x7E5\x7EA\x7EF\x7F4\x7F9");
		sb.Append("\x7FC\x801\x806\x810\x814\x81B\x820\x823\x828\x82B\x82F\x833");
		sb.Append("\x83B\x84E\x851\x854\x858\x862\x86F\x876\x879\x882\x885\x888");
		sb.Append("\x893\x896\x89A\x8A2\x8A5\x8AA\x8B2\x8B8\x8BC\x8C0\x8C5\x8CA");
		sb.Append("\x8D1\x8D5\x8E0\x8E8\x8EB\x8F1\x8F7\x8F9\x8FE\x904\x90A\x90C");
		sb.Append("\x910\x913\x916\x91C\x922\x925\x92B\x931\x933\x938\x940\x942");
		sb.Append("\x94B\x950\x958\x95C\x964\x96E\x973\x97A\x97E\x982\x99A\x99E");
		sb.Append("\x9AA\x9AD\x9B6\x9C7\x9D3\x9DA\x9E1\x9F0\x9FD\xA03\xA09\xA0F");
		sb.Append("\xA15\xA1B\xA21\xA26\xA2D\xA34\xA3B\xA40\xA43\xA45\xA53\xA5A");
		sb.Append("\xA61\xA67\xA6B\xA6F\xA76\xA79\xA7E\xA85\xA8C\xA90\xA99\xAA2");
		sb.Append("\xAAB\xAAE\xAB2\xABB\xABF\xAC2\xAC5\xACD\xAD3\xADC\xADF\xAEA");
		sb.Append("\xAED\xAF2\xAF5\xAFA\xB04\xB09\xB0F\xB11\xB17\xB19\xB1F\xB27");
		sb.Append("\xB2C\xB34\xB37\xB3C\xB3F\xB44\xB4C\xB54\xB5A\xB62\xB67\xB6F");
		sb.Append("\xB72\xB76\xB79\xB81\xB87\xB90\xB93\xB97\xB9B\xBA1\xBA5\xBA9");
		sb.Append("\xBAB\xBAE\xBB1\xBB4\xBBA\xBBE\xBC1\xBC4\xBC7\xBCA\xBCC\xBD0");
		sb.Append("\xBDE\xBE1\xBE7\xBEB\xBF3\xBF7\xBFA\xBFD\xC06\xC0A\xC0D\xC11");
		sb.Append("\xC15\xC18\xC1B\xC20\xC26\xC2A\xC34\xC3A\xC3E\xC44\xC48\xC4E");
		sb.Append("\xC51\xC5D\xC61\xC65\xC6D\xC71\xC79\xC7C\xC80\xC83\xC8B\xC90");
		sb.Append("\xC93\xC96\xC9A\xC9D\xCA6\xCAB\xCB4\xCB9\xCC0\xCC7\xCCF\xCD4");
		sb.Append("\xCDC\xCDF\xCE2\xCE9\xCEC\xCF3\xCF6\xCFE\xD04\xD0F\xD12\xD1D");
		sb.Append("\xD23\xD27\xD32\xD37\xD39\xD3D\xD47\xD51\xD57\xD5C\xD5F\xD62");
		sb.Append("\xD65\xD6B\xD70\xD73\xD76\xD79\xD7B\xD81\xD86\xD89\xD8C\xD90");
		sb.Append("\xD96\xD9A\xDA4\xDA8\xDAE\xDB7\xDBA\xDBE\xDC1\xDC5\xDC9\xDCC");
		sb.Append("\xDCE\xDD6\xDE2\xDE8\xDEA\xDF0\xDF2\xDF4\xDFA\xE02\xE0A\xE10");
		sb.Append("\xE19\xE1E\xE20\xE24\xE28\xE2E\xE35\xE39\xE42\xE45\xE49\xE4D");
		sb.Append("\xE51\xE54\xE57\xE5A\xE5E\xE62\xE65\xE68\xE6B\xE72\xE76\xE85");
		sb.Append("\xE92\xE9A\xEA4\xEA8\xEAB\xEB1\xEB4\xEB7\xEC0\xEC9\xED3\xED7");
		sb.Append("\xEE1\xEEB\xEF3\xEF6\xEFF\xF02\xF06\xF0B\xF0F\xF18\xF1B\xF3A");
		sb.Append("\xF3D\xF40\xF78\xF7D\xF99\xFA7\xFAE\xFB2\xFB8\xFC0\xFC2\xFCD");
		sb.Append("\xFD7\xFDE\xFE4\xFEC\xFF1\xFF9\x1001\x1009\x1011\x1017\x101A");
		sb.Append("\x101E\x1023\x1028\x102E\x1030\x103B\x1040\x1047\x1049\x1057");
		sb.Append("\x105D\x1062\x1067\x106D\x1074\x107C\x1084\x1089\x108F\x1092");
		sb.Append("\x109A\x10A1\x10AA\x10AD\x10BE\x10C6\x10CE\x10D2\x10D9\x10DF");
		sb.Append("\x10E7\x10F0\x10F6\x10FD\x1104\x1109\x110C\x110E\x1114\x1116");
		sb.Append("\x111A\x111C\x111F\x1128\x112E\x1135\x113C\x1141\x1144\x1146");
		sb.Append("\x114C\x114E\x1152\x1154\x1157\x115C\x1163\x116C\x1171\x117A");
		sb.Append("\x1181\x1186\x1189\x118B\x1191\x1193\x1196\x11A2\x11A8\x11B1");
		sb.Append("\x11BA\x11BF\x11C8\x11CE\x11D9\x11DC\x11E8\x11EF\x11F4\x1203");
		sb.Append("\x120E\x1211\x121B\x1225\x122F\x1239\x123D\x1241\x124A\x1266");
		sb.Append("\x1278\x1280\x128B\x1292\x1296\x129D\x12A2\x12A5\x12A8\x12B1");
		sb.Append("\x12B5\x12D3\x12DA\x12DE\x12E5\x12E8\x12F2\x12FC\x1300\x1306");
		sb.Append("\x1309\x130E\x1312\x1319\x131C\x1322\x133A\x1347\x134A\x1354");
		sb.Append("\x135C\x1360\x1367\x136A\x1373\x1379\x137F\x1389\x138B\x1391");
		sb.Append("\x1394\x1397\x13A3\x13A6\x13AC\x13AF\x13B7\x13BF\x13C5\x13C9");
		sb.Append("\x13D7\x13E3\x13EA\x13ED\x13F4\x13FB\x1400\x1405\x1410\x141B");
		sb.Append("\x1421\x1426\x1433\x1435\x143A\x143F\x1441\x1448\x144F\x1452");
		sb.Append("\x1455\x145B\x145F\x1465\x146B\x1478\x147D\x1485\x1488\x148E");
		sb.Append("\x1495\x149A\x14A0\x14A7\x14A9\x14AD\x14B3\x14B6\x14C0\x14C4");
		sb.Append("\x14D8\x14DF\x14E1\x14E8\x14EA\x14EE\x14F3\x14FE\x1503\x1509");
		sb.Append("\x150C\x1510\x1515\x1518\x151C\x1520\x1522\x1527\x152C\x1539");
		sb.Append("\x153C\x1540\x1543\x1548\x154B\x154F\x1554\x1557\x155C\x155F");
		sb.Append("\x1565\x1568\x156C\x156F\x1572\x1576\x1579\x157C\x1580\x1583");
		sb.Append("\x1586\x1589\x158D\x1590\x1593\x1598\x159D\x15A2\x15A5\x15A8");
		sb.Append("\x15B0\x15B7\x15BB\x15C0\x15C3\x15C8\x15CC\x15CE\x15DE\x15E7");
		sb.Append("\x15EF\x15F8\x1602\x160A\x1612\x161A\x1622\x1627\x162E\x1630");
		sb.Append("\x1635\x1638\x163D\x1640\x1644\x1652\x1659\x165E\x1680\x1684");
		sb.Append("\x168C\x1690\x1699\x16A1\x16A6\x16AE\x16B3\x16B8\x16BA\x16C3");
		sb.Append("\x16C8\x16D0\x16D5\x16DD\x16E5\x16E8\x16F2\x16FD\x170A\x1712");
		sb.Append("\x1716\x171B\x1724\x1727\x1733\x173B\x1745\x1748\x174C\x1750");
		sb.Append("\x1769\x1774\x177B\x177F\x1786\x178E\x1793\x179B\x17A1\x17AB");
		sb.Append("\x17B8\x17BE\x17C4\x17D4\x17DA\x17DC\x17DE\x17F1\x17FD\x180E");
		sb.Append("\x181B\x181D\x1830\x1839\x1842");
	    return sb.ToString();
	}

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());


}
} // namespace MySQLToCsharp.Parsers.MySql
